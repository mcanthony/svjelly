(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.svjelly || (g.svjelly = {})).Maker = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/Lau/www/svjelly/libs/p2.js":[function(require,module,exports){
(function (global){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 p2.js authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&false)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.p2=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
var Scalar = _dereq_('./Scalar');

module.exports = Line;

/**
 * Container for line-related functions
 * @class Line
 */
function Line(){};

/**
 * Compute the intersection between two lines.
 * @static
 * @method lineInt
 * @param  {Array}  l1          Line vector 1
 * @param  {Array}  l2          Line vector 2
 * @param  {Number} precision   Precision to use when checking if the lines are parallel
 * @return {Array}              The intersection point.
 */
Line.lineInt = function(l1,l2,precision){
    precision = precision || 0;
    var i = [0,0]; // point
    var a1, b1, c1, a2, b2, c2, det; // scalars
    a1 = l1[1][1] - l1[0][1];
    b1 = l1[0][0] - l1[1][0];
    c1 = a1 * l1[0][0] + b1 * l1[0][1];
    a2 = l2[1][1] - l2[0][1];
    b2 = l2[0][0] - l2[1][0];
    c2 = a2 * l2[0][0] + b2 * l2[0][1];
    det = a1 * b2 - a2*b1;
    if (!Scalar.eq(det, 0, precision)) { // lines are not parallel
        i[0] = (b2 * c1 - b1 * c2) / det;
        i[1] = (a1 * c2 - a2 * c1) / det;
    }
    return i;
};

/**
 * Checks if two line segments intersects.
 * @method segmentsIntersect
 * @param {Array} p1 The start vertex of the first line segment.
 * @param {Array} p2 The end vertex of the first line segment.
 * @param {Array} q1 The start vertex of the second line segment.
 * @param {Array} q2 The end vertex of the second line segment.
 * @return {Boolean} True if the two line segments intersect
 */
Line.segmentsIntersect = function(p1, p2, q1, q2){
   var dx = p2[0] - p1[0];
   var dy = p2[1] - p1[1];
   var da = q2[0] - q1[0];
   var db = q2[1] - q1[1];

   // segments are parallel
   if(da*dy - db*dx == 0)
      return false;

   var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx)
   var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy)

   return (s>=0 && s<=1 && t>=0 && t<=1);
};


},{"./Scalar":4}],2:[function(_dereq_,module,exports){
module.exports = Point;

/**
 * Point related functions
 * @class Point
 */
function Point(){};

/**
 * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.
 * @static
 * @method area
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return {Number}
 */
Point.area = function(a,b,c){
    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));
};

Point.left = function(a,b,c){
    return Point.area(a,b,c) > 0;
};

Point.leftOn = function(a,b,c) {
    return Point.area(a, b, c) >= 0;
};

Point.right = function(a,b,c) {
    return Point.area(a, b, c) < 0;
};

Point.rightOn = function(a,b,c) {
    return Point.area(a, b, c) <= 0;
};

var tmpPoint1 = [],
    tmpPoint2 = [];

/**
 * Check if three points are collinear
 * @method collinear
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.
 * @return {Boolean}
 */
Point.collinear = function(a,b,c,thresholdAngle) {
    if(!thresholdAngle)
        return Point.area(a, b, c) == 0;
    else {
        var ab = tmpPoint1,
            bc = tmpPoint2;

        ab[0] = b[0]-a[0];
        ab[1] = b[1]-a[1];
        bc[0] = c[0]-b[0];
        bc[1] = c[1]-b[1];

        var dot = ab[0]*bc[0] + ab[1]*bc[1],
            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),
            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),
            angle = Math.acos(dot/(magA*magB));
        return angle < thresholdAngle;
    }
};

Point.sqdist = function(a,b){
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    return dx * dx + dy * dy;
};

},{}],3:[function(_dereq_,module,exports){
var Line = _dereq_("./Line")
,   Point = _dereq_("./Point")
,   Scalar = _dereq_("./Scalar")

module.exports = Polygon;

/**
 * Polygon class.
 * @class Polygon
 * @constructor
 */
function Polygon(){

    /**
     * Vertices that this polygon consists of. An array of array of numbers, example: [[0,0],[1,0],..]
     * @property vertices
     * @type {Array}
     */
    this.vertices = [];
}

/**
 * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.
 * @method at
 * @param  {Number} i
 * @return {Array}
 */
Polygon.prototype.at = function(i){
    var v = this.vertices,
        s = v.length;
    return v[i < 0 ? i % s + s : i % s];
};

/**
 * Get first vertex
 * @method first
 * @return {Array}
 */
Polygon.prototype.first = function(){
    return this.vertices[0];
};

/**
 * Get last vertex
 * @method last
 * @return {Array}
 */
Polygon.prototype.last = function(){
    return this.vertices[this.vertices.length-1];
};

/**
 * Clear the polygon data
 * @method clear
 * @return {Array}
 */
Polygon.prototype.clear = function(){
    this.vertices.length = 0;
};

/**
 * Append points "from" to "to"-1 from an other polygon "poly" onto this one.
 * @method append
 * @param {Polygon} poly The polygon to get points from.
 * @param {Number}  from The vertex index in "poly".
 * @param {Number}  to The end vertex index in "poly". Note that this vertex is NOT included when appending.
 * @return {Array}
 */
Polygon.prototype.append = function(poly,from,to){
    if(typeof(from) == "undefined") throw new Error("From is not given!");
    if(typeof(to) == "undefined")   throw new Error("To is not given!");

    if(to-1 < from)                 throw new Error("lol1");
    if(to > poly.vertices.length)   throw new Error("lol2");
    if(from < 0)                    throw new Error("lol3");

    for(var i=from; i<to; i++){
        this.vertices.push(poly.vertices[i]);
    }
};

/**
 * Make sure that the polygon vertices are ordered counter-clockwise.
 * @method makeCCW
 */
Polygon.prototype.makeCCW = function(){
    var br = 0,
        v = this.vertices;

    // find bottom right point
    for (var i = 1; i < this.vertices.length; ++i) {
        if (v[i][1] < v[br][1] || (v[i][1] == v[br][1] && v[i][0] > v[br][0])) {
            br = i;
        }
    }

    // reverse poly if clockwise
    if (!Point.left(this.at(br - 1), this.at(br), this.at(br + 1))) {
        this.reverse();
    }
};

/**
 * Reverse the vertices in the polygon
 * @method reverse
 */
Polygon.prototype.reverse = function(){
    var tmp = [];
    for(var i=0, N=this.vertices.length; i!==N; i++){
        tmp.push(this.vertices.pop());
    }
    this.vertices = tmp;
};

/**
 * Check if a point in the polygon is a reflex point
 * @method isReflex
 * @param  {Number}  i
 * @return {Boolean}
 */
Polygon.prototype.isReflex = function(i){
    return Point.right(this.at(i - 1), this.at(i), this.at(i + 1));
};

var tmpLine1=[],
    tmpLine2=[];

/**
 * Check if two vertices in the polygon can see each other
 * @method canSee
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */
Polygon.prototype.canSee = function(a,b) {
    var p, dist, l1=tmpLine1, l2=tmpLine2;

    if (Point.leftOn(this.at(a + 1), this.at(a), this.at(b)) && Point.rightOn(this.at(a - 1), this.at(a), this.at(b))) {
        return false;
    }
    dist = Point.sqdist(this.at(a), this.at(b));
    for (var i = 0; i !== this.vertices.length; ++i) { // for each edge
        if ((i + 1) % this.vertices.length === a || i === a) // ignore incident edges
            continue;
        if (Point.leftOn(this.at(a), this.at(b), this.at(i + 1)) && Point.rightOn(this.at(a), this.at(b), this.at(i))) { // if diag intersects an edge
            l1[0] = this.at(a);
            l1[1] = this.at(b);
            l2[0] = this.at(i);
            l2[1] = this.at(i + 1);
            p = Line.lineInt(l1,l2);
            if (Point.sqdist(this.at(a), p) < dist) { // if edge is blocking visibility to b
                return false;
            }
        }
    }

    return true;
};

/**
 * Copy the polygon from vertex i to vertex j.
 * @method copy
 * @param  {Number} i
 * @param  {Number} j
 * @param  {Polygon} [targetPoly]   Optional target polygon to save in.
 * @return {Polygon}                The resulting copy.
 */
Polygon.prototype.copy = function(i,j,targetPoly){
    var p = targetPoly || new Polygon();
    p.clear();
    if (i < j) {
        // Insert all vertices from i to j
        for(var k=i; k<=j; k++)
            p.vertices.push(this.vertices[k]);

    } else {

        // Insert vertices 0 to j
        for(var k=0; k<=j; k++)
            p.vertices.push(this.vertices[k]);

        // Insert vertices i to end
        for(var k=i; k<this.vertices.length; k++)
            p.vertices.push(this.vertices[k]);
    }

    return p;
};

/**
 * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.
 * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.
 * @method getCutEdges
 * @return {Array}
 */
Polygon.prototype.getCutEdges = function() {
    var min=[], tmp1=[], tmp2=[], tmpPoly = new Polygon();
    var nDiags = Number.MAX_VALUE;

    for (var i = 0; i < this.vertices.length; ++i) {
        if (this.isReflex(i)) {
            for (var j = 0; j < this.vertices.length; ++j) {
                if (this.canSee(i, j)) {
                    tmp1 = this.copy(i, j, tmpPoly).getCutEdges();
                    tmp2 = this.copy(j, i, tmpPoly).getCutEdges();

                    for(var k=0; k<tmp2.length; k++)
                        tmp1.push(tmp2[k]);

                    if (tmp1.length < nDiags) {
                        min = tmp1;
                        nDiags = tmp1.length;
                        min.push([this.at(i), this.at(j)]);
                    }
                }
            }
        }
    }

    return min;
};

/**
 * Decomposes the polygon into one or more convex sub-Polygons.
 * @method decomp
 * @return {Array} An array or Polygon objects.
 */
Polygon.prototype.decomp = function(){
    var edges = this.getCutEdges();
    if(edges.length > 0)
        return this.slice(edges);
    else
        return [this];
};

/**
 * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.
 * @method slice
 * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()
 * @return {Array}
 */
Polygon.prototype.slice = function(cutEdges){
    if(cutEdges.length == 0) return [this];
    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length==2 && cutEdges[0][0] instanceof Array){

        var polys = [this];

        for(var i=0; i<cutEdges.length; i++){
            var cutEdge = cutEdges[i];
            // Cut all polys
            for(var j=0; j<polys.length; j++){
                var poly = polys[j];
                var result = poly.slice(cutEdge);
                if(result){
                    // Found poly! Cut and quit
                    polys.splice(j,1);
                    polys.push(result[0],result[1]);
                    break;
                }
            }
        }

        return polys;
    } else {

        // Was given one edge
        var cutEdge = cutEdges;
        var i = this.vertices.indexOf(cutEdge[0]);
        var j = this.vertices.indexOf(cutEdge[1]);

        if(i != -1 && j != -1){
            return [this.copy(i,j),
                    this.copy(j,i)];
        } else {
            return false;
        }
    }
};

/**
 * Checks that the line segments of this polygon do not intersect each other.
 * @method isSimple
 * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]
 * @return {Boolean}
 * @todo Should it check all segments with all others?
 */
Polygon.prototype.isSimple = function(){
    var path = this.vertices;
    // Check
    for(var i=0; i<path.length-1; i++){
        for(var j=0; j<i-1; j++){
            if(Line.segmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){
                return false;
            }
        }
    }

    // Check the segment between the last and the first point to all others
    for(var i=1; i<path.length-2; i++){
        if(Line.segmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){
            return false;
        }
    }

    return true;
};

function getIntersectionPoint(p1, p2, q1, q2, delta){
    delta = delta || 0;
   var a1 = p2[1] - p1[1];
   var b1 = p1[0] - p2[0];
   var c1 = (a1 * p1[0]) + (b1 * p1[1]);
   var a2 = q2[1] - q1[1];
   var b2 = q1[0] - q2[0];
   var c2 = (a2 * q1[0]) + (b2 * q1[1]);
   var det = (a1 * b2) - (a2 * b1);

   if(!Scalar.eq(det,0,delta))
      return [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det]
   else
      return [0,0]
}

/**
 * Quickly decompose the Polygon into convex sub-polygons.
 * @method quickDecomp
 * @param  {Array} result
 * @param  {Array} [reflexVertices]
 * @param  {Array} [steinerPoints]
 * @param  {Number} [delta]
 * @param  {Number} [maxlevel]
 * @param  {Number} [level]
 * @return {Array}
 */
Polygon.prototype.quickDecomp = function(result,reflexVertices,steinerPoints,delta,maxlevel,level){
    maxlevel = maxlevel || 100;
    level = level || 0;
    delta = delta || 25;
    result = typeof(result)!="undefined" ? result : [];
    reflexVertices = reflexVertices || [];
    steinerPoints = steinerPoints || [];

    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points
    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars
    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers
    var lowerPoly=new Polygon(), upperPoly=new Polygon(); // polygons
    var poly = this,
        v = this.vertices;

    if(v.length < 3) return result;

    level++;
    if(level > maxlevel){
        console.warn("quickDecomp: max level ("+maxlevel+") reached.");
        return result;
    }

    for (var i = 0; i < this.vertices.length; ++i) {
        if (poly.isReflex(i)) {
            reflexVertices.push(poly.vertices[i]);
            upperDist = lowerDist = Number.MAX_VALUE;


            for (var j = 0; j < this.vertices.length; ++j) {
                if (Point.left(poly.at(i - 1), poly.at(i), poly.at(j))
                        && Point.rightOn(poly.at(i - 1), poly.at(i), poly.at(j - 1))) { // if line intersects with an edge
                    p = getIntersectionPoint(poly.at(i - 1), poly.at(i), poly.at(j), poly.at(j - 1)); // find the point of intersection
                    if (Point.right(poly.at(i + 1), poly.at(i), p)) { // make sure it's inside the poly
                        d = Point.sqdist(poly.vertices[i], p);
                        if (d < lowerDist) { // keep only the closest intersection
                            lowerDist = d;
                            lowerInt = p;
                            lowerIndex = j;
                        }
                    }
                }
                if (Point.left(poly.at(i + 1), poly.at(i), poly.at(j + 1))
                        && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                    p = getIntersectionPoint(poly.at(i + 1), poly.at(i), poly.at(j), poly.at(j + 1));
                    if (Point.left(poly.at(i - 1), poly.at(i), p)) {
                        d = Point.sqdist(poly.vertices[i], p);
                        if (d < upperDist) {
                            upperDist = d;
                            upperInt = p;
                            upperIndex = j;
                        }
                    }
                }
            }

            // if there are no vertices to connect to, choose a point in the middle
            if (lowerIndex == (upperIndex + 1) % this.vertices.length) {
                //console.log("Case 1: Vertex("+i+"), lowerIndex("+lowerIndex+"), upperIndex("+upperIndex+"), poly.size("+this.vertices.length+")");
                p[0] = (lowerInt[0] + upperInt[0]) / 2;
                p[1] = (lowerInt[1] + upperInt[1]) / 2;
                steinerPoints.push(p);

                if (i < upperIndex) {
                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);
                    lowerPoly.append(poly, i, upperIndex+1);
                    lowerPoly.vertices.push(p);
                    upperPoly.vertices.push(p);
                    if (lowerIndex != 0){
                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());
                        upperPoly.append(poly,lowerIndex,poly.vertices.length);
                    }
                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);
                    upperPoly.append(poly,0,i+1);
                } else {
                    if (i != 0){
                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());
                        lowerPoly.append(poly,i,poly.vertices.length);
                    }
                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);
                    lowerPoly.append(poly,0,upperIndex+1);
                    lowerPoly.vertices.push(p);
                    upperPoly.vertices.push(p);
                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);
                    upperPoly.append(poly,lowerIndex,i+1);
                }
            } else {
                // connect to the closest point within the triangle
                //console.log("Case 2: Vertex("+i+"), closestIndex("+closestIndex+"), poly.size("+this.vertices.length+")\n");

                if (lowerIndex > upperIndex) {
                    upperIndex += this.vertices.length;
                }
                closestDist = Number.MAX_VALUE;

                if(upperIndex < lowerIndex){
                    return result;
                }

                for (var j = lowerIndex; j <= upperIndex; ++j) {
                    if (Point.leftOn(poly.at(i - 1), poly.at(i), poly.at(j))
                            && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                        d = Point.sqdist(poly.at(i), poly.at(j));
                        if (d < closestDist) {
                            closestDist = d;
                            closestIndex = j % this.vertices.length;
                        }
                    }
                }

                if (i < closestIndex) {
                    lowerPoly.append(poly,i,closestIndex+1);
                    if (closestIndex != 0){
                        upperPoly.append(poly,closestIndex,v.length);
                    }
                    upperPoly.append(poly,0,i+1);
                } else {
                    if (i != 0){
                        lowerPoly.append(poly,i,v.length);
                    }
                    lowerPoly.append(poly,0,closestIndex+1);
                    upperPoly.append(poly,closestIndex,i+1);
                }
            }

            // solve smallest poly first
            if (lowerPoly.vertices.length < upperPoly.vertices.length) {
                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
            } else {
                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
            }

            return result;
        }
    }
    result.push(this);

    return result;
};

/**
 * Remove collinear points in the polygon.
 * @method removeCollinearPoints
 * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.
 * @return {Number}           The number of points removed
 */
Polygon.prototype.removeCollinearPoints = function(precision){
    var num = 0;
    for(var i=this.vertices.length-1; this.vertices.length>3 && i>=0; --i){
        if(Point.collinear(this.at(i-1),this.at(i),this.at(i+1),precision)){
            // Remove the middle point
            this.vertices.splice(i%this.vertices.length,1);
            i--; // Jump one point forward. Otherwise we may get a chain removal
            num++;
        }
    }
    return num;
};

},{"./Line":1,"./Point":2,"./Scalar":4}],4:[function(_dereq_,module,exports){
module.exports = Scalar;

/**
 * Scalar functions
 * @class Scalar
 */
function Scalar(){}

/**
 * Check if two scalars are equal
 * @static
 * @method eq
 * @param  {Number} a
 * @param  {Number} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */
Scalar.eq = function(a,b,precision){
    precision = precision || 0;
    return Math.abs(a-b) < precision;
};

},{}],5:[function(_dereq_,module,exports){
module.exports = {
    Polygon : _dereq_("./Polygon"),
    Point : _dereq_("./Point"),
};

},{"./Point":2,"./Polygon":3}],6:[function(_dereq_,module,exports){
module.exports={
  "name": "p2",
  "version": "0.6.1",
  "description": "A JavaScript 2D physics engine.",
  "author": "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
  "keywords": [
    "p2.js",
    "p2",
    "physics",
    "engine",
    "2d"
  ],
  "main": "./src/p2.js",
  "engines": {
    "node": "*"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/schteppe/p2.js.git"
  },
  "bugs": {
    "url": "https://github.com/schteppe/p2.js/issues"
  },
  "licenses": [
    {
      "type": "MIT"
    }
  ],
  "devDependencies": {
    "grunt": "~0.4.0",
    "grunt-contrib-jshint": "~0.9.2",
    "grunt-contrib-nodeunit": "~0.1.2",
    "grunt-contrib-uglify": "~0.4.0",
    "grunt-contrib-watch": "~0.5.0",
    "grunt-browserify": "~2.0.1",
    "grunt-contrib-concat": "^0.4.0"
  },
  "dependencies": {
    "poly-decomp": "0.1.0"
  }
}

},{}],7:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Utils = _dereq_('../utils/Utils');

module.exports = AABB;

/**
 * Axis aligned bounding box class.
 * @class AABB
 * @constructor
 * @param {Object}  [options]
 * @param {Array}   [options.upperBound]
 * @param {Array}   [options.lowerBound]
 */
function AABB(options){

    /**
     * The lower bound of the bounding box.
     * @property lowerBound
     * @type {Array}
     */
    this.lowerBound = vec2.create();
    if(options && options.lowerBound){
        vec2.copy(this.lowerBound, options.lowerBound);
    }

    /**
     * The upper bound of the bounding box.
     * @property upperBound
     * @type {Array}
     */
    this.upperBound = vec2.create();
    if(options && options.upperBound){
        vec2.copy(this.upperBound, options.upperBound);
    }
}

var tmp = vec2.create();

/**
 * Set the AABB bounds from a set of points.
 * @method setFromPoints
 * @param {Array} points An array of vec2's.
 */
AABB.prototype.setFromPoints = function(points, position, angle, skinSize){
    var l = this.lowerBound,
        u = this.upperBound;

    if(typeof(angle) !== "number"){
        angle = 0;
    }

    // Set to the first point
    if(angle !== 0){
        vec2.rotate(l, points[0], angle);
    } else {
        vec2.copy(l, points[0]);
    }
    vec2.copy(u, l);

    // Compute cosines and sines just once
    var cosAngle = Math.cos(angle),
        sinAngle = Math.sin(angle);
    for(var i = 1; i<points.length; i++){
        var p = points[i];

        if(angle !== 0){
            var x = p[0],
                y = p[1];
            tmp[0] = cosAngle * x -sinAngle * y;
            tmp[1] = sinAngle * x +cosAngle * y;
            p = tmp;
        }

        for(var j=0; j<2; j++){
            if(p[j] > u[j]){
                u[j] = p[j];
            }
            if(p[j] < l[j]){
                l[j] = p[j];
            }
        }
    }

    // Add offset
    if(position){
        vec2.add(this.lowerBound, this.lowerBound, position);
        vec2.add(this.upperBound, this.upperBound, position);
    }

    if(skinSize){
        this.lowerBound[0] -= skinSize;
        this.lowerBound[1] -= skinSize;
        this.upperBound[0] += skinSize;
        this.upperBound[1] += skinSize;
    }
};

/**
 * Copy bounds from an AABB to this AABB
 * @method copy
 * @param  {AABB} aabb
 */
AABB.prototype.copy = function(aabb){
    vec2.copy(this.lowerBound, aabb.lowerBound);
    vec2.copy(this.upperBound, aabb.upperBound);
};

/**
 * Extend this AABB so that it covers the given AABB too.
 * @method extend
 * @param  {AABB} aabb
 */
AABB.prototype.extend = function(aabb){
    // Loop over x and y
    var i = 2;
    while(i--){
        // Extend lower bound
        var l = aabb.lowerBound[i];
        if(this.lowerBound[i] > l){
            this.lowerBound[i] = l;
        }

        // Upper
        var u = aabb.upperBound[i];
        if(this.upperBound[i] < u){
            this.upperBound[i] = u;
        }
    }
};

/**
 * Returns true if the given AABB overlaps this AABB.
 * @method overlaps
 * @param  {AABB} aabb
 * @return {Boolean}
 */
AABB.prototype.overlaps = function(aabb){
    var l1 = this.lowerBound,
        u1 = this.upperBound,
        l2 = aabb.lowerBound,
        u2 = aabb.upperBound;

    //      l2        u2
    //      |---------|
    // |--------|
    // l1       u1

    return ((l2[0] <= u1[0] && u1[0] <= u2[0]) || (l1[0] <= u2[0] && u2[0] <= u1[0])) &&
           ((l2[1] <= u1[1] && u1[1] <= u2[1]) || (l1[1] <= u2[1] && u2[1] <= u1[1]));
};

},{"../math/vec2":31,"../utils/Utils":50}],8:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Body = _dereq_('../objects/Body');

module.exports = Broadphase;

/**
 * Base class for broadphase implementations.
 * @class Broadphase
 * @constructor
 */
function Broadphase(type){

    this.type = type;

    /**
     * The resulting overlapping pairs. Will be filled with results during .getCollisionPairs().
     * @property result
     * @type {Array}
     */
    this.result = [];

    /**
     * The world to search for collision pairs in. To change it, use .setWorld()
     * @property world
     * @type {World}
     * @readOnly
     */
    this.world = null;

    /**
     * The bounding volume type to use in the broadphase algorithms.
     * @property {Number} boundingVolumeType
     */
    this.boundingVolumeType = Broadphase.AABB;
}

/**
 * Axis aligned bounding box type.
 * @static
 * @property {Number} AABB
 */
Broadphase.AABB = 1;

/**
 * Bounding circle type.
 * @static
 * @property {Number} BOUNDING_CIRCLE
 */
Broadphase.BOUNDING_CIRCLE = 2;

/**
 * Set the world that we are searching for collision pairs in
 * @method setWorld
 * @param  {World} world
 */
Broadphase.prototype.setWorld = function(world){
    this.world = world;
};

/**
 * Get all potential intersecting body pairs.
 * @method getCollisionPairs
 * @param  {World} world The world to search in.
 * @return {Array} An array of the bodies, ordered in pairs. Example: A result of [a,b,c,d] means that the potential pairs are: (a,b), (c,d).
 */
Broadphase.prototype.getCollisionPairs = function(world){
    throw new Error("getCollisionPairs must be implemented in a subclass!");
};

var dist = vec2.create();

/**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.boundingRadiusCheck = function(bodyA, bodyB){
    vec2.sub(dist, bodyA.position, bodyB.position);
    var d2 = vec2.squaredLength(dist),
        r = bodyA.boundingRadius + bodyB.boundingRadius;
    return d2 <= r*r;
};

/**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.aabbCheck = function(bodyA, bodyB){
    return bodyA.getAABB().overlaps(bodyB.getAABB());
};

/**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.prototype.boundingVolumeCheck = function(bodyA, bodyB){
    var result;

    switch(this.boundingVolumeType){
    case Broadphase.BOUNDING_CIRCLE:
        result =  Broadphase.boundingRadiusCheck(bodyA,bodyB);
        break;
    case Broadphase.AABB:
        result = Broadphase.aabbCheck(bodyA,bodyB);
        break;
    default:
        throw new Error('Bounding volume type not recognized: '+this.boundingVolumeType);
    }
    return result;
};

/**
 * Check whether two bodies are allowed to collide at all.
 * @method  canCollide
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.canCollide = function(bodyA, bodyB){

    // Cannot collide static bodies
    if(bodyA.type === Body.STATIC && bodyB.type === Body.STATIC){
        return false;
    }

    // Cannot collide static vs kinematic bodies
    if( (bodyA.type === Body.KINEMATIC && bodyB.type === Body.STATIC) ||
        (bodyA.type === Body.STATIC    && bodyB.type === Body.KINEMATIC)){
        return false;
    }

    // Cannot collide kinematic vs kinematic
    if(bodyA.type === Body.KINEMATIC && bodyB.type === Body.KINEMATIC){
        return false;
    }

    // Cannot collide both sleeping bodies
    if(bodyA.sleepState === Body.SLEEPING && bodyB.sleepState === Body.SLEEPING){
        return false;
    }

    // Cannot collide if one is static and the other is sleeping
    if( (bodyA.sleepState === Body.SLEEPING && bodyB.type === Body.STATIC) ||
        (bodyB.sleepState === Body.SLEEPING && bodyA.type === Body.STATIC)){
        return false;
    }

    return true;
};

Broadphase.NAIVE = 1;
Broadphase.SAP = 2;

},{"../math/vec2":31,"../objects/Body":32}],9:[function(_dereq_,module,exports){
var Circle = _dereq_('../shapes/Circle')
,   Plane = _dereq_('../shapes/Plane')
,   Particle = _dereq_('../shapes/Particle')
,   Broadphase = _dereq_('../collision/Broadphase')
,   vec2 = _dereq_('../math/vec2')
,   Utils = _dereq_('../utils/Utils');

module.exports = GridBroadphase;

/**
 * Broadphase that uses axis-aligned bins.
 * @class GridBroadphase
 * @constructor
 * @extends Broadphase
 * @param {object} [options]
 * @param {number} [options.xmin]   Lower x bound of the grid
 * @param {number} [options.xmax]   Upper x bound
 * @param {number} [options.ymin]   Lower y bound
 * @param {number} [options.ymax]   Upper y bound
 * @param {number} [options.nx]     Number of bins along x axis
 * @param {number} [options.ny]     Number of bins along y axis
 * @todo Should have an option for dynamic scene size
 */
function GridBroadphase(options){
    Broadphase.apply(this);

    options = Utils.defaults(options,{
        xmin:   -100,
        xmax:   100,
        ymin:   -100,
        ymax:   100,
        nx:     10,
        ny:     10
    });

    this.xmin = options.xmin;
    this.ymin = options.ymin;
    this.xmax = options.xmax;
    this.ymax = options.ymax;
    this.nx = options.nx;
    this.ny = options.ny;

    this.binsizeX = (this.xmax-this.xmin) / this.nx;
    this.binsizeY = (this.ymax-this.ymin) / this.ny;
}
GridBroadphase.prototype = new Broadphase();
GridBroadphase.prototype.constructor = GridBroadphase;

/**
 * Get collision pairs.
 * @method getCollisionPairs
 * @param  {World} world
 * @return {Array}
 */
GridBroadphase.prototype.getCollisionPairs = function(world){
    var result = [],
        bodies = world.bodies,
        Ncolliding = bodies.length,
        binsizeX = this.binsizeX,
        binsizeY = this.binsizeY,
        nx = this.nx,
        ny = this.ny,
        xmin = this.xmin,
        ymin = this.ymin,
        xmax = this.xmax,
        ymax = this.ymax;

    // Todo: make garbage free
    var bins=[], Nbins=nx*ny;
    for(var i=0; i<Nbins; i++){
        bins.push([]);
    }

    var xmult = nx / (xmax-xmin);
    var ymult = ny / (ymax-ymin);

    // Put all bodies into bins
    for(var i=0; i!==Ncolliding; i++){
        var bi = bodies[i];
        var aabb = bi.aabb;
        var lowerX = Math.max(aabb.lowerBound[0], xmin);
        var lowerY = Math.max(aabb.lowerBound[1], ymin);
        var upperX = Math.min(aabb.upperBound[0], xmax);
        var upperY = Math.min(aabb.upperBound[1], ymax);
        var xi1 = Math.floor(xmult * (lowerX - xmin));
        var yi1 = Math.floor(ymult * (lowerY - ymin));
        var xi2 = Math.floor(xmult * (upperX - xmin));
        var yi2 = Math.floor(ymult * (upperY - ymin));

        // Put in bin
        for(var j=xi1; j<=xi2; j++){
            for(var k=yi1; k<=yi2; k++){
                var xi = j;
                var yi = k;
                var idx = xi*(ny-1) + yi;
                if(idx >= 0 && idx < Nbins){
                    bins[ idx ].push(bi);
                }
            }
        }
    }

    // Check each bin
    for(var i=0; i!==Nbins; i++){
        var bin = bins[i];

        for(var j=0, NbodiesInBin=bin.length; j!==NbodiesInBin; j++){
            var bi = bin[j];
            for(var k=0; k!==j; k++){
                var bj = bin[k];
                if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){
                    result.push(bi,bj);
                }
            }
        }
    }
    return result;
};

},{"../collision/Broadphase":8,"../math/vec2":31,"../shapes/Circle":38,"../shapes/Particle":42,"../shapes/Plane":43,"../utils/Utils":50}],10:[function(_dereq_,module,exports){
var Circle = _dereq_('../shapes/Circle'),
    Plane = _dereq_('../shapes/Plane'),
    Shape = _dereq_('../shapes/Shape'),
    Particle = _dereq_('../shapes/Particle'),
    Broadphase = _dereq_('../collision/Broadphase'),
    vec2 = _dereq_('../math/vec2');

module.exports = NaiveBroadphase;

/**
 * Naive broadphase implementation. Does N^2 tests.
 *
 * @class NaiveBroadphase
 * @constructor
 * @extends Broadphase
 */
function NaiveBroadphase(){
    Broadphase.call(this, Broadphase.NAIVE);
}
NaiveBroadphase.prototype = new Broadphase();
NaiveBroadphase.prototype.constructor = NaiveBroadphase;

/**
 * Get the colliding pairs
 * @method getCollisionPairs
 * @param  {World} world
 * @return {Array}
 */
NaiveBroadphase.prototype.getCollisionPairs = function(world){
    var bodies = world.bodies,
        result = this.result;

    result.length = 0;

    for(var i=0, Ncolliding=bodies.length; i!==Ncolliding; i++){
        var bi = bodies[i];

        for(var j=0; j<i; j++){
            var bj = bodies[j];

            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){
                result.push(bi,bj);
            }
        }
    }

    return result;
};

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
NaiveBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    var bodies = world.bodies;
    for(var i = 0; i < bodies.length; i++){
        var b = bodies[i];

        if(b.aabbNeedsUpdate){
            b.updateAABB();
        }

        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"../collision/Broadphase":8,"../math/vec2":31,"../shapes/Circle":38,"../shapes/Particle":42,"../shapes/Plane":43,"../shapes/Shape":45}],11:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   sub = vec2.sub
,   add = vec2.add
,   dot = vec2.dot
,   Utils = _dereq_('../utils/Utils')
,   TupleDictionary = _dereq_('../utils/TupleDictionary')
,   Equation = _dereq_('../equations/Equation')
,   ContactEquation = _dereq_('../equations/ContactEquation')
,   FrictionEquation = _dereq_('../equations/FrictionEquation')
,   Circle = _dereq_('../shapes/Circle')
,   Convex = _dereq_('../shapes/Convex')
,   Shape = _dereq_('../shapes/Shape')
,   Body = _dereq_('../objects/Body')
,   Rectangle = _dereq_('../shapes/Rectangle');

module.exports = Narrowphase;

// Temp things
var yAxis = vec2.fromValues(0,1);

var tmp1 = vec2.fromValues(0,0)
,   tmp2 = vec2.fromValues(0,0)
,   tmp3 = vec2.fromValues(0,0)
,   tmp4 = vec2.fromValues(0,0)
,   tmp5 = vec2.fromValues(0,0)
,   tmp6 = vec2.fromValues(0,0)
,   tmp7 = vec2.fromValues(0,0)
,   tmp8 = vec2.fromValues(0,0)
,   tmp9 = vec2.fromValues(0,0)
,   tmp10 = vec2.fromValues(0,0)
,   tmp11 = vec2.fromValues(0,0)
,   tmp12 = vec2.fromValues(0,0)
,   tmp13 = vec2.fromValues(0,0)
,   tmp14 = vec2.fromValues(0,0)
,   tmp15 = vec2.fromValues(0,0)
,   tmp16 = vec2.fromValues(0,0)
,   tmp17 = vec2.fromValues(0,0)
,   tmp18 = vec2.fromValues(0,0)
,   tmpArray = [];

/**
 * Narrowphase. Creates contacts and friction given shapes and transforms.
 * @class Narrowphase
 * @constructor
 */
function Narrowphase(){

    /**
     * @property contactEquations
     * @type {Array}
     */
    this.contactEquations = [];

    /**
     * @property frictionEquations
     * @type {Array}
     */
    this.frictionEquations = [];

    /**
     * Whether to make friction equations in the upcoming contacts.
     * @property enableFriction
     * @type {Boolean}
     */
    this.enableFriction = true;

    /**
     * Whether to make equations enabled in upcoming contacts.
     * @property enabledEquations
     * @type {Boolean}
     */
    this.enabledEquations = true;

    /**
     * The friction slip force to use when creating friction equations.
     * @property slipForce
     * @type {Number}
     */
    this.slipForce = 10.0;

    /**
     * The friction value to use in the upcoming friction equations.
     * @property frictionCoefficient
     * @type {Number}
     */
    this.frictionCoefficient = 0.3;

    /**
     * Will be the .relativeVelocity in each produced FrictionEquation.
     * @property {Number} surfaceVelocity
     */
    this.surfaceVelocity = 0;

    this.reuseObjects = true;
    this.reusableContactEquations = [];
    this.reusableFrictionEquations = [];

    /**
     * The restitution value to use in the next contact equations.
     * @property restitution
     * @type {Number}
     */
    this.restitution = 0;

    /**
     * The stiffness value to use in the next contact equations.
     * @property {Number} stiffness
     */
    this.stiffness = Equation.DEFAULT_STIFFNESS;

    /**
     * The stiffness value to use in the next contact equations.
     * @property {Number} stiffness
     */
    this.relaxation = Equation.DEFAULT_RELAXATION;

    /**
     * The stiffness value to use in the next friction equations.
     * @property frictionStiffness
     * @type {Number}
     */
    this.frictionStiffness = Equation.DEFAULT_STIFFNESS;

    /**
     * The relaxation value to use in the next friction equations.
     * @property frictionRelaxation
     * @type {Number}
     */
    this.frictionRelaxation = Equation.DEFAULT_RELAXATION;

    /**
     * Enable reduction of friction equations. If disabled, a box on a plane will generate 2 contact equations and 2 friction equations. If enabled, there will be only one friction equation. Same kind of simplifications are made  for all collision types.
     * @property enableFrictionReduction
     * @type {Boolean}
     * @deprecated This flag will be removed when the feature is stable enough.
     * @default true
     */
    this.enableFrictionReduction = true;

    /**
     * Keeps track of the colliding bodies last step.
     * @private
     * @property collidingBodiesLastStep
     * @type {TupleDictionary}
     */
    this.collidingBodiesLastStep = new TupleDictionary();

    /**
     * Contact skin size value to use in the next contact equations.
     * @property {Number} contactSkinSize
     * @default 0.01
     */
    this.contactSkinSize = 0.01;
}

var bodiesOverlap_shapePositionA = vec2.create();
var bodiesOverlap_shapePositionB = vec2.create();

/**
 * @method bodiesOverlap
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Narrowphase.prototype.bodiesOverlap = function(bodyA, bodyB){
    var shapePositionA = bodiesOverlap_shapePositionA;
    var shapePositionB = bodiesOverlap_shapePositionB;

    // Loop over all shapes of bodyA
    for(var k=0, Nshapesi=bodyA.shapes.length; k!==Nshapesi; k++){
        var shapeA = bodyA.shapes[k],
            positionA = bodyA.shapeOffsets[k],
            angleA = bodyA.shapeAngles[k];

        bodyA.toWorldFrame(shapePositionA, positionA);

        // All shapes of body j
        for(var l=0, Nshapesj=bodyB.shapes.length; l!==Nshapesj; l++){
            var shapeB = bodyB.shapes[l],
                positionB = bodyB.shapeOffsets[l],
                angleB = bodyB.shapeAngles[l];

            bodyB.toWorldFrame(shapePositionB, positionB);

            if(this[shapeA.type | shapeB.type](
                bodyA,
                shapeA,
                shapePositionA,
                shapeA.angle + bodyA.angle,
                bodyB,
                shapeB,
                shapePositionB,
                shapeB.angle + bodyB.angle,
                true
            )){
                return true;
            }
        }
    }

    return false;
};

/**
 * Check if the bodies were in contact since the last reset().
 * @method collidedLastStep
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Narrowphase.prototype.collidedLastStep = function(bodyA, bodyB){
    var id1 = bodyA.id|0,
        id2 = bodyB.id|0;
    return !!this.collidingBodiesLastStep.get(id1, id2);
};

/**
 * Throws away the old equations and gets ready to create new
 * @method reset
 */
Narrowphase.prototype.reset = function(){
    this.collidingBodiesLastStep.reset();

    var eqs = this.contactEquations;
    var l = eqs.length;
    while(l--){
        var eq = eqs[l],
            id1 = eq.bodyA.id,
            id2 = eq.bodyB.id;
        this.collidingBodiesLastStep.set(id1, id2, true);
    }

    if(this.reuseObjects){
        var ce = this.contactEquations,
            fe = this.frictionEquations,
            rfe = this.reusableFrictionEquations,
            rce = this.reusableContactEquations;
        Utils.appendArray(rce,ce);
        Utils.appendArray(rfe,fe);
    }

    // Reset
    this.contactEquations.length = this.frictionEquations.length = 0;
};

/**
 * Creates a ContactEquation, either by reusing an existing object or creating a new one.
 * @method createContactEquation
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {ContactEquation}
 */
Narrowphase.prototype.createContactEquation = function(bodyA, bodyB, shapeA, shapeB){
    var c = this.reusableContactEquations.length ? this.reusableContactEquations.pop() : new ContactEquation(bodyA,bodyB);
    c.bodyA = bodyA;
    c.bodyB = bodyB;
    c.shapeA = shapeA;
    c.shapeB = shapeB;
    c.restitution = this.restitution;
    c.firstImpact = !this.collidedLastStep(bodyA,bodyB);
    c.stiffness = this.stiffness;
    c.relaxation = this.relaxation;
    c.needsUpdate = true;
    c.enabled = this.enabledEquations;
    c.offset = this.contactSkinSize;

    return c;
};

/**
 * Creates a FrictionEquation, either by reusing an existing object or creating a new one.
 * @method createFrictionEquation
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {FrictionEquation}
 */
Narrowphase.prototype.createFrictionEquation = function(bodyA, bodyB, shapeA, shapeB){
    var c = this.reusableFrictionEquations.length ? this.reusableFrictionEquations.pop() : new FrictionEquation(bodyA,bodyB);
    c.bodyA = bodyA;
    c.bodyB = bodyB;
    c.shapeA = shapeA;
    c.shapeB = shapeB;
    c.setSlipForce(this.slipForce);
    c.frictionCoefficient = this.frictionCoefficient;
    c.relativeVelocity = this.surfaceVelocity;
    c.enabled = this.enabledEquations;
    c.needsUpdate = true;
    c.stiffness = this.frictionStiffness;
    c.relaxation = this.frictionRelaxation;
    c.contactEquations.length = 0;
    return c;
};

/**
 * Creates a FrictionEquation given the data in the ContactEquation. Uses same offset vectors ri and rj, but the tangent vector will be constructed from the collision normal.
 * @method createFrictionFromContact
 * @param  {ContactEquation} contactEquation
 * @return {FrictionEquation}
 */
Narrowphase.prototype.createFrictionFromContact = function(c){
    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
    vec2.copy(eq.contactPointA, c.contactPointA);
    vec2.copy(eq.contactPointB, c.contactPointB);
    vec2.rotate90cw(eq.t, c.normalA);
    eq.contactEquations.push(c);
    return eq;
};

// Take the average N latest contact point on the plane.
Narrowphase.prototype.createFrictionFromAverage = function(numContacts){
    var c = this.contactEquations[this.contactEquations.length - 1];
    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    vec2.set(eq.contactPointA, 0, 0);
    vec2.set(eq.contactPointB, 0, 0);
    vec2.set(eq.t, 0, 0);
    for(var i=0; i!==numContacts; i++){
        c = this.contactEquations[this.contactEquations.length - 1 - i];
        if(c.bodyA === bodyA){
            vec2.add(eq.t, eq.t, c.normalA);
            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointB);
        } else {
            vec2.sub(eq.t, eq.t, c.normalA);
            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointB);
            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointA);
        }
        eq.contactEquations.push(c);
    }

    var invNumContacts = 1/numContacts;
    vec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);
    vec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);
    vec2.normalize(eq.t, eq.t);
    vec2.rotate90cw(eq.t, eq.t);
    return eq;
};

/**
 * Convex/line narrowphase
 * @method convexLine
 * @param  {Body}       convexBody
 * @param  {Convex}     convexShape
 * @param  {Array}      convexOffset
 * @param  {Number}     convexAngle
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      lineOffset
 * @param  {Number}     lineAngle
 * @param {boolean}     justTest
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.LINE | Shape.CONVEX] =
Narrowphase.prototype.convexLine = function(
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

/**
 * Line/rectangle narrowphase
 * @method lineRectangle
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      lineOffset
 * @param  {Number}     lineAngle
 * @param  {Body}       rectangleBody
 * @param  {Rectangle}  rectangleShape
 * @param  {Array}      rectangleOffset
 * @param  {Number}     rectangleAngle
 * @param  {Boolean}    justTest
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.LINE | Shape.RECTANGLE] =
Narrowphase.prototype.lineRectangle = function(
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    rectangleBody,
    rectangleShape,
    rectangleOffset,
    rectangleAngle,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

function setConvexToCapsuleShapeMiddle(convexShape, capsuleShape){
    vec2.set(convexShape.vertices[0], -capsuleShape.length * 0.5, -capsuleShape.radius);
    vec2.set(convexShape.vertices[1],  capsuleShape.length * 0.5, -capsuleShape.radius);
    vec2.set(convexShape.vertices[2],  capsuleShape.length * 0.5,  capsuleShape.radius);
    vec2.set(convexShape.vertices[3], -capsuleShape.length * 0.5,  capsuleShape.radius);
}

var convexCapsule_tempRect = new Rectangle(1,1),
    convexCapsule_tempVec = vec2.create();

/**
 * Convex/capsule narrowphase
 * @method convexCapsule
 * @param  {Body}       convexBody
 * @param  {Convex}     convexShape
 * @param  {Array}      convexPosition
 * @param  {Number}     convexAngle
 * @param  {Body}       capsuleBody
 * @param  {Capsule}    capsuleShape
 * @param  {Array}      capsulePosition
 * @param  {Number}     capsuleAngle
 */
Narrowphase.prototype[Shape.CAPSULE | Shape.CONVEX] =
Narrowphase.prototype[Shape.CAPSULE | Shape.RECTANGLE] =
Narrowphase.prototype.convexCapsule = function(
    convexBody,
    convexShape,
    convexPosition,
    convexAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
){

    // Check the circles
    // Add offsets!
    var circlePos = convexCapsule_tempVec;
    vec2.set(circlePos, capsuleShape.length/2,0);
    vec2.rotate(circlePos,circlePos,capsuleAngle);
    vec2.add(circlePos,circlePos,capsulePosition);
    var result1 = this.circleConvex(capsuleBody,capsuleShape,circlePos,capsuleAngle, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);

    vec2.set(circlePos,-capsuleShape.length/2, 0);
    vec2.rotate(circlePos,circlePos,capsuleAngle);
    vec2.add(circlePos,circlePos,capsulePosition);
    var result2 = this.circleConvex(capsuleBody,capsuleShape,circlePos,capsuleAngle, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);

    if(justTest && (result1 || result2)){
        return true;
    }

    // Check center rect
    var r = convexCapsule_tempRect;
    setConvexToCapsuleShapeMiddle(r,capsuleShape);
    var result = this.convexConvex(convexBody,convexShape,convexPosition,convexAngle, capsuleBody,r,capsulePosition,capsuleAngle, justTest);

    return result + result1 + result2;
};

/**
 * Capsule/line narrowphase
 * @method lineCapsule
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      linePosition
 * @param  {Number}     lineAngle
 * @param  {Body}       capsuleBody
 * @param  {Capsule}    capsuleShape
 * @param  {Array}      capsulePosition
 * @param  {Number}     capsuleAngle
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.CAPSULE | Shape.LINE] =
Narrowphase.prototype.lineCapsule = function(
    lineBody,
    lineShape,
    linePosition,
    lineAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

var capsuleCapsule_tempVec1 = vec2.create();
var capsuleCapsule_tempVec2 = vec2.create();
var capsuleCapsule_tempRect1 = new Rectangle(1,1);

/**
 * Capsule/capsule narrowphase
 * @method capsuleCapsule
 * @param  {Body}       bi
 * @param  {Capsule}    si
 * @param  {Array}      xi
 * @param  {Number}     ai
 * @param  {Body}       bj
 * @param  {Capsule}    sj
 * @param  {Array}      xj
 * @param  {Number}     aj
 */
Narrowphase.prototype[Shape.CAPSULE | Shape.CAPSULE] =
Narrowphase.prototype.capsuleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){

    var enableFrictionBefore;

    // Check the circles
    // Add offsets!
    var circlePosi = capsuleCapsule_tempVec1,
        circlePosj = capsuleCapsule_tempVec2;

    var numContacts = 0;


    // Need 4 circle checks, between all
    for(var i=0; i<2; i++){

        vec2.set(circlePosi,(i===0?-1:1)*si.length/2,0);
        vec2.rotate(circlePosi,circlePosi,ai);
        vec2.add(circlePosi,circlePosi,xi);

        for(var j=0; j<2; j++){

            vec2.set(circlePosj,(j===0?-1:1)*sj.length/2, 0);
            vec2.rotate(circlePosj,circlePosj,aj);
            vec2.add(circlePosj,circlePosj,xj);

            // Temporarily turn off friction
            if(this.enableFrictionReduction){
                enableFrictionBefore = this.enableFriction;
                this.enableFriction = false;
            }

            var result = this.circleCircle(bi,si,circlePosi,ai, bj,sj,circlePosj,aj, justTest, si.radius, sj.radius);

            if(this.enableFrictionReduction){
                this.enableFriction = enableFrictionBefore;
            }

            if(justTest && result){
                return true;
            }

            numContacts += result;
        }
    }

    if(this.enableFrictionReduction){
        // Temporarily turn off friction
        enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
    }

    // Check circles against the center rectangles
    var rect = capsuleCapsule_tempRect1;
    setConvexToCapsuleShapeMiddle(rect,si);
    var result1 = this.convexCapsule(bi,rect,xi,ai, bj,sj,xj,aj, justTest);

    if(this.enableFrictionReduction){
        this.enableFriction = enableFrictionBefore;
    }

    if(justTest && result1){
        return true;
    }
    numContacts += result1;

    if(this.enableFrictionReduction){
        // Temporarily turn off friction
        var enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
    }

    setConvexToCapsuleShapeMiddle(rect,sj);
    var result2 = this.convexCapsule(bj,rect,xj,aj, bi,si,xi,ai, justTest);

    if(this.enableFrictionReduction){
        this.enableFriction = enableFrictionBefore;
    }

    if(justTest && result2){
        return true;
    }
    numContacts += result2;

    if(this.enableFrictionReduction){
        if(numContacts && this.enableFriction){
            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        }
    }

    return numContacts;
};

/**
 * Line/line narrowphase
 * @method lineLine
 * @param  {Body}       bodyA
 * @param  {Line}       shapeA
 * @param  {Array}      positionA
 * @param  {Number}     angleA
 * @param  {Body}       bodyB
 * @param  {Line}       shapeB
 * @param  {Array}      positionB
 * @param  {Number}     angleB
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.LINE | Shape.LINE] =
Narrowphase.prototype.lineLine = function(
    bodyA,
    shapeA,
    positionA,
    angleA,
    bodyB,
    shapeB,
    positionB,
    angleB,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

/**
 * Plane/line Narrowphase
 * @method planeLine
 * @param  {Body}   planeBody
 * @param  {Plane}  planeShape
 * @param  {Array}  planeOffset
 * @param  {Number} planeAngle
 * @param  {Body}   lineBody
 * @param  {Line}   lineShape
 * @param  {Array}  lineOffset
 * @param  {Number} lineAngle
 */
Narrowphase.prototype[Shape.PLANE | Shape.LINE] =
Narrowphase.prototype.planeLine = function(planeBody, planeShape, planeOffset, planeAngle,
                                           lineBody,  lineShape,  lineOffset,  lineAngle, justTest){
    var worldVertex0 = tmp1,
        worldVertex1 = tmp2,
        worldVertex01 = tmp3,
        worldVertex11 = tmp4,
        worldEdge = tmp5,
        worldEdgeUnit = tmp6,
        dist = tmp7,
        worldNormal = tmp8,
        worldTangent = tmp9,
        verts = tmpArray,
        numContacts = 0;

    // Get start and end points
    vec2.set(worldVertex0, -lineShape.length/2, 0);
    vec2.set(worldVertex1,  lineShape.length/2, 0);

    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
    vec2.rotate(worldVertex01, worldVertex0, lineAngle);
    vec2.rotate(worldVertex11, worldVertex1, lineAngle);

    add(worldVertex01, worldVertex01, lineOffset);
    add(worldVertex11, worldVertex11, lineOffset);

    vec2.copy(worldVertex0,worldVertex01);
    vec2.copy(worldVertex1,worldVertex11);

    // Get vector along the line
    sub(worldEdge, worldVertex1, worldVertex0);
    vec2.normalize(worldEdgeUnit, worldEdge);

    // Get tangent to the edge.
    vec2.rotate90cw(worldTangent, worldEdgeUnit);

    vec2.rotate(worldNormal, yAxis, planeAngle);

    // Check line ends
    verts[0] = worldVertex0;
    verts[1] = worldVertex1;
    for(var i=0; i<verts.length; i++){
        var v = verts[i];

        sub(dist, v, planeOffset);

        var d = dot(dist,worldNormal);

        if(d < 0){

            if(justTest){
                return true;
            }

            var c = this.createContactEquation(planeBody,lineBody,planeShape,lineShape);
            numContacts++;

            vec2.copy(c.normalA, worldNormal);
            vec2.normalize(c.normalA,c.normalA);

            // distance vector along plane normal
            vec2.scale(dist, worldNormal, d);

            // Vector from plane center to contact
            sub(c.contactPointA, v, dist);
            sub(c.contactPointA, c.contactPointA, planeBody.position);

            // From line center to contact
            sub(c.contactPointB, v,    lineOffset);
            add(c.contactPointB, c.contactPointB, lineOffset);
            sub(c.contactPointB, c.contactPointB, lineBody.position);

            this.contactEquations.push(c);

            if(!this.enableFrictionReduction){
                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
    }

    if(justTest){
        return false;
    }

    if(!this.enableFrictionReduction){
        if(numContacts && this.enableFriction){
            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        }
    }

    return numContacts;
};

Narrowphase.prototype[Shape.PARTICLE | Shape.CAPSULE] =
Narrowphase.prototype.particleCapsule = function(
    particleBody,
    particleShape,
    particlePosition,
    particleAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
){
    return this.circleLine(particleBody,particleShape,particlePosition,particleAngle, capsuleBody,capsuleShape,capsulePosition,capsuleAngle, justTest, capsuleShape.radius, 0);
};

/**
 * Circle/line Narrowphase
 * @method circleLine
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} lineBody
 * @param  {Line} lineShape
 * @param  {Array} lineOffset
 * @param  {Number} lineAngle
 * @param {Boolean} justTest If set to true, this function will return the result (intersection or not) without adding equations.
 * @param {Number} lineRadius Radius to add to the line. Can be used to test Capsules.
 * @param {Number} circleRadius If set, this value overrides the circle shape radius.
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.LINE] =
Narrowphase.prototype.circleLine = function(
    circleBody,
    circleShape,
    circleOffset,
    circleAngle,
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    justTest,
    lineRadius,
    circleRadius
){
    var lineRadius = lineRadius || 0,
        circleRadius = typeof(circleRadius)!=="undefined" ? circleRadius : circleShape.radius,

        orthoDist = tmp1,
        lineToCircleOrthoUnit = tmp2,
        projectedPoint = tmp3,
        centerDist = tmp4,
        worldTangent = tmp5,
        worldEdge = tmp6,
        worldEdgeUnit = tmp7,
        worldVertex0 = tmp8,
        worldVertex1 = tmp9,
        worldVertex01 = tmp10,
        worldVertex11 = tmp11,
        dist = tmp12,
        lineToCircle = tmp13,
        lineEndToLineRadius = tmp14,

        verts = tmpArray;

    // Get start and end points
    vec2.set(worldVertex0, -lineShape.length/2, 0);
    vec2.set(worldVertex1,  lineShape.length/2, 0);

    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
    vec2.rotate(worldVertex01, worldVertex0, lineAngle);
    vec2.rotate(worldVertex11, worldVertex1, lineAngle);

    add(worldVertex01, worldVertex01, lineOffset);
    add(worldVertex11, worldVertex11, lineOffset);

    vec2.copy(worldVertex0,worldVertex01);
    vec2.copy(worldVertex1,worldVertex11);

    // Get vector along the line
    sub(worldEdge, worldVertex1, worldVertex0);
    vec2.normalize(worldEdgeUnit, worldEdge);

    // Get tangent to the edge.
    vec2.rotate90cw(worldTangent, worldEdgeUnit);

    // Check distance from the plane spanned by the edge vs the circle
    sub(dist, circleOffset, worldVertex0);
    var d = dot(dist, worldTangent); // Distance from center of line to circle center
    sub(centerDist, worldVertex0, lineOffset);

    sub(lineToCircle, circleOffset, lineOffset);

    var radiusSum = circleRadius + lineRadius;

    if(Math.abs(d) < radiusSum){

        // Now project the circle onto the edge
        vec2.scale(orthoDist, worldTangent, d);
        sub(projectedPoint, circleOffset, orthoDist);

        // Add the missing line radius
        vec2.scale(lineToCircleOrthoUnit, worldTangent, dot(worldTangent, lineToCircle));
        vec2.normalize(lineToCircleOrthoUnit,lineToCircleOrthoUnit);
        vec2.scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);
        add(projectedPoint,projectedPoint,lineToCircleOrthoUnit);

        // Check if the point is within the edge span
        var pos =  dot(worldEdgeUnit, projectedPoint);
        var pos0 = dot(worldEdgeUnit, worldVertex0);
        var pos1 = dot(worldEdgeUnit, worldVertex1);

        if(pos > pos0 && pos < pos1){
            // We got contact!

            if(justTest){
                return true;
            }

            var c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);

            vec2.scale(c.normalA, orthoDist, -1);
            vec2.normalize(c.normalA, c.normalA);

            vec2.scale( c.contactPointA, c.normalA,  circleRadius);
            add(c.contactPointA, c.contactPointA, circleOffset);
            sub(c.contactPointA, c.contactPointA, circleBody.position);

            sub(c.contactPointB, projectedPoint, lineOffset);
            add(c.contactPointB, c.contactPointB, lineOffset);
            sub(c.contactPointB, c.contactPointB, lineBody.position);

            this.contactEquations.push(c);

            if(this.enableFriction){
                this.frictionEquations.push(this.createFrictionFromContact(c));
            }

            return 1;
        }
    }

    // Add corner
    verts[0] = worldVertex0;
    verts[1] = worldVertex1;

    for(var i=0; i<verts.length; i++){
        var v = verts[i];

        sub(dist, v, circleOffset);

        if(vec2.squaredLength(dist) < Math.pow(radiusSum, 2)){

            if(justTest){
                return true;
            }

            var c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);

            vec2.copy(c.normalA, dist);
            vec2.normalize(c.normalA,c.normalA);

            // Vector from circle to contact point is the normal times the circle radius
            vec2.scale(c.contactPointA, c.normalA, circleRadius);
            add(c.contactPointA, c.contactPointA, circleOffset);
            sub(c.contactPointA, c.contactPointA, circleBody.position);

            sub(c.contactPointB, v, lineOffset);
            vec2.scale(lineEndToLineRadius, c.normalA, -lineRadius);
            add(c.contactPointB, c.contactPointB, lineEndToLineRadius);
            add(c.contactPointB, c.contactPointB, lineOffset);
            sub(c.contactPointB, c.contactPointB, lineBody.position);

            this.contactEquations.push(c);

            if(this.enableFriction){
                this.frictionEquations.push(this.createFrictionFromContact(c));
            }

            return 1;
        }
    }

    return 0;
};

/**
 * Circle/capsule Narrowphase
 * @method circleCapsule
 * @param  {Body}   bi
 * @param  {Circle} si
 * @param  {Array}  xi
 * @param  {Number} ai
 * @param  {Body}   bj
 * @param  {Line}   sj
 * @param  {Array}  xj
 * @param  {Number} aj
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.CAPSULE] =
Narrowphase.prototype.circleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){
    return this.circleLine(bi,si,xi,ai, bj,sj,xj,aj, justTest, sj.radius);
};

/**
 * Circle/convex Narrowphase.
 * @method circleConvex
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param  {Boolean} justTest
 * @param  {Number} circleRadius
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.CONVEX] =
Narrowphase.prototype[Shape.CIRCLE | Shape.RECTANGLE] =
Narrowphase.prototype.circleConvex = function(
    circleBody,
    circleShape,
    circleOffset,
    circleAngle,
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    justTest,
    circleRadius
){
    var circleRadius = typeof(circleRadius)==="number" ? circleRadius : circleShape.radius;

    var worldVertex0 = tmp1,
        worldVertex1 = tmp2,
        worldEdge = tmp3,
        worldEdgeUnit = tmp4,
        worldNormal = tmp5,
        centerDist = tmp6,
        convexToCircle = tmp7,
        orthoDist = tmp8,
        projectedPoint = tmp9,
        dist = tmp10,
        worldVertex = tmp11,

        closestEdge = -1,
        closestEdgeDistance = null,
        closestEdgeOrthoDist = tmp12,
        closestEdgeProjectedPoint = tmp13,
        candidate = tmp14,
        candidateDist = tmp15,
        minCandidate = tmp16,

        found = false,
        minCandidateDistance = Number.MAX_VALUE;

    var numReported = 0;

    // New algorithm:
    // 1. Check so center of circle is not inside the polygon. If it is, this wont work...
    // 2. For each edge
    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
    // 2. 2. Check if point is inside.

    var verts = convexShape.vertices;

    // Check all edges first
    for(var i=0; i!==verts.length+1; i++){
        var v0 = verts[i%verts.length],
            v1 = verts[(i+1)%verts.length];

        vec2.rotate(worldVertex0, v0, convexAngle);
        vec2.rotate(worldVertex1, v1, convexAngle);
        add(worldVertex0, worldVertex0, convexOffset);
        add(worldVertex1, worldVertex1, convexOffset);
        sub(worldEdge, worldVertex1, worldVertex0);

        vec2.normalize(worldEdgeUnit, worldEdge);

        // Get tangent to the edge. Points out of the Convex
        vec2.rotate90cw(worldNormal, worldEdgeUnit);

        // Get point on circle, closest to the polygon
        vec2.scale(candidate,worldNormal,-circleShape.radius);
        add(candidate,candidate,circleOffset);

        if(pointInConvex(candidate,convexShape,convexOffset,convexAngle)){

            vec2.sub(candidateDist,worldVertex0,candidate);
            var candidateDistance = Math.abs(vec2.dot(candidateDist,worldNormal));

            if(candidateDistance < minCandidateDistance){
                vec2.copy(minCandidate,candidate);
                minCandidateDistance = candidateDistance;
                vec2.scale(closestEdgeProjectedPoint,worldNormal,candidateDistance);
                vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,candidate);
                found = true;
            }
        }
    }

    if(found){

        if(justTest){
            return true;
        }

        var c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);
        vec2.sub(c.normalA, minCandidate, circleOffset);
        vec2.normalize(c.normalA, c.normalA);

        vec2.scale(c.contactPointA,  c.normalA, circleRadius);
        add(c.contactPointA, c.contactPointA, circleOffset);
        sub(c.contactPointA, c.contactPointA, circleBody.position);

        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
        add(c.contactPointB, c.contactPointB, convexOffset);
        sub(c.contactPointB, c.contactPointB, convexBody.position);

        this.contactEquations.push(c);

        if(this.enableFriction){
            this.frictionEquations.push( this.createFrictionFromContact(c) );
        }

        return 1;
    }

    // Check all vertices
    if(circleRadius > 0){
        for(var i=0; i<verts.length; i++){
            var localVertex = verts[i];
            vec2.rotate(worldVertex, localVertex, convexAngle);
            add(worldVertex, worldVertex, convexOffset);

            sub(dist, worldVertex, circleOffset);
            if(vec2.squaredLength(dist) < Math.pow(circleRadius, 2)){

                if(justTest){
                    return true;
                }

                var c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);

                vec2.copy(c.normalA, dist);
                vec2.normalize(c.normalA,c.normalA);

                // Vector from circle to contact point is the normal times the circle radius
                vec2.scale(c.contactPointA, c.normalA, circleRadius);
                add(c.contactPointA, c.contactPointA, circleOffset);
                sub(c.contactPointA, c.contactPointA, circleBody.position);

                sub(c.contactPointB, worldVertex, convexOffset);
                add(c.contactPointB, c.contactPointB, convexOffset);
                sub(c.contactPointB, c.contactPointB, convexBody.position);

                this.contactEquations.push(c);

                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }

                return 1;
            }
        }
    }

    return 0;
};

var pic_worldVertex0 = vec2.create(),
    pic_worldVertex1 = vec2.create(),
    pic_r0 = vec2.create(),
    pic_r1 = vec2.create();

/*
 * Check if a point is in a polygon
 */
function pointInConvex(worldPoint,convexShape,convexOffset,convexAngle){
    var worldVertex0 = pic_worldVertex0,
        worldVertex1 = pic_worldVertex1,
        r0 = pic_r0,
        r1 = pic_r1,
        point = worldPoint,
        verts = convexShape.vertices,
        lastCross = null;
    for(var i=0; i!==verts.length+1; i++){
        var v0 = verts[i%verts.length],
            v1 = verts[(i+1)%verts.length];

        // Transform vertices to world
        // @todo The point should be transformed to local coordinates in the convex, no need to transform each vertex
        vec2.rotate(worldVertex0, v0, convexAngle);
        vec2.rotate(worldVertex1, v1, convexAngle);
        add(worldVertex0, worldVertex0, convexOffset);
        add(worldVertex1, worldVertex1, convexOffset);

        sub(r0, worldVertex0, point);
        sub(r1, worldVertex1, point);
        var cross = vec2.crossLength(r0,r1);

        if(lastCross===null){
            lastCross = cross;
        }

        // If we got a different sign of the distance vector, the point is out of the polygon
        if(cross*lastCross <= 0){
            return false;
        }
        lastCross = cross;
    }
    return true;
}

/**
 * Particle/convex Narrowphase
 * @method particleConvex
 * @param  {Body} particleBody
 * @param  {Particle} particleShape
 * @param  {Array} particleOffset
 * @param  {Number} particleAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param {Boolean} justTest
 * @todo use pointInConvex and code more similar to circleConvex
 * @todo don't transform each vertex, but transform the particle position to convex-local instead
 */
Narrowphase.prototype[Shape.PARTICLE | Shape.CONVEX] =
Narrowphase.prototype[Shape.PARTICLE | Shape.RECTANGLE] =
Narrowphase.prototype.particleConvex = function(
    particleBody,
    particleShape,
    particleOffset,
    particleAngle,
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    justTest
){
    var worldVertex0 = tmp1,
        worldVertex1 = tmp2,
        worldEdge = tmp3,
        worldEdgeUnit = tmp4,
        worldTangent = tmp5,
        centerDist = tmp6,
        convexToparticle = tmp7,
        orthoDist = tmp8,
        projectedPoint = tmp9,
        dist = tmp10,
        worldVertex = tmp11,
        closestEdge = -1,
        closestEdgeDistance = null,
        closestEdgeOrthoDist = tmp12,
        closestEdgeProjectedPoint = tmp13,
        r0 = tmp14, // vector from particle to vertex0
        r1 = tmp15,
        localPoint = tmp16,
        candidateDist = tmp17,
        minEdgeNormal = tmp18,
        minCandidateDistance = Number.MAX_VALUE;

    var numReported = 0,
        found = false,
        verts = convexShape.vertices;

    // Check if the particle is in the polygon at all
    if(!pointInConvex(particleOffset,convexShape,convexOffset,convexAngle)){
        return 0;
    }

    if(justTest){
        return true;
    }

    // Check edges first
    var lastCross = null;
    for(var i=0; i!==verts.length+1; i++){
        var v0 = verts[i%verts.length],
            v1 = verts[(i+1)%verts.length];

        // Transform vertices to world
        vec2.rotate(worldVertex0, v0, convexAngle);
        vec2.rotate(worldVertex1, v1, convexAngle);
        add(worldVertex0, worldVertex0, convexOffset);
        add(worldVertex1, worldVertex1, convexOffset);

        // Get world edge
        sub(worldEdge, worldVertex1, worldVertex0);
        vec2.normalize(worldEdgeUnit, worldEdge);

        // Get tangent to the edge. Points out of the Convex
        vec2.rotate90cw(worldTangent, worldEdgeUnit);

        // Check distance from the infinite line (spanned by the edge) to the particle
        sub(dist, particleOffset, worldVertex0);
        var d = dot(dist, worldTangent);
        sub(centerDist, worldVertex0, convexOffset);

        sub(convexToparticle, particleOffset, convexOffset);

        vec2.sub(candidateDist,worldVertex0,particleOffset);
        var candidateDistance = Math.abs(vec2.dot(candidateDist,worldTangent));

        if(candidateDistance < minCandidateDistance){
            minCandidateDistance = candidateDistance;
            vec2.scale(closestEdgeProjectedPoint,worldTangent,candidateDistance);
            vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,particleOffset);
            vec2.copy(minEdgeNormal,worldTangent);
            found = true;
        }
    }

    if(found){
        var c = this.createContactEquation(particleBody,convexBody,particleShape,convexShape);

        vec2.scale(c.normalA, minEdgeNormal, -1);
        vec2.normalize(c.normalA, c.normalA);

        // Particle has no extent to the contact point
        vec2.set(c.contactPointA,  0, 0);
        add(c.contactPointA, c.contactPointA, particleOffset);
        sub(c.contactPointA, c.contactPointA, particleBody.position);

        // From convex center to point
        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
        add(c.contactPointB, c.contactPointB, convexOffset);
        sub(c.contactPointB, c.contactPointB, convexBody.position);

        this.contactEquations.push(c);

        if(this.enableFriction){
            this.frictionEquations.push( this.createFrictionFromContact(c) );
        }

        return 1;
    }


    return 0;
};

/**
 * Circle/circle Narrowphase
 * @method circleCircle
 * @param  {Body} bodyA
 * @param  {Circle} shapeA
 * @param  {Array} offsetA
 * @param  {Number} angleA
 * @param  {Body} bodyB
 * @param  {Circle} shapeB
 * @param  {Array} offsetB
 * @param  {Number} angleB
 * @param {Boolean} justTest
 * @param {Number} [radiusA] Optional radius to use for shapeA
 * @param {Number} [radiusB] Optional radius to use for shapeB
 */
Narrowphase.prototype[Shape.CIRCLE] =
Narrowphase.prototype.circleCircle = function(
    bodyA,
    shapeA,
    offsetA,
    angleA,
    bodyB,
    shapeB,
    offsetB,
    angleB,
    justTest,
    radiusA,
    radiusB
){

    var dist = tmp1,
        radiusA = radiusA || shapeA.radius,
        radiusB = radiusB || shapeB.radius;

    sub(dist,offsetA,offsetB);
    var r = radiusA + radiusB;
    if(vec2.squaredLength(dist) > Math.pow(r,2)){
        return 0;
    }

    if(justTest){
        return true;
    }

    var c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);
    sub(c.normalA, offsetB, offsetA);
    vec2.normalize(c.normalA,c.normalA);

    vec2.scale( c.contactPointA, c.normalA,  radiusA);
    vec2.scale( c.contactPointB, c.normalA, -radiusB);

    add(c.contactPointA, c.contactPointA, offsetA);
    sub(c.contactPointA, c.contactPointA, bodyA.position);

    add(c.contactPointB, c.contactPointB, offsetB);
    sub(c.contactPointB, c.contactPointB, bodyB.position);

    this.contactEquations.push(c);

    if(this.enableFriction){
        this.frictionEquations.push(this.createFrictionFromContact(c));
    }
    return 1;
};

/**
 * Plane/Convex Narrowphase
 * @method planeConvex
 * @param  {Body} planeBody
 * @param  {Plane} planeShape
 * @param  {Array} planeOffset
 * @param  {Number} planeAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param {Boolean} justTest
 */
Narrowphase.prototype[Shape.PLANE | Shape.CONVEX] =
Narrowphase.prototype[Shape.PLANE | Shape.RECTANGLE] =
Narrowphase.prototype.planeConvex = function(
    planeBody,
    planeShape,
    planeOffset,
    planeAngle,
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    justTest
){
    var worldVertex = tmp1,
        worldNormal = tmp2,
        dist = tmp3;

    var numReported = 0;
    vec2.rotate(worldNormal, yAxis, planeAngle);

    for(var i=0; i!==convexShape.vertices.length; i++){
        var v = convexShape.vertices[i];
        vec2.rotate(worldVertex, v, convexAngle);
        add(worldVertex, worldVertex, convexOffset);

        sub(dist, worldVertex, planeOffset);

        if(dot(dist,worldNormal) <= 0){

            if(justTest){
                return true;
            }

            // Found vertex
            numReported++;

            var c = this.createContactEquation(planeBody,convexBody,planeShape,convexShape);

            sub(dist, worldVertex, planeOffset);

            vec2.copy(c.normalA, worldNormal);

            var d = dot(dist, c.normalA);
            vec2.scale(dist, c.normalA, d);

            // rj is from convex center to contact
            sub(c.contactPointB, worldVertex, convexBody.position);


            // ri is from plane center to contact
            sub( c.contactPointA, worldVertex, dist);
            sub( c.contactPointA, c.contactPointA, planeBody.position);

            this.contactEquations.push(c);

            if(!this.enableFrictionReduction){
                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
    }

    if(this.enableFrictionReduction){
        if(this.enableFriction && numReported){
            this.frictionEquations.push(this.createFrictionFromAverage(numReported));
        }
    }

    return numReported;
};

/**
 * Narrowphase for particle vs plane
 * @method particlePlane
 * @param  {Body}       particleBody
 * @param  {Particle}   particleShape
 * @param  {Array}      particleOffset
 * @param  {Number}     particleAngle
 * @param  {Body}       planeBody
 * @param  {Plane}      planeShape
 * @param  {Array}      planeOffset
 * @param  {Number}     planeAngle
 * @param {Boolean}     justTest
 */
Narrowphase.prototype[Shape.PARTICLE | Shape.PLANE] =
Narrowphase.prototype.particlePlane = function(
    particleBody,
    particleShape,
    particleOffset,
    particleAngle,
    planeBody,
    planeShape,
    planeOffset,
    planeAngle,
    justTest
){
    var dist = tmp1,
        worldNormal = tmp2;

    planeAngle = planeAngle || 0;

    sub(dist, particleOffset, planeOffset);
    vec2.rotate(worldNormal, yAxis, planeAngle);

    var d = dot(dist, worldNormal);

    if(d > 0){
        return 0;
    }
    if(justTest){
        return true;
    }

    var c = this.createContactEquation(planeBody,particleBody,planeShape,particleShape);

    vec2.copy(c.normalA, worldNormal);
    vec2.scale( dist, c.normalA, d );
    // dist is now the distance vector in the normal direction

    // ri is the particle position projected down onto the plane, from the plane center
    sub( c.contactPointA, particleOffset, dist);
    sub( c.contactPointA, c.contactPointA, planeBody.position);

    // rj is from the body center to the particle center
    sub( c.contactPointB, particleOffset, particleBody.position );

    this.contactEquations.push(c);

    if(this.enableFriction){
        this.frictionEquations.push(this.createFrictionFromContact(c));
    }
    return 1;
};

/**
 * Circle/Particle Narrowphase
 * @method circleParticle
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} particleBody
 * @param  {Particle} particleShape
 * @param  {Array} particleOffset
 * @param  {Number} particleAngle
 * @param  {Boolean} justTest
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.PARTICLE] =
Narrowphase.prototype.circleParticle = function(
    circleBody,
    circleShape,
    circleOffset,
    circleAngle,
    particleBody,
    particleShape,
    particleOffset,
    particleAngle,
    justTest
){
    var dist = tmp1;

    sub(dist, particleOffset, circleOffset);
    if(vec2.squaredLength(dist) > Math.pow(circleShape.radius, 2)){
        return 0;
    }
    if(justTest){
        return true;
    }

    var c = this.createContactEquation(circleBody,particleBody,circleShape,particleShape);
    vec2.copy(c.normalA, dist);
    vec2.normalize(c.normalA,c.normalA);

    // Vector from circle to contact point is the normal times the circle radius
    vec2.scale(c.contactPointA, c.normalA, circleShape.radius);
    add(c.contactPointA, c.contactPointA, circleOffset);
    sub(c.contactPointA, c.contactPointA, circleBody.position);

    // Vector from particle center to contact point is zero
    sub(c.contactPointB, particleOffset, particleBody.position);

    this.contactEquations.push(c);

    if(this.enableFriction){
        this.frictionEquations.push(this.createFrictionFromContact(c));
    }

    return 1;
};

var planeCapsule_tmpCircle = new Circle(1),
    planeCapsule_tmp1 = vec2.create(),
    planeCapsule_tmp2 = vec2.create(),
    planeCapsule_tmp3 = vec2.create();

/**
 * @method planeCapsule
 * @param  {Body} planeBody
 * @param  {Circle} planeShape
 * @param  {Array} planeOffset
 * @param  {Number} planeAngle
 * @param  {Body} capsuleBody
 * @param  {Particle} capsuleShape
 * @param  {Array} capsuleOffset
 * @param  {Number} capsuleAngle
 * @param {Boolean} justTest
 */
Narrowphase.prototype[Shape.PLANE | Shape.CAPSULE] =
Narrowphase.prototype.planeCapsule = function(
    planeBody,
    planeShape,
    planeOffset,
    planeAngle,
    capsuleBody,
    capsuleShape,
    capsuleOffset,
    capsuleAngle,
    justTest
){
    var end1 = planeCapsule_tmp1,
        end2 = planeCapsule_tmp2,
        circle = planeCapsule_tmpCircle,
        dst = planeCapsule_tmp3;

    // Compute world end positions
    vec2.set(end1, -capsuleShape.length/2, 0);
    vec2.rotate(end1,end1,capsuleAngle);
    add(end1,end1,capsuleOffset);

    vec2.set(end2,  capsuleShape.length/2, 0);
    vec2.rotate(end2,end2,capsuleAngle);
    add(end2,end2,capsuleOffset);

    circle.radius = capsuleShape.radius;

    var enableFrictionBefore;

    // Temporarily turn off friction
    if(this.enableFrictionReduction){
        enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
    }

    // Do Narrowphase as two circles
    var numContacts1 = this.circlePlane(capsuleBody,circle,end1,0, planeBody,planeShape,planeOffset,planeAngle, justTest),
        numContacts2 = this.circlePlane(capsuleBody,circle,end2,0, planeBody,planeShape,planeOffset,planeAngle, justTest);

    // Restore friction
    if(this.enableFrictionReduction){
        this.enableFriction = enableFrictionBefore;
    }

    if(justTest){
        return numContacts1 || numContacts2;
    } else {
        var numTotal = numContacts1 + numContacts2;
        if(this.enableFrictionReduction){
            if(numTotal){
                this.frictionEquations.push(this.createFrictionFromAverage(numTotal));
            }
        }
        return numTotal;
    }
};

/**
 * Creates ContactEquations and FrictionEquations for a collision.
 * @method circlePlane
 * @param  {Body}    bi     The first body that should be connected to the equations.
 * @param  {Circle}  si     The circle shape participating in the collision.
 * @param  {Array}   xi     Extra offset to take into account for the Shape, in addition to the one in circleBody.position. Will *not* be rotated by circleBody.angle (maybe it should, for sake of homogenity?). Set to null if none.
 * @param  {Body}    bj     The second body that should be connected to the equations.
 * @param  {Plane}   sj     The Plane shape that is participating
 * @param  {Array}   xj     Extra offset for the plane shape.
 * @param  {Number}  aj     Extra angle to apply to the plane
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.PLANE] =
Narrowphase.prototype.circlePlane = function(   bi,si,xi,ai, bj,sj,xj,aj, justTest ){
    var circleBody = bi,
        circleShape = si,
        circleOffset = xi, // Offset from body center, rotated!
        planeBody = bj,
        shapeB = sj,
        planeOffset = xj,
        planeAngle = aj;

    planeAngle = planeAngle || 0;

    // Vector from plane to circle
    var planeToCircle = tmp1,
        worldNormal = tmp2,
        temp = tmp3;

    sub(planeToCircle, circleOffset, planeOffset);

    // World plane normal
    vec2.rotate(worldNormal, yAxis, planeAngle);

    // Normal direction distance
    var d = dot(worldNormal, planeToCircle);

    if(d > circleShape.radius){
        return 0; // No overlap. Abort.
    }

    if(justTest){
        return true;
    }

    // Create contact
    var contact = this.createContactEquation(planeBody,circleBody,sj,si);

    // ni is the plane world normal
    vec2.copy(contact.normalA, worldNormal);

    // rj is the vector from circle center to the contact point
    vec2.scale(contact.contactPointB, contact.normalA, -circleShape.radius);
    add(contact.contactPointB, contact.contactPointB, circleOffset);
    sub(contact.contactPointB, contact.contactPointB, circleBody.position);

    // ri is the distance from plane center to contact.
    vec2.scale(temp, contact.normalA, d);
    sub(contact.contactPointA, planeToCircle, temp ); // Subtract normal distance vector from the distance vector
    add(contact.contactPointA, contact.contactPointA, planeOffset);
    sub(contact.contactPointA, contact.contactPointA, planeBody.position);

    this.contactEquations.push(contact);

    if(this.enableFriction){
        this.frictionEquations.push( this.createFrictionFromContact(contact) );
    }

    return 1;
};

/**
 * Convex/convex Narrowphase.See <a href="http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/">this article</a> for more info.
 * @method convexConvex
 * @param  {Body} bi
 * @param  {Convex} si
 * @param  {Array} xi
 * @param  {Number} ai
 * @param  {Body} bj
 * @param  {Convex} sj
 * @param  {Array} xj
 * @param  {Number} aj
 */
Narrowphase.prototype[Shape.CONVEX] =
Narrowphase.prototype[Shape.CONVEX | Shape.RECTANGLE] =
Narrowphase.prototype[Shape.RECTANGLE] =
Narrowphase.prototype.convexConvex = function(  bi,si,xi,ai, bj,sj,xj,aj, justTest, precision ){
    var sepAxis = tmp1,
        worldPoint = tmp2,
        worldPoint0 = tmp3,
        worldPoint1 = tmp4,
        worldEdge = tmp5,
        projected = tmp6,
        penetrationVec = tmp7,
        dist = tmp8,
        worldNormal = tmp9,
        numContacts = 0,
        precision = typeof(precision) === 'number' ? precision : 0;

    var found = Narrowphase.findSeparatingAxis(si,xi,ai,sj,xj,aj,sepAxis);
    if(!found){
        return 0;
    }

    // Make sure the separating axis is directed from shape i to shape j
    sub(dist,xj,xi);
    if(dot(sepAxis,dist) > 0){
        vec2.scale(sepAxis,sepAxis,-1);
    }

    // Find edges with normals closest to the separating axis
    var closestEdge1 = Narrowphase.getClosestEdge(si,ai,sepAxis,true), // Flipped axis
        closestEdge2 = Narrowphase.getClosestEdge(sj,aj,sepAxis);

    if(closestEdge1 === -1 || closestEdge2 === -1){
        return 0;
    }

    // Loop over the shapes
    for(var k=0; k<2; k++){

        var closestEdgeA = closestEdge1,
            closestEdgeB = closestEdge2,
            shapeA =  si, shapeB =  sj,
            offsetA = xi, offsetB = xj,
            angleA = ai, angleB = aj,
            bodyA = bi, bodyB = bj;

        if(k === 0){
            // Swap!
            var tmp;
            tmp = closestEdgeA;
            closestEdgeA = closestEdgeB;
            closestEdgeB = tmp;

            tmp = shapeA;
            shapeA = shapeB;
            shapeB = tmp;

            tmp = offsetA;
            offsetA = offsetB;
            offsetB = tmp;

            tmp = angleA;
            angleA = angleB;
            angleB = tmp;

            tmp = bodyA;
            bodyA = bodyB;
            bodyB = tmp;
        }

        // Loop over 2 points in convex B
        for(var j=closestEdgeB; j<closestEdgeB+2; j++){

            // Get world point
            var v = shapeB.vertices[(j+shapeB.vertices.length)%shapeB.vertices.length];
            vec2.rotate(worldPoint, v, angleB);
            add(worldPoint, worldPoint, offsetB);

            var insideNumEdges = 0;

            // Loop over the 3 closest edges in convex A
            for(var i=closestEdgeA-1; i<closestEdgeA+2; i++){

                var v0 = shapeA.vertices[(i  +shapeA.vertices.length)%shapeA.vertices.length],
                    v1 = shapeA.vertices[(i+1+shapeA.vertices.length)%shapeA.vertices.length];

                // Construct the edge
                vec2.rotate(worldPoint0, v0, angleA);
                vec2.rotate(worldPoint1, v1, angleA);
                add(worldPoint0, worldPoint0, offsetA);
                add(worldPoint1, worldPoint1, offsetA);

                sub(worldEdge, worldPoint1, worldPoint0);

                vec2.rotate90cw(worldNormal, worldEdge); // Normal points out of convex 1
                vec2.normalize(worldNormal,worldNormal);

                sub(dist, worldPoint, worldPoint0);

                var d = dot(worldNormal,dist);

                if((i === closestEdgeA && d <= precision) || (i !== closestEdgeA && d <= 0)){
                    insideNumEdges++;
                }
            }

            if(insideNumEdges >= 3){

                if(justTest){
                    return true;
                }

                // worldPoint was on the "inside" side of each of the 3 checked edges.
                // Project it to the center edge and use the projection direction as normal

                // Create contact
                var c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);
                numContacts++;

                // Get center edge from body A
                var v0 = shapeA.vertices[(closestEdgeA)   % shapeA.vertices.length],
                    v1 = shapeA.vertices[(closestEdgeA+1) % shapeA.vertices.length];

                // Construct the edge
                vec2.rotate(worldPoint0, v0, angleA);
                vec2.rotate(worldPoint1, v1, angleA);
                add(worldPoint0, worldPoint0, offsetA);
                add(worldPoint1, worldPoint1, offsetA);

                sub(worldEdge, worldPoint1, worldPoint0);

                vec2.rotate90cw(c.normalA, worldEdge); // Normal points out of convex A
                vec2.normalize(c.normalA,c.normalA);

                sub(dist, worldPoint, worldPoint0); // From edge point to the penetrating point
                var d = dot(c.normalA,dist);             // Penetration
                vec2.scale(penetrationVec, c.normalA, d);     // Vector penetration

                sub(c.contactPointA, worldPoint, offsetA);
                sub(c.contactPointA, c.contactPointA, penetrationVec);
                add(c.contactPointA, c.contactPointA, offsetA);
                sub(c.contactPointA, c.contactPointA, bodyA.position);

                sub(c.contactPointB, worldPoint, offsetB);
                add(c.contactPointB, c.contactPointB, offsetB);
                sub(c.contactPointB, c.contactPointB, bodyB.position);

                this.contactEquations.push(c);

                // Todo reduce to 1 friction equation if we have 2 contact points
                if(!this.enableFrictionReduction){
                    if(this.enableFriction){
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                }
            }
        }
    }

    if(this.enableFrictionReduction){
        if(this.enableFriction && numContacts){
            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        }
    }

    return numContacts;
};

// .projectConvex is called by other functions, need local tmp vectors
var pcoa_tmp1 = vec2.fromValues(0,0);

/**
 * Project a Convex onto a world-oriented axis
 * @method projectConvexOntoAxis
 * @static
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param  {Array} worldAxis
 * @param  {Array} result
 */
Narrowphase.projectConvexOntoAxis = function(convexShape, convexOffset, convexAngle, worldAxis, result){
    var max=null,
        min=null,
        v,
        value,
        localAxis = pcoa_tmp1;

    // Convert the axis to local coords of the body
    vec2.rotate(localAxis, worldAxis, -convexAngle);

    // Get projected position of all vertices
    for(var i=0; i<convexShape.vertices.length; i++){
        v = convexShape.vertices[i];
        value = dot(v,localAxis);
        if(max === null || value > max){
            max = value;
        }
        if(min === null || value < min){
            min = value;
        }
    }

    if(min > max){
        var t = min;
        min = max;
        max = t;
    }

    // Project the position of the body onto the axis - need to add this to the result
    var offset = dot(convexOffset, worldAxis);

    vec2.set( result, min + offset, max + offset);
};

// .findSeparatingAxis is called by other functions, need local tmp vectors
var fsa_tmp1 = vec2.fromValues(0,0)
,   fsa_tmp2 = vec2.fromValues(0,0)
,   fsa_tmp3 = vec2.fromValues(0,0)
,   fsa_tmp4 = vec2.fromValues(0,0)
,   fsa_tmp5 = vec2.fromValues(0,0)
,   fsa_tmp6 = vec2.fromValues(0,0);

/**
 * Find a separating axis between the shapes, that maximizes the separating distance between them.
 * @method findSeparatingAxis
 * @static
 * @param  {Convex}     c1
 * @param  {Array}      offset1
 * @param  {Number}     angle1
 * @param  {Convex}     c2
 * @param  {Array}      offset2
 * @param  {Number}     angle2
 * @param  {Array}      sepAxis     The resulting axis
 * @return {Boolean}                Whether the axis could be found.
 */
Narrowphase.findSeparatingAxis = function(c1,offset1,angle1,c2,offset2,angle2,sepAxis){
    var maxDist = null,
        overlap = false,
        found = false,
        edge = fsa_tmp1,
        worldPoint0 = fsa_tmp2,
        worldPoint1 = fsa_tmp3,
        normal = fsa_tmp4,
        span1 = fsa_tmp5,
        span2 = fsa_tmp6;

    if(c1 instanceof Rectangle && c2 instanceof Rectangle){

        for(var j=0; j!==2; j++){
            var c = c1,
                angle = angle1;
            if(j===1){
                c = c2;
                angle = angle2;
            }

            for(var i=0; i!==2; i++){

                // Get the world edge
                if(i === 0){
                    vec2.set(normal, 0, 1);
                } else if(i === 1) {
                    vec2.set(normal, 1, 0);
                }
                if(angle !== 0){
                    vec2.rotate(normal, normal, angle);
                }

                // Project hulls onto that normal
                Narrowphase.projectConvexOntoAxis(c1,offset1,angle1,normal,span1);
                Narrowphase.projectConvexOntoAxis(c2,offset2,angle2,normal,span2);

                // Order by span position
                var a=span1,
                    b=span2,
                    swapped = false;
                if(span1[0] > span2[0]){
                    b=span1;
                    a=span2;
                    swapped = true;
                }

                // Get separating distance
                var dist = b[0] - a[1];
                overlap = (dist <= 0);

                if(maxDist===null || dist > maxDist){
                    vec2.copy(sepAxis, normal);
                    maxDist = dist;
                    found = overlap;
                }
            }
        }

    } else {

        for(var j=0; j!==2; j++){
            var c = c1,
                angle = angle1;
            if(j===1){
                c = c2;
                angle = angle2;
            }

            for(var i=0; i!==c.vertices.length; i++){
                // Get the world edge
                vec2.rotate(worldPoint0, c.vertices[i], angle);
                vec2.rotate(worldPoint1, c.vertices[(i+1)%c.vertices.length], angle);

                sub(edge, worldPoint1, worldPoint0);

                // Get normal - just rotate 90 degrees since vertices are given in CCW
                vec2.rotate90cw(normal, edge);
                vec2.normalize(normal,normal);

                // Project hulls onto that normal
                Narrowphase.projectConvexOntoAxis(c1,offset1,angle1,normal,span1);
                Narrowphase.projectConvexOntoAxis(c2,offset2,angle2,normal,span2);

                // Order by span position
                var a=span1,
                    b=span2,
                    swapped = false;
                if(span1[0] > span2[0]){
                    b=span1;
                    a=span2;
                    swapped = true;
                }

                // Get separating distance
                var dist = b[0] - a[1];
                overlap = (dist <= 0);

                if(maxDist===null || dist > maxDist){
                    vec2.copy(sepAxis, normal);
                    maxDist = dist;
                    found = overlap;
                }
            }
        }
    }


    /*
    // Needs to be tested some more
    for(var j=0; j!==2; j++){
        var c = c1,
            angle = angle1;
        if(j===1){
            c = c2;
            angle = angle2;
        }

        for(var i=0; i!==c.axes.length; i++){

            var normal = c.axes[i];

            // Project hulls onto that normal
            Narrowphase.projectConvexOntoAxis(c1, offset1, angle1, normal, span1);
            Narrowphase.projectConvexOntoAxis(c2, offset2, angle2, normal, span2);

            // Order by span position
            var a=span1,
                b=span2,
                swapped = false;
            if(span1[0] > span2[0]){
                b=span1;
                a=span2;
                swapped = true;
            }

            // Get separating distance
            var dist = b[0] - a[1];
            overlap = (dist <= Narrowphase.convexPrecision);

            if(maxDist===null || dist > maxDist){
                vec2.copy(sepAxis, normal);
                maxDist = dist;
                found = overlap;
            }
        }
    }
    */

    return found;
};

// .getClosestEdge is called by other functions, need local tmp vectors
var gce_tmp1 = vec2.fromValues(0,0)
,   gce_tmp2 = vec2.fromValues(0,0)
,   gce_tmp3 = vec2.fromValues(0,0);

/**
 * Get the edge that has a normal closest to an axis.
 * @method getClosestEdge
 * @static
 * @param  {Convex}     c
 * @param  {Number}     angle
 * @param  {Array}      axis
 * @param  {Boolean}    flip
 * @return {Number}             Index of the edge that is closest. This index and the next spans the resulting edge. Returns -1 if failed.
 */
Narrowphase.getClosestEdge = function(c,angle,axis,flip){
    var localAxis = gce_tmp1,
        edge = gce_tmp2,
        normal = gce_tmp3;

    // Convert the axis to local coords of the body
    vec2.rotate(localAxis, axis, -angle);
    if(flip){
        vec2.scale(localAxis,localAxis,-1);
    }

    var closestEdge = -1,
        N = c.vertices.length,
        maxDot = -1;
    for(var i=0; i!==N; i++){
        // Get the edge
        sub(edge, c.vertices[(i+1)%N], c.vertices[i%N]);

        // Get normal - just rotate 90 degrees since vertices are given in CCW
        vec2.rotate90cw(normal, edge);
        vec2.normalize(normal,normal);

        var d = dot(normal,localAxis);
        if(closestEdge === -1 || d > maxDot){
            closestEdge = i % N;
            maxDot = d;
        }
    }

    return closestEdge;
};

var circleHeightfield_candidate = vec2.create(),
    circleHeightfield_dist = vec2.create(),
    circleHeightfield_v0 = vec2.create(),
    circleHeightfield_v1 = vec2.create(),
    circleHeightfield_minCandidate = vec2.create(),
    circleHeightfield_worldNormal = vec2.create(),
    circleHeightfield_minCandidateNormal = vec2.create();

/**
 * @method circleHeightfield
 * @param  {Body}           bi
 * @param  {Circle}         si
 * @param  {Array}          xi
 * @param  {Body}           bj
 * @param  {Heightfield}    sj
 * @param  {Array}          xj
 * @param  {Number}         aj
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.HEIGHTFIELD] =
Narrowphase.prototype.circleHeightfield = function( circleBody,circleShape,circlePos,circleAngle,
                                                    hfBody,hfShape,hfPos,hfAngle, justTest, radius ){
    var data = hfShape.data,
        radius = radius || circleShape.radius,
        w = hfShape.elementWidth,
        dist = circleHeightfield_dist,
        candidate = circleHeightfield_candidate,
        minCandidate = circleHeightfield_minCandidate,
        minCandidateNormal = circleHeightfield_minCandidateNormal,
        worldNormal = circleHeightfield_worldNormal,
        v0 = circleHeightfield_v0,
        v1 = circleHeightfield_v1;

    // Get the index of the points to test against
    var idxA = Math.floor( (circlePos[0] - radius - hfPos[0]) / w ),
        idxB = Math.ceil(  (circlePos[0] + radius - hfPos[0]) / w );

    /*if(idxB < 0 || idxA >= data.length)
        return justTest ? false : 0;*/

    if(idxA < 0){
        idxA = 0;
    }
    if(idxB >= data.length){
        idxB = data.length-1;
    }

    // Get max and min
    var max = data[idxA],
        min = data[idxB];
    for(var i=idxA; i<idxB; i++){
        if(data[i] < min){
            min = data[i];
        }
        if(data[i] > max){
            max = data[i];
        }
    }

    if(circlePos[1]-radius > max){
        return justTest ? false : 0;
    }

    /*
    if(circlePos[1]+radius < min){
        // Below the minimum point... We can just guess.
        // TODO
    }
    */

    // 1. Check so center of circle is not inside the field. If it is, this wont work...
    // 2. For each edge
    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
    // 2. 2. Check if point is inside.

    var found = false;

    // Check all edges first
    for(var i=idxA; i<idxB; i++){

        // Get points
        vec2.set(v0,     i*w, data[i]  );
        vec2.set(v1, (i+1)*w, data[i+1]);
        vec2.add(v0,v0,hfPos);
        vec2.add(v1,v1,hfPos);

        // Get normal
        vec2.sub(worldNormal, v1, v0);
        vec2.rotate(worldNormal, worldNormal, Math.PI/2);
        vec2.normalize(worldNormal,worldNormal);

        // Get point on circle, closest to the edge
        vec2.scale(candidate,worldNormal,-radius);
        vec2.add(candidate,candidate,circlePos);

        // Distance from v0 to the candidate point
        vec2.sub(dist,candidate,v0);

        // Check if it is in the element "stick"
        var d = vec2.dot(dist,worldNormal);
        if(candidate[0] >= v0[0] && candidate[0] < v1[0] && d <= 0){

            if(justTest){
                return true;
            }

            found = true;

            // Store the candidate point, projected to the edge
            vec2.scale(dist,worldNormal,-d);
            vec2.add(minCandidate,candidate,dist);
            vec2.copy(minCandidateNormal,worldNormal);

            var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);

            // Normal is out of the heightfield
            vec2.copy(c.normalA, minCandidateNormal);

            // Vector from circle to heightfield
            vec2.scale(c.contactPointB,  c.normalA, -radius);
            add(c.contactPointB, c.contactPointB, circlePos);
            sub(c.contactPointB, c.contactPointB, circleBody.position);

            vec2.copy(c.contactPointA, minCandidate);
            vec2.sub(c.contactPointA, c.contactPointA, hfBody.position);

            this.contactEquations.push(c);

            if(this.enableFriction){
                this.frictionEquations.push( this.createFrictionFromContact(c) );
            }
        }
    }

    // Check all vertices
    found = false;
    if(radius > 0){
        for(var i=idxA; i<=idxB; i++){

            // Get point
            vec2.set(v0, i*w, data[i]);
            vec2.add(v0,v0,hfPos);

            vec2.sub(dist, circlePos, v0);

            if(vec2.squaredLength(dist) < Math.pow(radius, 2)){

                if(justTest){
                    return true;
                }

                found = true;

                var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);

                // Construct normal - out of heightfield
                vec2.copy(c.normalA, dist);
                vec2.normalize(c.normalA,c.normalA);

                vec2.scale(c.contactPointB, c.normalA, -radius);
                add(c.contactPointB, c.contactPointB, circlePos);
                sub(c.contactPointB, c.contactPointB, circleBody.position);

                sub(c.contactPointA, v0, hfPos);
                add(c.contactPointA, c.contactPointA, hfPos);
                sub(c.contactPointA, c.contactPointA, hfBody.position);

                this.contactEquations.push(c);

                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
    }

    if(found){
        return 1;
    }

    return 0;

};

var convexHeightfield_v0 = vec2.create(),
    convexHeightfield_v1 = vec2.create(),
    convexHeightfield_tilePos = vec2.create(),
    convexHeightfield_tempConvexShape = new Convex([vec2.create(),vec2.create(),vec2.create(),vec2.create()]);
/**
 * @method circleHeightfield
 * @param  {Body}           bi
 * @param  {Circle}         si
 * @param  {Array}          xi
 * @param  {Body}           bj
 * @param  {Heightfield}    sj
 * @param  {Array}          xj
 * @param  {Number}         aj
 */
Narrowphase.prototype[Shape.RECTANGLE | Shape.HEIGHTFIELD] =
Narrowphase.prototype[Shape.CONVEX | Shape.HEIGHTFIELD] =
Narrowphase.prototype.convexHeightfield = function( convexBody,convexShape,convexPos,convexAngle,
                                                    hfBody,hfShape,hfPos,hfAngle, justTest ){
    var data = hfShape.data,
        w = hfShape.elementWidth,
        v0 = convexHeightfield_v0,
        v1 = convexHeightfield_v1,
        tilePos = convexHeightfield_tilePos,
        tileConvex = convexHeightfield_tempConvexShape;

    // Get the index of the points to test against
    var idxA = Math.floor( (convexBody.aabb.lowerBound[0] - hfPos[0]) / w ),
        idxB = Math.ceil(  (convexBody.aabb.upperBound[0] - hfPos[0]) / w );

    if(idxA < 0){
        idxA = 0;
    }
    if(idxB >= data.length){
        idxB = data.length-1;
    }

    // Get max and min
    var max = data[idxA],
        min = data[idxB];
    for(var i=idxA; i<idxB; i++){
        if(data[i] < min){
            min = data[i];
        }
        if(data[i] > max){
            max = data[i];
        }
    }

    if(convexBody.aabb.lowerBound[1] > max){
        return justTest ? false : 0;
    }

    var found = false;
    var numContacts = 0;

    // Loop over all edges
    // TODO: If possible, construct a convex from several data points (need o check if the points make a convex shape)
    for(var i=idxA; i<idxB; i++){

        // Get points
        vec2.set(v0,     i*w, data[i]  );
        vec2.set(v1, (i+1)*w, data[i+1]);
        vec2.add(v0,v0,hfPos);
        vec2.add(v1,v1,hfPos);

        // Construct a convex
        var tileHeight = 100; // todo
        vec2.set(tilePos, (v1[0] + v0[0])*0.5, (v1[1] + v0[1] - tileHeight)*0.5);

        vec2.sub(tileConvex.vertices[0], v1, tilePos);
        vec2.sub(tileConvex.vertices[1], v0, tilePos);
        vec2.copy(tileConvex.vertices[2], tileConvex.vertices[1]);
        vec2.copy(tileConvex.vertices[3], tileConvex.vertices[0]);
        tileConvex.vertices[2][1] -= tileHeight;
        tileConvex.vertices[3][1] -= tileHeight;

        // Do convex collision
        numContacts += this.convexConvex(   convexBody, convexShape, convexPos, convexAngle,
                                            hfBody, tileConvex, tilePos, 0, justTest);
    }

    return numContacts;
};
},{"../equations/ContactEquation":22,"../equations/Equation":23,"../equations/FrictionEquation":24,"../math/vec2":31,"../objects/Body":32,"../shapes/Circle":38,"../shapes/Convex":39,"../shapes/Rectangle":44,"../shapes/Shape":45,"../utils/TupleDictionary":49,"../utils/Utils":50}],12:[function(_dereq_,module,exports){
module.exports = Ray;

var vec2 = _dereq_('../math/vec2');
var RaycastResult = _dereq_('../collision/RaycastResult');
var Shape = _dereq_('../shapes/Shape');
var AABB = _dereq_('../collision/AABB');

/**
 * A line with a start and end point that is used to intersect shapes.
 * @class Ray
 * @constructor
 */
function Ray(options){
    options = options || {};

    /**
     * @property {array} from
     */
    this.from = options.from ? vec2.fromValues(options.from[0], options.from[1]) : vec2.create();

    /**
     * @property {array} to
     */
    this.to = options.to ? vec2.fromValues(options.to[0], options.to[1]) : vec2.create();

    /**
     * @private
     * @property {array} _direction
     */
    this._direction = vec2.create();

    /**
     * The precision of the ray. Used when checking parallelity etc.
     * @property {Number} precision
     */
    this.precision = 0.0001;

    /**
     * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.
     * @property {Boolean} checkCollisionResponse
     */
    this.checkCollisionResponse = true;

    /**
     * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.
     * @property {Boolean} skipBackfaces
     */
    this.skipBackfaces = false;

    /**
     * @property {number} collisionMask
     * @default -1
     */
    this.collisionMask = -1;

    /**
     * @property {number} collisionGroup
     * @default -1
     */
    this.collisionGroup = -1;

    /**
     * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
     * @property {number} mode
     */
    this.mode = Ray.ANY;

    /**
     * Current result object.
     * @property {RaycastResult} result
     */
    this.result = new RaycastResult();

    /**
     * Will be set to true during intersectWorld() if the ray hit anything.
     * @property {Boolean} hasHit
     */
    this.hasHit = false;

    /**
     * Current, user-provided result callback. Will be used if mode is Ray.ALL.
     * @property {Function} callback
     */
    this.callback = function(result){};
}
Ray.prototype.constructor = Ray;

Ray.CLOSEST = 1;
Ray.ANY = 2;
Ray.ALL = 4;

var tmpAABB = new AABB();
var tmpArray = [];

/**
 * Do itersection against all bodies in the given World.
 * @method intersectWorld
 * @param  {World} world
 * @param  {object} options
 * @return {Boolean} True if the ray hit anything, otherwise false.
 */
Ray.prototype.intersectWorld = function (world, options) {
    this.mode = options.mode || Ray.ANY;
    this.result = options.result || new RaycastResult();
    this.skipBackfaces = !!options.skipBackfaces;
    this.collisionMask = typeof(options.collisionMask) !== 'undefined' ? options.collisionMask : -1;
    this.collisionGroup = typeof(options.collisionGroup) !== 'undefined' ? options.collisionGroup : -1;
    if(options.from){
        vec2.copy(this.from, options.from);
    }
    if(options.to){
        vec2.copy(this.to, options.to);
    }
    this.callback = options.callback || function(){};
    this.hasHit = false;

    this.result.reset();
    this._updateDirection();

    this.getAABB(tmpAABB);
    tmpArray.length = 0;
    world.broadphase.aabbQuery(world, tmpAABB, tmpArray);
    this.intersectBodies(tmpArray);

    return this.hasHit;
};

var v1 = vec2.create(),
    v2 = vec2.create();

var intersectBody_worldPosition = vec2.create();

/**
 * Shoot a ray at a body, get back information about the hit.
 * @method intersectBody
 * @private
 * @param {Body} body
 * @param {RaycastResult} [result] Deprecated - set the result property of the Ray instead.
 */
Ray.prototype.intersectBody = function (body, result) {

    if(result){
        this.result = result;
        this._updateDirection();
    }
    var checkCollisionResponse = this.checkCollisionResponse;

    if(checkCollisionResponse && !body.collisionResponse){
        return;
    }

    // if((this.collisionGroup & body.collisionMask)===0 || (body.collisionGroup & this.collisionMask)===0){
    //     return;
    // }

    var worldPosition = intersectBody_worldPosition;

    for (var i = 0, N = body.shapes.length; i < N; i++) {
        var shape = body.shapes[i];

        if(checkCollisionResponse && !shape.collisionResponse){
            continue; // Skip
        }

        // Get world angle and position of the shape
        vec2.copy(worldPosition, body.shapeOffsets[i]);
        vec2.rotate(worldPosition, worldPosition, body.angle);
        vec2.add(worldPosition, worldPosition, body.position);
        var worldAngle = body.shapeAngles[i] + body.angle;

        this.intersectShape(
            shape,
            worldAngle,
            worldPosition,
            body
        );

        if(this.result._shouldStop){
            break;
        }
    }
};

/**
 * @method intersectBodies
 * @param {Array} bodies An array of Body objects.
 * @param {RaycastResult} [result] Deprecated
 */
Ray.prototype.intersectBodies = function (bodies, result) {
    if(result){
        this.result = result;
        this._updateDirection();
    }

    for ( var i = 0, l = bodies.length; !this.result._shouldStop && i < l; i ++ ) {
        this.intersectBody(bodies[i]);
    }
};

/**
 * Updates the _direction vector.
 * @private
 * @method _updateDirection
 */
Ray.prototype._updateDirection = function(){
    var d = this._direction;
    vec2.sub(d, this.to, this.from); // this.to.vsub(this.from, this._direction);
    vec2.normalize(d, d); // this._direction.normalize();
};

/**
 * @method intersectShape
 * @private
 * @param {Shape} shape
 * @param {number} angle
 * @param {array} position
 * @param {Body} body
 */
Ray.prototype.intersectShape = function(shape, angle, position, body){
    var from = this.from;


    // Checking boundingSphere
    var distance = distanceFromIntersection(from, this._direction, position);
    if ( distance > shape.boundingSphereRadius ) {
        return;
    }

    var method = this[shape.type];
    if(method){
        method.call(this, shape, angle, position, body);
    }
};

var vector = vec2.create();
var normal = vec2.create();
var intersectPoint = vec2.create();

var a = vec2.create();
var b = vec2.create();
var c = vec2.create();
var d = vec2.create();

var tmpRaycastResult = new RaycastResult();
var intersectRectangle_direction = vec2.create();
var intersectRectangle_rayStart = vec2.create();
var intersectRectangle_worldNormalMin = vec2.create();
var intersectRectangle_worldNormalMax = vec2.create();
var intersectRectangle_hitPointWorld = vec2.create();
var intersectRectangle_boxMin = vec2.create();
var intersectRectangle_boxMax = vec2.create();

/**
 * @method intersectRectangle
 * @private
 * @param  {Shape} shape
 * @param  {number} angle
 * @param  {array} position
 * @param  {Body} body
 */
Ray.prototype.intersectRectangle = function(shape, angle, position, body){
    var tmin = -Number.MAX_VALUE;
    var tmax = Number.MAX_VALUE;

    var direction = intersectRectangle_direction;
    var rayStart = intersectRectangle_rayStart;
    var worldNormalMin = intersectRectangle_worldNormalMin;
    var worldNormalMax = intersectRectangle_worldNormalMax;
    var hitPointWorld = intersectRectangle_hitPointWorld;
    var boxMin = intersectRectangle_boxMin;
    var boxMax = intersectRectangle_boxMax;

    vec2.set(boxMin, -shape.width * 0.5, -shape.height * 0.5);
    vec2.set(boxMax, shape.width * 0.5, shape.height * 0.5);

    // Transform the ray direction and start to local space
    vec2.rotate(direction, this._direction, -angle);
    body.toLocalFrame(rayStart, this.from);

    if (direction[0] !== 0) {
        var tx1 = (boxMin[0] - rayStart[0]) / direction[0];
        var tx2 = (boxMax[0] - rayStart[0]) / direction[0];

        var tminOld = tmin;
        tmin = Math.max(tmin, Math.min(tx1, tx2));
        if(tmin !== tminOld){
            vec2.set(worldNormalMin, tx1 > tx2 ? 1 : -1, 0);
        }

        var tmaxOld = tmax;
        tmax = Math.min(tmax, Math.max(tx1, tx2));
        if(tmax !== tmaxOld){
            vec2.set(worldNormalMax, tx1 < tx2 ? 1 : -1, 0);
        }
    }

    if (direction[1] !== 0) {
        var ty1 = (boxMin[1] - rayStart[1]) / direction[1];
        var ty2 = (boxMax[1] - rayStart[1]) / direction[1];

        var tminOld = tmin;
        tmin = Math.max(tmin, Math.min(ty1, ty2));
        if(tmin !== tminOld){
            vec2.set(worldNormalMin, 0, ty1 > ty2 ? 1 : -1);
        }

        var tmaxOld = tmax;
        tmax = Math.min(tmax, Math.max(ty1, ty2));
        if(tmax !== tmaxOld){
            vec2.set(worldNormalMax, 0, ty1 < ty2 ? 1 : -1);
        }
    }

    if(tmax >= tmin){
        // Hit point
        vec2.set(
            hitPointWorld,
            rayStart[0] + direction[0] * tmin,
            rayStart[1] + direction[1] * tmin
        );

        vec2.rotate(worldNormalMin, worldNormalMin, angle);

        body.toWorldFrame(hitPointWorld, hitPointWorld);

        this.reportIntersection(worldNormalMin, hitPointWorld, shape, body, -1);
        if(this._shouldStop){
            return;
        }

        vec2.rotate(worldNormalMax, worldNormalMax, angle);

        // Hit point
        vec2.set(
            hitPointWorld,
            rayStart[0] + direction[0] * tmax,
            rayStart[1] + direction[1] * tmax
        );
        body.toWorldFrame(hitPointWorld, hitPointWorld);

        this.reportIntersection(worldNormalMax, hitPointWorld, shape, body, -1);
    }
};
Ray.prototype[Shape.RECTANGLE] = Ray.prototype.intersectRectangle;

var intersectPlane_planePointToFrom = vec2.create();
var intersectPlane_dir_scaled_with_t = vec2.create();
var intersectPlane_hitPointWorld = vec2.create();
var intersectPlane_worldNormal = vec2.create();
var intersectPlane_len = vec2.create();

/**
 * @method intersectPlane
 * @private
 * @param  {Shape} shape
 * @param  {number} angle
 * @param  {array} position
 * @param  {Body} body
 */
Ray.prototype.intersectPlane = function(shape, angle, position, body){
    var from = this.from;
    var to = this.to;
    var direction = this._direction;

    var planePointToFrom = intersectPlane_planePointToFrom;
    var dir_scaled_with_t = intersectPlane_dir_scaled_with_t;
    var hitPointWorld = intersectPlane_hitPointWorld;
    var worldNormal = intersectPlane_worldNormal;
    var len = intersectPlane_len;

    // Get plane normal
    vec2.set(worldNormal, 0, 1);
    vec2.rotate(worldNormal, worldNormal, angle);

    vec2.sub(len, from, position); //from.vsub(position, len);
    var planeToFrom = vec2.dot(len, worldNormal); // len.dot(worldNormal);
    vec2.sub(len, to, position); // to.vsub(position, len);
    var planeToTo = vec2.dot(len, worldNormal); // len.dot(worldNormal);

    if(planeToFrom * planeToTo > 0){
        // "from" and "to" are on the same side of the plane... bail out
        return;
    }

    if(vec2.distance(from, to) /* from.distanceTo(to) */ < planeToFrom){
        return;
    }

    var n_dot_dir = vec2.dot(worldNormal, direction); // worldNormal.dot(direction);

    // if (Math.abs(n_dot_dir) < this.precision) {
    //     // No intersection
    //     return;
    // }

    vec2.sub(planePointToFrom, from, position); // from.vsub(position, planePointToFrom);
    var t = -vec2.dot(worldNormal, planePointToFrom) / n_dot_dir; // - worldNormal.dot(planePointToFrom) / n_dot_dir;
    vec2.scale(dir_scaled_with_t, direction, t); // direction.scale(t, dir_scaled_with_t);
    vec2.add(hitPointWorld, from, dir_scaled_with_t); // from.vadd(dir_scaled_with_t, hitPointWorld);

    this.reportIntersection(worldNormal, hitPointWorld, shape, body, -1);
};
Ray.prototype[Shape.PLANE] = Ray.prototype.intersectPlane;

var Ray_intersectSphere_intersectionPoint = vec2.create();
var Ray_intersectSphere_normal = vec2.create();
Ray.prototype.intersectCircle = function(shape, angle, position, body){
    var from = this.from,
        to = this.to,
        r = shape.radius;

    var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
    var b = 2 * ((to[0] - from[0]) * (from[0] - position[0]) + (to[1] - from[1]) * (from[1] - position[1]));
    var c = Math.pow(from[0] - position[0], 2) + Math.pow(from[1] - position[1], 2) - Math.pow(r, 2);

    var delta = Math.pow(b, 2) - 4 * a * c;

    var intersectionPoint = Ray_intersectSphere_intersectionPoint;
    var normal = Ray_intersectSphere_normal;

    if(delta < 0){
        // No intersection
        return;

    } else if(delta === 0){
        // single intersection point
        vec2.lerp(intersectionPoint, from, to, delta); // from.lerp(to, delta, intersectionPoint);

        vec2.sub(normal, intersectionPoint, position); // intersectionPoint.vsub(position, normal);
        vec2.normalize(normal,normal); //normal.normalize();

        this.reportIntersection(normal, intersectionPoint, shape, body, -1);

    } else {
        var d1 = (- b - Math.sqrt(delta)) / (2 * a);
        var d2 = (- b + Math.sqrt(delta)) / (2 * a);

        vec2.lerp(intersectionPoint, from, to, d1); // from.lerp(to, d1, intersectionPoint);

        vec2.sub(normal, intersectionPoint, position); // intersectionPoint.vsub(position, normal);
        vec2.normalize(normal,normal); //normal.normalize();

        this.reportIntersection(normal, intersectionPoint, shape, body, -1);

        if(this.result._shouldStop){
            return;
        }

        vec2.lerp(intersectionPoint, from, to, d2); // from.lerp(to, d2, intersectionPoint);

        vec2.sub(normal, intersectionPoint, position); // intersectionPoint.vsub(position, normal);
        vec2.normalize(normal,normal); //normal.normalize();

        this.reportIntersection(normal, intersectionPoint, shape, body, -1);
    }
};
Ray.prototype[Shape.CIRCLE] = Ray.prototype.intersectCircle;

/**
 * Get the AABB of the ray.
 * @method getAABB
 * @param  {AABB} aabb
 */
Ray.prototype.getAABB = function(result){
    var to = this.to;
    var from = this.from;
    result.lowerBound[0] = Math.min(to[0], from[0]);
    result.lowerBound[1] = Math.min(to[1], from[1]);
    result.upperBound[0] = Math.max(to[0], from[0]);
    result.upperBound[1] = Math.max(to[1], from[1]);
};

/**
 * @method reportIntersection
 * @private
 * @param  {array} normal
 * @param  {array} hitPointWorld
 * @param  {Shape} shape
 * @param  {Body} body
 * @return {boolean} True if the intersections should continue
 */
Ray.prototype.reportIntersection = function(normal, hitPointWorld, shape, body, hitFaceIndex){
    var from = this.from;
    var to = this.to;
    var distance = vec2.distance(from, hitPointWorld); // from.distanceTo(hitPointWorld);
    var result = this.result;

    // Skip back faces?
    if(this.skipBackfaces && /* normal.dot(this._direction) */ vec2.dot(normal, this._direction) > 0){
        return;
    }

    result.hitFaceIndex = typeof(hitFaceIndex) !== 'undefined' ? hitFaceIndex : -1;

    switch(this.mode){
    case Ray.ALL:
        this.hasHit = true;
        result.set(
            from,
            to,
            normal,
            hitPointWorld,
            shape,
            body,
            distance
        );
        result.hasHit = true;
        this.callback(result);
        break;

    case Ray.CLOSEST:

        // Store if closer than current closest
        if(distance < result.distance || !result.hasHit){
            this.hasHit = true;
            result.hasHit = true;
            result.set(
                from,
                to,
                normal,
                hitPointWorld,
                shape,
                body,
                distance
            );
        }
        break;

    case Ray.ANY:

        // Report and stop.
        this.hasHit = true;
        result.hasHit = true;
        result.set(
            from,
            to,
            normal,
            hitPointWorld,
            shape,
            body,
            distance
        );
        result._shouldStop = true;
        break;
    }
};

var v0 = vec2.create(),
    intersect = vec2.create();
function distanceFromIntersection(from, direction, position) {

    // v0 is vector from from to position
    vec2.sub(v0, position, from); // position.vsub(from,v0);
    var dot = vec2.dot(v0, direction); // v0.dot(direction);

    // intersect = direction*dot + from
    vec2.scale(intersect, direction, dot); //direction.mult(dot,intersect);
    vec2.add(intersect, intersect, from); // intersect.vadd(from, intersect);

    var distance = vec2.distance(position, intersect); // position.distanceTo(intersect);

    return distance;
}


},{"../collision/AABB":7,"../collision/RaycastResult":13,"../math/vec2":31,"../shapes/Shape":45}],13:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');

module.exports = RaycastResult;

/**
 * Storage for Ray casting data.
 * @class RaycastResult
 * @constructor
 */
function RaycastResult(){

	/**
	 * @property {array} rayFromWorld
	 */
	this.rayFromWorld = vec2.create();

	/**
	 * @property {array} rayToWorld
	 */
	this.rayToWorld = vec2.create();

	/**
	 * @property {array} hitNormalWorld
	 */
	this.hitNormalWorld = vec2.create();

	/**
	 * @property {array} hitPointWorld
	 */
	this.hitPointWorld = vec2.create();

	/**
	 * @property {boolean} hasHit
	 */
	this.hasHit = false;

	/**
	 * The hit shape, or null.
	 * @property {Shape} shape
	 */
	this.shape = null;

	/**
	 * The hit body, or null.
	 * @property {Body} body
	 */
	this.body = null;

	/**
	 * The index of the hit triangle, if the hit shape was a trimesh.
	 * @property {number} hitFaceIndex
	 * @default -1
	 */
	this.hitFaceIndex = -1;

	/**
	 * Distance to the hit. Will be set to -1 if there was no hit.
	 * @property {number} distance
	 * @default -1
	 */
	this.distance = -1;

	/**
	 * If the ray should stop traversing the bodies.
	 * @private
	 * @property {Boolean} _shouldStop
	 * @default false
	 */
	this._shouldStop = false;
}

/**
 * Reset all result data.
 * @method reset
 */
RaycastResult.prototype.reset = function () {
	vec2.set(this.rayFromWorld, 0, 0);
	vec2.set(this.rayToWorld, 0, 0);
	vec2.set(this.hitNormalWorld, 0, 0);
	vec2.set(this.hitPointWorld, 0, 0);
	this.hasHit = false;
	this.shape = null;
	this.body = null;
	this.hitFaceIndex = -1;
	this.distance = -1;
	this._shouldStop = false;
};

/**
 * @method abort
 */
RaycastResult.prototype.abort = function(){
	this._shouldStop = true;
};

/**
 * @method set
 * @param {array} rayFromWorld
 * @param {array} rayToWorld
 * @param {array} hitNormalWorld
 * @param {array} hitPointWorld
 * @param {Shape} shape
 * @param {Body} body
 * @param {number} distance
 */
RaycastResult.prototype.set = function(
	rayFromWorld,
	rayToWorld,
	hitNormalWorld,
	hitPointWorld,
	shape,
	body,
	distance
){
	vec2.copy(this.rayFromWorld, rayFromWorld);
	vec2.copy(this.rayToWorld, rayToWorld);
	vec2.copy(this.hitNormalWorld, hitNormalWorld);
	vec2.copy(this.hitPointWorld, hitPointWorld);
	this.shape = shape;
	this.body = body;
	this.distance = distance;
};
},{"../math/vec2":31}],14:[function(_dereq_,module,exports){
var Utils = _dereq_('../utils/Utils')
,   Broadphase = _dereq_('../collision/Broadphase');

module.exports = SAPBroadphase;

/**
 * Sweep and prune broadphase along one axis.
 *
 * @class SAPBroadphase
 * @constructor
 * @extends Broadphase
 */
function SAPBroadphase(){
    Broadphase.call(this,Broadphase.SAP);

    /**
     * List of bodies currently in the broadphase.
     * @property axisList
     * @type {Array}
     */
    this.axisList = [];

    /**
     * The axis to sort along. 0 means x-axis and 1 y-axis. If your bodies are more spread out over the X axis, set axisIndex to 0, and you will gain some performance.
     * @property axisIndex
     * @type {Number}
     */
    this.axisIndex = 0;

    var that = this;
    this._addBodyHandler = function(e){
        that.axisList.push(e.body);
    };

    this._removeBodyHandler = function(e){
        // Remove from list
        var idx = that.axisList.indexOf(e.body);
        if(idx !== -1){
            that.axisList.splice(idx,1);
        }
    };
}
SAPBroadphase.prototype = new Broadphase();
SAPBroadphase.prototype.constructor = SAPBroadphase;

/**
 * Change the world
 * @method setWorld
 * @param {World} world
 */
SAPBroadphase.prototype.setWorld = function(world){
    // Clear the old axis array
    this.axisList.length = 0;

    // Add all bodies from the new world
    Utils.appendArray(this.axisList, world.bodies);

    // Remove old handlers, if any
    world
        .off("addBody",this._addBodyHandler)
        .off("removeBody",this._removeBodyHandler);

    // Add handlers to update the list of bodies.
    world.on("addBody",this._addBodyHandler).on("removeBody",this._removeBodyHandler);

    this.world = world;
};

/**
 * Sorts bodies along an axis.
 * @method sortAxisList
 * @param {Array} a
 * @param {number} axisIndex
 * @return {Array}
 */
SAPBroadphase.sortAxisList = function(a, axisIndex){
    axisIndex = axisIndex|0;
    for(var i=1,l=a.length; i<l; i++) {
        var v = a[i];
        for(var j=i - 1;j>=0;j--) {
            if(a[j].aabb.lowerBound[axisIndex] <= v.aabb.lowerBound[axisIndex]){
                break;
            }
            a[j+1] = a[j];
        }
        a[j+1] = v;
    }
    return a;
};

SAPBroadphase.prototype.sortList = function(){
    var bodies = this.axisList,
    axisIndex = this.axisIndex;

    // Sort the lists
    SAPBroadphase.sortAxisList(bodies, axisIndex);
};

/**
 * Get the colliding pairs
 * @method getCollisionPairs
 * @param  {World} world
 * @return {Array}
 */
SAPBroadphase.prototype.getCollisionPairs = function(world){
    var bodies = this.axisList,
        result = this.result,
        axisIndex = this.axisIndex;

    result.length = 0;

    // Update all AABBs if needed
    var l = bodies.length;
    while(l--){
        var b = bodies[l];
        if(b.aabbNeedsUpdate){
            b.updateAABB();
        }
    }

    // Sort the lists
    this.sortList();

    // Look through the X list
    for(var i=0, N=bodies.length|0; i!==N; i++){
        var bi = bodies[i];

        for(var j=i+1; j<N; j++){
            var bj = bodies[j];

            // Bounds overlap?
            var overlaps = (bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex]);
            if(!overlaps){
                break;
            }

            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){
                result.push(bi,bj);
            }
        }
    }

    return result;
};

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
SAPBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    this.sortList();

    var axisIndex = this.axisIndex;
    var axis = 'x';
    if(axisIndex === 1){ axis = 'y'; }
    if(axisIndex === 2){ axis = 'z'; }

    var axisList = this.axisList;
    var lower = aabb.lowerBound[axis];
    var upper = aabb.upperBound[axis];
    for(var i = 0; i < axisList.length; i++){
        var b = axisList[i];

        if(b.aabbNeedsUpdate){
            b.updateAABB();
        }

        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"../collision/Broadphase":8,"../utils/Utils":50}],15:[function(_dereq_,module,exports){
module.exports = Constraint;

var Utils = _dereq_('../utils/Utils');

/**
 * Base constraint class.
 *
 * @class Constraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} type
 * @param {Object} [options]
 * @param {Object} [options.collideConnected=true]
 */
function Constraint(bodyA, bodyB, type, options){

    /**
     * The type of constraint. May be one of Constraint.DISTANCE, Constraint.GEAR, Constraint.LOCK, Constraint.PRISMATIC or Constraint.REVOLUTE.
     * @property {number} type
     */
    this.type = type;

    options = Utils.defaults(options,{
        collideConnected : true,
        wakeUpBodies : true,
    });

    /**
     * Equations to be solved in this constraint
     *
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * First body participating in the constraint.
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second body participating in the constraint.
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;

    /**
     * Set to true if you want the connected bodies to collide.
     * @property collideConnected
     * @type {Boolean}
     * @default true
     */
    this.collideConnected = options.collideConnected;

    // Wake up bodies when connected
    if(options.wakeUpBodies){
        if(bodyA){
            bodyA.wakeUp();
        }
        if(bodyB){
            bodyB.wakeUp();
        }
    }
}

/**
 * Updates the internal constraint parameters before solve.
 * @method update
 */
Constraint.prototype.update = function(){
    throw new Error("method update() not implmemented in this Constraint subclass!");
};

/**
 * @static
 * @property {number} DISTANCE
 */
Constraint.DISTANCE = 1;

/**
 * @static
 * @property {number} GEAR
 */
Constraint.GEAR = 2;

/**
 * @static
 * @property {number} LOCK
 */
Constraint.LOCK = 3;

/**
 * @static
 * @property {number} PRISMATIC
 */
Constraint.PRISMATIC = 4;

/**
 * @static
 * @property {number} REVOLUTE
 */
Constraint.REVOLUTE = 5;

/**
 * Set stiffness for this constraint.
 * @method setStiffness
 * @param {Number} stiffness
 */
Constraint.prototype.setStiffness = function(stiffness){
    var eqs = this.equations;
    for(var i=0; i !== eqs.length; i++){
        var eq = eqs[i];
        eq.stiffness = stiffness;
        eq.needsUpdate = true;
    }
};

/**
 * Set relaxation for this constraint.
 * @method setRelaxation
 * @param {Number} relaxation
 */
Constraint.prototype.setRelaxation = function(relaxation){
    var eqs = this.equations;
    for(var i=0; i !== eqs.length; i++){
        var eq = eqs[i];
        eq.relaxation = relaxation;
        eq.needsUpdate = true;
    }
};

},{"../utils/Utils":50}],16:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   Equation = _dereq_('../equations/Equation')
,   vec2 = _dereq_('../math/vec2')
,   Utils = _dereq_('../utils/Utils');

module.exports = DistanceConstraint;

/**
 * Constraint that tries to keep the distance between two bodies constant.
 *
 * @class DistanceConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {number} [options.distance] The distance to keep between the anchor points. Defaults to the current distance between the bodies.
 * @param {Array} [options.localAnchorA] The anchor point for bodyA, defined locally in bodyA frame. Defaults to [0,0].
 * @param {Array} [options.localAnchorB] The anchor point for bodyB, defined locally in bodyB frame. Defaults to [0,0].
 * @param {object} [options.maxForce=Number.MAX_VALUE] Maximum force to apply.
 * @extends Constraint
 *
 * @example
 *     // If distance is not given as an option, then the current distance between the bodies is used.
 *     // In this example, the bodies will be constrained to have a distance of 2 between their centers.
 *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
 *     var bodyB = new Body({ mass: 1, position: [1, 0] });
 *     var constraint = new DistanceConstraint(bodyA, bodyB);
 *
 * @example
 *     var constraint = new DistanceConstraint(bodyA, bodyB, {
 *         distance: 1,          // Distance to keep between the points
 *         localAnchorA: [1, 0], // Point on bodyA
 *         localAnchorB: [-1, 0] // Point on bodyB
 *     });
 */
function DistanceConstraint(bodyA,bodyB,options){
    options = Utils.defaults(options,{
        localAnchorA:[0,0],
        localAnchorB:[0,0]
    });

    Constraint.call(this,bodyA,bodyB,Constraint.DISTANCE,options);

    /**
     * Local anchor in body A.
     * @property localAnchorA
     * @type {Array}
     */
    this.localAnchorA = vec2.fromValues(options.localAnchorA[0], options.localAnchorA[1]);

    /**
     * Local anchor in body B.
     * @property localAnchorB
     * @type {Array}
     */
    this.localAnchorB = vec2.fromValues(options.localAnchorB[0], options.localAnchorB[1]);

    var localAnchorA = this.localAnchorA;
    var localAnchorB = this.localAnchorB;

    /**
     * The distance to keep.
     * @property distance
     * @type {Number}
     */
    this.distance = 0;

    if(typeof(options.distance) === 'number'){
        this.distance = options.distance;
    } else {
        // Use the current world distance between the world anchor points.
        var worldAnchorA = vec2.create(),
            worldAnchorB = vec2.create(),
            r = vec2.create();

        // Transform local anchors to world
        vec2.rotate(worldAnchorA, localAnchorA, bodyA.angle);
        vec2.rotate(worldAnchorB, localAnchorB, bodyB.angle);

        vec2.add(r, bodyB.position, worldAnchorB);
        vec2.sub(r, r, worldAnchorA);
        vec2.sub(r, r, bodyA.position);

        this.distance = vec2.length(r);
    }

    var maxForce;
    if(typeof(options.maxForce)==="undefined" ){
        maxForce = Number.MAX_VALUE;
    } else {
        maxForce = options.maxForce;
    }

    var normal = new Equation(bodyA,bodyB,-maxForce,maxForce); // Just in the normal direction
    this.equations = [ normal ];

    /**
     * Max force to apply.
     * @property {number} maxForce
     */
    this.maxForce = maxForce;

    // g = (xi - xj).dot(n)
    // dg/dt = (vi - vj).dot(n) = G*W = [n 0 -n 0] * [vi wi vj wj]'

    // ...and if we were to include offset points (TODO for now):
    // g =
    //      (xj + rj - xi - ri).dot(n) - distance
    //
    // dg/dt =
    //      (vj + wj x rj - vi - wi x ri).dot(n) =
    //      { term 2 is near zero } =
    //      [-n   -ri x n   n   rj x n] * [vi wi vj wj]' =
    //      G * W
    //
    // => G = [-n -rixn n rjxn]

    var r = vec2.create();
    var ri = vec2.create(); // worldAnchorA
    var rj = vec2.create(); // worldAnchorB
    var that = this;
    normal.computeGq = function(){
        var bodyA = this.bodyA,
            bodyB = this.bodyB,
            xi = bodyA.position,
            xj = bodyB.position;

        // Transform local anchors to world
        vec2.rotate(ri, localAnchorA, bodyA.angle);
        vec2.rotate(rj, localAnchorB, bodyB.angle);

        vec2.add(r, xj, rj);
        vec2.sub(r, r, ri);
        vec2.sub(r, r, xi);

        //vec2.sub(r, bodyB.position, bodyA.position);
        return vec2.length(r) - that.distance;
    };

    // Make the contact constraint bilateral
    this.setMaxForce(maxForce);

    /**
     * If the upper limit is enabled or not.
     * @property {Boolean} upperLimitEnabled
     */
    this.upperLimitEnabled = false;

    /**
     * The upper constraint limit.
     * @property {number} upperLimit
     */
    this.upperLimit = 1;

    /**
     * If the lower limit is enabled or not.
     * @property {Boolean} lowerLimitEnabled
     */
    this.lowerLimitEnabled = false;

    /**
     * The lower constraint limit.
     * @property {number} lowerLimit
     */
    this.lowerLimit = 0;

    /**
     * Current constraint position. This is equal to the current distance between the world anchor points.
     * @property {number} position
     */
    this.position = 0;
}
DistanceConstraint.prototype = new Constraint();
DistanceConstraint.prototype.constructor = DistanceConstraint;

/**
 * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
 * @method update
 */
var n = vec2.create();
var ri = vec2.create(); // worldAnchorA
var rj = vec2.create(); // worldAnchorB
DistanceConstraint.prototype.update = function(){
    var normal = this.equations[0],
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        distance = this.distance,
        xi = bodyA.position,
        xj = bodyB.position,
        normalEquation = this.equations[0],
        G = normal.G;

    // Transform local anchors to world
    vec2.rotate(ri, this.localAnchorA, bodyA.angle);
    vec2.rotate(rj, this.localAnchorB, bodyB.angle);

    // Get world anchor points and normal
    vec2.add(n, xj, rj);
    vec2.sub(n, n, ri);
    vec2.sub(n, n, xi);
    this.position = vec2.length(n);

    var violating = false;
    if(this.upperLimitEnabled){
        if(this.position > this.upperLimit){
            normalEquation.maxForce = 0;
            normalEquation.minForce = -this.maxForce;
            this.distance = this.upperLimit;
            violating = true;
        }
    }

    if(this.lowerLimitEnabled){
        if(this.position < this.lowerLimit){
            normalEquation.maxForce = this.maxForce;
            normalEquation.minForce = 0;
            this.distance = this.lowerLimit;
            violating = true;
        }
    }

    if((this.lowerLimitEnabled || this.upperLimitEnabled) && !violating){
        // No constraint needed.
        normalEquation.enabled = false;
        return;
    }

    normalEquation.enabled = true;

    vec2.normalize(n,n);

    // Caluclate cross products
    var rixn = vec2.crossLength(ri, n),
        rjxn = vec2.crossLength(rj, n);

    // G = [-n -rixn n rjxn]
    G[0] = -n[0];
    G[1] = -n[1];
    G[2] = -rixn;
    G[3] = n[0];
    G[4] = n[1];
    G[5] = rjxn;
};

/**
 * Set the max force to be used
 * @method setMaxForce
 * @param {Number} f
 */
DistanceConstraint.prototype.setMaxForce = function(f){
    var normal = this.equations[0];
    normal.minForce = -f;
    normal.maxForce =  f;
};

/**
 * Get the max force
 * @method getMaxForce
 * @return {Number}
 */
DistanceConstraint.prototype.getMaxForce = function(f){
    var normal = this.equations[0];
    return normal.maxForce;
};

},{"../equations/Equation":23,"../math/vec2":31,"../utils/Utils":50,"./Constraint":15}],17:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   Equation = _dereq_('../equations/Equation')
,   AngleLockEquation = _dereq_('../equations/AngleLockEquation')
,   vec2 = _dereq_('../math/vec2');

module.exports = GearConstraint;

/**
 * Connects two bodies at given offset points, letting them rotate relative to each other around this point.
 * @class GearConstraint
 * @constructor
 * @author schteppe
 * @param {Body}            bodyA
 * @param {Body}            bodyB
 * @param {Object}          [options]
 * @param {Number}          [options.angle=0] Relative angle between the bodies. Will be set to the current angle between the bodies (the gear ratio is accounted for).
 * @param {Number}          [options.ratio=1] Gear ratio.
 * @param {Number}          [options.maxTorque] Maximum torque to apply.
 * @extends Constraint
 * @todo Ability to specify world points
 */
function GearConstraint(bodyA, bodyB, options){
    options = options || {};

    Constraint.call(this, bodyA, bodyB, Constraint.GEAR, options);

    /**
     * The gear ratio.
     * @property ratio
     * @type {Number}
     */
    this.ratio = typeof(options.ratio) === "number" ? options.ratio : 1;

    /**
     * The relative angle
     * @property angle
     * @type {Number}
     */
    this.angle = typeof(options.angle) === "number" ? options.angle : bodyB.angle - this.ratio * bodyA.angle;

    // Send same parameters to the equation
    options.angle = this.angle;
    options.ratio = this.ratio;

    this.equations = [
        new AngleLockEquation(bodyA,bodyB,options),
    ];

    // Set max torque
    if(typeof(options.maxTorque) === "number"){
        this.setMaxTorque(options.maxTorque);
    }
}
GearConstraint.prototype = new Constraint();
GearConstraint.prototype.constructor = GearConstraint;

GearConstraint.prototype.update = function(){
    var eq = this.equations[0];
    if(eq.ratio !== this.ratio){
        eq.setRatio(this.ratio);
    }
    eq.angle = this.angle;
};

/**
 * Set the max torque for the constraint.
 * @method setMaxTorque
 * @param {Number} torque
 */
GearConstraint.prototype.setMaxTorque = function(torque){
    this.equations[0].setMaxTorque(torque);
};

/**
 * Get the max torque for the constraint.
 * @method getMaxTorque
 * @return {Number}
 */
GearConstraint.prototype.getMaxTorque = function(torque){
    return this.equations[0].maxForce;
};
},{"../equations/AngleLockEquation":21,"../equations/Equation":23,"../math/vec2":31,"./Constraint":15}],18:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   vec2 = _dereq_('../math/vec2')
,   Equation = _dereq_('../equations/Equation');

module.exports = LockConstraint;

/**
 * Locks the relative position between two bodies.
 *
 * @class LockConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Array}  [options.localOffsetB] The offset of bodyB in bodyA's frame. If not given the offset is computed from current positions.
 * @param {number} [options.localAngleB] The angle of bodyB in bodyA's frame. If not given, the angle is computed from current angles.
 * @param {number} [options.maxForce]
 * @extends Constraint
 */
function LockConstraint(bodyA, bodyB, options){
    options = options || {};

    Constraint.call(this,bodyA,bodyB,Constraint.LOCK,options);

    var maxForce = ( typeof(options.maxForce)==="undefined" ? Number.MAX_VALUE : options.maxForce );

    var localAngleB = options.localAngleB || 0;

    // Use 3 equations:
    // gx =   (xj - xi - l) * xhat = 0
    // gy =   (xj - xi - l) * yhat = 0
    // gr =   (xi - xj + r) * that = 0
    //
    // ...where:
    //   l is the localOffsetB vector rotated to world in bodyA frame
    //   r is the same vector but reversed and rotated from bodyB frame
    //   xhat, yhat are world axis vectors
    //   that is the tangent of r
    //
    // For the first two constraints, we get
    // G*W = (vj - vi - ldot  ) * xhat
    //     = (vj - vi - wi x l) * xhat
    //
    // Since (wi x l) * xhat = (l x xhat) * wi, we get
    // G*W = [ -1   0   (-l x xhat)  1   0   0] * [vi wi vj wj]
    //
    // The last constraint gives
    // GW = (vi - vj + wj x r) * that
    //    = [  that   0  -that  (r x t) ]

    var x =     new Equation(bodyA,bodyB,-maxForce,maxForce),
        y =     new Equation(bodyA,bodyB,-maxForce,maxForce),
        rot =   new Equation(bodyA,bodyB,-maxForce,maxForce);

    var l = vec2.create(),
        g = vec2.create(),
        that = this;
    x.computeGq = function(){
        vec2.rotate(l, that.localOffsetB, bodyA.angle);
        vec2.sub(g, bodyB.position, bodyA.position);
        vec2.sub(g, g, l);
        return g[0];
    };
    y.computeGq = function(){
        vec2.rotate(l, that.localOffsetB, bodyA.angle);
        vec2.sub(g, bodyB.position, bodyA.position);
        vec2.sub(g, g, l);
        return g[1];
    };
    var r = vec2.create(),
        t = vec2.create();
    rot.computeGq = function(){
        vec2.rotate(r, that.localOffsetB, bodyB.angle - that.localAngleB);
        vec2.scale(r,r,-1);
        vec2.sub(g,bodyA.position,bodyB.position);
        vec2.add(g,g,r);
        vec2.rotate(t,r,-Math.PI/2);
        vec2.normalize(t,t);
        return vec2.dot(g,t);
    };

    /**
     * The offset of bodyB in bodyA's frame.
     * @property {Array} localOffsetB
     */
    this.localOffsetB = vec2.create();
    if(options.localOffsetB){
        vec2.copy(this.localOffsetB, options.localOffsetB);
    } else {
        // Construct from current positions
        vec2.sub(this.localOffsetB, bodyB.position, bodyA.position);
        vec2.rotate(this.localOffsetB, this.localOffsetB, -bodyA.angle);
    }

    /**
     * The offset angle of bodyB in bodyA's frame.
     * @property {Number} localAngleB
     */
    this.localAngleB = 0;
    if(typeof(options.localAngleB) === 'number'){
        this.localAngleB = options.localAngleB;
    } else {
        // Construct
        this.localAngleB = bodyB.angle - bodyA.angle;
    }

    this.equations.push(x, y, rot);
    this.setMaxForce(maxForce);
}
LockConstraint.prototype = new Constraint();
LockConstraint.prototype.constructor = LockConstraint;

/**
 * Set the maximum force to be applied.
 * @method setMaxForce
 * @param {Number} force
 */
LockConstraint.prototype.setMaxForce = function(force){
    var eqs = this.equations;
    for(var i=0; i<this.equations.length; i++){
        eqs[i].maxForce =  force;
        eqs[i].minForce = -force;
    }
};

/**
 * Get the max force.
 * @method getMaxForce
 * @return {Number}
 */
LockConstraint.prototype.getMaxForce = function(){
    return this.equations[0].maxForce;
};

var l = vec2.create();
var r = vec2.create();
var t = vec2.create();
var xAxis = vec2.fromValues(1,0);
var yAxis = vec2.fromValues(0,1);
LockConstraint.prototype.update = function(){
    var x =   this.equations[0],
        y =   this.equations[1],
        rot = this.equations[2],
        bodyA = this.bodyA,
        bodyB = this.bodyB;

    vec2.rotate(l,this.localOffsetB,bodyA.angle);
    vec2.rotate(r,this.localOffsetB,bodyB.angle - this.localAngleB);
    vec2.scale(r,r,-1);

    vec2.rotate(t,r,Math.PI/2);
    vec2.normalize(t,t);

    x.G[0] = -1;
    x.G[1] =  0;
    x.G[2] = -vec2.crossLength(l,xAxis);
    x.G[3] =  1;

    y.G[0] =  0;
    y.G[1] = -1;
    y.G[2] = -vec2.crossLength(l,yAxis);
    y.G[4] =  1;

    rot.G[0] =  -t[0];
    rot.G[1] =  -t[1];
    rot.G[3] =  t[0];
    rot.G[4] =  t[1];
    rot.G[5] =  vec2.crossLength(r,t);
};

},{"../equations/Equation":23,"../math/vec2":31,"./Constraint":15}],19:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   ContactEquation = _dereq_('../equations/ContactEquation')
,   Equation = _dereq_('../equations/Equation')
,   vec2 = _dereq_('../math/vec2')
,   RotationalLockEquation = _dereq_('../equations/RotationalLockEquation');

module.exports = PrismaticConstraint;

/**
 * Constraint that only allows bodies to move along a line, relative to each other. See <a href="http://www.iforce2d.net/b2dtut/joints-prismatic">this tutorial</a>.
 *
 * @class PrismaticConstraint
 * @constructor
 * @extends Constraint
 * @author schteppe
 * @param {Body}    bodyA
 * @param {Body}    bodyB
 * @param {Object}  [options]
 * @param {Number}  [options.maxForce]                Max force to be applied by the constraint
 * @param {Array}   [options.localAnchorA]            Body A's anchor point, defined in its own local frame.
 * @param {Array}   [options.localAnchorB]            Body B's anchor point, defined in its own local frame.
 * @param {Array}   [options.localAxisA]              An axis, defined in body A frame, that body B's anchor point may slide along.
 * @param {Boolean} [options.disableRotationalLock]   If set to true, bodyB will be free to rotate around its anchor point.
 * @param {Number}  [options.upperLimit]
 * @param {Number}  [options.lowerLimit]
 * @todo Ability to create using only a point and a worldAxis
 */
function PrismaticConstraint(bodyA, bodyB, options){
    options = options || {};
    Constraint.call(this,bodyA,bodyB,Constraint.PRISMATIC,options);

    // Get anchors
    var localAnchorA = vec2.fromValues(0,0),
        localAxisA = vec2.fromValues(1,0),
        localAnchorB = vec2.fromValues(0,0);
    if(options.localAnchorA){ vec2.copy(localAnchorA, options.localAnchorA); }
    if(options.localAxisA){ vec2.copy(localAxisA,   options.localAxisA); }
    if(options.localAnchorB){ vec2.copy(localAnchorB, options.localAnchorB); }

    /**
     * @property localAnchorA
     * @type {Array}
     */
    this.localAnchorA = localAnchorA;

    /**
     * @property localAnchorB
     * @type {Array}
     */
    this.localAnchorB = localAnchorB;

    /**
     * @property localAxisA
     * @type {Array}
     */
    this.localAxisA = localAxisA;

    /*

    The constraint violation for the common axis point is

        g = ( xj + rj - xi - ri ) * t   :=  gg*t

    where r are body-local anchor points, and t is a tangent to the constraint axis defined in body i frame.

        gdot =  ( vj + wj x rj - vi - wi x ri ) * t + ( xj + rj - xi - ri ) * ( wi x t )

    Note the use of the chain rule. Now we identify the jacobian

        G*W = [ -t      -ri x t + t x gg     t    rj x t ] * [vi wi vj wj]

    The rotational part is just a rotation lock.

     */

    var maxForce = this.maxForce = typeof(options.maxForce)!=="undefined" ? options.maxForce : Number.MAX_VALUE;

    // Translational part
    var trans = new Equation(bodyA,bodyB,-maxForce,maxForce);
    var ri = new vec2.create(),
        rj = new vec2.create(),
        gg = new vec2.create(),
        t =  new vec2.create();
    trans.computeGq = function(){
        // g = ( xj + rj - xi - ri ) * t
        return vec2.dot(gg,t);
    };
    trans.updateJacobian = function(){
        var G = this.G,
            xi = bodyA.position,
            xj = bodyB.position;
        vec2.rotate(ri,localAnchorA,bodyA.angle);
        vec2.rotate(rj,localAnchorB,bodyB.angle);
        vec2.add(gg,xj,rj);
        vec2.sub(gg,gg,xi);
        vec2.sub(gg,gg,ri);
        vec2.rotate(t,localAxisA,bodyA.angle+Math.PI/2);

        G[0] = -t[0];
        G[1] = -t[1];
        G[2] = -vec2.crossLength(ri,t) + vec2.crossLength(t,gg);
        G[3] = t[0];
        G[4] = t[1];
        G[5] = vec2.crossLength(rj,t);
    };
    this.equations.push(trans);

    // Rotational part
    if(!options.disableRotationalLock){
        var rot = new RotationalLockEquation(bodyA,bodyB,-maxForce,maxForce);
        this.equations.push(rot);
    }

    /**
     * The position of anchor A relative to anchor B, along the constraint axis.
     * @property position
     * @type {Number}
     */
    this.position = 0;

    // Is this one used at all?
    this.velocity = 0;

    /**
     * Set to true to enable lower limit.
     * @property lowerLimitEnabled
     * @type {Boolean}
     */
    this.lowerLimitEnabled = typeof(options.lowerLimit)!=="undefined" ? true : false;

    /**
     * Set to true to enable upper limit.
     * @property upperLimitEnabled
     * @type {Boolean}
     */
    this.upperLimitEnabled = typeof(options.upperLimit)!=="undefined" ? true : false;

    /**
     * Lower constraint limit. The constraint position is forced to be larger than this value.
     * @property lowerLimit
     * @type {Number}
     */
    this.lowerLimit = typeof(options.lowerLimit)!=="undefined" ? options.lowerLimit : 0;

    /**
     * Upper constraint limit. The constraint position is forced to be smaller than this value.
     * @property upperLimit
     * @type {Number}
     */
    this.upperLimit = typeof(options.upperLimit)!=="undefined" ? options.upperLimit : 1;

    // Equations used for limits
    this.upperLimitEquation = new ContactEquation(bodyA,bodyB);
    this.lowerLimitEquation = new ContactEquation(bodyA,bodyB);

    // Set max/min forces
    this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0;
    this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = maxForce;

    /**
     * Equation used for the motor.
     * @property motorEquation
     * @type {Equation}
     */
    this.motorEquation = new Equation(bodyA,bodyB);

    /**
     * The current motor state. Enable or disable the motor using .enableMotor
     * @property motorEnabled
     * @type {Boolean}
     */
    this.motorEnabled = false;

    /**
     * Set the target speed for the motor.
     * @property motorSpeed
     * @type {Number}
     */
    this.motorSpeed = 0;

    var that = this;
    var motorEquation = this.motorEquation;
    var old = motorEquation.computeGW;
    motorEquation.computeGq = function(){ return 0; };
    motorEquation.computeGW = function(){
        var G = this.G,
            bi = this.bodyA,
            bj = this.bodyB,
            vi = bi.velocity,
            vj = bj.velocity,
            wi = bi.angularVelocity,
            wj = bj.angularVelocity;
        return this.gmult(G,vi,wi,vj,wj) + that.motorSpeed;
    };
}

PrismaticConstraint.prototype = new Constraint();
PrismaticConstraint.prototype.constructor = PrismaticConstraint;

var worldAxisA = vec2.create(),
    worldAnchorA = vec2.create(),
    worldAnchorB = vec2.create(),
    orientedAnchorA = vec2.create(),
    orientedAnchorB = vec2.create(),
    tmp = vec2.create();

/**
 * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
 * @method update
 */
PrismaticConstraint.prototype.update = function(){
    var eqs = this.equations,
        trans = eqs[0],
        upperLimit = this.upperLimit,
        lowerLimit = this.lowerLimit,
        upperLimitEquation = this.upperLimitEquation,
        lowerLimitEquation = this.lowerLimitEquation,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        localAxisA = this.localAxisA,
        localAnchorA = this.localAnchorA,
        localAnchorB = this.localAnchorB;

    trans.updateJacobian();

    // Transform local things to world
    vec2.rotate(worldAxisA,      localAxisA,      bodyA.angle);
    vec2.rotate(orientedAnchorA, localAnchorA,    bodyA.angle);
    vec2.add(worldAnchorA,       orientedAnchorA, bodyA.position);
    vec2.rotate(orientedAnchorB, localAnchorB,    bodyB.angle);
    vec2.add(worldAnchorB,       orientedAnchorB, bodyB.position);

    var relPosition = this.position = vec2.dot(worldAnchorB,worldAxisA) - vec2.dot(worldAnchorA,worldAxisA);

    // Motor
    if(this.motorEnabled){
        // G = [ a     a x ri   -a   -a x rj ]
        var G = this.motorEquation.G;
        G[0] = worldAxisA[0];
        G[1] = worldAxisA[1];
        G[2] = vec2.crossLength(worldAxisA,orientedAnchorB);
        G[3] = -worldAxisA[0];
        G[4] = -worldAxisA[1];
        G[5] = -vec2.crossLength(worldAxisA,orientedAnchorA);
    }

    /*
        Limits strategy:
        Add contact equation, with normal along the constraint axis.
        min/maxForce is set so the constraint is repulsive in the correct direction.
        Some offset is added to either equation.contactPointA or .contactPointB to get the correct upper/lower limit.

                 ^
                 |
      upperLimit x
                 |    ------
         anchorB x<---|  B |
                 |    |    |
        ------   |    ------
        |    |   |
        |  A |-->x anchorA
        ------   |
                 x lowerLimit
                 |
                axis
     */


    if(this.upperLimitEnabled && relPosition > upperLimit){
        // Update contact constraint normal, etc
        vec2.scale(upperLimitEquation.normalA, worldAxisA, -1);
        vec2.sub(upperLimitEquation.contactPointA, worldAnchorA, bodyA.position);
        vec2.sub(upperLimitEquation.contactPointB, worldAnchorB, bodyB.position);
        vec2.scale(tmp,worldAxisA,upperLimit);
        vec2.add(upperLimitEquation.contactPointA,upperLimitEquation.contactPointA,tmp);
        if(eqs.indexOf(upperLimitEquation) === -1){
            eqs.push(upperLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(upperLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }

    if(this.lowerLimitEnabled && relPosition < lowerLimit){
        // Update contact constraint normal, etc
        vec2.scale(lowerLimitEquation.normalA, worldAxisA, 1);
        vec2.sub(lowerLimitEquation.contactPointA, worldAnchorA, bodyA.position);
        vec2.sub(lowerLimitEquation.contactPointB, worldAnchorB, bodyB.position);
        vec2.scale(tmp,worldAxisA,lowerLimit);
        vec2.sub(lowerLimitEquation.contactPointB,lowerLimitEquation.contactPointB,tmp);
        if(eqs.indexOf(lowerLimitEquation) === -1){
            eqs.push(lowerLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(lowerLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }
};

/**
 * Enable the motor
 * @method enableMotor
 */
PrismaticConstraint.prototype.enableMotor = function(){
    if(this.motorEnabled){
        return;
    }
    this.equations.push(this.motorEquation);
    this.motorEnabled = true;
};

/**
 * Disable the rotational motor
 * @method disableMotor
 */
PrismaticConstraint.prototype.disableMotor = function(){
    if(!this.motorEnabled){
        return;
    }
    var i = this.equations.indexOf(this.motorEquation);
    this.equations.splice(i,1);
    this.motorEnabled = false;
};

/**
 * Set the constraint limits.
 * @method setLimits
 * @param {number} lower Lower limit.
 * @param {number} upper Upper limit.
 */
PrismaticConstraint.prototype.setLimits = function (lower, upper) {
    if(typeof(lower) === 'number'){
        this.lowerLimit = lower;
        this.lowerLimitEnabled = true;
    } else {
        this.lowerLimit = lower;
        this.lowerLimitEnabled = false;
    }

    if(typeof(upper) === 'number'){
        this.upperLimit = upper;
        this.upperLimitEnabled = true;
    } else {
        this.upperLimit = upper;
        this.upperLimitEnabled = false;
    }
};


},{"../equations/ContactEquation":22,"../equations/Equation":23,"../equations/RotationalLockEquation":25,"../math/vec2":31,"./Constraint":15}],20:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   Equation = _dereq_('../equations/Equation')
,   RotationalVelocityEquation = _dereq_('../equations/RotationalVelocityEquation')
,   RotationalLockEquation = _dereq_('../equations/RotationalLockEquation')
,   vec2 = _dereq_('../math/vec2');

module.exports = RevoluteConstraint;

var worldPivotA = vec2.create(),
    worldPivotB = vec2.create(),
    xAxis = vec2.fromValues(1,0),
    yAxis = vec2.fromValues(0,1),
    g = vec2.create();

/**
 * Connects two bodies at given offset points, letting them rotate relative to each other around this point.
 * @class RevoluteConstraint
 * @constructor
 * @author schteppe
 * @param {Body}    bodyA
 * @param {Body}    bodyB
 * @param {Object}  [options]
 * @param {Array}   [options.worldPivot] A pivot point given in world coordinates. If specified, localPivotA and localPivotB are automatically computed from this value.
 * @param {Array}   [options.localPivotA] The point relative to the center of mass of bodyA which bodyA is constrained to.
 * @param {Array}   [options.localPivotB] See localPivotA.
 * @param {Number}  [options.maxForce] The maximum force that should be applied to constrain the bodies.
 * @extends Constraint
 *
 * @example
 *     // This will create a revolute constraint between two bodies with pivot point in between them.
 *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
 *     var bodyB = new Body({ mass: 1, position: [1, 0] });
 *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
 *         worldPivot: [0, 0]
 *     });
 *     world.addConstraint(constraint);
 *
 *     // Using body-local pivot points, the constraint could have been constructed like this:
 *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
 *         localPivotA: [1, 0],
 *         localPivotB: [-1, 0]
 *     });
 */
function RevoluteConstraint(bodyA, bodyB, options){
    options = options || {};
    Constraint.call(this,bodyA,bodyB,Constraint.REVOLUTE,options);

    var maxForce = this.maxForce = typeof(options.maxForce) !== "undefined" ? options.maxForce : Number.MAX_VALUE;

    /**
     * @property {Array} pivotA
     */
    this.pivotA = vec2.create();

    /**
     * @property {Array} pivotB
     */
    this.pivotB = vec2.create();

    if(options.worldPivot){
        // Compute pivotA and pivotB
        vec2.sub(this.pivotA, options.worldPivot, bodyA.position);
        vec2.sub(this.pivotB, options.worldPivot, bodyB.position);
        // Rotate to local coordinate system
        vec2.rotate(this.pivotA, this.pivotA, -bodyA.angle);
        vec2.rotate(this.pivotB, this.pivotB, -bodyB.angle);
    } else {
        // Get pivotA and pivotB
        vec2.copy(this.pivotA, options.localPivotA);
        vec2.copy(this.pivotB, options.localPivotB);
    }

    // Equations to be fed to the solver
    var eqs = this.equations = [
        new Equation(bodyA,bodyB,-maxForce,maxForce),
        new Equation(bodyA,bodyB,-maxForce,maxForce),
    ];

    var x = eqs[0];
    var y = eqs[1];
    var that = this;

    x.computeGq = function(){
        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
        vec2.add(g, bodyB.position, worldPivotB);
        vec2.sub(g, g, bodyA.position);
        vec2.sub(g, g, worldPivotA);
        return vec2.dot(g,xAxis);
    };

    y.computeGq = function(){
        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
        vec2.add(g, bodyB.position, worldPivotB);
        vec2.sub(g, g, bodyA.position);
        vec2.sub(g, g, worldPivotA);
        return vec2.dot(g,yAxis);
    };

    y.minForce = x.minForce = -maxForce;
    y.maxForce = x.maxForce =  maxForce;

    this.motorEquation = new RotationalVelocityEquation(bodyA,bodyB);

    /**
     * Indicates whether the motor is enabled. Use .enableMotor() to enable the constraint motor.
     * @property {Boolean} motorEnabled
     * @readOnly
     */
    this.motorEnabled = false;

    /**
     * The constraint position.
     * @property angle
     * @type {Number}
     * @readOnly
     */
    this.angle = 0;

    /**
     * Set to true to enable lower limit
     * @property lowerLimitEnabled
     * @type {Boolean}
     */
    this.lowerLimitEnabled = false;

    /**
     * Set to true to enable upper limit
     * @property upperLimitEnabled
     * @type {Boolean}
     */
    this.upperLimitEnabled = false;

    /**
     * The lower limit on the constraint angle.
     * @property lowerLimit
     * @type {Boolean}
     */
    this.lowerLimit = 0;

    /**
     * The upper limit on the constraint angle.
     * @property upperLimit
     * @type {Boolean}
     */
    this.upperLimit = 0;

    this.upperLimitEquation = new RotationalLockEquation(bodyA,bodyB);
    this.lowerLimitEquation = new RotationalLockEquation(bodyA,bodyB);
    this.upperLimitEquation.minForce = 0;
    this.lowerLimitEquation.maxForce = 0;
}
RevoluteConstraint.prototype = new Constraint();
RevoluteConstraint.prototype.constructor = RevoluteConstraint;

/**
 * Set the constraint angle limits.
 * @method setLimits
 * @param {number} lower Lower angle limit.
 * @param {number} upper Upper angle limit.
 */
RevoluteConstraint.prototype.setLimits = function (lower, upper) {
    if(typeof(lower) === 'number'){
        this.lowerLimit = lower;
        this.lowerLimitEnabled = true;
    } else {
        this.lowerLimit = lower;
        this.lowerLimitEnabled = false;
    }

    if(typeof(upper) === 'number'){
        this.upperLimit = upper;
        this.upperLimitEnabled = true;
    } else {
        this.upperLimit = upper;
        this.upperLimitEnabled = false;
    }
};

RevoluteConstraint.prototype.update = function(){
    var bodyA =  this.bodyA,
        bodyB =  this.bodyB,
        pivotA = this.pivotA,
        pivotB = this.pivotB,
        eqs =    this.equations,
        normal = eqs[0],
        tangent= eqs[1],
        x = eqs[0],
        y = eqs[1],
        upperLimit = this.upperLimit,
        lowerLimit = this.lowerLimit,
        upperLimitEquation = this.upperLimitEquation,
        lowerLimitEquation = this.lowerLimitEquation;

    var relAngle = this.angle = bodyB.angle - bodyA.angle;

    if(this.upperLimitEnabled && relAngle > upperLimit){
        upperLimitEquation.angle = upperLimit;
        if(eqs.indexOf(upperLimitEquation) === -1){
            eqs.push(upperLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(upperLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }

    if(this.lowerLimitEnabled && relAngle < lowerLimit){
        lowerLimitEquation.angle = lowerLimit;
        if(eqs.indexOf(lowerLimitEquation) === -1){
            eqs.push(lowerLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(lowerLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }

    /*

    The constraint violation is

        g = xj + rj - xi - ri

    ...where xi and xj are the body positions and ri and rj world-oriented offset vectors. Differentiate:

        gdot = vj + wj x rj - vi - wi x ri

    We split this into x and y directions. (let x and y be unit vectors along the respective axes)

        gdot * x = ( vj + wj x rj - vi - wi x ri ) * x
                 = ( vj*x + (wj x rj)*x -vi*x -(wi x ri)*x
                 = ( vj*x + (rj x x)*wj -vi*x -(ri x x)*wi
                 = [ -x   -(ri x x)   x   (rj x x)] * [vi wi vj wj]
                 = G*W

    ...and similar for y. We have then identified the jacobian entries for x and y directions:

        Gx = [ x   (rj x x)   -x   -(ri x x)]
        Gy = [ y   (rj x y)   -y   -(ri x y)]

     */

    vec2.rotate(worldPivotA, pivotA, bodyA.angle);
    vec2.rotate(worldPivotB, pivotB, bodyB.angle);

    // todo: these are a bit sparse. We could save some computations on making custom eq.computeGW functions, etc

    x.G[0] = -1;
    x.G[1] =  0;
    x.G[2] = -vec2.crossLength(worldPivotA,xAxis);
    x.G[3] =  1;
    x.G[4] =  0;
    x.G[5] =  vec2.crossLength(worldPivotB,xAxis);

    y.G[0] =  0;
    y.G[1] = -1;
    y.G[2] = -vec2.crossLength(worldPivotA,yAxis);
    y.G[3] =  0;
    y.G[4] =  1;
    y.G[5] =  vec2.crossLength(worldPivotB,yAxis);
};

/**
 * Enable the rotational motor
 * @method enableMotor
 */
RevoluteConstraint.prototype.enableMotor = function(){
    if(this.motorEnabled){
        return;
    }
    this.equations.push(this.motorEquation);
    this.motorEnabled = true;
};

/**
 * Disable the rotational motor
 * @method disableMotor
 */
RevoluteConstraint.prototype.disableMotor = function(){
    if(!this.motorEnabled){
        return;
    }
    var i = this.equations.indexOf(this.motorEquation);
    this.equations.splice(i,1);
    this.motorEnabled = false;
};

/**
 * Check if the motor is enabled.
 * @method motorIsEnabled
 * @deprecated use property motorEnabled instead.
 * @return {Boolean}
 */
RevoluteConstraint.prototype.motorIsEnabled = function(){
    return !!this.motorEnabled;
};

/**
 * Set the speed of the rotational constraint motor
 * @method setMotorSpeed
 * @param  {Number} speed
 */
RevoluteConstraint.prototype.setMotorSpeed = function(speed){
    if(!this.motorEnabled){
        return;
    }
    var i = this.equations.indexOf(this.motorEquation);
    this.equations[i].relativeVelocity = speed;
};

/**
 * Get the speed of the rotational constraint motor
 * @method getMotorSpeed
 * @return {Number} The current speed, or false if the motor is not enabled.
 */
RevoluteConstraint.prototype.getMotorSpeed = function(){
    if(!this.motorEnabled){
        return false;
    }
    return this.motorEquation.relativeVelocity;
};

},{"../equations/Equation":23,"../equations/RotationalLockEquation":25,"../equations/RotationalVelocityEquation":26,"../math/vec2":31,"./Constraint":15}],21:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = AngleLockEquation;

/**
 * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
 *
 * @class AngleLockEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Number} [options.angle] Angle to add to the local vector in body A.
 * @param {Number} [options.ratio] Gear ratio
 */
function AngleLockEquation(bodyA, bodyB, options){
    options = options || {};
    Equation.call(this,bodyA,bodyB,-Number.MAX_VALUE,Number.MAX_VALUE);
    this.angle = options.angle || 0;

    /**
     * The gear ratio.
     * @property {Number} ratio
     * @private
     * @see setRatio
     */
    this.ratio = typeof(options.ratio)==="number" ? options.ratio : 1;

    this.setRatio(this.ratio);
}
AngleLockEquation.prototype = new Equation();
AngleLockEquation.prototype.constructor = AngleLockEquation;

AngleLockEquation.prototype.computeGq = function(){
    return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;
};

/**
 * Set the gear ratio for this equation
 * @method setRatio
 * @param {Number} ratio
 */
AngleLockEquation.prototype.setRatio = function(ratio){
    var G = this.G;
    G[2] =  ratio;
    G[5] = -1;
    this.ratio = ratio;
};

/**
 * Set the max force for the equation.
 * @method setMaxTorque
 * @param {Number} torque
 */
AngleLockEquation.prototype.setMaxTorque = function(torque){
    this.maxForce =  torque;
    this.minForce = -torque;
};

},{"../math/vec2":31,"./Equation":23}],22:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = ContactEquation;

/**
 * Non-penetration constraint equation. Tries to make the contactPointA and contactPointB vectors coincide, while keeping the applied force repulsive.
 *
 * @class ContactEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function ContactEquation(bodyA, bodyB){
    Equation.call(this, bodyA, bodyB, 0, Number.MAX_VALUE);

    /**
     * Vector from body i center of mass to the contact point.
     * @property contactPointA
     * @type {Array}
     */
    this.contactPointA = vec2.create();
    this.penetrationVec = vec2.create();

    /**
     * World-oriented vector from body A center of mass to the contact point.
     * @property contactPointB
     * @type {Array}
     */
    this.contactPointB = vec2.create();

    /**
     * The normal vector, pointing out of body i
     * @property normalA
     * @type {Array}
     */
    this.normalA = vec2.create();

    /**
     * The restitution to use (0=no bounciness, 1=max bounciness).
     * @property restitution
     * @type {Number}
     */
    this.restitution = 0;

    /**
     * This property is set to true if this is the first impact between the bodies (not persistant contact).
     * @property firstImpact
     * @type {Boolean}
     * @readOnly
     */
    this.firstImpact = false;

    /**
     * The shape in body i that triggered this contact.
     * @property shapeA
     * @type {Shape}
     */
    this.shapeA = null;

    /**
     * The shape in body j that triggered this contact.
     * @property shapeB
     * @type {Shape}
     */
    this.shapeB = null;
}
ContactEquation.prototype = new Equation();
ContactEquation.prototype.constructor = ContactEquation;
ContactEquation.prototype.computeB = function(a,b,h){
    var bi = this.bodyA,
        bj = this.bodyB,
        ri = this.contactPointA,
        rj = this.contactPointB,
        xi = bi.position,
        xj = bj.position;

    var penetrationVec = this.penetrationVec,
        n = this.normalA,
        G = this.G;

    // Caluclate cross products
    var rixn = vec2.crossLength(ri,n),
        rjxn = vec2.crossLength(rj,n);

    // G = [-n -rixn n rjxn]
    G[0] = -n[0];
    G[1] = -n[1];
    G[2] = -rixn;
    G[3] = n[0];
    G[4] = n[1];
    G[5] = rjxn;

    // Calculate q = xj+rj -(xi+ri) i.e. the penetration vector
    vec2.add(penetrationVec,xj,rj);
    vec2.sub(penetrationVec,penetrationVec,xi);
    vec2.sub(penetrationVec,penetrationVec,ri);

    // Compute iteration
    var GW, Gq;
    if(this.firstImpact && this.restitution !== 0){
        Gq = 0;
        GW = (1/b)*(1+this.restitution) * this.computeGW();
    } else {
        Gq = vec2.dot(n,penetrationVec) + this.offset;
        GW = this.computeGW();
    }

    var GiMf = this.computeGiMf();
    var B = - Gq * a - GW * b - h*GiMf;

    return B;
};

},{"../math/vec2":31,"./Equation":23}],23:[function(_dereq_,module,exports){
module.exports = Equation;

var vec2 = _dereq_('../math/vec2'),
    Utils = _dereq_('../utils/Utils'),
    Body = _dereq_('../objects/Body');

/**
 * Base class for constraint equations.
 * @class Equation
 * @constructor
 * @param {Body} bodyA First body participating in the equation
 * @param {Body} bodyB Second body participating in the equation
 * @param {number} minForce Minimum force to apply. Default: -Number.MAX_VALUE
 * @param {number} maxForce Maximum force to apply. Default: Number.MAX_VALUE
 */
function Equation(bodyA, bodyB, minForce, maxForce){

    /**
     * Minimum force to apply when solving.
     * @property minForce
     * @type {Number}
     */
    this.minForce = typeof(minForce)==="undefined" ? -Number.MAX_VALUE : minForce;

    /**
     * Max force to apply when solving.
     * @property maxForce
     * @type {Number}
     */
    this.maxForce = typeof(maxForce)==="undefined" ? Number.MAX_VALUE : maxForce;

    /**
     * First body participating in the constraint
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second body participating in the constraint
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;

    /**
     * The stiffness of this equation. Typically chosen to a large number (~1e7), but can be chosen somewhat freely to get a stable simulation.
     * @property stiffness
     * @type {Number}
     */
    this.stiffness = Equation.DEFAULT_STIFFNESS;

    /**
     * The number of time steps needed to stabilize the constraint equation. Typically between 3 and 5 time steps.
     * @property relaxation
     * @type {Number}
     */
    this.relaxation = Equation.DEFAULT_RELAXATION;

    /**
     * The Jacobian entry of this equation. 6 numbers, 3 per body (x,y,angle).
     * @property G
     * @type {Array}
     */
    this.G = new Utils.ARRAY_TYPE(6);
    for(var i=0; i<6; i++){
        this.G[i]=0;
    }

    this.offset = 0;

    this.a = 0;
    this.b = 0;
    this.epsilon = 0;
    this.timeStep = 1/60;

    /**
     * Indicates if stiffness or relaxation was changed.
     * @property {Boolean} needsUpdate
     */
    this.needsUpdate = true;

    /**
     * The resulting constraint multiplier from the last solve. This is mostly equivalent to the force produced by the constraint.
     * @property multiplier
     * @type {Number}
     */
    this.multiplier = 0;

    /**
     * Relative velocity.
     * @property {Number} relativeVelocity
     */
    this.relativeVelocity = 0;

    /**
     * Whether this equation is enabled or not. If true, it will be added to the solver.
     * @property {Boolean} enabled
     */
    this.enabled = true;
}
Equation.prototype.constructor = Equation;

/**
 * The default stiffness when creating a new Equation.
 * @static
 * @property {Number} DEFAULT_STIFFNESS
 * @default 1e6
 */
Equation.DEFAULT_STIFFNESS = 1e6;

/**
 * The default relaxation when creating a new Equation.
 * @static
 * @property {Number} DEFAULT_RELAXATION
 * @default 4
 */
Equation.DEFAULT_RELAXATION = 4;

/**
 * Compute SPOOK parameters .a, .b and .epsilon according to the current parameters. See equations 9, 10 and 11 in the <a href="http://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf">SPOOK notes</a>.
 * @method update
 */
Equation.prototype.update = function(){
    var k = this.stiffness,
        d = this.relaxation,
        h = this.timeStep;

    this.a = 4.0 / (h * (1 + 4 * d));
    this.b = (4.0 * d) / (1 + 4 * d);
    this.epsilon = 4.0 / (h * h * k * (1 + 4 * d));

    this.needsUpdate = false;
};

/**
 * Multiply a jacobian entry with corresponding positions or velocities
 * @method gmult
 * @return {Number}
 */
Equation.prototype.gmult = function(G,vi,wi,vj,wj){
    return  G[0] * vi[0] +
            G[1] * vi[1] +
            G[2] * wi +
            G[3] * vj[0] +
            G[4] * vj[1] +
            G[5] * wj;
};

/**
 * Computes the RHS of the SPOOK equation
 * @method computeB
 * @return {Number}
 */
Equation.prototype.computeB = function(a,b,h){
    var GW = this.computeGW();
    var Gq = this.computeGq();
    var GiMf = this.computeGiMf();
    return - Gq * a - GW * b - GiMf*h;
};

/**
 * Computes G\*q, where q are the generalized body coordinates
 * @method computeGq
 * @return {Number}
 */
var qi = vec2.create(),
    qj = vec2.create();
Equation.prototype.computeGq = function(){
    var G = this.G,
        bi = this.bodyA,
        bj = this.bodyB,
        xi = bi.position,
        xj = bj.position,
        ai = bi.angle,
        aj = bj.angle;

    return this.gmult(G, qi, ai, qj, aj) + this.offset;
};

/**
 * Computes G\*W, where W are the body velocities
 * @method computeGW
 * @return {Number}
 */
Equation.prototype.computeGW = function(){
    var G = this.G,
        bi = this.bodyA,
        bj = this.bodyB,
        vi = bi.velocity,
        vj = bj.velocity,
        wi = bi.angularVelocity,
        wj = bj.angularVelocity;
    return this.gmult(G,vi,wi,vj,wj) + this.relativeVelocity;
};

/**
 * Computes G\*Wlambda, where W are the body velocities
 * @method computeGWlambda
 * @return {Number}
 */
Equation.prototype.computeGWlambda = function(){
    var G = this.G,
        bi = this.bodyA,
        bj = this.bodyB,
        vi = bi.vlambda,
        vj = bj.vlambda,
        wi = bi.wlambda,
        wj = bj.wlambda;
    return this.gmult(G,vi,wi,vj,wj);
};

/**
 * Computes G\*inv(M)\*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
 * @method computeGiMf
 * @return {Number}
 */
var iMfi = vec2.create(),
    iMfj = vec2.create();
Equation.prototype.computeGiMf = function(){
    var bi = this.bodyA,
        bj = this.bodyB,
        fi = bi.force,
        ti = bi.angularForce,
        fj = bj.force,
        tj = bj.angularForce,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaSolve,
        invIj = bj.invInertiaSolve,
        G = this.G;

    vec2.scale(iMfi, fi,invMassi);
    vec2.scale(iMfj, fj,invMassj);

    return this.gmult(G,iMfi,ti*invIi,iMfj,tj*invIj);
};

/**
 * Computes G\*inv(M)\*G'
 * @method computeGiMGt
 * @return {Number}
 */
Equation.prototype.computeGiMGt = function(){
    var bi = this.bodyA,
        bj = this.bodyB,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaSolve,
        invIj = bj.invInertiaSolve,
        G = this.G;

    return  G[0] * G[0] * invMassi +
            G[1] * G[1] * invMassi +
            G[2] * G[2] *    invIi +
            G[3] * G[3] * invMassj +
            G[4] * G[4] * invMassj +
            G[5] * G[5] *    invIj;
};

var addToWlambda_temp = vec2.create(),
    addToWlambda_Gi = vec2.create(),
    addToWlambda_Gj = vec2.create(),
    addToWlambda_ri = vec2.create(),
    addToWlambda_rj = vec2.create(),
    addToWlambda_Mdiag = vec2.create();

/**
 * Add constraint velocity to the bodies.
 * @method addToWlambda
 * @param {Number} deltalambda
 */
Equation.prototype.addToWlambda = function(deltalambda){
    var bi = this.bodyA,
        bj = this.bodyB,
        temp = addToWlambda_temp,
        Gi = addToWlambda_Gi,
        Gj = addToWlambda_Gj,
        ri = addToWlambda_ri,
        rj = addToWlambda_rj,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaSolve,
        invIj = bj.invInertiaSolve,
        Mdiag = addToWlambda_Mdiag,
        G = this.G;

    Gi[0] = G[0];
    Gi[1] = G[1];
    Gj[0] = G[3];
    Gj[1] = G[4];

    // Add to linear velocity
    // v_lambda += inv(M) * delta_lamba * G
    vec2.scale(temp, Gi, invMassi*deltalambda);
    vec2.add( bi.vlambda, bi.vlambda, temp);
    // This impulse is in the offset frame
    // Also add contribution to angular
    //bi.wlambda -= vec2.crossLength(temp,ri);
    bi.wlambda += invIi * G[2] * deltalambda;


    vec2.scale(temp, Gj, invMassj*deltalambda);
    vec2.add( bj.vlambda, bj.vlambda, temp);
    //bj.wlambda -= vec2.crossLength(temp,rj);
    bj.wlambda += invIj * G[5] * deltalambda;
};

/**
 * Compute the denominator part of the SPOOK equation: C = G\*inv(M)\*G' + eps
 * @method computeInvC
 * @param  {Number} eps
 * @return {Number}
 */
Equation.prototype.computeInvC = function(eps){
    return 1.0 / (this.computeGiMGt() + eps);
};

},{"../math/vec2":31,"../objects/Body":32,"../utils/Utils":50}],24:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Equation = _dereq_('./Equation')
,   Utils = _dereq_('../utils/Utils');

module.exports = FrictionEquation;

/**
 * Constrains the slipping in a contact along a tangent
 *
 * @class FrictionEquation
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} slipForce
 * @extends Equation
 */
function FrictionEquation(bodyA, bodyB, slipForce){
    Equation.call(this, bodyA, bodyB, -slipForce, slipForce);

    /**
     * Relative vector from center of body A to the contact point, world oriented.
     * @property contactPointA
     * @type {Array}
     */
    this.contactPointA = vec2.create();

    /**
     * Relative vector from center of body B to the contact point, world oriented.
     * @property contactPointB
     * @type {Array}
     */
    this.contactPointB = vec2.create();

    /**
     * Tangent vector that the friction force will act along. World oriented.
     * @property t
     * @type {Array}
     */
    this.t = vec2.create();

    /**
     * A ContactEquation connected to this friction. The contact equations can be used to rescale the max force for the friction. If more than one contact equation is given, then the max force can be set to the average.
     * @property contactEquations
     * @type {ContactEquation}
     */
    this.contactEquations = [];

    /**
     * The shape in body i that triggered this friction.
     * @property shapeA
     * @type {Shape}
     * @todo Needed? The shape can be looked up via contactEquation.shapeA...
     */
    this.shapeA = null;

    /**
     * The shape in body j that triggered this friction.
     * @property shapeB
     * @type {Shape}
     * @todo Needed? The shape can be looked up via contactEquation.shapeB...
     */
    this.shapeB = null;

    /**
     * The friction coefficient to use.
     * @property frictionCoefficient
     * @type {Number}
     */
    this.frictionCoefficient = 0.3;
}
FrictionEquation.prototype = new Equation();
FrictionEquation.prototype.constructor = FrictionEquation;

/**
 * Set the slipping condition for the constraint. The friction force cannot be
 * larger than this value.
 * @method setSlipForce
 * @param  {Number} slipForce
 */
FrictionEquation.prototype.setSlipForce = function(slipForce){
    this.maxForce = slipForce;
    this.minForce = -slipForce;
};

/**
 * Get the max force for the constraint.
 * @method getSlipForce
 * @return {Number}
 */
FrictionEquation.prototype.getSlipForce = function(){
    return this.maxForce;
};

FrictionEquation.prototype.computeB = function(a,b,h){
    var bi = this.bodyA,
        bj = this.bodyB,
        ri = this.contactPointA,
        rj = this.contactPointB,
        t = this.t,
        G = this.G;

    // G = [-t -rixt t rjxt]
    // And remember, this is a pure velocity constraint, g is always zero!
    G[0] = -t[0];
    G[1] = -t[1];
    G[2] = -vec2.crossLength(ri,t);
    G[3] = t[0];
    G[4] = t[1];
    G[5] = vec2.crossLength(rj,t);

    var GW = this.computeGW(),
        GiMf = this.computeGiMf();

    var B = /* - g * a  */ - GW * b - h*GiMf;

    return B;
};

},{"../math/vec2":31,"../utils/Utils":50,"./Equation":23}],25:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = RotationalLockEquation;

/**
 * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
 *
 * @class RotationalLockEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Number} [options.angle] Angle to add to the local vector in bodyA.
 */
function RotationalLockEquation(bodyA, bodyB, options){
    options = options || {};
    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);

    /**
     * @property {number} angle
     */
    this.angle = options.angle || 0;

    var G = this.G;
    G[2] =  1;
    G[5] = -1;
}
RotationalLockEquation.prototype = new Equation();
RotationalLockEquation.prototype.constructor = RotationalLockEquation;

var worldVectorA = vec2.create(),
    worldVectorB = vec2.create(),
    xAxis = vec2.fromValues(1,0),
    yAxis = vec2.fromValues(0,1);
RotationalLockEquation.prototype.computeGq = function(){
    vec2.rotate(worldVectorA,xAxis,this.bodyA.angle+this.angle);
    vec2.rotate(worldVectorB,yAxis,this.bodyB.angle);
    return vec2.dot(worldVectorA,worldVectorB);
};

},{"../math/vec2":31,"./Equation":23}],26:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = RotationalVelocityEquation;

/**
 * Syncs rotational velocity of two bodies, or sets a relative velocity (motor).
 *
 * @class RotationalVelocityEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function RotationalVelocityEquation(bodyA, bodyB){
    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
    this.relativeVelocity = 1;
    this.ratio = 1;
}
RotationalVelocityEquation.prototype = new Equation();
RotationalVelocityEquation.prototype.constructor = RotationalVelocityEquation;
RotationalVelocityEquation.prototype.computeB = function(a,b,h){
    var G = this.G;
    G[2] = -1;
    G[5] = this.ratio;

    var GiMf = this.computeGiMf();
    var GW = this.computeGW();
    var B = - GW * b - h*GiMf;

    return B;
};

},{"../math/vec2":31,"./Equation":23}],27:[function(_dereq_,module,exports){
/**
 * Base class for objects that dispatches events.
 * @class EventEmitter
 * @constructor
 */
var EventEmitter = function () {};

module.exports = EventEmitter;

EventEmitter.prototype = {
    constructor: EventEmitter,

    /**
     * Add an event listener
     * @method on
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     */
    on: function ( type, listener, context ) {
        listener.context = context || this;
        if ( this._listeners === undefined ){
            this._listeners = {};
        }
        var listeners = this._listeners;
        if ( listeners[ type ] === undefined ) {
            listeners[ type ] = [];
        }
        if ( listeners[ type ].indexOf( listener ) === - 1 ) {
            listeners[ type ].push( listener );
        }
        return this;
    },

    /**
     * Check if an event listener is added
     * @method has
     * @param  {String} type
     * @param  {Function} listener
     * @return {Boolean}
     */
    has: function ( type, listener ) {
        if ( this._listeners === undefined ){
            return false;
        }
        var listeners = this._listeners;
        if(listener){
            if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
                return true;
            }
        } else {
            if ( listeners[ type ] !== undefined ) {
                return true;
            }
        }

        return false;
    },

    /**
     * Remove an event listener
     * @method off
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     */
    off: function ( type, listener ) {
        if ( this._listeners === undefined ){
            return this;
        }
        var listeners = this._listeners;
        var index = listeners[ type ].indexOf( listener );
        if ( index !== - 1 ) {
            listeners[ type ].splice( index, 1 );
        }
        return this;
    },

    /**
     * Emit an event.
     * @method emit
     * @param  {Object} event
     * @param  {String} event.type
     * @return {EventEmitter} The self object, for chainability.
     */
    emit: function ( event ) {
        if ( this._listeners === undefined ){
            return this;
        }
        var listeners = this._listeners;
        var listenerArray = listeners[ event.type ];
        if ( listenerArray !== undefined ) {
            event.target = this;
            for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {
                var listener = listenerArray[ i ];
                listener.call( listener.context, event );
            }
        }
        return this;
    }
};

},{}],28:[function(_dereq_,module,exports){
var Material = _dereq_('./Material');
var Equation = _dereq_('../equations/Equation');

module.exports = ContactMaterial;

/**
 * Defines what happens when two materials meet, such as what friction coefficient to use. You can also set other things such as restitution, surface velocity and constraint parameters.
 * @class ContactMaterial
 * @constructor
 * @param {Material} materialA
 * @param {Material} materialB
 * @param {Object}   [options]
 * @param {Number}   [options.friction=0.3]       Friction coefficient.
 * @param {Number}   [options.restitution=0]      Restitution coefficient aka "bounciness".
 * @param {Number}   [options.stiffness]          ContactEquation stiffness.
 * @param {Number}   [options.relaxation]         ContactEquation relaxation.
 * @param {Number}   [options.frictionStiffness]  FrictionEquation stiffness.
 * @param {Number}   [options.frictionRelaxation] FrictionEquation relaxation.
 * @param {Number}   [options.surfaceVelocity=0]  Surface velocity.
 * @author schteppe
 */
function ContactMaterial(materialA, materialB, options){
    options = options || {};

    if(!(materialA instanceof Material) || !(materialB instanceof Material)){
        throw new Error("First two arguments must be Material instances.");
    }

    /**
     * The contact material identifier
     * @property id
     * @type {Number}
     */
    this.id = ContactMaterial.idCounter++;

    /**
     * First material participating in the contact material
     * @property materialA
     * @type {Material}
     */
    this.materialA = materialA;

    /**
     * Second material participating in the contact material
     * @property materialB
     * @type {Material}
     */
    this.materialB = materialB;

    /**
     * Friction to use in the contact of these two materials
     * @property friction
     * @type {Number}
     */
    this.friction    =  typeof(options.friction)    !== "undefined" ?   Number(options.friction)    : 0.3;

    /**
     * Restitution to use in the contact of these two materials
     * @property restitution
     * @type {Number}
     */
    this.restitution =  typeof(options.restitution) !== "undefined" ?   Number(options.restitution) : 0.0;

    /**
     * Stiffness of the resulting ContactEquation that this ContactMaterial generate
     * @property stiffness
     * @type {Number}
     */
    this.stiffness =            typeof(options.stiffness)           !== "undefined" ?   Number(options.stiffness)   : Equation.DEFAULT_STIFFNESS;

    /**
     * Relaxation of the resulting ContactEquation that this ContactMaterial generate
     * @property relaxation
     * @type {Number}
     */
    this.relaxation =           typeof(options.relaxation)          !== "undefined" ?   Number(options.relaxation)  : Equation.DEFAULT_RELAXATION;

    /**
     * Stiffness of the resulting FrictionEquation that this ContactMaterial generate
     * @property frictionStiffness
     * @type {Number}
     */
    this.frictionStiffness =    typeof(options.frictionStiffness)   !== "undefined" ?   Number(options.frictionStiffness)   : Equation.DEFAULT_STIFFNESS;

    /**
     * Relaxation of the resulting FrictionEquation that this ContactMaterial generate
     * @property frictionRelaxation
     * @type {Number}
     */
    this.frictionRelaxation =   typeof(options.frictionRelaxation)  !== "undefined" ?   Number(options.frictionRelaxation)  : Equation.DEFAULT_RELAXATION;

    /**
     * Will add surface velocity to this material. If bodyA rests on top if bodyB, and the surface velocity is positive, bodyA will slide to the right.
     * @property {Number} surfaceVelocity
     */
    this.surfaceVelocity = typeof(options.surfaceVelocity)    !== "undefined" ?   Number(options.surfaceVelocity)    : 0;

    /**
     * Offset to be set on ContactEquations. A positive value will make the bodies penetrate more into each other. Can be useful in scenes where contacts need to be more persistent, for example when stacking. Aka "cure for nervous contacts".
     * @property contactSkinSize
     * @type {Number}
     */
    this.contactSkinSize = 0.005;
}

ContactMaterial.idCounter = 0;

},{"../equations/Equation":23,"./Material":29}],29:[function(_dereq_,module,exports){
module.exports = Material;

/**
 * Defines a physics material.
 * @class Material
 * @constructor
 * @param {number} id Material identifier
 * @author schteppe
 */
function Material(id){
    /**
     * The material identifier
     * @property id
     * @type {Number}
     */
    this.id = id || Material.idCounter++;
}

Material.idCounter = 0;

},{}],30:[function(_dereq_,module,exports){

    /*
        PolyK library
        url: http://polyk.ivank.net
        Released under MIT licence.

        Copyright (c) 2012 Ivan Kuckir

        Permission is hereby granted, free of charge, to any person
        obtaining a copy of this software and associated documentation
        files (the "Software"), to deal in the Software without
        restriction, including without limitation the rights to use,
        copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the
        Software is furnished to do so, subject to the following
        conditions:

        The above copyright notice and this permission notice shall be
        included in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
        OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
        HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
        WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
        FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
        OTHER DEALINGS IN THE SOFTWARE.
    */

    var PolyK = {};

    /*
        Is Polygon self-intersecting?

        O(n^2)
    */
    /*
    PolyK.IsSimple = function(p)
    {
        var n = p.length>>1;
        if(n<4) return true;
        var a1 = new PolyK._P(), a2 = new PolyK._P();
        var b1 = new PolyK._P(), b2 = new PolyK._P();
        var c = new PolyK._P();

        for(var i=0; i<n; i++)
        {
            a1.x = p[2*i  ];
            a1.y = p[2*i+1];
            if(i==n-1)  { a2.x = p[0    ];  a2.y = p[1    ]; }
            else        { a2.x = p[2*i+2];  a2.y = p[2*i+3]; }

            for(var j=0; j<n; j++)
            {
                if(Math.abs(i-j) < 2) continue;
                if(j==n-1 && i==0) continue;
                if(i==n-1 && j==0) continue;

                b1.x = p[2*j  ];
                b1.y = p[2*j+1];
                if(j==n-1)  { b2.x = p[0    ];  b2.y = p[1    ]; }
                else        { b2.x = p[2*j+2];  b2.y = p[2*j+3]; }

                if(PolyK._GetLineIntersection(a1,a2,b1,b2,c) != null) return false;
            }
        }
        return true;
    }

    PolyK.IsConvex = function(p)
    {
        if(p.length<6) return true;
        var l = p.length - 4;
        for(var i=0; i<l; i+=2)
            if(!PolyK._convex(p[i], p[i+1], p[i+2], p[i+3], p[i+4], p[i+5])) return false;
        if(!PolyK._convex(p[l  ], p[l+1], p[l+2], p[l+3], p[0], p[1])) return false;
        if(!PolyK._convex(p[l+2], p[l+3], p[0  ], p[1  ], p[2], p[3])) return false;
        return true;
    }
    */
    PolyK.GetArea = function(p)
    {
        if(p.length <6) return 0;
        var l = p.length - 2;
        var sum = 0;
        for(var i=0; i<l; i+=2)
            sum += (p[i+2]-p[i]) * (p[i+1]+p[i+3]);
        sum += (p[0]-p[l]) * (p[l+1]+p[1]);
        return - sum * 0.5;
    }
    /*
    PolyK.GetAABB = function(p)
    {
        var minx = Infinity;
        var miny = Infinity;
        var maxx = -minx;
        var maxy = -miny;
        for(var i=0; i<p.length; i+=2)
        {
            minx = Math.min(minx, p[i  ]);
            maxx = Math.max(maxx, p[i  ]);
            miny = Math.min(miny, p[i+1]);
            maxy = Math.max(maxy, p[i+1]);
        }
        return {x:minx, y:miny, width:maxx-minx, height:maxy-miny};
    }
    */

    PolyK.Triangulate = function(p)
    {
        var n = p.length>>1;
        if(n<3) return [];
        var tgs = [];
        var avl = [];
        for(var i=0; i<n; i++) avl.push(i);

        var i = 0;
        var al = n;
        while(al > 3)
        {
            var i0 = avl[(i+0)%al];
            var i1 = avl[(i+1)%al];
            var i2 = avl[(i+2)%al];

            var ax = p[2*i0],  ay = p[2*i0+1];
            var bx = p[2*i1],  by = p[2*i1+1];
            var cx = p[2*i2],  cy = p[2*i2+1];

            var earFound = false;
            if(PolyK._convex(ax, ay, bx, by, cx, cy))
            {
                earFound = true;
                for(var j=0; j<al; j++)
                {
                    var vi = avl[j];
                    if(vi==i0 || vi==i1 || vi==i2) continue;
                    if(PolyK._PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy)) {earFound = false; break;}
                }
            }
            if(earFound)
            {
                tgs.push(i0, i1, i2);
                avl.splice((i+1)%al, 1);
                al--;
                i= 0;
            }
            else if(i++ > 3*al) break;      // no convex angles :(
        }
        tgs.push(avl[0], avl[1], avl[2]);
        return tgs;
    }
    /*
    PolyK.ContainsPoint = function(p, px, py)
    {
        var n = p.length>>1;
        var ax, ay, bx = p[2*n-2]-px, by = p[2*n-1]-py;
        var depth = 0;
        for(var i=0; i<n; i++)
        {
            ax = bx;  ay = by;
            bx = p[2*i  ] - px;
            by = p[2*i+1] - py;
            if(ay< 0 && by< 0) continue;    // both "up" or both "donw"
            if(ay>=0 && by>=0) continue;    // both "up" or both "donw"
            if(ax< 0 && bx< 0) continue;

            var lx = ax + (bx-ax)*(-ay)/(by-ay);
            if(lx>0) depth++;
        }
        return (depth & 1) == 1;
    }

    PolyK.Slice = function(p, ax, ay, bx, by)
    {
        if(PolyK.ContainsPoint(p, ax, ay) || PolyK.ContainsPoint(p, bx, by)) return [p.slice(0)];

        var a = new PolyK._P(ax, ay);
        var b = new PolyK._P(bx, by);
        var iscs = [];  // intersections
        var ps = [];    // points
        for(var i=0; i<p.length; i+=2) ps.push(new PolyK._P(p[i], p[i+1]));

        for(var i=0; i<ps.length; i++)
        {
            var isc = new PolyK._P(0,0);
            isc = PolyK._GetLineIntersection(a, b, ps[i], ps[(i+1)%ps.length], isc);

            if(isc)
            {
                isc.flag = true;
                iscs.push(isc);
                ps.splice(i+1,0,isc);
                i++;
            }
        }
        if(iscs.length == 0) return [p.slice(0)];
        var comp = function(u,v) {return PolyK._P.dist(a,u) - PolyK._P.dist(a,v); }
        iscs.sort(comp);

        var pgs = [];
        var dir = 0;
        while(iscs.length > 0)
        {
            var n = ps.length;
            var i0 = iscs[0];
            var i1 = iscs[1];
            var ind0 = ps.indexOf(i0);
            var ind1 = ps.indexOf(i1);
            var solved = false;

            if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;
            else
            {
                i0 = iscs[1];
                i1 = iscs[0];
                ind0 = ps.indexOf(i0);
                ind1 = ps.indexOf(i1);
                if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;
            }
            if(solved)
            {
                dir--;
                var pgn = PolyK._getPoints(ps, ind0, ind1);
                pgs.push(pgn);
                ps = PolyK._getPoints(ps, ind1, ind0);
                i0.flag = i1.flag = false;
                iscs.splice(0,2);
                if(iscs.length == 0) pgs.push(ps);
            }
            else { dir++; iscs.reverse(); }
            if(dir>1) break;
        }
        var result = [];
        for(var i=0; i<pgs.length; i++)
        {
            var pg = pgs[i];
            var npg = [];
            for(var j=0; j<pg.length; j++) npg.push(pg[j].x, pg[j].y);
            result.push(npg);
        }
        return result;
    }

    PolyK.Raycast = function(p, x, y, dx, dy, isc)
    {
        var l = p.length - 2;
        var tp = PolyK._tp;
        var a1 = tp[0], a2 = tp[1],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;
        a2.x = x+dx; a2.y = y+dy;

        if(isc==null) isc = {dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);
            if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, i/2, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);
        if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, p.length/2, isc);

        return (isc.dist != Infinity) ? isc : null;
    }

    PolyK.ClosestEdge = function(p, x, y, isc)
    {
        var l = p.length - 2;
        var tp = PolyK._tp;
        var a1 = tp[0],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;

        if(isc==null) isc = {dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            PolyK._pointLineDist(a1, b1, b2, i>>1, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        PolyK._pointLineDist(a1, b1, b2, l>>1, isc);

        var idst = 1/isc.dist;
        isc.norm.x = (x-isc.point.x)*idst;
        isc.norm.y = (y-isc.point.y)*idst;
        return isc;
    }

    PolyK._pointLineDist = function(p, a, b, edge, isc)
    {
        var x = p.x, y = p.y, x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;

        var A = x - x1;
        var B = y - y1;
        var C = x2 - x1;
        var D = y2 - y1;

        var dot = A * C + B * D;
        var len_sq = C * C + D * D;
        var param = dot / len_sq;

        var xx, yy;

        if (param < 0 || (x1 == x2 && y1 == y2)) {
            xx = x1;
            yy = y1;
        }
        else if (param > 1) {
            xx = x2;
            yy = y2;
        }
        else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        var dx = x - xx;
        var dy = y - yy;
        var dst = Math.sqrt(dx * dx + dy * dy);
        if(dst<isc.dist)
        {
            isc.dist = dst;
            isc.edge = edge;
            isc.point.x = xx;
            isc.point.y = yy;
        }
    }

    PolyK._updateISC = function(dx, dy, a1, b1, b2, c, edge, isc)
    {
        var nrl = PolyK._P.dist(a1, c);
        if(nrl<isc.dist)
        {
            var ibl = 1/PolyK._P.dist(b1, b2);
            var nx = -(b2.y-b1.y)*ibl;
            var ny =  (b2.x-b1.x)*ibl;
            var ddot = 2*(dx*nx+dy*ny);
            isc.dist = nrl;
            isc.norm.x = nx;
            isc.norm.y = ny;
            isc.refl.x = -ddot*nx+dx;
            isc.refl.y = -ddot*ny+dy;
            isc.edge = edge;
        }
    }

    PolyK._getPoints = function(ps, ind0, ind1)
    {
        var n = ps.length;
        var nps = [];
        if(ind1<ind0) ind1 += n;
        for(var i=ind0; i<= ind1; i++) nps.push(ps[i%n]);
        return nps;
    }

    PolyK._firstWithFlag = function(ps, ind)
    {
        var n = ps.length;
        while(true)
        {
            ind = (ind+1)%n;
            if(ps[ind].flag) return ind;
        }
    }
    */
    PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy)
    {
        var v0x = cx-ax;
        var v0y = cy-ay;
        var v1x = bx-ax;
        var v1y = by-ay;
        var v2x = px-ax;
        var v2y = py-ay;

        var dot00 = v0x*v0x+v0y*v0y;
        var dot01 = v0x*v1x+v0y*v1y;
        var dot02 = v0x*v2x+v0y*v2y;
        var dot11 = v1x*v1x+v1y*v1y;
        var dot12 = v1x*v2x+v1y*v2y;

        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

        // Check if point is in triangle
        return (u >= 0) && (v >= 0) && (u + v < 1);
    }
    /*
    PolyK._RayLineIntersection = function(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        var iDen = 1/Den;
        I.x = ( A*dbx - dax*B ) * iDen;
        I.y = ( A*dby - day*B ) * iDen;

        if(!PolyK._InRect(I, b1, b2)) return null;
        if((day>0 && I.y>a1.y) || (day<0 && I.y<a1.y)) return null;
        if((dax>0 && I.x>a1.x) || (dax<0 && I.x<a1.x)) return null;
        return I;
    }

    PolyK._GetLineIntersection = function(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        I.x = ( A*dbx - dax*B ) / Den;
        I.y = ( A*dby - day*B ) / Den;

        if(PolyK._InRect(I, a1, a2) && PolyK._InRect(I, b1, b2)) return I;
        return null;
    }

    PolyK._InRect = function(a, b, c)
    {
        if  (b.x == c.x) return (a.y>=Math.min(b.y, c.y) && a.y<=Math.max(b.y, c.y));
        if  (b.y == c.y) return (a.x>=Math.min(b.x, c.x) && a.x<=Math.max(b.x, c.x));

        if(a.x >= Math.min(b.x, c.x) && a.x <= Math.max(b.x, c.x)
        && a.y >= Math.min(b.y, c.y) && a.y <= Math.max(b.y, c.y))
        return true;
        return false;
    }
    */
    PolyK._convex = function(ax, ay, bx, by, cx, cy)
    {
        return (ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0;
    }
    /*
    PolyK._P = function(x,y)
    {
        this.x = x;
        this.y = y;
        this.flag = false;
    }
    PolyK._P.prototype.toString = function()
    {
        return "Point ["+this.x+", "+this.y+"]";
    }
    PolyK._P.dist = function(a,b)
    {
        var dx = b.x-a.x;
        var dy = b.y-a.y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    PolyK._tp = [];
    for(var i=0; i<10; i++) PolyK._tp.push(new PolyK._P(0,0));
        */

module.exports = PolyK;

},{}],31:[function(_dereq_,module,exports){
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * The vec2 object from glMatrix, with some extensions and some removed methods. See http://glmatrix.net.
 * @class vec2
 */

var vec2 = module.exports = {};

var Utils = _dereq_('../utils/Utils');

/**
 * Make a cross product and only return the z component
 * @method crossLength
 * @static
 * @param  {Array} a
 * @param  {Array} b
 * @return {Number}
 */
vec2.crossLength = function(a,b){
    return a[0] * b[1] - a[1] * b[0];
};

/**
 * Cross product between a vector and the Z component of a vector
 * @method crossVZ
 * @static
 * @param  {Array} out
 * @param  {Array} vec
 * @param  {Number} zcomp
 * @return {Number}
 */
vec2.crossVZ = function(out, vec, zcomp){
    vec2.rotate(out,vec,-Math.PI/2);// Rotate according to the right hand rule
    vec2.scale(out,out,zcomp);      // Scale with z
    return out;
};

/**
 * Cross product between a vector and the Z component of a vector
 * @method crossZV
 * @static
 * @param  {Array} out
 * @param  {Number} zcomp
 * @param  {Array} vec
 * @return {Number}
 */
vec2.crossZV = function(out, zcomp, vec){
    vec2.rotate(out,vec,Math.PI/2); // Rotate according to the right hand rule
    vec2.scale(out,out,zcomp);      // Scale with z
    return out;
};

/**
 * Rotate a vector by an angle
 * @method rotate
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Number} angle
 */
vec2.rotate = function(out,a,angle){
    if(angle !== 0){
        var c = Math.cos(angle),
            s = Math.sin(angle),
            x = a[0],
            y = a[1];
        out[0] = c*x -s*y;
        out[1] = s*x +c*y;
    } else {
        out[0] = a[0];
        out[1] = a[1];
    }
};

/**
 * Rotate a vector 90 degrees clockwise
 * @method rotate90cw
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Number} angle
 */
vec2.rotate90cw = function(out, a) {
    var x = a[0];
    var y = a[1];
    out[0] = y;
    out[1] = -x;
};

/**
 * Transform a point position to local frame.
 * @method toLocalFrame
 * @param  {Array} out
 * @param  {Array} worldPoint
 * @param  {Array} framePosition
 * @param  {Number} frameAngle
 */
vec2.toLocalFrame = function(out, worldPoint, framePosition, frameAngle){
    vec2.copy(out, worldPoint);
    vec2.sub(out, out, framePosition);
    vec2.rotate(out, out, -frameAngle);
};

/**
 * Transform a point position to global frame.
 * @method toGlobalFrame
 * @param  {Array} out
 * @param  {Array} localPoint
 * @param  {Array} framePosition
 * @param  {Number} frameAngle
 */
vec2.toGlobalFrame = function(out, localPoint, framePosition, frameAngle){
    vec2.copy(out, localPoint);
    vec2.rotate(out, out, frameAngle);
    vec2.add(out, out, framePosition);
};

/**
 * Compute centroid of a triangle spanned by vectors a,b,c. See http://easycalculation.com/analytical/learn-centroid.php
 * @method centroid
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return  {Array} The out object
 */
vec2.centroid = function(out, a, b, c){
    vec2.add(out, a, b);
    vec2.add(out, out, c);
    vec2.scale(out, out, 1/3);
    return out;
};

/**
 * Creates a new, empty vec2
 * @static
 * @method create
 * @return {Array} a new 2D vector
 */
vec2.create = function() {
    var out = new Utils.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 * @static
 * @method clone
 * @param {Array} a vector to clone
 * @return {Array} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new Utils.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 * @static
 * @method fromValues
 * @param {Number} x X component
 * @param {Number} y Y component
 * @return {Array} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new Utils.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 * @static
 * @method copy
 * @param {Array} out the receiving vector
 * @param {Array} a the source vector
 * @return {Array} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 * @static
 * @method set
 * @param {Array} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @return {Array} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 * @static
 * @method add
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts two vec2's
 * @static
 * @method subtract
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for vec2.subtract
 * @static
 * @method sub
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 * @static
 * @method multiply
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for vec2.multiply
 * @static
 * @method mul
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 * @static
 * @method divide
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for vec2.divide
 * @static
 * @method div
 */
vec2.div = vec2.divide;

/**
 * Scales a vec2 by a scalar number
 * @static
 * @method scale
 * @param {Array} out the receiving vector
 * @param {Array} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @return {Array} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 * @static
 * @method distance
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for vec2.distance
 * @static
 * @method dist
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 * @static
 * @method squaredDistance
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for vec2.squaredDistance
 * @static
 * @method sqrDist
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 * @static
 * @method length
 * @param {Array} a vector to calculate length of
 * @return {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for vec2.length
 * @method len
 * @static
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 * @static
 * @method squaredLength
 * @param {Array} a vector to calculate squared length of
 * @return {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for vec2.squaredLength
 * @static
 * @method sqrLen
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 * @static
 * @method negate
 * @param {Array} out the receiving vector
 * @param {Array} a vector to negate
 * @return {Array} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Normalize a vec2
 * @static
 * @method normalize
 * @param {Array} out the receiving vector
 * @param {Array} a vector to normalize
 * @return {Array} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 * @static
 * @method dot
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Returns a string representation of a vector
 * @static
 * @method str
 * @param {Array} vec vector to represent as a string
 * @return {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

},{"../utils/Utils":50}],32:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   decomp = _dereq_('poly-decomp')
,   Convex = _dereq_('../shapes/Convex')
,   AABB = _dereq_('../collision/AABB')
,   EventEmitter = _dereq_('../events/EventEmitter');

module.exports = Body;

/**
 * A rigid body. Has got a center of mass, position, velocity and a number of
 * shapes that are used for collisions.
 *
 * @class Body
 * @constructor
 * @extends EventEmitter
 * @param {Object}              [options]
 * @param {Number}              [options.mass=0]    A number >= 0. If zero, the .type will be set to Body.STATIC.
 * @param {Array}               [options.position]
 * @param {Array}               [options.velocity]
 * @param {Number}              [options.angle=0]
 * @param {Number}              [options.angularVelocity=0]
 * @param {Array}               [options.force]
 * @param {Number}              [options.angularForce=0]
 * @param {Number}              [options.fixedRotation=false]
 * @param {Number}              [options.ccdSpeedThreshold=-1]
 * @param {Number}              [options.ccdIterations=10]
 *
 * @example
 *
 *     // Create a typical dynamic body
 *     var body = new Body({
 *         mass: 1,
 *         position: [0, 0],
 *         angle: 0,
 *         velocity: [0, 0],
 *         angularVelocity: 0
 *     });
 *
 *     // Add a circular shape to the body
 *     body.addShape(new Circle(1));
 *
 *     // Add the body to the world
 *     world.addBody(body);
 */
function Body(options){
    options = options || {};

    EventEmitter.call(this);

    /**
     * The body identifyer
     * @property id
     * @type {Number}
     */
    this.id = ++Body._idCounter;

    /**
     * The world that this body is added to. This property is set to NULL if the body is not added to any world.
     * @property world
     * @type {World}
     */
    this.world = null;

    /**
     * The shapes of the body. The local transform of the shape in .shapes[i] is
     * defined by .shapeOffsets[i] and .shapeAngles[i].
     *
     * @property shapes
     * @type {Array}
     */
    this.shapes = [];

    /**
     * The local shape offsets, relative to the body center of mass. This is an
     * array of Array.
     * @property shapeOffsets
     * @type {Array}
     */
    this.shapeOffsets = [];

    /**
     * The body-local shape angle transforms. This is an array of numbers (angles).
     * @property shapeAngles
     * @type {Array}
     */
    this.shapeAngles = [];

    /**
     * The mass of the body.
     * @property mass
     * @type {number}
     */
    this.mass = options.mass || 0;

    /**
     * The inverse mass of the body.
     * @property invMass
     * @type {number}
     */
    this.invMass = 0;

    /**
     * The inertia of the body around the Z axis.
     * @property inertia
     * @type {number}
     */
    this.inertia = 0;

    /**
     * The inverse inertia of the body.
     * @property invInertia
     * @type {number}
     */
    this.invInertia = 0;

    this.invMassSolve = 0;
    this.invInertiaSolve = 0;

    /**
     * Set to true if you want to fix the rotation of the body.
     * @property fixedRotation
     * @type {Boolean}
     */
    this.fixedRotation = !!options.fixedRotation;

    /**
     * The position of the body
     * @property position
     * @type {Array}
     */
    this.position = vec2.fromValues(0,0);
    if(options.position){
        vec2.copy(this.position, options.position);
    }

    /**
     * The interpolated position of the body.
     * @property interpolatedPosition
     * @type {Array}
     */
    this.interpolatedPosition = vec2.fromValues(0,0);

    /**
     * The interpolated angle of the body.
     * @property interpolatedAngle
     * @type {Number}
     */
    this.interpolatedAngle = 0;

    /**
     * The previous position of the body.
     * @property previousPosition
     * @type {Array}
     */
    this.previousPosition = vec2.fromValues(0,0);

    /**
     * The previous angle of the body.
     * @property previousAngle
     * @type {Number}
     */
    this.previousAngle = 0;

    /**
     * The velocity of the body
     * @property velocity
     * @type {Array}
     */
    this.velocity = vec2.fromValues(0,0);
    if(options.velocity){
        vec2.copy(this.velocity, options.velocity);
    }

    /**
     * Constraint velocity that was added to the body during the last step.
     * @property vlambda
     * @type {Array}
     */
    this.vlambda = vec2.fromValues(0,0);

    /**
     * Angular constraint velocity that was added to the body during last step.
     * @property wlambda
     * @type {Array}
     */
    this.wlambda = 0;

    /**
     * The angle of the body, in radians.
     * @property angle
     * @type {number}
     * @example
     *     // The angle property is not normalized to the interval 0 to 2*pi, it can be any value.
     *     // If you need a value between 0 and 2*pi, use the following function to normalize it.
     *     function normalizeAngle(angle){
     *         angle = angle % (2*Math.PI);
     *         if(angle < 0){
     *             angle += (2*Math.PI);
     *         }
     *         return angle;
     *     }
     */
    this.angle = options.angle || 0;

    /**
     * The angular velocity of the body, in radians per second.
     * @property angularVelocity
     * @type {number}
     */
    this.angularVelocity = options.angularVelocity || 0;

    /**
     * The force acting on the body. Since the body force (and {{#crossLink "Body/angularForce:property"}}{{/crossLink}}) will be zeroed after each step, so you need to set the force before each step.
     * @property force
     * @type {Array}
     *
     * @example
     *     // This produces a forcefield of 1 Newton in the positive x direction.
     *     for(var i=0; i<numSteps; i++){
     *         body.force[0] = 1;
     *         world.step(1/60);
     *     }
     *
     * @example
     *     // This will apply a rotational force on the body
     *     for(var i=0; i<numSteps; i++){
     *         body.angularForce = -3;
     *         world.step(1/60);
     *     }
     */
    this.force = vec2.create();
    if(options.force){
        vec2.copy(this.force, options.force);
    }

    /**
     * The angular force acting on the body. See {{#crossLink "Body/force:property"}}{{/crossLink}}.
     * @property angularForce
     * @type {number}
     */
    this.angularForce = options.angularForce || 0;

    /**
     * The linear damping acting on the body in the velocity direction. Should be a value between 0 and 1.
     * @property damping
     * @type {Number}
     * @default 0.1
     */
    this.damping = typeof(options.damping) === "number" ? options.damping : 0.1;

    /**
     * The angular force acting on the body. Should be a value between 0 and 1.
     * @property angularDamping
     * @type {Number}
     * @default 0.1
     */
    this.angularDamping = typeof(options.angularDamping) === "number" ? options.angularDamping : 0.1;

    /**
     * The type of motion this body has. Should be one of: {{#crossLink "Body/STATIC:property"}}Body.STATIC{{/crossLink}}, {{#crossLink "Body/DYNAMIC:property"}}Body.DYNAMIC{{/crossLink}} and {{#crossLink "Body/KINEMATIC:property"}}Body.KINEMATIC{{/crossLink}}.
     *
     * * Static bodies do not move, and they do not respond to forces or collision.
     * * Dynamic bodies body can move and respond to collisions and forces.
     * * Kinematic bodies only moves according to its .velocity, and does not respond to collisions or force.
     *
     * @property type
     * @type {number}
     *
     * @example
     *     // Bodies are static by default. Static bodies will never move.
     *     var body = new Body();
     *     console.log(body.type == Body.STATIC); // true
     *
     * @example
     *     // By setting the mass of a body to a nonzero number, the body
     *     // will become dynamic and will move and interact with other bodies.
     *     var dynamicBody = new Body({
     *         mass : 1
     *     });
     *     console.log(dynamicBody.type == Body.DYNAMIC); // true
     *
     * @example
     *     // Kinematic bodies will only move if you change their velocity.
     *     var kinematicBody = new Body({
     *         type: Body.KINEMATIC // Type can be set via the options object.
     *     });
     */
    this.type = Body.STATIC;

    if(typeof(options.type) !== 'undefined'){
        this.type = options.type;
    } else if(!options.mass){
        this.type = Body.STATIC;
    } else {
        this.type = Body.DYNAMIC;
    }

    /**
     * Bounding circle radius.
     * @property boundingRadius
     * @type {Number}
     */
    this.boundingRadius = 0;

    /**
     * Bounding box of this body.
     * @property aabb
     * @type {AABB}
     */
    this.aabb = new AABB();

    /**
     * Indicates if the AABB needs update. Update it with {{#crossLink "Body/updateAABB:method"}}.updateAABB(){{/crossLink}}.
     * @property aabbNeedsUpdate
     * @type {Boolean}
     * @see updateAABB
     *
     * @example
     *     // Force update the AABB
     *     body.aabbNeedsUpdate = true;
     *     body.updateAABB();
     *     console.log(body.aabbNeedsUpdate); // false
     */
    this.aabbNeedsUpdate = true;

    /**
     * If true, the body will automatically fall to sleep. Note that you need to enable sleeping in the {{#crossLink "World"}}{{/crossLink}} before anything will happen.
     * @property allowSleep
     * @type {Boolean}
     * @default true
     */
    this.allowSleep = true;

    this.wantsToSleep = false;

    /**
     * One of {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}}, {{#crossLink "Body/SLEEPY:property"}}Body.SLEEPY{{/crossLink}} and {{#crossLink "Body/SLEEPING:property"}}Body.SLEEPING{{/crossLink}}.
     *
     * The body is initially Body.AWAKE. If its velocity norm is below .sleepSpeedLimit, the sleepState will become Body.SLEEPY. If the body continues to be Body.SLEEPY for .sleepTimeLimit seconds, it will fall asleep (Body.SLEEPY).
     *
     * @property sleepState
     * @type {Number}
     * @default Body.AWAKE
     */
    this.sleepState = Body.AWAKE;

    /**
     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
     * @property sleepSpeedLimit
     * @type {Number}
     * @default 0.2
     */
    this.sleepSpeedLimit = 0.2;

    /**
     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
     * @property sleepTimeLimit
     * @type {Number}
     * @default 1
     */
    this.sleepTimeLimit = 1;

    /**
     * Gravity scaling factor. If you want the body to ignore gravity, set this to zero. If you want to reverse gravity, set it to -1.
     * @property {Number} gravityScale
     * @default 1
     */
    this.gravityScale = 1;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this body will move through other bodies, but it will still trigger contact events, etc.
     * @property {Boolean} collisionResponse
     */
    this.collisionResponse = true;

    /**
     * How long the body has been sleeping.
     * @property {Number} idleTime
     */
    this.idleTime = 0;

    /**
     * The last time when the body went to SLEEPY state.
     * @property {Number} timeLastSleepy
     * @private
     */
    this.timeLastSleepy = 0;

    /**
     * If the body speed exceeds this threshold, CCD (continuous collision detection) will be enabled. Set it to a negative number to disable CCD completely for this body.
     * @property {number} ccdSpeedThreshold
     * @default -1
     */
    this.ccdSpeedThreshold = options.ccdSpeedThreshold !== undefined ? options.ccdSpeedThreshold : -1;

    /**
     * The number of iterations that should be used when searching for the time of impact during CCD. A larger number will assure that there's a small penetration on CCD collision, but a small number will give more performance.
     * @property {number} ccdIterations
     * @default 10
     */
    this.ccdIterations = options.ccdIterations !== undefined ? options.ccdIterations : 10;

    this.concavePath = null;

    this._wakeUpAfterNarrowphase = false;

    this.updateMassProperties();
}
Body.prototype = new EventEmitter();
Body.prototype.constructor = Body;

Body._idCounter = 0;

Body.prototype.updateSolveMassProperties = function(){
    if(this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC){
        this.invMassSolve = 0;
        this.invInertiaSolve = 0;
    } else {
        this.invMassSolve = this.invMass;
        this.invInertiaSolve = this.invInertia;
    }
};

/**
 * Set the total density of the body
 * @method setDensity
 */
Body.prototype.setDensity = function(density) {
    var totalArea = this.getArea();
    this.mass = totalArea * density;
    this.updateMassProperties();
};

/**
 * Get the total area of all shapes in the body
 * @method getArea
 * @return {Number}
 */
Body.prototype.getArea = function() {
    var totalArea = 0;
    for(var i=0; i<this.shapes.length; i++){
        totalArea += this.shapes[i].area;
    }
    return totalArea;
};

/**
 * Get the AABB from the body. The AABB is updated if necessary.
 * @method getAABB
 */
Body.prototype.getAABB = function(){
    if(this.aabbNeedsUpdate){
        this.updateAABB();
    }
    return this.aabb;
};

var shapeAABB = new AABB(),
    tmp = vec2.create();

/**
 * Updates the AABB of the Body
 * @method updateAABB
 */
Body.prototype.updateAABB = function() {
    var shapes = this.shapes,
        shapeOffsets = this.shapeOffsets,
        shapeAngles = this.shapeAngles,
        N = shapes.length,
        offset = tmp,
        bodyAngle = this.angle;

    for(var i=0; i!==N; i++){
        var shape = shapes[i],
            angle = shapeAngles[i] + bodyAngle;

        // Get shape world offset
        vec2.rotate(offset, shapeOffsets[i], bodyAngle);
        vec2.add(offset, offset, this.position);

        // Get shape AABB
        shape.computeAABB(shapeAABB, offset, angle);

        if(i===0){
            this.aabb.copy(shapeAABB);
        } else {
            this.aabb.extend(shapeAABB);
        }
    }

    this.aabbNeedsUpdate = false;
};

/**
 * Update the bounding radius of the body. Should be done if any of the shapes
 * are changed.
 * @method updateBoundingRadius
 */
Body.prototype.updateBoundingRadius = function(){
    var shapes = this.shapes,
        shapeOffsets = this.shapeOffsets,
        N = shapes.length,
        radius = 0;

    for(var i=0; i!==N; i++){
        var shape = shapes[i],
            offset = vec2.length(shapeOffsets[i]),
            r = shape.boundingRadius;
        if(offset + r > radius){
            radius = offset + r;
        }
    }

    this.boundingRadius = radius;
};

/**
 * Add a shape to the body. You can pass a local transform when adding a shape,
 * so that the shape gets an offset and angle relative to the body center of mass.
 * Will automatically update the mass properties and bounding radius.
 *
 * @method addShape
 * @param  {Shape}              shape
 * @param  {Array} [offset] Local body offset of the shape.
 * @param  {Number}             [angle]  Local body angle.
 *
 * @example
 *     var body = new Body(),
 *         shape = new Circle();
 *
 *     // Add the shape to the body, positioned in the center
 *     body.addShape(shape);
 *
 *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local x-axis.
 *     body.addShape(shape,[1,0]);
 *
 *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local y-axis, and rotated 90 degrees CCW.
 *     body.addShape(shape,[0,1],Math.PI/2);
 */
Body.prototype.addShape = function(shape,offset,angle){
    angle = angle || 0.0;

    // Copy the offset vector
    if(offset){
        offset = vec2.fromValues(offset[0],offset[1]);
    } else {
        offset = vec2.fromValues(0,0);
    }

    this.shapes      .push(shape);
    this.shapeOffsets.push(offset);
    this.shapeAngles .push(angle);
    this.updateMassProperties();
    this.updateBoundingRadius();

    this.aabbNeedsUpdate = true;
};

/**
 * Remove a shape
 * @method removeShape
 * @param  {Shape}  shape
 * @return {Boolean}       True if the shape was found and removed, else false.
 */
Body.prototype.removeShape = function(shape){
    var idx = this.shapes.indexOf(shape);

    if(idx !== -1){
        this.shapes.splice(idx,1);
        this.shapeOffsets.splice(idx,1);
        this.shapeAngles.splice(idx,1);
        this.aabbNeedsUpdate = true;
        return true;
    } else {
        return false;
    }
};

/**
 * Updates .inertia, .invMass, .invInertia for this Body. Should be called when
 * changing the structure or mass of the Body.
 *
 * @method updateMassProperties
 *
 * @example
 *     body.mass += 1;
 *     body.updateMassProperties();
 */
Body.prototype.updateMassProperties = function(){
    if(this.type === Body.STATIC || this.type === Body.KINEMATIC){

        this.mass = Number.MAX_VALUE;
        this.invMass = 0;
        this.inertia = Number.MAX_VALUE;
        this.invInertia = 0;

    } else {

        var shapes = this.shapes,
            N = shapes.length,
            m = this.mass / N,
            I = 0;

        if(!this.fixedRotation){
            for(var i=0; i<N; i++){
                var shape = shapes[i],
                    r2 = vec2.squaredLength(this.shapeOffsets[i]),
                    Icm = shape.computeMomentOfInertia(m);
                I += Icm + m*r2;
            }
            this.inertia = I;
            this.invInertia = I>0 ? 1/I : 0;

        } else {
            this.inertia = Number.MAX_VALUE;
            this.invInertia = 0;
        }

        // Inverse mass properties are easy
        this.invMass = 1/this.mass;// > 0 ? 1/this.mass : 0;
    }
};

var Body_applyForce_r = vec2.create();

/**
 * Apply force to a world point. This could for example be a point on the RigidBody surface. Applying force this way will add to Body.force and Body.angularForce.
 * @method applyForce
 * @param {Array} force The force to add.
 * @param {Array} worldPoint A world point to apply the force on.
 */
Body.prototype.applyForce = function(force,worldPoint){
    // Compute point position relative to the body center
    var r = Body_applyForce_r;
    vec2.sub(r,worldPoint,this.position);

    // Add linear force
    vec2.add(this.force,this.force,force);

    // Compute produced rotational force
    var rotForce = vec2.crossLength(r,force);

    // Add rotational force
    this.angularForce += rotForce;
};

/**
 * Transform a world point to local body frame.
 * @method toLocalFrame
 * @param  {Array} out          The vector to store the result in
 * @param  {Array} worldPoint   The input world vector
 */
Body.prototype.toLocalFrame = function(out, worldPoint){
    vec2.toLocalFrame(out, worldPoint, this.position, this.angle);
};

/**
 * Transform a local point to world frame.
 * @method toWorldFrame
 * @param  {Array} out          The vector to store the result in
 * @param  {Array} localPoint   The input local vector
 */
Body.prototype.toWorldFrame = function(out, localPoint){
    vec2.toGlobalFrame(out, localPoint, this.position, this.angle);
};

/**
 * Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points.
 * @method fromPolygon
 * @param {Array} path An array of 2d vectors, e.g. [[0,0],[0,1],...] that resembles a concave or convex polygon. The shape must be simple and without holes.
 * @param {Object} [options]
 * @param {Boolean} [options.optimalDecomp=false]   Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.
 * @param {Boolean} [options.skipSimpleCheck=false] Set to true if you already know that the path is not intersecting itself.
 * @param {Boolean|Number} [options.removeCollinearPoints=false] Set to a number (angle threshold value) to remove collinear points, or false to keep all points.
 * @return {Boolean} True on success, else false.
 */
Body.prototype.fromPolygon = function(path,options){
    options = options || {};

    // Remove all shapes
    for(var i=this.shapes.length; i>=0; --i){
        this.removeShape(this.shapes[i]);
    }

    var p = new decomp.Polygon();
    p.vertices = path;

    // Make it counter-clockwise
    p.makeCCW();

    if(typeof(options.removeCollinearPoints) === "number"){
        p.removeCollinearPoints(options.removeCollinearPoints);
    }

    // Check if any line segment intersects the path itself
    if(typeof(options.skipSimpleCheck) === "undefined"){
        if(!p.isSimple()){
            return false;
        }
    }

    // Save this path for later
    this.concavePath = p.vertices.slice(0);
    for(var i=0; i<this.concavePath.length; i++){
        var v = [0,0];
        vec2.copy(v,this.concavePath[i]);
        this.concavePath[i] = v;
    }

    // Slow or fast decomp?
    var convexes;
    if(options.optimalDecomp){
        convexes = p.decomp();
    } else {
        convexes = p.quickDecomp();
    }

    var cm = vec2.create();

    // Add convexes
    for(var i=0; i!==convexes.length; i++){
        // Create convex
        var c = new Convex(convexes[i].vertices);

        // Move all vertices so its center of mass is in the local center of the convex
        for(var j=0; j!==c.vertices.length; j++){
            var v = c.vertices[j];
            vec2.sub(v,v,c.centerOfMass);
        }

        vec2.scale(cm,c.centerOfMass,1);
        c.updateTriangles();
        c.updateCenterOfMass();
        c.updateBoundingRadius();

        // Add the shape
        this.addShape(c,cm);
    }

    this.adjustCenterOfMass();

    this.aabbNeedsUpdate = true;

    return true;
};

var adjustCenterOfMass_tmp1 = vec2.fromValues(0,0),
    adjustCenterOfMass_tmp2 = vec2.fromValues(0,0),
    adjustCenterOfMass_tmp3 = vec2.fromValues(0,0),
    adjustCenterOfMass_tmp4 = vec2.fromValues(0,0);

/**
 * Moves the shape offsets so their center of mass becomes the body center of mass.
 * @method adjustCenterOfMass
 */
Body.prototype.adjustCenterOfMass = function(){
    var offset_times_area = adjustCenterOfMass_tmp2,
        sum =               adjustCenterOfMass_tmp3,
        cm =                adjustCenterOfMass_tmp4,
        totalArea =         0;
    vec2.set(sum,0,0);

    for(var i=0; i!==this.shapes.length; i++){
        var s = this.shapes[i],
            offset = this.shapeOffsets[i];
        vec2.scale(offset_times_area,offset,s.area);
        vec2.add(sum,sum,offset_times_area);
        totalArea += s.area;
    }

    vec2.scale(cm,sum,1/totalArea);

    // Now move all shapes
    for(var i=0; i!==this.shapes.length; i++){
        var s = this.shapes[i],
            offset = this.shapeOffsets[i];

        // Offset may be undefined. Fix that.
        if(!offset){
            offset = this.shapeOffsets[i] = vec2.create();
        }

        vec2.sub(offset,offset,cm);
    }

    // Move the body position too
    vec2.add(this.position,this.position,cm);

    // And concave path
    for(var i=0; this.concavePath && i<this.concavePath.length; i++){
        vec2.sub(this.concavePath[i], this.concavePath[i], cm);
    }

    this.updateMassProperties();
    this.updateBoundingRadius();
};

/**
 * Sets the force on the body to zero.
 * @method setZeroForce
 */
Body.prototype.setZeroForce = function(){
    vec2.set(this.force,0.0,0.0);
    this.angularForce = 0.0;
};

Body.prototype.resetConstraintVelocity = function(){
    var b = this,
        vlambda = b.vlambda;
    vec2.set(vlambda,0,0);
    b.wlambda = 0;
};

Body.prototype.addConstraintVelocity = function(){
    var b = this,
        v = b.velocity;
    vec2.add( v, v, b.vlambda);
    b.angularVelocity += b.wlambda;
};

/**
 * Apply damping, see <a href="http://code.google.com/p/bullet/issues/detail?id=74">this</a> for details.
 * @method applyDamping
 * @param  {number} dt Current time step
 */
Body.prototype.applyDamping = function(dt){
    if(this.type === Body.DYNAMIC){ // Only for dynamic bodies
        var v = this.velocity;
        vec2.scale(v, v, Math.pow(1.0 - this.damping,dt));
        this.angularVelocity *= Math.pow(1.0 - this.angularDamping,dt);
    }
};

/**
 * Wake the body up. Normally you should not need this, as the body is automatically awoken at events such as collisions.
 * Sets the sleepState to {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}} and emits the wakeUp event if the body wasn't awake before.
 * @method wakeUp
 */
Body.prototype.wakeUp = function(){
    var s = this.sleepState;
    this.sleepState = Body.AWAKE;
    this.idleTime = 0;
    if(s !== Body.AWAKE){
        this.emit(Body.wakeUpEvent);
    }
};

/**
 * Force body sleep
 * @method sleep
 */
Body.prototype.sleep = function(){
    this.sleepState = Body.SLEEPING;
    this.angularVelocity = 0;
    this.angularForce = 0;
    vec2.set(this.velocity,0,0);
    vec2.set(this.force,0,0);
    this.emit(Body.sleepEvent);
};

/**
 * Called every timestep to update internal sleep timer and change sleep state if needed.
 * @method sleepTick
 * @param {number} time The world time in seconds
 * @param {boolean} dontSleep
 * @param {number} dt
 */
Body.prototype.sleepTick = function(time, dontSleep, dt){
    if(!this.allowSleep || this.type === Body.SLEEPING){
        return;
    }

    this.wantsToSleep = false;

    var sleepState = this.sleepState,
        speedSquared = vec2.squaredLength(this.velocity) + Math.pow(this.angularVelocity,2),
        speedLimitSquared = Math.pow(this.sleepSpeedLimit,2);

    // Add to idle time
    if(speedSquared >= speedLimitSquared){
        this.idleTime = 0;
        this.sleepState = Body.AWAKE;
    } else {
        this.idleTime += dt;
        this.sleepState = Body.SLEEPY;
    }
    if(this.idleTime > this.sleepTimeLimit){
        if(!dontSleep){
            this.sleep();
        } else {
            this.wantsToSleep = true;
        }
    }

    /*
    if(sleepState===Body.AWAKE && speedSquared < speedLimitSquared){
        this.sleepState = Body.SLEEPY; // Sleepy
        this.timeLastSleepy = time;
        this.emit(Body.sleepyEvent);
    } else if(sleepState===Body.SLEEPY && speedSquared >= speedLimitSquared){
        this.wakeUp(); // Wake up
    } else if(sleepState===Body.SLEEPY && (time - this.timeLastSleepy ) > this.sleepTimeLimit){
        this.wantsToSleep = true;
        if(!dontSleep){
            this.sleep();
        }
    }
    */
};

Body.prototype.getVelocityFromPosition = function(store, timeStep){
    store = store || vec2.create();
    vec2.sub(store, this.position, this.previousPosition);
    vec2.scale(store, store, 1/timeStep);
    return store;
};

Body.prototype.getAngularVelocityFromPosition = function(timeStep){
    return (this.angle - this.previousAngle) / timeStep;
};

/**
 * Check if the body is overlapping another body. Note that this method only works if the body was added to a World and if at least one step was taken.
 * @method overlaps
 * @param  {Body} body
 * @return {boolean}
 */
Body.prototype.overlaps = function(body){
    return this.world.overlapKeeper.bodiesAreOverlapping(this, body);
};

var integrate_fhMinv = vec2.create();
var integrate_velodt = vec2.create();

/**
 * Move the body forward in time given its current velocity.
 * @method integrate
 * @param  {Number} dt
 */
Body.prototype.integrate = function(dt){
    var minv = this.invMass,
        f = this.force,
        pos = this.position,
        velo = this.velocity;

    // Save old position
    vec2.copy(this.previousPosition, this.position);
    this.previousAngle = this.angle;

    // Velocity update
    if(!this.fixedRotation){
        this.angularVelocity += this.angularForce * this.invInertia * dt;
    }
    vec2.scale(integrate_fhMinv, f, dt * minv);
    vec2.add(velo, integrate_fhMinv, velo);

    // CCD
    if(!this.integrateToTimeOfImpact(dt)){

        // Regular position update
        vec2.scale(integrate_velodt, velo, dt);
        vec2.add(pos, pos, integrate_velodt);
        if(!this.fixedRotation){
            this.angle += this.angularVelocity * dt;
        }
    }

    this.aabbNeedsUpdate = true;
};

var direction = vec2.create();
var end = vec2.create();
var startToEnd = vec2.create();
var rememberPosition = vec2.create();
Body.prototype.integrateToTimeOfImpact = function(dt){

    if(this.ccdSpeedThreshold < 0 || vec2.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)){
        return false;
    }

    vec2.normalize(direction, this.velocity);

    vec2.scale(end, this.velocity, dt);
    vec2.add(end, end, this.position);

    vec2.sub(startToEnd, end, this.position);
    var startToEndAngle = this.angularVelocity * dt;
    var len = vec2.length(startToEnd);

    var timeOfImpact = 1;

    var hit;
    var that = this;
    this.world.raycastAll(this.position, end, {}, function (result) {
        if(result.body === that){
            return;
        }
        hit = result.body;
        vec2.copy(end, result.hitPointWorld);
        vec2.sub(startToEnd, result.hitPointWorld, that.position);
        timeOfImpact = vec2.length(startToEnd) / len;
        result.abort();
    });

    if(!hit){
        return false;
    }

    var rememberAngle = this.angle;
    vec2.copy(rememberPosition, this.position);

    // Got a start and end point. Approximate time of impact using binary search
    var iter = 0;
    var tmin = 0;
    var tmid = 0;
    var tmax = timeOfImpact;
    while (tmax >= tmin && iter < this.ccdIterations) {
        iter++;

        // calculate the midpoint
        tmid = (tmax - tmin) / 2;

        // Move the body to that point
        vec2.scale(integrate_velodt, startToEnd, timeOfImpact);
        vec2.add(this.position, rememberPosition, integrate_velodt);
        this.angle = rememberAngle + startToEndAngle * timeOfImpact;
        this.updateAABB();

        // check overlap
        var overlaps = this.aabb.overlaps(hit.aabb) && this.world.narrowphase.bodiesOverlap(this, hit);

        if (overlaps) {
            // change min to search upper interval
            tmin = tmid;
        } else {
            // change max to search lower interval
            tmax = tmid;
        }
    }

    timeOfImpact = tmid;

    vec2.copy(this.position, rememberPosition);
    this.angle = rememberAngle;

    // move to TOI
    vec2.scale(integrate_velodt, startToEnd, timeOfImpact);
    vec2.add(this.position, this.position, integrate_velodt);
    if(!this.fixedRotation){
        this.angle += startToEndAngle * timeOfImpact;
    }

    return true;
};

/**
 * @event sleepy
 */
Body.sleepyEvent = {
    type: "sleepy"
};

/**
 * @event sleep
 */
Body.sleepEvent = {
    type: "sleep"
};

/**
 * @event wakeup
 */
Body.wakeUpEvent = {
    type: "wakeup"
};

/**
 * Dynamic body.
 * @property DYNAMIC
 * @type {Number}
 * @static
 */
Body.DYNAMIC = 1;

/**
 * Static body.
 * @property STATIC
 * @type {Number}
 * @static
 */
Body.STATIC = 2;

/**
 * Kinematic body.
 * @property KINEMATIC
 * @type {Number}
 * @static
 */
Body.KINEMATIC = 4;

/**
 * @property AWAKE
 * @type {Number}
 * @static
 */
Body.AWAKE = 0;

/**
 * @property SLEEPY
 * @type {Number}
 * @static
 */
Body.SLEEPY = 1;

/**
 * @property SLEEPING
 * @type {Number}
 * @static
 */
Body.SLEEPING = 2;


},{"../collision/AABB":7,"../events/EventEmitter":27,"../math/vec2":31,"../shapes/Convex":39,"poly-decomp":5}],33:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Spring = _dereq_('./Spring');
var Utils = _dereq_('../utils/Utils');

module.exports = LinearSpring;

/**
 * A spring, connecting two bodies.
 *
 * The Spring explicitly adds force and angularForce to the bodies.
 *
 * @class LinearSpring
 * @extends Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.restLength]   A number > 0. Default is the current distance between the world anchor points.
 * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1]      A number >= 0. Default: 1
 * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
 * @param {Array}  [options.worldAnchorB]
 * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
 * @param {Array}  [options.localAnchorB]
 */
function LinearSpring(bodyA,bodyB,options){
    options = options || {};

    Spring.call(this, bodyA, bodyB, options);

    /**
     * Anchor for bodyA in local bodyA coordinates.
     * @property localAnchorA
     * @type {Array}
     */
    this.localAnchorA = vec2.fromValues(0,0);

    /**
     * Anchor for bodyB in local bodyB coordinates.
     * @property localAnchorB
     * @type {Array}
     */
    this.localAnchorB = vec2.fromValues(0,0);

    if(options.localAnchorA){ vec2.copy(this.localAnchorA, options.localAnchorA); }
    if(options.localAnchorB){ vec2.copy(this.localAnchorB, options.localAnchorB); }
    if(options.worldAnchorA){ this.setWorldAnchorA(options.worldAnchorA); }
    if(options.worldAnchorB){ this.setWorldAnchorB(options.worldAnchorB); }

    var worldAnchorA = vec2.create();
    var worldAnchorB = vec2.create();
    this.getWorldAnchorA(worldAnchorA);
    this.getWorldAnchorB(worldAnchorB);
    var worldDistance = vec2.distance(worldAnchorA, worldAnchorB);

    /**
     * Rest length of the spring.
     * @property restLength
     * @type {number}
     */
    this.restLength = typeof(options.restLength) === "number" ? options.restLength : worldDistance;
}
LinearSpring.prototype = new Spring();
LinearSpring.prototype.constructor = LinearSpring;

/**
 * Set the anchor point on body A, using world coordinates.
 * @method setWorldAnchorA
 * @param {Array} worldAnchorA
 */
LinearSpring.prototype.setWorldAnchorA = function(worldAnchorA){
    this.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA);
};

/**
 * Set the anchor point on body B, using world coordinates.
 * @method setWorldAnchorB
 * @param {Array} worldAnchorB
 */
LinearSpring.prototype.setWorldAnchorB = function(worldAnchorB){
    this.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB);
};

/**
 * Get the anchor point on body A, in world coordinates.
 * @method getWorldAnchorA
 * @param {Array} result The vector to store the result in.
 */
LinearSpring.prototype.getWorldAnchorA = function(result){
    this.bodyA.toWorldFrame(result, this.localAnchorA);
};

/**
 * Get the anchor point on body B, in world coordinates.
 * @method getWorldAnchorB
 * @param {Array} result The vector to store the result in.
 */
LinearSpring.prototype.getWorldAnchorB = function(result){
    this.bodyB.toWorldFrame(result, this.localAnchorB);
};

var applyForce_r =              vec2.create(),
    applyForce_r_unit =         vec2.create(),
    applyForce_u =              vec2.create(),
    applyForce_f =              vec2.create(),
    applyForce_worldAnchorA =   vec2.create(),
    applyForce_worldAnchorB =   vec2.create(),
    applyForce_ri =             vec2.create(),
    applyForce_rj =             vec2.create(),
    applyForce_tmp =            vec2.create();

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
LinearSpring.prototype.applyForce = function(){
    var k = this.stiffness,
        d = this.damping,
        l = this.restLength,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        r = applyForce_r,
        r_unit = applyForce_r_unit,
        u = applyForce_u,
        f = applyForce_f,
        tmp = applyForce_tmp;

    var worldAnchorA = applyForce_worldAnchorA,
        worldAnchorB = applyForce_worldAnchorB,
        ri = applyForce_ri,
        rj = applyForce_rj;

    // Get world anchors
    this.getWorldAnchorA(worldAnchorA);
    this.getWorldAnchorB(worldAnchorB);

    // Get offset points
    vec2.sub(ri, worldAnchorA, bodyA.position);
    vec2.sub(rj, worldAnchorB, bodyB.position);

    // Compute distance vector between world anchor points
    vec2.sub(r, worldAnchorB, worldAnchorA);
    var rlen = vec2.len(r);
    vec2.normalize(r_unit,r);

    //console.log(rlen)
    //console.log("A",vec2.str(worldAnchorA),"B",vec2.str(worldAnchorB))

    // Compute relative velocity of the anchor points, u
    vec2.sub(u, bodyB.velocity, bodyA.velocity);
    vec2.crossZV(tmp, bodyB.angularVelocity, rj);
    vec2.add(u, u, tmp);
    vec2.crossZV(tmp, bodyA.angularVelocity, ri);
    vec2.sub(u, u, tmp);

    // F = - k * ( x - L ) - D * ( u )
    vec2.scale(f, r_unit, -k*(rlen-l) - d*vec2.dot(u,r_unit));

    // Add forces to bodies
    vec2.sub( bodyA.force, bodyA.force, f);
    vec2.add( bodyB.force, bodyB.force, f);

    // Angular force
    var ri_x_f = vec2.crossLength(ri, f);
    var rj_x_f = vec2.crossLength(rj, f);
    bodyA.angularForce -= ri_x_f;
    bodyB.angularForce += rj_x_f;
};

},{"../math/vec2":31,"../utils/Utils":50,"./Spring":35}],34:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Spring = _dereq_('./Spring');

module.exports = RotationalSpring;

/**
 * A rotational spring, connecting two bodies rotation. This spring explicitly adds angularForce (torque) to the bodies.
 *
 * The spring can be combined with a {{#crossLink "RevoluteConstraint"}}{{/crossLink}} to make, for example, a mouse trap.
 *
 * @class RotationalSpring
 * @extends Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.restAngle] The relative angle of bodies at which the spring is at rest. If not given, it's set to the current relative angle between the bodies.
 * @param {number} [options.stiffness=100] Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1] A number >= 0.
 */
function RotationalSpring(bodyA, bodyB, options){
    options = options || {};

    Spring.call(this, bodyA, bodyB, options);

    /**
     * Rest angle of the spring.
     * @property restAngle
     * @type {number}
     */
    this.restAngle = typeof(options.restAngle) === "number" ? options.restAngle : bodyB.angle - bodyA.angle;
}
RotationalSpring.prototype = new Spring();
RotationalSpring.prototype.constructor = RotationalSpring;

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
RotationalSpring.prototype.applyForce = function(){
    var k = this.stiffness,
        d = this.damping,
        l = this.restAngle,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        x = bodyB.angle - bodyA.angle,
        u = bodyB.angularVelocity - bodyA.angularVelocity;

    var torque = - k * (x - l) - d * u * 0;

    bodyA.angularForce -= torque;
    bodyB.angularForce += torque;
};

},{"../math/vec2":31,"./Spring":35}],35:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Utils = _dereq_('../utils/Utils');

module.exports = Spring;

/**
 * A spring, connecting two bodies. The Spring explicitly adds force and angularForce to the bodies and does therefore not put load on the constraint solver.
 *
 * @class Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1]      A number >= 0. Default: 1
 * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
 * @param {Array}  [options.localAnchorB]
 * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
 * @param {Array}  [options.worldAnchorB]
 */
function Spring(bodyA, bodyB, options){
    options = Utils.defaults(options,{
        stiffness: 100,
        damping: 1,
    });

    /**
     * Stiffness of the spring.
     * @property stiffness
     * @type {number}
     */
    this.stiffness = options.stiffness;

    /**
     * Damping of the spring.
     * @property damping
     * @type {number}
     */
    this.damping = options.damping;

    /**
     * First connected body.
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second connected body.
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;
}

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
Spring.prototype.applyForce = function(){
    // To be implemented by subclasses
};

},{"../math/vec2":31,"../utils/Utils":50}],36:[function(_dereq_,module,exports){
// Export p2 classes
module.exports = {
    AABB :                          _dereq_('./collision/AABB'),
    AngleLockEquation :             _dereq_('./equations/AngleLockEquation'),
    Body :                          _dereq_('./objects/Body'),
    Broadphase :                    _dereq_('./collision/Broadphase'),
    Capsule :                       _dereq_('./shapes/Capsule'),
    Circle :                        _dereq_('./shapes/Circle'),
    Constraint :                    _dereq_('./constraints/Constraint'),
    ContactEquation :               _dereq_('./equations/ContactEquation'),
    ContactMaterial :               _dereq_('./material/ContactMaterial'),
    Convex :                        _dereq_('./shapes/Convex'),
    DistanceConstraint :            _dereq_('./constraints/DistanceConstraint'),
    Equation :                      _dereq_('./equations/Equation'),
    EventEmitter :                  _dereq_('./events/EventEmitter'),
    FrictionEquation :              _dereq_('./equations/FrictionEquation'),
    GearConstraint :                _dereq_('./constraints/GearConstraint'),
    GridBroadphase :                _dereq_('./collision/GridBroadphase'),
    GSSolver :                      _dereq_('./solver/GSSolver'),
    Heightfield :                   _dereq_('./shapes/Heightfield'),
    Line :                          _dereq_('./shapes/Line'),
    LockConstraint :                _dereq_('./constraints/LockConstraint'),
    Material :                      _dereq_('./material/Material'),
    Narrowphase :                   _dereq_('./collision/Narrowphase'),
    NaiveBroadphase :               _dereq_('./collision/NaiveBroadphase'),
    Particle :                      _dereq_('./shapes/Particle'),
    Plane :                         _dereq_('./shapes/Plane'),
    RevoluteConstraint :            _dereq_('./constraints/RevoluteConstraint'),
    PrismaticConstraint :           _dereq_('./constraints/PrismaticConstraint'),
    Ray :                           _dereq_('./collision/Ray'),
    RaycastResult :                 _dereq_('./collision/RaycastResult'),
    Rectangle :                     _dereq_('./shapes/Rectangle'),
    RotationalVelocityEquation :    _dereq_('./equations/RotationalVelocityEquation'),
    SAPBroadphase :                 _dereq_('./collision/SAPBroadphase'),
    Shape :                         _dereq_('./shapes/Shape'),
    Solver :                        _dereq_('./solver/Solver'),
    Spring :                        _dereq_('./objects/Spring'),
    LinearSpring :                  _dereq_('./objects/LinearSpring'),
    RotationalSpring :              _dereq_('./objects/RotationalSpring'),
    Utils :                         _dereq_('./utils/Utils'),
    World :                         _dereq_('./world/World'),
    vec2 :                          _dereq_('./math/vec2'),
    version :                       _dereq_('../package.json').version,
};

},{"../package.json":6,"./collision/AABB":7,"./collision/Broadphase":8,"./collision/GridBroadphase":9,"./collision/NaiveBroadphase":10,"./collision/Narrowphase":11,"./collision/Ray":12,"./collision/RaycastResult":13,"./collision/SAPBroadphase":14,"./constraints/Constraint":15,"./constraints/DistanceConstraint":16,"./constraints/GearConstraint":17,"./constraints/LockConstraint":18,"./constraints/PrismaticConstraint":19,"./constraints/RevoluteConstraint":20,"./equations/AngleLockEquation":21,"./equations/ContactEquation":22,"./equations/Equation":23,"./equations/FrictionEquation":24,"./equations/RotationalVelocityEquation":26,"./events/EventEmitter":27,"./material/ContactMaterial":28,"./material/Material":29,"./math/vec2":31,"./objects/Body":32,"./objects/LinearSpring":33,"./objects/RotationalSpring":34,"./objects/Spring":35,"./shapes/Capsule":37,"./shapes/Circle":38,"./shapes/Convex":39,"./shapes/Heightfield":40,"./shapes/Line":41,"./shapes/Particle":42,"./shapes/Plane":43,"./shapes/Rectangle":44,"./shapes/Shape":45,"./solver/GSSolver":46,"./solver/Solver":47,"./utils/Utils":50,"./world/World":54}],37:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2');

module.exports = Capsule;

/**
 * Capsule shape class.
 * @class Capsule
 * @constructor
 * @extends Shape
 * @param {Number} [length=1] The distance between the end points
 * @param {Number} [radius=1] Radius of the capsule
 * @example
 *     var radius = 1;
 *     var length = 2;
 *     var capsuleShape = new Capsule(length, radius);
 *     body.addShape(capsuleShape);
 */
function Capsule(length, radius){

    /**
     * The distance between the end points.
     * @property {Number} length
     */
    this.length = length || 1;

    /**
     * The radius of the capsule.
     * @property {Number} radius
     */
    this.radius = radius || 1;

    Shape.call(this,Shape.CAPSULE);
}
Capsule.prototype = new Shape();
Capsule.prototype.constructor = Capsule;

/**
 * Compute the mass moment of inertia of the Capsule.
 * @method conputeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 * @todo
 */
Capsule.prototype.computeMomentOfInertia = function(mass){
    // Approximate with rectangle
    var r = this.radius,
        w = this.length + r, // 2*r is too much, 0 is too little
        h = r*2;
    return mass * (h*h + w*w) / 12;
};

/**
 * @method updateBoundingRadius
 */
Capsule.prototype.updateBoundingRadius = function(){
    this.boundingRadius = this.radius + this.length/2;
};

/**
 * @method updateArea
 */
Capsule.prototype.updateArea = function(){
    this.area = Math.PI * this.radius * this.radius + this.radius * 2 * this.length;
};

var r = vec2.create();

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Capsule.prototype.computeAABB = function(out, position, angle){
    var radius = this.radius;

    // Compute center position of one of the the circles, world oriented, but with local offset
    vec2.set(r,this.length / 2,0);
    if(angle !== 0){
        vec2.rotate(r,r,angle);
    }

    // Get bounds
    vec2.set(out.upperBound,  Math.max(r[0]+radius, -r[0]+radius),
                              Math.max(r[1]+radius, -r[1]+radius));
    vec2.set(out.lowerBound,  Math.min(r[0]-radius, -r[0]-radius),
                              Math.min(r[1]-radius, -r[1]-radius));

    // Add offset
    vec2.add(out.lowerBound, out.lowerBound, position);
    vec2.add(out.upperBound, out.upperBound, position);
};

},{"../math/vec2":31,"./Shape":45}],38:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,    vec2 = _dereq_('../math/vec2');

module.exports = Circle;

/**
 * Circle shape class.
 * @class Circle
 * @extends Shape
 * @constructor
 * @param {number} [radius=1] The radius of this circle
 *
 * @example
 *     var radius = 1;
 *     var circleShape = new Circle(radius);
 *     body.addShape(circleShape);
 */
function Circle(radius){

    /**
     * The radius of the circle.
     * @property radius
     * @type {number}
     */
    this.radius = radius || 1;

    Shape.call(this,Shape.CIRCLE);
}
Circle.prototype = new Shape();
Circle.prototype.constructor = Circle;

/**
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */
Circle.prototype.computeMomentOfInertia = function(mass){
    var r = this.radius;
    return mass * r * r / 2;
};

/**
 * @method updateBoundingRadius
 * @return {Number}
 */
Circle.prototype.updateBoundingRadius = function(){
    this.boundingRadius = this.radius;
};

/**
 * @method updateArea
 * @return {Number}
 */
Circle.prototype.updateArea = function(){
    this.area = Math.PI * this.radius * this.radius;
};

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Circle.prototype.computeAABB = function(out, position, angle){
    var r = this.radius;
    vec2.set(out.upperBound,  r,  r);
    vec2.set(out.lowerBound, -r, -r);
    if(position){
        vec2.add(out.lowerBound, out.lowerBound, position);
        vec2.add(out.upperBound, out.upperBound, position);
    }
};

},{"../math/vec2":31,"./Shape":45}],39:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2')
,   polyk = _dereq_('../math/polyk')
,   decomp = _dereq_('poly-decomp');

module.exports = Convex;

/**
 * Convex shape class.
 * @class Convex
 * @constructor
 * @extends Shape
 * @param {Array} vertices An array of vertices that span this shape. Vertices are given in counter-clockwise (CCW) direction.
 * @param {Array} [axes] An array of unit length vectors, representing the symmetry axes in the convex.
 * @example
 *     // Create a box
 *     var vertices = [[-1,-1], [1,-1], [1,1], [-1,1]];
 *     var convexShape = new Convex(vertices);
 *     body.addShape(convexShape);
 */
function Convex(vertices, axes){

    /**
     * Vertices defined in the local frame.
     * @property vertices
     * @type {Array}
     */
    this.vertices = [];

    /**
     * Axes defined in the local frame.
     * @property axes
     * @type {Array}
     */
    this.axes = [];

    // Copy the verts
    for(var i=0; i<vertices.length; i++){
        var v = vec2.create();
        vec2.copy(v,vertices[i]);
        this.vertices.push(v);
    }

    if(axes){
        // Copy the axes
        for(var i=0; i < axes.length; i++){
            var axis = vec2.create();
            vec2.copy(axis, axes[i]);
            this.axes.push(axis);
        }
    } else {
        // Construct axes from the vertex data
        for(var i = 0; i < vertices.length; i++){
            // Get the world edge
            var worldPoint0 = vertices[i];
            var worldPoint1 = vertices[(i+1) % vertices.length];

            var normal = vec2.create();
            vec2.sub(normal, worldPoint1, worldPoint0);

            // Get normal - just rotate 90 degrees since vertices are given in CCW
            vec2.rotate90cw(normal, normal);
            vec2.normalize(normal, normal);

            this.axes.push(normal);
        }
    }

    /**
     * The center of mass of the Convex
     * @property centerOfMass
     * @type {Array}
     */
    this.centerOfMass = vec2.fromValues(0,0);

    /**
     * Triangulated version of this convex. The structure is Array of 3-Arrays, and each subarray contains 3 integers, referencing the vertices.
     * @property triangles
     * @type {Array}
     */
    this.triangles = [];

    if(this.vertices.length){
        this.updateTriangles();
        this.updateCenterOfMass();
    }

    /**
     * The bounding radius of the convex
     * @property boundingRadius
     * @type {Number}
     */
    this.boundingRadius = 0;

    Shape.call(this, Shape.CONVEX);

    this.updateBoundingRadius();
    this.updateArea();
    if(this.area < 0){
        throw new Error("Convex vertices must be given in conter-clockwise winding.");
    }
}
Convex.prototype = new Shape();
Convex.prototype.constructor = Convex;

var tmpVec1 = vec2.create();
var tmpVec2 = vec2.create();

/**
 * Project a Convex onto a world-oriented axis
 * @method projectOntoAxis
 * @static
 * @param  {Array} offset
 * @param  {Array} localAxis
 * @param  {Array} result
 */
Convex.prototype.projectOntoLocalAxis = function(localAxis, result){
    var max=null,
        min=null,
        v,
        value,
        localAxis = tmpVec1;

    // Get projected position of all vertices
    for(var i=0; i<this.vertices.length; i++){
        v = this.vertices[i];
        value = vec2.dot(v, localAxis);
        if(max === null || value > max){
            max = value;
        }
        if(min === null || value < min){
            min = value;
        }
    }

    if(min > max){
        var t = min;
        min = max;
        max = t;
    }

    vec2.set(result, min, max);
};

Convex.prototype.projectOntoWorldAxis = function(localAxis, shapeOffset, shapeAngle, result){
    var worldAxis = tmpVec2;

    this.projectOntoLocalAxis(localAxis, result);

    // Project the position of the body onto the axis - need to add this to the result
    if(shapeAngle !== 0){
        vec2.rotate(worldAxis, localAxis, shapeAngle);
    } else {
        worldAxis = localAxis;
    }
    var offset = vec2.dot(shapeOffset, worldAxis);

    vec2.set(result, result[0] + offset, result[1] + offset);
};


/**
 * Update the .triangles property
 * @method updateTriangles
 */
Convex.prototype.updateTriangles = function(){

    this.triangles.length = 0;

    // Rewrite on polyk notation, array of numbers
    var polykVerts = [];
    for(var i=0; i<this.vertices.length; i++){
        var v = this.vertices[i];
        polykVerts.push(v[0],v[1]);
    }

    // Triangulate
    var triangles = polyk.Triangulate(polykVerts);

    // Loop over all triangles, add their inertia contributions to I
    for(var i=0; i<triangles.length; i+=3){
        var id1 = triangles[i],
            id2 = triangles[i+1],
            id3 = triangles[i+2];

        // Add to triangles
        this.triangles.push([id1,id2,id3]);
    }
};

var updateCenterOfMass_centroid = vec2.create(),
    updateCenterOfMass_centroid_times_mass = vec2.create(),
    updateCenterOfMass_a = vec2.create(),
    updateCenterOfMass_b = vec2.create(),
    updateCenterOfMass_c = vec2.create(),
    updateCenterOfMass_ac = vec2.create(),
    updateCenterOfMass_ca = vec2.create(),
    updateCenterOfMass_cb = vec2.create(),
    updateCenterOfMass_n = vec2.create();

/**
 * Update the .centerOfMass property.
 * @method updateCenterOfMass
 */
Convex.prototype.updateCenterOfMass = function(){
    var triangles = this.triangles,
        verts = this.vertices,
        cm = this.centerOfMass,
        centroid = updateCenterOfMass_centroid,
        n = updateCenterOfMass_n,
        a = updateCenterOfMass_a,
        b = updateCenterOfMass_b,
        c = updateCenterOfMass_c,
        ac = updateCenterOfMass_ac,
        ca = updateCenterOfMass_ca,
        cb = updateCenterOfMass_cb,
        centroid_times_mass = updateCenterOfMass_centroid_times_mass;

    vec2.set(cm,0,0);
    var totalArea = 0;

    for(var i=0; i!==triangles.length; i++){
        var t = triangles[i],
            a = verts[t[0]],
            b = verts[t[1]],
            c = verts[t[2]];

        vec2.centroid(centroid,a,b,c);

        // Get mass for the triangle (density=1 in this case)
        // http://math.stackexchange.com/questions/80198/area-of-triangle-via-vectors
        var m = Convex.triangleArea(a,b,c);
        totalArea += m;

        // Add to center of mass
        vec2.scale(centroid_times_mass, centroid, m);
        vec2.add(cm, cm, centroid_times_mass);
    }

    vec2.scale(cm,cm,1/totalArea);
};

/**
 * Compute the mass moment of inertia of the Convex.
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 * @see http://www.gamedev.net/topic/342822-moment-of-inertia-of-a-polygon-2d/
 */
Convex.prototype.computeMomentOfInertia = function(mass){
    var denom = 0.0,
        numer = 0.0,
        N = this.vertices.length;
    for(var j = N-1, i = 0; i < N; j = i, i ++){
        var p0 = this.vertices[j];
        var p1 = this.vertices[i];
        var a = Math.abs(vec2.crossLength(p0,p1));
        var b = vec2.dot(p1,p1) + vec2.dot(p1,p0) + vec2.dot(p0,p0);
        denom += a * b;
        numer += a;
    }
    return (mass / 6.0) * (denom / numer);
};

/**
 * Updates the .boundingRadius property
 * @method updateBoundingRadius
 */
Convex.prototype.updateBoundingRadius = function(){
    var verts = this.vertices,
        r2 = 0;

    for(var i=0; i!==verts.length; i++){
        var l2 = vec2.squaredLength(verts[i]);
        if(l2 > r2){
            r2 = l2;
        }
    }

    this.boundingRadius = Math.sqrt(r2);
};

/**
 * Get the area of the triangle spanned by the three points a, b, c. The area is positive if the points are given in counter-clockwise order, otherwise negative.
 * @static
 * @method triangleArea
 * @param {Array} a
 * @param {Array} b
 * @param {Array} c
 * @return {Number}
 */
Convex.triangleArea = function(a,b,c){
    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1]))) * 0.5;
};

/**
 * Update the .area
 * @method updateArea
 */
Convex.prototype.updateArea = function(){
    this.updateTriangles();
    this.area = 0;

    var triangles = this.triangles,
        verts = this.vertices;
    for(var i=0; i!==triangles.length; i++){
        var t = triangles[i],
            a = verts[t[0]],
            b = verts[t[1]],
            c = verts[t[2]];

        // Get mass for the triangle (density=1 in this case)
        var m = Convex.triangleArea(a,b,c);
        this.area += m;
    }
};

/**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */
Convex.prototype.computeAABB = function(out, position, angle){
    out.setFromPoints(this.vertices, position, angle, 0);
};

},{"../math/polyk":30,"../math/vec2":31,"./Shape":45,"poly-decomp":5}],40:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,    vec2 = _dereq_('../math/vec2')
,    Utils = _dereq_('../utils/Utils');

module.exports = Heightfield;

/**
 * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a distance "elementWidth".
 * @class Heightfield
 * @extends Shape
 * @constructor
 * @param {Array} data An array of Y values that will be used to construct the terrain.
 * @param {object} options
 * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
 * @param {Number} [options.maxValue] Maximum value.
 * @param {Number} [options.elementWidth=0.1] World spacing between the data points in X direction.
 * @todo Should be possible to use along all axes, not just y
 *
 * @example
 *     // Generate some height data (y-values).
 *     var data = [];
 *     for(var i = 0; i < 1000; i++){
 *         var y = 0.5 * Math.cos(0.2 * i);
 *         data.push(y);
 *     }
 *
 *     // Create the heightfield shape
 *     var heightfieldShape = new Heightfield(data, {
 *         elementWidth: 1 // Distance between the data points in X direction
 *     });
 *     var heightfieldBody = new Body();
 *     heightfieldBody.addShape(heightfieldShape);
 *     world.addBody(heightfieldBody);
 */
function Heightfield(data, options){
    options = Utils.defaults(options, {
        maxValue : null,
        minValue : null,
        elementWidth : 0.1
    });

    if(options.minValue === null || options.maxValue === null){
        options.maxValue = data[0];
        options.minValue = data[0];
        for(var i=0; i !== data.length; i++){
            var v = data[i];
            if(v > options.maxValue){
                options.maxValue = v;
            }
            if(v < options.minValue){
                options.minValue = v;
            }
        }
    }

    /**
     * An array of numbers, or height values, that are spread out along the x axis.
     * @property {array} data
     */
    this.data = data;

    /**
     * Max value of the data
     * @property {number} maxValue
     */
    this.maxValue = options.maxValue;

    /**
     * Max value of the data
     * @property {number} minValue
     */
    this.minValue = options.minValue;

    /**
     * The width of each element
     * @property {number} elementWidth
     */
    this.elementWidth = options.elementWidth;

    Shape.call(this,Shape.HEIGHTFIELD);
}
Heightfield.prototype = new Shape();
Heightfield.prototype.constructor = Heightfield;

/**
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */
Heightfield.prototype.computeMomentOfInertia = function(mass){
    return Number.MAX_VALUE;
};

Heightfield.prototype.updateBoundingRadius = function(){
    this.boundingRadius = Number.MAX_VALUE;
};

Heightfield.prototype.updateArea = function(){
    var data = this.data,
        area = 0;
    for(var i=0; i<data.length-1; i++){
        area += (data[i]+data[i+1]) / 2 * this.elementWidth;
    }
    this.area = area;
};

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Heightfield.prototype.computeAABB = function(out, position, angle){
    // Use the max data rectangle
    out.upperBound[0] = this.elementWidth * this.data.length + position[0];
    out.upperBound[1] = this.maxValue + position[1];
    out.lowerBound[0] = position[0];
    out.lowerBound[1] = -Number.MAX_VALUE; // Infinity
};

},{"../math/vec2":31,"../utils/Utils":50,"./Shape":45}],41:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2');

module.exports = Line;

/**
 * Line shape class. The line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].
 * @class Line
 * @param {Number} [length=1] The total length of the line
 * @extends Shape
 * @constructor
 */
function Line(length){

    /**
     * Length of this line
     * @property length
     * @type {Number}
     */
    this.length = length || 1;

    Shape.call(this,Shape.LINE);
}
Line.prototype = new Shape();
Line.prototype.constructor = Line;

Line.prototype.computeMomentOfInertia = function(mass){
    return mass * Math.pow(this.length,2) / 12;
};

Line.prototype.updateBoundingRadius = function(){
    this.boundingRadius = this.length/2;
};

var points = [vec2.create(),vec2.create()];

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Line.prototype.computeAABB = function(out, position, angle){
    var l2 = this.length / 2;
    vec2.set(points[0], -l2,  0);
    vec2.set(points[1],  l2,  0);
    out.setFromPoints(points,position,angle,0);
};


},{"../math/vec2":31,"./Shape":45}],42:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2');

module.exports = Particle;

/**
 * Particle shape class.
 * @class Particle
 * @constructor
 * @extends Shape
 */
function Particle(){
    Shape.call(this,Shape.PARTICLE);
}
Particle.prototype = new Shape();
Particle.prototype.constructor = Particle;

Particle.prototype.computeMomentOfInertia = function(mass){
    return 0; // Can't rotate a particle
};

Particle.prototype.updateBoundingRadius = function(){
    this.boundingRadius = 0;
};

/**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */
Particle.prototype.computeAABB = function(out, position, angle){
    vec2.copy(out.lowerBound, position);
    vec2.copy(out.upperBound, position);
};

},{"../math/vec2":31,"./Shape":45}],43:[function(_dereq_,module,exports){
var Shape =  _dereq_('./Shape')
,    vec2 =  _dereq_('../math/vec2')
,    Utils = _dereq_('../utils/Utils');

module.exports = Plane;

/**
 * Plane shape class. The plane is facing in the Y direction.
 * @class Plane
 * @extends Shape
 * @constructor
 */
function Plane(){
    Shape.call(this,Shape.PLANE);
}
Plane.prototype = new Shape();
Plane.prototype.constructor = Plane;

/**
 * Compute moment of inertia
 * @method computeMomentOfInertia
 */
Plane.prototype.computeMomentOfInertia = function(mass){
    return 0; // Plane is infinite. The inertia should therefore be infinty but by convention we set 0 here
};

/**
 * Update the bounding radius
 * @method updateBoundingRadius
 */
Plane.prototype.updateBoundingRadius = function(){
    this.boundingRadius = Number.MAX_VALUE;
};

/**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */
Plane.prototype.computeAABB = function(out, position, angle){
    var a = 0,
        set = vec2.set;
    if(typeof(angle) === "number"){
        a = angle % (2*Math.PI);
    }

    if(a === 0){
        // y goes from -inf to 0
        set(out.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);
        set(out.upperBound,  Number.MAX_VALUE,  0);
    } else if(a === Math.PI / 2){
        // x goes from 0 to inf
        set(out.lowerBound, 0, -Number.MAX_VALUE);
        set(out.upperBound,      Number.MAX_VALUE,  Number.MAX_VALUE);
    } else if(a === Math.PI){
        // y goes from 0 to inf
        set(out.lowerBound, -Number.MAX_VALUE, 0);
        set(out.upperBound,  Number.MAX_VALUE, Number.MAX_VALUE);
    } else if(a === 3*Math.PI/2){
        // x goes from -inf to 0
        set(out.lowerBound, -Number.MAX_VALUE,     -Number.MAX_VALUE);
        set(out.upperBound,  0,  Number.MAX_VALUE);
    } else {
        // Set max bounds
        set(out.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);
        set(out.upperBound,  Number.MAX_VALUE,  Number.MAX_VALUE);
    }

    vec2.add(out.lowerBound, out.lowerBound, position);
    vec2.add(out.upperBound, out.upperBound, position);
};

Plane.prototype.updateArea = function(){
    this.area = Number.MAX_VALUE;
};


},{"../math/vec2":31,"../utils/Utils":50,"./Shape":45}],44:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Shape = _dereq_('./Shape')
,   Convex = _dereq_('./Convex');

module.exports = Rectangle;

/**
 * Rectangle shape class.
 * @class Rectangle
 * @constructor
 * @param {Number} [width=1] Width
 * @param {Number} [height=1] Height
 * @extends Convex
 */
function Rectangle(width, height){

    /**
     * Total width of the rectangle
     * @property width
     * @type {Number}
     */
    this.width = width || 1;

    /**
     * Total height of the rectangle
     * @property height
     * @type {Number}
     */
    this.height = height || 1;

    var verts = [   vec2.fromValues(-width/2, -height/2),
                    vec2.fromValues( width/2, -height/2),
                    vec2.fromValues( width/2,  height/2),
                    vec2.fromValues(-width/2,  height/2)];
    var axes = [vec2.fromValues(1, 0), vec2.fromValues(0, 1)];

    Convex.call(this, verts, axes);

    this.type = Shape.RECTANGLE;
}
Rectangle.prototype = new Convex([]);
Rectangle.prototype.constructor = Rectangle;

/**
 * Compute moment of inertia
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */
Rectangle.prototype.computeMomentOfInertia = function(mass){
    var w = this.width,
        h = this.height;
    return mass * (h*h + w*w) / 12;
};

/**
 * Update the bounding radius
 * @method updateBoundingRadius
 */
Rectangle.prototype.updateBoundingRadius = function(){
    var w = this.width,
        h = this.height;
    this.boundingRadius = Math.sqrt(w*w + h*h) / 2;
};

var corner1 = vec2.create(),
    corner2 = vec2.create(),
    corner3 = vec2.create(),
    corner4 = vec2.create();

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Rectangle.prototype.computeAABB = function(out, position, angle){
    out.setFromPoints(this.vertices,position,angle,0);
};

Rectangle.prototype.updateArea = function(){
    this.area = this.width * this.height;
};


},{"../math/vec2":31,"./Convex":39,"./Shape":45}],45:[function(_dereq_,module,exports){
module.exports = Shape;

/**
 * Base class for shapes.
 * @class Shape
 * @constructor
 * @param {Number} type
 */
function Shape(type){

    /**
     * The type of the shape. One of:
     *
     * * {{#crossLink "Shape/CIRCLE:property"}}Shape.CIRCLE{{/crossLink}}
     * * {{#crossLink "Shape/PARTICLE:property"}}Shape.PARTICLE{{/crossLink}}
     * * {{#crossLink "Shape/PLANE:property"}}Shape.PLANE{{/crossLink}}
     * * {{#crossLink "Shape/CONVEX:property"}}Shape.CONVEX{{/crossLink}}
     * * {{#crossLink "Shape/LINE:property"}}Shape.LINE{{/crossLink}}
     * * {{#crossLink "Shape/RECTANGLE:property"}}Shape.RECTANGLE{{/crossLink}}
     * * {{#crossLink "Shape/CAPSULE:property"}}Shape.CAPSULE{{/crossLink}}
     * * {{#crossLink "Shape/HEIGHTFIELD:property"}}Shape.HEIGHTFIELD{{/crossLink}}
     *
     * @property {number} type
     */
    this.type = type;

    /**
     * Shape object identifier.
     * @type {Number}
     * @property id
     */
    this.id = Shape.idCounter++;

    /**
     * Bounding circle radius of this shape
     * @property boundingRadius
     * @type {Number}
     */
    this.boundingRadius = 0;

    /**
     * Collision group that this shape belongs to (bit mask). See <a href="http://www.aurelienribon.com/blog/2011/07/box2d-tutorial-collision-filtering/">this tutorial</a>.
     * @property collisionGroup
     * @type {Number}
     * @example
     *     // Setup bits for each available group
     *     var PLAYER = Math.pow(2,0),
     *         ENEMY =  Math.pow(2,1),
     *         GROUND = Math.pow(2,2)
     *
     *     // Put shapes into their groups
     *     player1Shape.collisionGroup = PLAYER;
     *     player2Shape.collisionGroup = PLAYER;
     *     enemyShape  .collisionGroup = ENEMY;
     *     groundShape .collisionGroup = GROUND;
     *
     *     // Assign groups that each shape collide with.
     *     // Note that the players can collide with ground and enemies, but not with other players.
     *     player1Shape.collisionMask = ENEMY | GROUND;
     *     player2Shape.collisionMask = ENEMY | GROUND;
     *     enemyShape  .collisionMask = PLAYER | GROUND;
     *     groundShape .collisionMask = PLAYER | ENEMY;
     *
     * @example
     *     // How collision check is done
     *     if(shapeA.collisionGroup & shapeB.collisionMask)!=0 && (shapeB.collisionGroup & shapeA.collisionMask)!=0){
     *         // The shapes will collide
     *     }
     */
    this.collisionGroup = 1;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this shape will move through other body shapes, but it will still trigger contact events, etc.
     * @property {Boolean} collisionResponse
     */
    this.collisionResponse = true;

    /**
     * Collision mask of this shape. See .collisionGroup.
     * @property collisionMask
     * @type {Number}
     */
    this.collisionMask =  1;
    if(type){
        this.updateBoundingRadius();
    }

    /**
     * Material to use in collisions for this Shape. If this is set to null, the world will use default material properties instead.
     * @property material
     * @type {Material}
     */
    this.material = null;

    /**
     * Area of this shape.
     * @property area
     * @type {Number}
     */
    this.area = 0;

    /**
     * Set to true if you want this shape to be a sensor. A sensor does not generate contacts, but it still reports contact events. This is good if you want to know if a shape is overlapping another shape, without them generating contacts.
     * @property {Boolean} sensor
     */
    this.sensor = false;

    this.updateArea();
}

Shape.idCounter = 0;

/**
 * @static
 * @property {Number} CIRCLE
 */
Shape.CIRCLE =      1;

/**
 * @static
 * @property {Number} PARTICLE
 */
Shape.PARTICLE =    2;

/**
 * @static
 * @property {Number} PLANE
 */
Shape.PLANE =       4;

/**
 * @static
 * @property {Number} CONVEX
 */
Shape.CONVEX =      8;

/**
 * @static
 * @property {Number} LINE
 */
Shape.LINE =        16;

/**
 * @static
 * @property {Number} RECTANGLE
 */
Shape.RECTANGLE =   32;

/**
 * @static
 * @property {Number} CAPSULE
 */
Shape.CAPSULE =     64;

/**
 * @static
 * @property {Number} HEIGHTFIELD
 */
Shape.HEIGHTFIELD = 128;

/**
 * Should return the moment of inertia around the Z axis of the body given the total mass. See <a href="http://en.wikipedia.org/wiki/List_of_moments_of_inertia">Wikipedia's list of moments of inertia</a>.
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number} If the inertia is infinity or if the object simply isn't possible to rotate, return 0.
 */
Shape.prototype.computeMomentOfInertia = function(mass){
    throw new Error("Shape.computeMomentOfInertia is not implemented in this Shape...");
};

/**
 * Returns the bounding circle radius of this shape.
 * @method updateBoundingRadius
 * @return {Number}
 */
Shape.prototype.updateBoundingRadius = function(){
    throw new Error("Shape.updateBoundingRadius is not implemented in this Shape...");
};

/**
 * Update the .area property of the shape.
 * @method updateArea
 */
Shape.prototype.updateArea = function(){
    // To be implemented in all subclasses
};

/**
 * Compute the world axis-aligned bounding box (AABB) of this shape.
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Shape.prototype.computeAABB = function(out, position, angle){
    // To be implemented in each subclass
};

},{}],46:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Solver = _dereq_('./Solver')
,   Utils = _dereq_('../utils/Utils')
,   FrictionEquation = _dereq_('../equations/FrictionEquation');

module.exports = GSSolver;

/**
 * Iterative Gauss-Seidel constraint equation solver.
 *
 * @class GSSolver
 * @constructor
 * @extends Solver
 * @param {Object} [options]
 * @param {Number} [options.iterations=10]
 * @param {Number} [options.tolerance=0]
 */
function GSSolver(options){
    Solver.call(this,options,Solver.GS);
    options = options || {};

    /**
     * The number of iterations to do when solving. More gives better results, but is more expensive.
     * @property iterations
     * @type {Number}
     */
    this.iterations = options.iterations || 10;

    /**
     * The error tolerance, per constraint. If the total error is below this limit, the solver will stop iterating. Set to zero for as good solution as possible, but to something larger than zero to make computations faster.
     * @property tolerance
     * @type {Number}
     */
    this.tolerance = options.tolerance || 1e-10;

    this.arrayStep = 30;
    this.lambda = new Utils.ARRAY_TYPE(this.arrayStep);
    this.Bs =     new Utils.ARRAY_TYPE(this.arrayStep);
    this.invCs =  new Utils.ARRAY_TYPE(this.arrayStep);

    /**
     * Set to true to set all right hand side terms to zero when solving. Can be handy for a few applications.
     * @property useZeroRHS
     * @type {Boolean}
     */
    this.useZeroRHS = false;

    /**
     * Number of solver iterations that are done to approximate normal forces. When these iterations are done, friction force will be computed from the contact normal forces. These friction forces will override any other friction forces set from the World for example.
     * The solver will use less iterations if the solution is below the .tolerance.
     * @property frictionIterations
     * @type {Number}
     */
    this.frictionIterations = 0;

    /**
     * The number of iterations that were made during the last solve. If .tolerance is zero, this value will always be equal to .iterations, but if .tolerance is larger than zero, and the solver can quit early, then this number will be somewhere between 1 and .iterations.
     * @property {Number} usedIterations
     */
    this.usedIterations = 0;
}
GSSolver.prototype = new Solver();
GSSolver.prototype.constructor = GSSolver;

function setArrayZero(array){
    var l = array.length;
    while(l--){
        array[l] = +0.0;
    }
}

/**
 * Solve the system of equations
 * @method solve
 * @param  {Number}  h       Time step
 * @param  {World}   world    World to solve
 */
GSSolver.prototype.solve = function(h, world){

    this.sortEquations();

    var iter = 0,
        maxIter = this.iterations,
        maxFrictionIter = this.frictionIterations,
        equations = this.equations,
        Neq = equations.length,
        tolSquared = Math.pow(this.tolerance*Neq, 2),
        bodies = world.bodies,
        Nbodies = world.bodies.length,
        add = vec2.add,
        set = vec2.set,
        useZeroRHS = this.useZeroRHS,
        lambda = this.lambda;

    this.usedIterations = 0;

    if(Neq){
        for(var i=0; i!==Nbodies; i++){
            var b = bodies[i];

            // Update solve mass
            b.updateSolveMassProperties();
        }
    }

    // Things that does not change during iteration can be computed once
    if(lambda.length < Neq){
        lambda = this.lambda =  new Utils.ARRAY_TYPE(Neq + this.arrayStep);
        this.Bs =               new Utils.ARRAY_TYPE(Neq + this.arrayStep);
        this.invCs =            new Utils.ARRAY_TYPE(Neq + this.arrayStep);
    }
    setArrayZero(lambda);
    var invCs = this.invCs,
        Bs = this.Bs,
        lambda = this.lambda;

    for(var i=0; i!==equations.length; i++){
        var c = equations[i];
        if(c.timeStep !== h || c.needsUpdate){
            c.timeStep = h;
            c.update();
        }
        Bs[i] =     c.computeB(c.a,c.b,h);
        invCs[i] =  c.computeInvC(c.epsilon);
    }

    var q, B, c, deltalambdaTot,i,j;

    if(Neq !== 0){

        for(i=0; i!==Nbodies; i++){
            var b = bodies[i];

            // Reset vlambda
            b.resetConstraintVelocity();
        }

        if(maxFrictionIter){
            // Iterate over contact equations to get normal forces
            for(iter=0; iter!==maxFrictionIter; iter++){

                // Accumulate the total error for each iteration.
                deltalambdaTot = 0.0;

                for(j=0; j!==Neq; j++){
                    c = equations[j];

                    var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);
                    deltalambdaTot += Math.abs(deltalambda);
                }

                this.usedIterations++;

                // If the total error is small enough - stop iterate
                if(deltalambdaTot*deltalambdaTot <= tolSquared){
                    break;
                }
            }

            GSSolver.updateMultipliers(equations, lambda, 1/h);

            // Set computed friction force
            for(j=0; j!==Neq; j++){
                var eq = equations[j];
                if(eq instanceof FrictionEquation){
                    var f = 0.0;
                    for(var k=0; k!==eq.contactEquations.length; k++){
                        f += eq.contactEquations[k].multiplier;
                    }
                    f *= eq.frictionCoefficient / eq.contactEquations.length;
                    eq.maxForce =  f;
                    eq.minForce = -f;
                }
            }
        }

        // Iterate over all equations
        for(iter=0; iter!==maxIter; iter++){

            // Accumulate the total error for each iteration.
            deltalambdaTot = 0.0;

            for(j=0; j!==Neq; j++){
                c = equations[j];

                var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);
                deltalambdaTot += Math.abs(deltalambda);
            }

            this.usedIterations++;

            // If the total error is small enough - stop iterate
            if(deltalambdaTot*deltalambdaTot <= tolSquared){
                break;
            }
        }

        // Add result to velocity
        for(i=0; i!==Nbodies; i++){
            bodies[i].addConstraintVelocity();
        }

        GSSolver.updateMultipliers(equations, lambda, 1/h);
    }
};

// Sets the .multiplier property of each equation
GSSolver.updateMultipliers = function(equations, lambda, invDt){
    // Set the .multiplier property of each equation
    var l = equations.length;
    while(l--){
        equations[l].multiplier = lambda[l] * invDt;
    }
};

GSSolver.iterateEquation = function(j,eq,eps,Bs,invCs,lambda,useZeroRHS,dt,iter){
    // Compute iteration
    var B = Bs[j],
        invC = invCs[j],
        lambdaj = lambda[j],
        GWlambda = eq.computeGWlambda();

    var maxForce = eq.maxForce,
        minForce = eq.minForce;

    if(useZeroRHS){
        B = 0;
    }

    var deltalambda = invC * ( B - GWlambda - eps * lambdaj );

    // Clamp if we are not within the min/max interval
    var lambdaj_plus_deltalambda = lambdaj + deltalambda;
    if(lambdaj_plus_deltalambda < minForce*dt){
        deltalambda = minForce*dt - lambdaj;
    } else if(lambdaj_plus_deltalambda > maxForce*dt){
        deltalambda = maxForce*dt - lambdaj;
    }
    lambda[j] += deltalambda;
    eq.addToWlambda(deltalambda);

    return deltalambda;
};

},{"../equations/FrictionEquation":24,"../math/vec2":31,"../utils/Utils":50,"./Solver":47}],47:[function(_dereq_,module,exports){
var Utils = _dereq_('../utils/Utils')
,   EventEmitter = _dereq_('../events/EventEmitter');

module.exports = Solver;

/**
 * Base class for constraint solvers.
 * @class Solver
 * @constructor
 * @extends EventEmitter
 */
function Solver(options,type){
    options = options || {};

    EventEmitter.call(this);

    this.type = type;

    /**
     * Current equations in the solver.
     *
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * Function that is used to sort all equations before each solve.
     * @property equationSortFunction
     * @type {function|boolean}
     */
    this.equationSortFunction = options.equationSortFunction || false;
}
Solver.prototype = new EventEmitter();
Solver.prototype.constructor = Solver;

/**
 * Method to be implemented in each subclass
 * @method solve
 * @param  {Number} dt
 * @param  {World} world
 */
Solver.prototype.solve = function(dt,world){
    throw new Error("Solver.solve should be implemented by subclasses!");
};

var mockWorld = {bodies:[]};

/**
 * Solves all constraints in an island.
 * @method solveIsland
 * @param  {Number} dt
 * @param  {Island} island
 */
Solver.prototype.solveIsland = function(dt,island){

    this.removeAllEquations();

    if(island.equations.length){
        // Add equations to solver
        this.addEquations(island.equations);
        mockWorld.bodies.length = 0;
        island.getBodies(mockWorld.bodies);

        // Solve
        if(mockWorld.bodies.length){
            this.solve(dt,mockWorld);
        }
    }
};

/**
 * Sort all equations using the .equationSortFunction. Should be called by subclasses before solving.
 * @method sortEquations
 */
Solver.prototype.sortEquations = function(){
    if(this.equationSortFunction){
        this.equations.sort(this.equationSortFunction);
    }
};

/**
 * Add an equation to be solved.
 *
 * @method addEquation
 * @param {Equation} eq
 */
Solver.prototype.addEquation = function(eq){
    if(eq.enabled){
        this.equations.push(eq);
    }
};

/**
 * Add equations. Same as .addEquation, but this time the argument is an array of Equations
 *
 * @method addEquations
 * @param {Array} eqs
 */
Solver.prototype.addEquations = function(eqs){
    //Utils.appendArray(this.equations,eqs);
    for(var i=0, N=eqs.length; i!==N; i++){
        var eq = eqs[i];
        if(eq.enabled){
            this.equations.push(eq);
        }
    }
};

/**
 * Remove an equation.
 *
 * @method removeEquation
 * @param {Equation} eq
 */
Solver.prototype.removeEquation = function(eq){
    var i = this.equations.indexOf(eq);
    if(i !== -1){
        this.equations.splice(i,1);
    }
};

/**
 * Remove all currently added equations.
 *
 * @method removeAllEquations
 */
Solver.prototype.removeAllEquations = function(){
    this.equations.length=0;
};

Solver.GS = 1;
Solver.ISLAND = 2;

},{"../events/EventEmitter":27,"../utils/Utils":50}],48:[function(_dereq_,module,exports){
var TupleDictionary = _dereq_('./TupleDictionary');
var Utils = _dereq_('./Utils');

module.exports = OverlapKeeper;

/**
 * Keeps track of overlaps in the current state and the last step state.
 * @class OverlapKeeper
 * @constructor
 */
function OverlapKeeper() {
    this.overlappingShapesLastState = new TupleDictionary();
    this.overlappingShapesCurrentState = new TupleDictionary();
    this.recordPool = [];
    this.tmpDict = new TupleDictionary();
    this.tmpArray1 = [];
}

/**
 * Ticks one step forward in time. This will move the current overlap state to the "old" overlap state, and create a new one as current.
 * @method tick
 */
OverlapKeeper.prototype.tick = function() {
    var last = this.overlappingShapesLastState;
    var current = this.overlappingShapesCurrentState;

    // Save old objects into pool
    var l = last.keys.length;
    while(l--){
        var key = last.keys[l];
        var lastObject = last.getByKey(key);
        var currentObject = current.getByKey(key);
        if(lastObject && !currentObject){
            // The record is only used in the "last" dict, and will be removed. We might as well pool it.
            this.recordPool.push(lastObject);
        }
    }

    // Clear last object
    last.reset();

    // Transfer from new object to old
    last.copy(current);

    // Clear current object
    current.reset();
};

/**
 * @method setOverlapping
 * @param {Body} bodyA
 * @param {Body} shapeA
 * @param {Body} bodyB
 * @param {Body} shapeB
 */
OverlapKeeper.prototype.setOverlapping = function(bodyA, shapeA, bodyB, shapeB) {
    var last = this.overlappingShapesLastState;
    var current = this.overlappingShapesCurrentState;

    // Store current contact state
    if(!current.get(shapeA.id, shapeB.id)){

        var data;
        if(this.recordPool.length){
            data = this.recordPool.pop();
            data.set(bodyA, shapeA, bodyB, shapeB);
        } else {
            data = new OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB);
        }

        current.set(shapeA.id, shapeB.id, data);
    }
};

OverlapKeeper.prototype.getNewOverlaps = function(result){
    return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, result);
};

OverlapKeeper.prototype.getEndOverlaps = function(result){
    return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, result);
};

/**
 * Checks if two bodies are currently overlapping.
 * @method bodiesAreOverlapping
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {boolean}
 */
OverlapKeeper.prototype.bodiesAreOverlapping = function(bodyA, bodyB){
    var current = this.overlappingShapesCurrentState;
    var l = current.keys.length;
    while(l--){
        var key = current.keys[l];
        var data = current.data[key];
        if((data.bodyA === bodyA && data.bodyB === bodyB) || data.bodyA === bodyB && data.bodyB === bodyA){
            return true;
        }
    }
    return false;
};

OverlapKeeper.prototype.getDiff = function(dictA, dictB, result){
    var result = result || [];
    var last = dictA;
    var current = dictB;

    result.length = 0;

    var l = current.keys.length;
    while(l--){
        var key = current.keys[l];
        var data = current.data[key];

        if(!data){
            throw new Error('Key '+key+' had no data!');
        }

        var lastData = last.data[key];
        if(!lastData){
            // Not overlapping in last state, but in current.
            result.push(data);
        }
    }

    return result;
};

OverlapKeeper.prototype.isNewOverlap = function(shapeA, shapeB){
    var idA = shapeA.id|0,
        idB = shapeB.id|0;
    var last = this.overlappingShapesLastState;
    var current = this.overlappingShapesCurrentState;
    // Not in last but in new
    return !!!last.get(idA, idB) && !!current.get(idA, idB);
};

OverlapKeeper.prototype.getNewBodyOverlaps = function(result){
    this.tmpArray1.length = 0;
    var overlaps = this.getNewOverlaps(this.tmpArray1);
    return this.getBodyDiff(overlaps, result);
};

OverlapKeeper.prototype.getEndBodyOverlaps = function(result){
    this.tmpArray1.length = 0;
    var overlaps = this.getEndOverlaps(this.tmpArray1);
    return this.getBodyDiff(overlaps, result);
};

OverlapKeeper.prototype.getBodyDiff = function(overlaps, result){
    result = result || [];
    var accumulator = this.tmpDict;

    var l = overlaps.length;

    while(l--){
        var data = overlaps[l];

        // Since we use body id's for the accumulator, these will be a subset of the original one
        accumulator.set(data.bodyA.id|0, data.bodyB.id|0, data);
    }

    l = accumulator.keys.length;
    while(l--){
        var data = accumulator.getByKey(accumulator.keys[l]);
        if(data){
            result.push(data.bodyA, data.bodyB);
        }
    }

    accumulator.reset();

    return result;
};

/**
 * Overlap data container for the OverlapKeeper
 * @class OverlapKeeperRecord
 * @constructor
 * @param {Body} bodyA
 * @param {Shape} shapeA
 * @param {Body} bodyB
 * @param {Shape} shapeB
 */
function OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB){
    /**
     * @property {Shape} shapeA
     */
    this.shapeA = shapeA;
    /**
     * @property {Shape} shapeB
     */
    this.shapeB = shapeB;
    /**
     * @property {Body} bodyA
     */
    this.bodyA = bodyA;
    /**
     * @property {Body} bodyB
     */
    this.bodyB = bodyB;
}

/**
 * Set the data for the record
 * @method set
 * @param {Body} bodyA
 * @param {Shape} shapeA
 * @param {Body} bodyB
 * @param {Shape} shapeB
 */
OverlapKeeperRecord.prototype.set = function(bodyA, shapeA, bodyB, shapeB){
    OverlapKeeperRecord.call(this, bodyA, shapeA, bodyB, shapeB);
};

},{"./TupleDictionary":49,"./Utils":50}],49:[function(_dereq_,module,exports){
var Utils = _dereq_('./Utils');

module.exports = TupleDictionary;

/**
 * @class TupleDictionary
 * @constructor
 */
function TupleDictionary() {

    /**
     * The data storage
     * @property data
     * @type {Object}
     */
    this.data = {};

    /**
     * Keys that are currently used.
     * @property {Array} keys
     */
    this.keys = [];
}

/**
 * Generate a key given two integers
 * @method getKey
 * @param  {number} i
 * @param  {number} j
 * @return {string}
 */
TupleDictionary.prototype.getKey = function(id1, id2) {
    id1 = id1|0;
    id2 = id2|0;

    if ( (id1|0) === (id2|0) ){
        return -1;
    }

    // valid for values < 2^16
    return ((id1|0) > (id2|0) ?
        (id1 << 16) | (id2 & 0xFFFF) :
        (id2 << 16) | (id1 & 0xFFFF))|0
        ;
};

/**
 * @method getByKey
 * @param  {Number} key
 * @return {Object}
 */
TupleDictionary.prototype.getByKey = function(key) {
    key = key|0;
    return this.data[key];
};

/**
 * @method get
 * @param  {Number} i
 * @param  {Number} j
 * @return {Number}
 */
TupleDictionary.prototype.get = function(i, j) {
    return this.data[this.getKey(i, j)];
};

/**
 * Set a value.
 * @method set
 * @param  {Number} i
 * @param  {Number} j
 * @param {Number} value
 */
TupleDictionary.prototype.set = function(i, j, value) {
    if(!value){
        throw new Error("No data!");
    }

    var key = this.getKey(i, j);

    // Check if key already exists
    if(!this.data[key]){
        this.keys.push(key);
    }

    this.data[key] = value;

    return key;
};

/**
 * Remove all data.
 * @method reset
 */
TupleDictionary.prototype.reset = function() {
    var data = this.data,
        keys = this.keys;

    var l = keys.length;
    while(l--) {
        delete data[keys[l]];
    }

    keys.length = 0;
};

/**
 * Copy another TupleDictionary. Note that all data in this dictionary will be removed.
 * @method copy
 * @param {TupleDictionary} dict The TupleDictionary to copy into this one.
 */
TupleDictionary.prototype.copy = function(dict) {
    this.reset();
    Utils.appendArray(this.keys, dict.keys);
    var l = dict.keys.length;
    while(l--){
        var key = dict.keys[l];
        this.data[key] = dict.data[key];
    }
};

},{"./Utils":50}],50:[function(_dereq_,module,exports){
/* global P2_ARRAY_TYPE */

module.exports = Utils;

/**
 * Misc utility functions
 * @class Utils
 * @constructor
 */
function Utils(){}

/**
 * Append the values in array b to the array a. See <a href="http://stackoverflow.com/questions/1374126/how-to-append-an-array-to-an-existing-javascript-array/1374131#1374131">this</a> for an explanation.
 * @method appendArray
 * @static
 * @param  {Array} a
 * @param  {Array} b
 */
Utils.appendArray = function(a,b){
    if (b.length < 150000) {
        a.push.apply(a, b);
    } else {
        for (var i = 0, len = b.length; i !== len; ++i) {
            a.push(b[i]);
        }
    }
};

/**
 * Garbage free Array.splice(). Does not allocate a new array.
 * @method splice
 * @static
 * @param  {Array} array
 * @param  {Number} index
 * @param  {Number} howmany
 */
Utils.splice = function(array,index,howmany){
    howmany = howmany || 1;
    for (var i=index, len=array.length-howmany; i < len; i++){
        array[i] = array[i + howmany];
    }
    array.length = len;
};

/**
 * The array type to use for internal numeric computations throughout the library. Float32Array is used if it is available, but falls back on Array. If you want to set array type manually, inject it via the global variable P2_ARRAY_TYPE. See example below.
 * @static
 * @property {function} ARRAY_TYPE
 * @example
 *     <script>
 *         <!-- Inject your preferred array type before loading p2.js -->
 *         P2_ARRAY_TYPE = Array;
 *     </script>
 *     <script src="p2.js"></script>
 */
if(typeof P2_ARRAY_TYPE !== 'undefined') {
    Utils.ARRAY_TYPE = P2_ARRAY_TYPE;
} else if (typeof Float32Array !== 'undefined'){
    Utils.ARRAY_TYPE = Float32Array;
} else {
    Utils.ARRAY_TYPE = Array;
}

/**
 * Extend an object with the properties of another
 * @static
 * @method extend
 * @param  {object} a
 * @param  {object} b
 */
Utils.extend = function(a,b){
    for(var key in b){
        a[key] = b[key];
    }
};

/**
 * Extend an options object with default values.
 * @static
 * @method defaults
 * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.
 * @param  {object} defaults An object containing default values.
 * @return {object} The modified options object.
 */
Utils.defaults = function(options, defaults){
    options = options || {};
    for(var key in defaults){
        if(!(key in options)){
            options[key] = defaults[key];
        }
    }
    return options;
};

},{}],51:[function(_dereq_,module,exports){
var Body = _dereq_('../objects/Body');

module.exports = Island;

/**
 * An island of bodies connected with equations.
 * @class Island
 * @constructor
 */
function Island(){

    /**
     * Current equations in this island.
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * Current bodies in this island.
     * @property bodies
     * @type {Array}
     */
    this.bodies = [];
}

/**
 * Clean this island from bodies and equations.
 * @method reset
 */
Island.prototype.reset = function(){
    this.equations.length = this.bodies.length = 0;
};

var bodyIds = [];

/**
 * Get all unique bodies in this island.
 * @method getBodies
 * @return {Array} An array of Body
 */
Island.prototype.getBodies = function(result){
    var bodies = result || [],
        eqs = this.equations;
    bodyIds.length = 0;
    for(var i=0; i!==eqs.length; i++){
        var eq = eqs[i];
        if(bodyIds.indexOf(eq.bodyA.id)===-1){
            bodies.push(eq.bodyA);
            bodyIds.push(eq.bodyA.id);
        }
        if(bodyIds.indexOf(eq.bodyB.id)===-1){
            bodies.push(eq.bodyB);
            bodyIds.push(eq.bodyB.id);
        }
    }
    return bodies;
};

/**
 * Check if the entire island wants to sleep.
 * @method wantsToSleep
 * @return {Boolean}
 */
Island.prototype.wantsToSleep = function(){
    for(var i=0; i<this.bodies.length; i++){
        var b = this.bodies[i];
        if(b.type === Body.DYNAMIC && !b.wantsToSleep){
            return false;
        }
    }
    return true;
};

/**
 * Make all bodies in the island sleep.
 * @method sleep
 */
Island.prototype.sleep = function(){
    for(var i=0; i<this.bodies.length; i++){
        var b = this.bodies[i];
        b.sleep();
    }
    return true;
};

},{"../objects/Body":32}],52:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Island = _dereq_('./Island')
,   IslandNode = _dereq_('./IslandNode')
,   Body = _dereq_('../objects/Body');

module.exports = IslandManager;

/**
 * Splits the system of bodies and equations into independent islands
 *
 * @class IslandManager
 * @constructor
 * @param {Object} [options]
 * @extends Solver
 */
function IslandManager(options){

    // Pooling of node objects saves some GC load
    this._nodePool = [];
    this._islandPool = [];

    /**
     * The equations to split. Manually fill this array before running .split().
     * @property {Array} equations
     */
    this.equations = [];

    /**
     * The resulting {{#crossLink "Island"}}{{/crossLink}}s.
     * @property {Array} islands
     */
    this.islands = [];

    /**
     * The resulting graph nodes.
     * @property {Array} nodes
     */
    this.nodes = [];

    /**
     * The node queue, used when traversing the graph of nodes.
     * @private
     * @property {Array} queue
     */
    this.queue = [];
}

/**
 * Get an unvisited node from a list of nodes.
 * @static
 * @method getUnvisitedNode
 * @param  {Array} nodes
 * @return {IslandNode|boolean} The node if found, else false.
 */
IslandManager.getUnvisitedNode = function(nodes){
    var Nnodes = nodes.length;
    for(var i=0; i!==Nnodes; i++){
        var node = nodes[i];
        if(!node.visited && node.body.type === Body.DYNAMIC){
            return node;
        }
    }
    return false;
};

/**
 * Visit a node.
 * @method visit
 * @param  {IslandNode} node
 * @param  {Array} bds
 * @param  {Array} eqs
 */
IslandManager.prototype.visit = function (node,bds,eqs){
    bds.push(node.body);
    var Neqs = node.equations.length;
    for(var i=0; i!==Neqs; i++){
        var eq = node.equations[i];
        if(eqs.indexOf(eq) === -1){ // Already added?
            eqs.push(eq);
        }
    }
};

/**
 * Runs the search algorithm, starting at a root node. The resulting bodies and equations will be stored in the provided arrays.
 * @method bfs
 * @param  {IslandNode} root The node to start from
 * @param  {Array} bds  An array to append resulting Bodies to.
 * @param  {Array} eqs  An array to append resulting Equations to.
 */
IslandManager.prototype.bfs = function(root,bds,eqs){

    // Reset the visit queue
    var queue = this.queue;
    queue.length = 0;

    // Add root node to queue
    queue.push(root);
    root.visited = true;
    this.visit(root,bds,eqs);

    // Process all queued nodes
    while(queue.length) {

        // Get next node in the queue
        var node = queue.pop();

        // Visit unvisited neighboring nodes
        var child;
        while((child = IslandManager.getUnvisitedNode(node.neighbors))) {
            child.visited = true;
            this.visit(child,bds,eqs);

            // Only visit the children of this node if it's dynamic
            if(child.body.type === Body.DYNAMIC){
                queue.push(child);
            }
        }
    }
};

/**
 * Split the world into independent islands. The result is stored in .islands.
 * @method split
 * @param  {World} world
 * @return {Array} The generated islands
 */
IslandManager.prototype.split = function(world){
    var bodies = world.bodies,
        nodes = this.nodes,
        equations = this.equations;

    // Move old nodes to the node pool
    while(nodes.length){
        this._nodePool.push(nodes.pop());
    }

    // Create needed nodes, reuse if possible
    for(var i=0; i!==bodies.length; i++){
        if(this._nodePool.length){
            var node = this._nodePool.pop();
            node.reset();
            node.body = bodies[i];
            nodes.push(node);
        } else {
            nodes.push(new IslandNode(bodies[i]));
        }
    }

    // Add connectivity data. Each equation connects 2 bodies.
    for(var k=0; k!==equations.length; k++){
        var eq=equations[k],
            i=bodies.indexOf(eq.bodyA),
            j=bodies.indexOf(eq.bodyB),
            ni=nodes[i],
            nj=nodes[j];
        ni.neighbors.push(nj);
        nj.neighbors.push(ni);
        ni.equations.push(eq);
        nj.equations.push(eq);
    }

    // Move old islands to the island pool
    var islands = this.islands;
    while(islands.length){
        var island = islands.pop();
        island.reset();
        this._islandPool.push(island);
    }

    // Get islands
    var child;
    while((child = IslandManager.getUnvisitedNode(nodes))){

        // Create new island
        var island = this._islandPool.length ? this._islandPool.pop() : new Island();

        // Get all equations and bodies in this island
        this.bfs(child, island.bodies, island.equations);

        islands.push(island);
    }

    return islands;
};

},{"../math/vec2":31,"../objects/Body":32,"./Island":51,"./IslandNode":53}],53:[function(_dereq_,module,exports){
module.exports = IslandNode;

/**
 * Holds a body and keeps track of some additional properties needed for graph traversal.
 * @class IslandNode
 * @constructor
 * @param {Body} body
 */
function IslandNode(body){

	/**
	 * The body that is contained in this node.
	 * @property {Body} body
	 */
    this.body = body;

    /**
     * Neighboring IslandNodes
     * @property {Array} neighbors
     */
    this.neighbors = [];

    /**
     * Equations connected to this node.
     * @property {Array} equations
     */
    this.equations = [];

    /**
     * If this node was visiting during the graph traversal.
     * @property visited
     * @type {Boolean}
     */
    this.visited = false;
}

/**
 * Clean this node from bodies and equations.
 * @method reset
 */
IslandNode.prototype.reset = function(){
    this.equations.length = 0;
    this.neighbors.length = 0;
    this.visited = false;
    this.body = null;
};

},{}],54:[function(_dereq_,module,exports){
/* global performance */
/*jshint -W020 */

var  GSSolver = _dereq_('../solver/GSSolver')
,    Solver = _dereq_('../solver/Solver')
,    NaiveBroadphase = _dereq_('../collision/NaiveBroadphase')
,    Ray = _dereq_('../collision/Ray')
,    vec2 = _dereq_('../math/vec2')
,    Circle = _dereq_('../shapes/Circle')
,    Rectangle = _dereq_('../shapes/Rectangle')
,    Convex = _dereq_('../shapes/Convex')
,    Line = _dereq_('../shapes/Line')
,    Plane = _dereq_('../shapes/Plane')
,    Capsule = _dereq_('../shapes/Capsule')
,    Particle = _dereq_('../shapes/Particle')
,    EventEmitter = _dereq_('../events/EventEmitter')
,    Body = _dereq_('../objects/Body')
,    Shape = _dereq_('../shapes/Shape')
,    LinearSpring = _dereq_('../objects/LinearSpring')
,    Material = _dereq_('../material/Material')
,    ContactMaterial = _dereq_('../material/ContactMaterial')
,    DistanceConstraint = _dereq_('../constraints/DistanceConstraint')
,    Constraint = _dereq_('../constraints/Constraint')
,    LockConstraint = _dereq_('../constraints/LockConstraint')
,    RevoluteConstraint = _dereq_('../constraints/RevoluteConstraint')
,    PrismaticConstraint = _dereq_('../constraints/PrismaticConstraint')
,    GearConstraint = _dereq_('../constraints/GearConstraint')
,    pkg = _dereq_('../../package.json')
,    Broadphase = _dereq_('../collision/Broadphase')
,    SAPBroadphase = _dereq_('../collision/SAPBroadphase')
,    Narrowphase = _dereq_('../collision/Narrowphase')
,    Utils = _dereq_('../utils/Utils')
,    OverlapKeeper = _dereq_('../utils/OverlapKeeper')
,    IslandManager = _dereq_('./IslandManager')
,    RotationalSpring = _dereq_('../objects/RotationalSpring');

module.exports = World;

if(typeof performance === 'undefined'){
    performance = {};
}
if(!performance.now){
    var nowOffset = Date.now();
    if (performance.timing && performance.timing.navigationStart){
        nowOffset = performance.timing.navigationStart;
    }
    performance.now = function(){
        return Date.now() - nowOffset;
    };
}

/**
 * The dynamics world, where all bodies and constraints lives.
 *
 * @class World
 * @constructor
 * @param {Object}          [options]
 * @param {Solver}          [options.solver]            Defaults to GSSolver.
 * @param {Array}           [options.gravity]           Defaults to [0,-9.78]
 * @param {Broadphase}      [options.broadphase]        Defaults to NaiveBroadphase
 * @param {Boolean}         [options.islandSplit=false]
 * @param {Boolean}         [options.doProfiling=false]
 * @extends EventEmitter
 *
 * @example
 *     var world = new World({
 *         gravity: [0, -9.81],
 *         broadphase: new SAPBroadphase()
 *     });
 */
function World(options){
    EventEmitter.apply(this);

    options = options || {};

    /**
     * All springs in the world. To add a spring to the world, use {{#crossLink "World/addSpring:method"}}{{/crossLink}}.
     *
     * @property springs
     * @type {Array}
     */
    this.springs = [];

    /**
     * All bodies in the world. To add a body to the world, use {{#crossLink "World/addBody:method"}}{{/crossLink}}.
     * @property {Array} bodies
     */
    this.bodies = [];

    /**
     * Disabled body collision pairs. See {{#crossLink "World/disableBodyCollision:method"}}.
     * @private
     * @property {Array} disabledBodyCollisionPairs
     */
    this.disabledBodyCollisionPairs = [];

    /**
     * The solver used to satisfy constraints and contacts. Default is {{#crossLink "GSSolver"}}{{/crossLink}}.
     * @property {Solver} solver
     */
    this.solver = options.solver || new GSSolver();

    /**
     * The narrowphase to use to generate contacts.
     *
     * @property narrowphase
     * @type {Narrowphase}
     */
    this.narrowphase = new Narrowphase(this);

    /**
     * The island manager of this world.
     * @property {IslandManager} islandManager
     */
    this.islandManager = new IslandManager();

    /**
     * Gravity in the world. This is applied on all bodies in the beginning of each step().
     *
     * @property gravity
     * @type {Array}
     */
    this.gravity = vec2.fromValues(0, -9.78);
    if(options.gravity){
        vec2.copy(this.gravity, options.gravity);
    }

    /**
     * Gravity to use when approximating the friction max force (mu*mass*gravity).
     * @property {Number} frictionGravity
     */
    this.frictionGravity = vec2.length(this.gravity) || 10;

    /**
     * Set to true if you want .frictionGravity to be automatically set to the length of .gravity.
     * @property {Boolean} useWorldGravityAsFrictionGravity
     */
    this.useWorldGravityAsFrictionGravity = true;

    /**
     * If the length of .gravity is zero, and .useWorldGravityAsFrictionGravity=true, then switch to using .frictionGravity for friction instead. This fallback is useful for gravityless games.
     * @property {Boolean} useFrictionGravityOnZeroGravity
     */
    this.useFrictionGravityOnZeroGravity = true;

    /**
     * Whether to do timing measurements during the step() or not.
     *
     * @property doPofiling
     * @type {Boolean}
     */
    this.doProfiling = options.doProfiling || false;

    /**
     * How many millisecconds the last step() took. This is updated each step if .doProfiling is set to true.
     *
     * @property lastStepTime
     * @type {Number}
     */
    this.lastStepTime = 0.0;

    /**
     * The broadphase algorithm to use.
     *
     * @property broadphase
     * @type {Broadphase}
     */
    this.broadphase = options.broadphase || new SAPBroadphase();
    this.broadphase.setWorld(this);

    /**
     * User-added constraints.
     *
     * @property constraints
     * @type {Array}
     */
    this.constraints = [];

    /**
     * Dummy default material in the world, used in .defaultContactMaterial
     * @property {Material} defaultMaterial
     */
    this.defaultMaterial = new Material();

    /**
     * The default contact material to use, if no contact material was set for the colliding materials.
     * @property {ContactMaterial} defaultContactMaterial
     */
    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial,this.defaultMaterial);

    /**
     * For keeping track of what time step size we used last step
     * @property lastTimeStep
     * @type {Number}
     */
    this.lastTimeStep = 1/60;

    /**
     * Enable to automatically apply spring forces each step.
     * @property applySpringForces
     * @type {Boolean}
     */
    this.applySpringForces = true;

    /**
     * Enable to automatically apply body damping each step.
     * @property applyDamping
     * @type {Boolean}
     */
    this.applyDamping = true;

    /**
     * Enable to automatically apply gravity each step.
     * @property applyGravity
     * @type {Boolean}
     */
    this.applyGravity = true;

    /**
     * Enable/disable constraint solving in each step.
     * @property solveConstraints
     * @type {Boolean}
     */
    this.solveConstraints = true;

    /**
     * The ContactMaterials added to the World.
     * @property contactMaterials
     * @type {Array}
     */
    this.contactMaterials = [];

    /**
     * World time.
     * @property time
     * @type {Number}
     */
    this.time = 0.0;

    /**
     * Is true during the step().
     * @property {Boolean} stepping
     */
    this.stepping = false;

    /**
     * Bodies that are scheduled to be removed at the end of the step.
     * @property {Array} bodiesToBeRemoved
     * @private
     */
    this.bodiesToBeRemoved = [];

    this.fixedStepTime = 0.0;

    /**
     * Whether to enable island splitting. Island splitting can be an advantage for many things, including solver performance. See {{#crossLink "IslandManager"}}{{/crossLink}}.
     * @property {Boolean} islandSplit
     */
    this.islandSplit = typeof(options.islandSplit)!=="undefined" ? !!options.islandSplit : false;

    /**
     * Set to true if you want to the world to emit the "impact" event. Turning this off could improve performance.
     * @property emitImpactEvent
     * @type {Boolean}
     */
    this.emitImpactEvent = true;

    // Id counters
    this._constraintIdCounter = 0;
    this._bodyIdCounter = 0;

    /**
     * Fired after the step().
     * @event postStep
     */
    this.postStepEvent = {
        type : "postStep",
    };

    /**
     * Fired when a body is added to the world.
     * @event addBody
     * @param {Body} body
     */
    this.addBodyEvent = {
        type : "addBody",
        body : null
    };

    /**
     * Fired when a body is removed from the world.
     * @event removeBody
     * @param {Body} body
     */
    this.removeBodyEvent = {
        type : "removeBody",
        body : null
    };

    /**
     * Fired when a spring is added to the world.
     * @event addSpring
     * @param {Spring} spring
     */
    this.addSpringEvent = {
        type : "addSpring",
        spring : null,
    };

    /**
     * Fired when a first contact is created between two bodies. This event is fired after the step has been done.
     * @event impact
     * @param {Body} bodyA
     * @param {Body} bodyB
     */
    this.impactEvent = {
        type: "impact",
        bodyA : null,
        bodyB : null,
        shapeA : null,
        shapeB : null,
        contactEquation : null,
    };

    /**
     * Fired after the Broadphase has collected collision pairs in the world.
     * Inside the event handler, you can modify the pairs array as you like, to
     * prevent collisions between objects that you don't want.
     * @event postBroadphase
     * @param {Array} pairs An array of collision pairs. If this array is [body1,body2,body3,body4], then the body pairs 1,2 and 3,4 would advance to narrowphase.
     */
    this.postBroadphaseEvent = {
        type:"postBroadphase",
        pairs:null,
    };

    /**
     * How to deactivate bodies during simulation. Possible modes are: {{#crossLink "World/NO_SLEEPING:property"}}World.NO_SLEEPING{{/crossLink}}, {{#crossLink "World/BODY_SLEEPING:property"}}World.BODY_SLEEPING{{/crossLink}} and {{#crossLink "World/ISLAND_SLEEPING:property"}}World.ISLAND_SLEEPING{{/crossLink}}.
     * If sleeping is enabled, you might need to {{#crossLink "Body/wakeUp:method"}}wake up{{/crossLink}} the bodies if they fall asleep when they shouldn't. If you want to enable sleeping in the world, but want to disable it for a particular body, see {{#crossLink "Body/allowSleep:property"}}Body.allowSleep{{/crossLink}}.
     * @property sleepMode
     * @type {number}
     * @default World.NO_SLEEPING
     */
    this.sleepMode = World.NO_SLEEPING;

    /**
     * Fired when two shapes starts start to overlap. Fired in the narrowphase, during step.
     * @event beginContact
     * @param {Shape} shapeA
     * @param {Shape} shapeB
     * @param {Body}  bodyA
     * @param {Body}  bodyB
     * @param {Array} contactEquations
     */
    this.beginContactEvent = {
        type:"beginContact",
        shapeA : null,
        shapeB : null,
        bodyA : null,
        bodyB : null,
        contactEquations : [],
    };

    /**
     * Fired when two shapes stop overlapping, after the narrowphase (during step).
     * @event endContact
     * @param {Shape} shapeA
     * @param {Shape} shapeB
     * @param {Body}  bodyA
     * @param {Body}  bodyB
     * @param {Array} contactEquations
     */
    this.endContactEvent = {
        type:"endContact",
        shapeA : null,
        shapeB : null,
        bodyA : null,
        bodyB : null,
    };

    /**
     * Fired just before equations are added to the solver to be solved. Can be used to control what equations goes into the solver.
     * @event preSolve
     * @param {Array} contactEquations  An array of contacts to be solved.
     * @param {Array} frictionEquations An array of friction equations to be solved.
     */
    this.preSolveEvent = {
        type:"preSolve",
        contactEquations:null,
        frictionEquations:null,
    };

    // For keeping track of overlapping shapes
    this.overlappingShapesLastState = { keys:[] };
    this.overlappingShapesCurrentState = { keys:[] };

    this.overlapKeeper = new OverlapKeeper();
}
World.prototype = new Object(EventEmitter.prototype);
World.prototype.constructor = World;

/**
 * Never deactivate bodies.
 * @static
 * @property {number} NO_SLEEPING
 */
World.NO_SLEEPING = 1;

/**
 * Deactivate individual bodies if they are sleepy.
 * @static
 * @property {number} BODY_SLEEPING
 */
World.BODY_SLEEPING = 2;

/**
 * Deactivates bodies that are in contact, if all of them are sleepy. Note that you must enable {{#crossLink "World/islandSplit:property"}}.islandSplit{{/crossLink}} for this to work.
 * @static
 * @property {number} ISLAND_SLEEPING
 */
World.ISLAND_SLEEPING = 4;

/**
 * Add a constraint to the simulation.
 *
 * @method addConstraint
 * @param {Constraint} c
 */
World.prototype.addConstraint = function(c){
    this.constraints.push(c);
};

/**
 * Add a ContactMaterial to the simulation.
 * @method addContactMaterial
 * @param {ContactMaterial} contactMaterial
 */
World.prototype.addContactMaterial = function(contactMaterial){
    this.contactMaterials.push(contactMaterial);
};

/**
 * Removes a contact material
 *
 * @method removeContactMaterial
 * @param {ContactMaterial} cm
 */
World.prototype.removeContactMaterial = function(cm){
    var idx = this.contactMaterials.indexOf(cm);
    if(idx!==-1){
        Utils.splice(this.contactMaterials,idx,1);
    }
};

/**
 * Get a contact material given two materials
 * @method getContactMaterial
 * @param {Material} materialA
 * @param {Material} materialB
 * @return {ContactMaterial} The matching ContactMaterial, or false on fail.
 * @todo Use faster hash map to lookup from material id's
 */
World.prototype.getContactMaterial = function(materialA,materialB){
    var cmats = this.contactMaterials;
    for(var i=0, N=cmats.length; i!==N; i++){
        var cm = cmats[i];
        if( (cm.materialA.id === materialA.id) && (cm.materialB.id === materialB.id) ||
            (cm.materialA.id === materialB.id) && (cm.materialB.id === materialA.id) ){
            return cm;
        }
    }
    return false;
};

/**
 * Removes a constraint
 *
 * @method removeConstraint
 * @param {Constraint} c
 */
World.prototype.removeConstraint = function(c){
    var idx = this.constraints.indexOf(c);
    if(idx!==-1){
        Utils.splice(this.constraints,idx,1);
    }
};

var step_r = vec2.create(),
    step_runit = vec2.create(),
    step_u = vec2.create(),
    step_f = vec2.create(),
    step_fhMinv = vec2.create(),
    step_velodt = vec2.create(),
    step_mg = vec2.create(),
    xiw = vec2.fromValues(0,0),
    xjw = vec2.fromValues(0,0),
    zero = vec2.fromValues(0,0),
    interpvelo = vec2.fromValues(0,0);

/**
 * Step the physics world forward in time.
 *
 * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
 *
 * @method step
 * @param {Number} dt                       The fixed time step size to use.
 * @param {Number} [timeSinceLastCalled=0]  The time elapsed since the function was last called.
 * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
 *
 * @example
 *     // fixed timestepping without interpolation
 *     var world = new World();
 *     world.step(0.01);
 *
 * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
 */
World.prototype.step = function(dt,timeSinceLastCalled,maxSubSteps){
    maxSubSteps = maxSubSteps || 10;
    timeSinceLastCalled = timeSinceLastCalled || 0;

    if(timeSinceLastCalled === 0){ // Fixed, simple stepping

        this.internalStep(dt);

        // Increment time
        this.time += dt;

    } else {

        // Compute the number of fixed steps we should have taken since the last step
        var internalSteps = Math.floor( (this.time+timeSinceLastCalled) / dt) - Math.floor(this.time / dt);
        internalSteps = Math.min(internalSteps,maxSubSteps);

        // Do some fixed steps to catch up
        var t0 = performance.now();
        for(var i=0; i!==internalSteps; i++){
            this.internalStep(dt);
            if(performance.now() - t0 > dt*1000){
                // We are slower than real-time. Better bail out.
                break;
            }
        }

        // Increment internal clock
        this.time += timeSinceLastCalled;

        // Compute "Left over" time step
        var h = this.time % dt;
        var h_div_dt = h/dt;

        for(var j=0; j!==this.bodies.length; j++){
            var b = this.bodies[j];
            if(b.type !== Body.STATIC && b.sleepState !== Body.SLEEPING){
                // Interpolate
                vec2.sub(interpvelo, b.position, b.previousPosition);
                vec2.scale(interpvelo, interpvelo, h_div_dt);
                vec2.add(b.interpolatedPosition, b.position, interpvelo);

                b.interpolatedAngle = b.angle + (b.angle - b.previousAngle) * h_div_dt;
            } else {
                // For static bodies, just copy. Who else will do it?
                vec2.copy(b.interpolatedPosition, b.position);
                b.interpolatedAngle = b.angle;
            }
        }
    }
};

var endOverlaps = [];

/**
 * Make a fixed step.
 * @method internalStep
 * @param  {number} dt
 * @private
 */
World.prototype.internalStep = function(dt){
    this.stepping = true;

    var that = this,
        doProfiling = this.doProfiling,
        Nsprings = this.springs.length,
        springs = this.springs,
        bodies = this.bodies,
        g = this.gravity,
        solver = this.solver,
        Nbodies = this.bodies.length,
        broadphase = this.broadphase,
        np = this.narrowphase,
        constraints = this.constraints,
        t0, t1,
        fhMinv = step_fhMinv,
        velodt = step_velodt,
        mg = step_mg,
        scale = vec2.scale,
        add = vec2.add,
        rotate = vec2.rotate,
        islandManager = this.islandManager;

    this.overlapKeeper.tick();

    this.lastTimeStep = dt;

    if(doProfiling){
        t0 = performance.now();
    }

    // Update approximate friction gravity.
    if(this.useWorldGravityAsFrictionGravity){
        var gravityLen = vec2.length(this.gravity);
        if(!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity)){
            // Nonzero gravity. Use it.
            this.frictionGravity = gravityLen;
        }
    }

    // Add gravity to bodies
    if(this.applyGravity){
        for(var i=0; i!==Nbodies; i++){
            var b = bodies[i],
                fi = b.force;
            if(b.type !== Body.DYNAMIC || b.sleepState === Body.SLEEPING){
                continue;
            }
            vec2.scale(mg,g,b.mass*b.gravityScale); // F=m*g
            add(fi,fi,mg);
        }
    }

    // Add spring forces
    if(this.applySpringForces){
        for(var i=0; i!==Nsprings; i++){
            var s = springs[i];
            s.applyForce();
        }
    }

    if(this.applyDamping){
        for(var i=0; i!==Nbodies; i++){
            var b = bodies[i];
            if(b.type === Body.DYNAMIC){
                b.applyDamping(dt);
            }
        }
    }

    // Broadphase
    var result = broadphase.getCollisionPairs(this);

    // Remove ignored collision pairs
    var ignoredPairs = this.disabledBodyCollisionPairs;
    for(var i=ignoredPairs.length-2; i>=0; i-=2){
        for(var j=result.length-2; j>=0; j-=2){
            if( (ignoredPairs[i]   === result[j] && ignoredPairs[i+1] === result[j+1]) ||
                (ignoredPairs[i+1] === result[j] && ignoredPairs[i]   === result[j+1])){
                result.splice(j,2);
            }
        }
    }

    // Remove constrained pairs with collideConnected == false
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        var c = constraints[i];
        if(!c.collideConnected){
            for(var j=result.length-2; j>=0; j-=2){
                if( (c.bodyA === result[j] && c.bodyB === result[j+1]) ||
                    (c.bodyB === result[j] && c.bodyA === result[j+1])){
                    result.splice(j,2);
                }
            }
        }
    }

    // postBroadphase event
    this.postBroadphaseEvent.pairs = result;
    this.emit(this.postBroadphaseEvent);

    // Narrowphase
    np.reset(this);
    for(var i=0, Nresults=result.length; i!==Nresults; i+=2){
        var bi = result[i],
            bj = result[i+1];

        // Loop over all shapes of body i
        for(var k=0, Nshapesi=bi.shapes.length; k!==Nshapesi; k++){
            var si = bi.shapes[k],
                xi = bi.shapeOffsets[k],
                ai = bi.shapeAngles[k];

            // All shapes of body j
            for(var l=0, Nshapesj=bj.shapes.length; l!==Nshapesj; l++){
                var sj = bj.shapes[l],
                    xj = bj.shapeOffsets[l],
                    aj = bj.shapeAngles[l];

                var cm = this.defaultContactMaterial;
                if(si.material && sj.material){
                    var tmp = this.getContactMaterial(si.material,sj.material);
                    if(tmp){
                        cm = tmp;
                    }
                }

                this.runNarrowphase(np,bi,si,xi,ai,bj,sj,xj,aj,cm,this.frictionGravity);
            }
        }
    }

    // Wake up bodies
    for(var i=0; i!==Nbodies; i++){
        var body = bodies[i];
        if(body._wakeUpAfterNarrowphase){
            body.wakeUp();
            body._wakeUpAfterNarrowphase = false;
        }
    }

    // Emit end overlap events
    if(this.has('endContact')){
        this.overlapKeeper.getEndOverlaps(endOverlaps);
        var e = this.endContactEvent;
        var l = endOverlaps.length;
        while(l--){
            var data = endOverlaps[l];
            e.shapeA = data.shapeA;
            e.shapeB = data.shapeB;
            e.bodyA = data.bodyA;
            e.bodyB = data.bodyB;
            this.emit(e);
        }
    }

    var preSolveEvent = this.preSolveEvent;
    preSolveEvent.contactEquations = np.contactEquations;
    preSolveEvent.frictionEquations = np.frictionEquations;
    this.emit(preSolveEvent);

    // update constraint equations
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        constraints[i].update();
    }

    if(np.contactEquations.length || np.frictionEquations.length || constraints.length){
        if(this.islandSplit){
            // Split into islands
            islandManager.equations.length = 0;
            Utils.appendArray(islandManager.equations, np.contactEquations);
            Utils.appendArray(islandManager.equations, np.frictionEquations);
            for(i=0; i!==Nconstraints; i++){
                Utils.appendArray(islandManager.equations, constraints[i].equations);
            }
            islandManager.split(this);

            for(var i=0; i!==islandManager.islands.length; i++){
                var island = islandManager.islands[i];
                if(island.equations.length){
                    solver.solveIsland(dt,island);
                }
            }

        } else {

            // Add contact equations to solver
            solver.addEquations(np.contactEquations);
            solver.addEquations(np.frictionEquations);

            // Add user-defined constraint equations
            for(i=0; i!==Nconstraints; i++){
                solver.addEquations(constraints[i].equations);
            }

            if(this.solveConstraints){
                solver.solve(dt,this);
            }

            solver.removeAllEquations();
        }
    }

    // Step forward
    for(var i=0; i!==Nbodies; i++){
        var body = bodies[i];

        if(body.sleepState !== Body.SLEEPING && body.type !== Body.STATIC){
            body.integrate(dt);
        }
    }

    // Reset force
    for(var i=0; i!==Nbodies; i++){
        bodies[i].setZeroForce();
    }

    if(doProfiling){
        t1 = performance.now();
        that.lastStepTime = t1-t0;
    }

    // Emit impact event
    if(this.emitImpactEvent && this.has('impact')){
        var ev = this.impactEvent;
        for(var i=0; i!==np.contactEquations.length; i++){
            var eq = np.contactEquations[i];
            if(eq.firstImpact){
                ev.bodyA = eq.bodyA;
                ev.bodyB = eq.bodyB;
                ev.shapeA = eq.shapeA;
                ev.shapeB = eq.shapeB;
                ev.contactEquation = eq;
                this.emit(ev);
            }
        }
    }

    // Sleeping update
    if(this.sleepMode === World.BODY_SLEEPING){
        for(i=0; i!==Nbodies; i++){
            bodies[i].sleepTick(this.time, false, dt);
        }
    } else if(this.sleepMode === World.ISLAND_SLEEPING && this.islandSplit){

        // Tell all bodies to sleep tick but dont sleep yet
        for(i=0; i!==Nbodies; i++){
            bodies[i].sleepTick(this.time, true, dt);
        }

        // Sleep islands
        for(var i=0; i<this.islandManager.islands.length; i++){
            var island = this.islandManager.islands[i];
            if(island.wantsToSleep()){
                island.sleep();
            }
        }
    }

    this.stepping = false;

    // Remove bodies that are scheduled for removal
    if(this.bodiesToBeRemoved.length){
        for(var i=0; i!==this.bodiesToBeRemoved.length; i++){
            this.removeBody(this.bodiesToBeRemoved[i]);
        }
        this.bodiesToBeRemoved.length = 0;
    }

    this.emit(this.postStepEvent);
};

/**
 * Runs narrowphase for the shape pair i and j.
 * @method runNarrowphase
 * @param  {Narrowphase} np
 * @param  {Body} bi
 * @param  {Shape} si
 * @param  {Array} xi
 * @param  {Number} ai
 * @param  {Body} bj
 * @param  {Shape} sj
 * @param  {Array} xj
 * @param  {Number} aj
 * @param  {Number} mu
 */
World.prototype.runNarrowphase = function(np,bi,si,xi,ai,bj,sj,xj,aj,cm,glen){

    // Check collision groups and masks
    if(!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)){
        return;
    }

    // Get world position and angle of each shape
    vec2.rotate(xiw, xi, bi.angle);
    vec2.rotate(xjw, xj, bj.angle);
    vec2.add(xiw, xiw, bi.position);
    vec2.add(xjw, xjw, bj.position);
    var aiw = ai + bi.angle;
    var ajw = aj + bj.angle;

    np.enableFriction = cm.friction > 0;
    np.frictionCoefficient = cm.friction;
    var reducedMass;
    if(bi.type === Body.STATIC || bi.type === Body.KINEMATIC){
        reducedMass = bj.mass;
    } else if(bj.type === Body.STATIC || bj.type === Body.KINEMATIC){
        reducedMass = bi.mass;
    } else {
        reducedMass = (bi.mass*bj.mass)/(bi.mass+bj.mass);
    }
    np.slipForce = cm.friction*glen*reducedMass;
    np.restitution = cm.restitution;
    np.surfaceVelocity = cm.surfaceVelocity;
    np.frictionStiffness = cm.frictionStiffness;
    np.frictionRelaxation = cm.frictionRelaxation;
    np.stiffness = cm.stiffness;
    np.relaxation = cm.relaxation;
    np.contactSkinSize = cm.contactSkinSize;
    np.enabledEquations = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;

    var resolver = np[si.type | sj.type],
        numContacts = 0;
    if (resolver) {
        var sensor = si.sensor || sj.sensor;
        var numFrictionBefore = np.frictionEquations.length;
        if (si.type < sj.type) {
            numContacts = resolver.call(np, bi,si,xiw,aiw, bj,sj,xjw,ajw, sensor);
        } else {
            numContacts = resolver.call(np, bj,sj,xjw,ajw, bi,si,xiw,aiw, sensor);
        }
        var numFrictionEquations = np.frictionEquations.length - numFrictionBefore;

        if(numContacts){

            if( bi.allowSleep &&
                bi.type === Body.DYNAMIC &&
                bi.sleepState  === Body.SLEEPING &&
                bj.sleepState  === Body.AWAKE &&
                bj.type !== Body.STATIC
            ){
                var speedSquaredB = vec2.squaredLength(bj.velocity) + Math.pow(bj.angularVelocity,2);
                var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit,2);
                if(speedSquaredB >= speedLimitSquaredB*2){
                    bi._wakeUpAfterNarrowphase = true;
                }
            }

            if( bj.allowSleep &&
                bj.type === Body.DYNAMIC &&
                bj.sleepState  === Body.SLEEPING &&
                bi.sleepState  === Body.AWAKE &&
                bi.type !== Body.STATIC
            ){
                var speedSquaredA = vec2.squaredLength(bi.velocity) + Math.pow(bi.angularVelocity,2);
                var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit,2);
                if(speedSquaredA >= speedLimitSquaredA*2){
                    bj._wakeUpAfterNarrowphase = true;
                }
            }

            this.overlapKeeper.setOverlapping(bi, si, bj, sj);
            if(this.has('beginContact') && this.overlapKeeper.isNewOverlap(si, sj)){

                // Report new shape overlap
                var e = this.beginContactEvent;
                e.shapeA = si;
                e.shapeB = sj;
                e.bodyA = bi;
                e.bodyB = bj;

                // Reset contact equations
                e.contactEquations.length = 0;

                if(typeof(numContacts)==="number"){
                    for(var i=np.contactEquations.length-numContacts; i<np.contactEquations.length; i++){
                        e.contactEquations.push(np.contactEquations[i]);
                    }
                }

                this.emit(e);
            }

            // divide the max friction force by the number of contacts
            if(typeof(numContacts)==="number" && numFrictionEquations > 1){ // Why divide by 1?
                for(var i=np.frictionEquations.length-numFrictionEquations; i<np.frictionEquations.length; i++){
                    var f = np.frictionEquations[i];
                    f.setSlipForce(f.getSlipForce() / numFrictionEquations);
                }
            }
        }
    }

};

/**
 * Add a spring to the simulation
 *
 * @method addSpring
 * @param {Spring} s
 */
World.prototype.addSpring = function(s){
    this.springs.push(s);
    this.addSpringEvent.spring = s;
    this.emit(this.addSpringEvent);
};

/**
 * Remove a spring
 *
 * @method removeSpring
 * @param {Spring} s
 */
World.prototype.removeSpring = function(s){
    var idx = this.springs.indexOf(s);
    if(idx!==-1){
        Utils.splice(this.springs,idx,1);
    }
};

/**
 * Add a body to the simulation
 *
 * @method addBody
 * @param {Body} body
 *
 * @example
 *     var world = new World(),
 *         body = new Body();
 *     world.addBody(body);
 * @todo What if this is done during step?
 */
World.prototype.addBody = function(body){
    if(this.bodies.indexOf(body) === -1){
        this.bodies.push(body);
        body.world = this;
        this.addBodyEvent.body = body;
        this.emit(this.addBodyEvent);
    }
};

/**
 * Remove a body from the simulation. If this method is called during step(), the body removal is scheduled to after the step.
 *
 * @method removeBody
 * @param {Body} body
 */
World.prototype.removeBody = function(body){
    if(this.stepping){
        this.bodiesToBeRemoved.push(body);
    } else {
        body.world = null;
        var idx = this.bodies.indexOf(body);
        if(idx!==-1){
            Utils.splice(this.bodies,idx,1);
            this.removeBodyEvent.body = body;
            body.resetConstraintVelocity();
            this.emit(this.removeBodyEvent);
        }
    }
};

/**
 * Get a body by its id.
 * @method getBodyById
 * @return {Body|Boolean} The body, or false if it was not found.
 */
World.prototype.getBodyById = function(id){
    var bodies = this.bodies;
    for(var i=0; i<bodies.length; i++){
        var b = bodies[i];
        if(b.id === id){
            return b;
        }
    }
    return false;
};

/**
 * Disable collision between two bodies
 * @method disableCollision
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
World.prototype.disableBodyCollision = function(bodyA,bodyB){
    this.disabledBodyCollisionPairs.push(bodyA,bodyB);
};

/**
 * Enable collisions between the given two bodies
 * @method enableCollision
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
World.prototype.enableBodyCollision = function(bodyA,bodyB){
    var pairs = this.disabledBodyCollisionPairs;
    for(var i=0; i<pairs.length; i+=2){
        if((pairs[i] === bodyA && pairs[i+1] === bodyB) || (pairs[i+1] === bodyA && pairs[i] === bodyB)){
            pairs.splice(i,2);
            return;
        }
    }
};


function v2a(v){
    if(!v){
        return v;
    }
    return [v[0],v[1]];
}

function extend(a,b){
    for(var key in b){
        a[key] = b[key];
    }
}

function contactMaterialToJSON(cm){
    return {
        id : cm.id,
        materialA :             cm.materialA.id,
        materialB :             cm.materialB.id,
        friction :              cm.friction,
        restitution :           cm.restitution,
        stiffness :             cm.stiffness,
        relaxation :            cm.relaxation,
        frictionStiffness :     cm.frictionStiffness,
        frictionRelaxation :    cm.frictionRelaxation,
    };
}

/**
 * Resets the World, removes all bodies, constraints and springs.
 *
 * @method clear
 */
World.prototype.clear = function(){

    this.time = 0;
    this.fixedStepTime = 0;

    // Remove all solver equations
    if(this.solver && this.solver.equations.length){
        this.solver.removeAllEquations();
    }

    // Remove all constraints
    var cs = this.constraints;
    for(var i=cs.length-1; i>=0; i--){
        this.removeConstraint(cs[i]);
    }

    // Remove all bodies
    var bodies = this.bodies;
    for(var i=bodies.length-1; i>=0; i--){
        this.removeBody(bodies[i]);
    }

    // Remove all springs
    var springs = this.springs;
    for(var i=springs.length-1; i>=0; i--){
        this.removeSpring(springs[i]);
    }

    // Remove all contact materials
    var cms = this.contactMaterials;
    for(var i=cms.length-1; i>=0; i--){
        this.removeContactMaterial(cms[i]);
    }

    World.apply(this);
};

/**
 * Get a copy of this World instance
 * @method clone
 * @return {World}
 */
World.prototype.clone = function(){
    var world = new World();
    world.fromJSON(this.toJSON());
    return world;
};

var hitTest_tmp1 = vec2.create(),
    hitTest_zero = vec2.fromValues(0,0),
    hitTest_tmp2 = vec2.fromValues(0,0);

/**
 * Test if a world point overlaps bodies
 * @method hitTest
 * @param  {Array}  worldPoint  Point to use for intersection tests
 * @param  {Array}  bodies      A list of objects to check for intersection
 * @param  {Number} precision   Used for matching against particles and lines. Adds some margin to these infinitesimal objects.
 * @return {Array}              Array of bodies that overlap the point
 */
World.prototype.hitTest = function(worldPoint,bodies,precision){
    precision = precision || 0;

    // Create a dummy particle body with a particle shape to test against the bodies
    var pb = new Body({ position:worldPoint }),
        ps = new Particle(),
        px = worldPoint,
        pa = 0,
        x = hitTest_tmp1,
        zero = hitTest_zero,
        tmp = hitTest_tmp2;
    pb.addShape(ps);

    var n = this.narrowphase,
        result = [];

    // Check bodies
    for(var i=0, N=bodies.length; i!==N; i++){
        var b = bodies[i];
        for(var j=0, NS=b.shapes.length; j!==NS; j++){
            var s = b.shapes[j],
                offset = b.shapeOffsets[j] || zero,
                angle = b.shapeAngles[j] || 0.0;

            // Get shape world position + angle
            vec2.rotate(x, offset, b.angle);
            vec2.add(x, x, b.position);
            var a = angle + b.angle;

            if( (s instanceof Circle    && n.circleParticle  (b,s,x,a,     pb,ps,px,pa, true)) ||
                (s instanceof Convex    && n.particleConvex  (pb,ps,px,pa, b,s,x,a,     true)) ||
                (s instanceof Plane     && n.particlePlane   (pb,ps,px,pa, b,s,x,a,     true)) ||
                (s instanceof Capsule   && n.particleCapsule (pb,ps,px,pa, b,s,x,a,     true)) ||
                (s instanceof Particle  && vec2.squaredLength(vec2.sub(tmp,x,worldPoint)) < precision*precision)
                ){
                result.push(b);
            }
        }
    }

    return result;
};

/**
 * Sets the Equation parameters for all constraints and contact materials.
 * @method setGlobalEquationParameters
 * @param {object} [parameters]
 * @param {Number} [parameters.relaxation]
 * @param {Number} [parameters.stiffness]
 */
World.prototype.setGlobalEquationParameters = function(parameters){
    parameters = parameters || {};

    // Set for all constraints
    for(var i=0; i !== this.constraints.length; i++){
        var c = this.constraints[i];
        for(var j=0; j !== c.equations.length; j++){
            var eq = c.equations[j];
            if(typeof(parameters.stiffness) !== "undefined"){
                eq.stiffness = parameters.stiffness;
            }
            if(typeof(parameters.relaxation) !== "undefined"){
                eq.relaxation = parameters.relaxation;
            }
            eq.needsUpdate = true;
        }
    }

    // Set for all contact materials
    for(var i=0; i !== this.contactMaterials.length; i++){
        var c = this.contactMaterials[i];
        if(typeof(parameters.stiffness) !== "undefined"){
            c.stiffness = parameters.stiffness;
            c.frictionStiffness = parameters.stiffness;
        }
        if(typeof(parameters.relaxation) !== "undefined"){
            c.relaxation = parameters.relaxation;
            c.frictionRelaxation = parameters.relaxation;
        }
    }

    // Set for default contact material
    var c = this.defaultContactMaterial;
    if(typeof(parameters.stiffness) !== "undefined"){
        c.stiffness = parameters.stiffness;
        c.frictionStiffness = parameters.stiffness;
    }
    if(typeof(parameters.relaxation) !== "undefined"){
        c.relaxation = parameters.relaxation;
        c.frictionRelaxation = parameters.relaxation;
    }
};

/**
 * Set the stiffness for all equations and contact materials.
 * @method setGlobalStiffness
 * @param {Number} stiffness
 */
World.prototype.setGlobalStiffness = function(stiffness){
    this.setGlobalEquationParameters({
        stiffness: stiffness
    });
};

/**
 * Set the relaxation for all equations and contact materials.
 * @method setGlobalRelaxation
 * @param {Number} relaxation
 */
World.prototype.setGlobalRelaxation = function(relaxation){
    this.setGlobalEquationParameters({
        relaxation: relaxation
    });
};

var tmpRay = new Ray();

/**
 * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
 * @method raycastAll
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionMask=-1]
 * @param  {number} [options.collisionGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {Function} callback
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastAll = function(from, to, options, callback){
    options.mode = Ray.ALL;
    options.from = from;
    options.to = to;
    options.callback = callback;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
 * @method raycastAny
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionMask=-1]
 * @param  {number} [options.collisionGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {RaycastResult} result
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastAny = function(from, to, options, result){
    options.mode = Ray.ANY;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Ray cast, and return information of the closest hit.
 * @method raycastClosest
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionMask=-1]
 * @param  {number} [options.collisionGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {RaycastResult} result
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastClosest = function(from, to, options, result){
    options.mode = Ray.CLOSEST;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
};
},{"../../package.json":6,"../collision/Broadphase":8,"../collision/NaiveBroadphase":10,"../collision/Narrowphase":11,"../collision/Ray":12,"../collision/SAPBroadphase":14,"../constraints/Constraint":15,"../constraints/DistanceConstraint":16,"../constraints/GearConstraint":17,"../constraints/LockConstraint":18,"../constraints/PrismaticConstraint":19,"../constraints/RevoluteConstraint":20,"../events/EventEmitter":27,"../material/ContactMaterial":28,"../material/Material":29,"../math/vec2":31,"../objects/Body":32,"../objects/LinearSpring":33,"../objects/RotationalSpring":34,"../shapes/Capsule":37,"../shapes/Circle":38,"../shapes/Convex":39,"../shapes/Line":41,"../shapes/Particle":42,"../shapes/Plane":43,"../shapes/Rectangle":44,"../shapes/Shape":45,"../solver/GSSolver":46,"../solver/Solver":47,"../utils/OverlapKeeper":48,"../utils/Utils":50,"./IslandManager":52}]},{},[36])
(36)
});;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/Lau/www/svjelly/libs/poly2tri/dist/poly2tri.js":[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.poly2tri=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
module.exports={"version": "1.3.5"}
},{}],2:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:11 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */


// -------------------------------------------------------------------------Node

/**
 * Advancing front node
 * @constructor
 * @private
 * @struct
 * @param {!XY} p - Point
 * @param {Triangle=} t triangle (optional)
 */
var Node = function(p, t) {
    /** @type {XY} */
    this.point = p;

    /** @type {Triangle|null} */
    this.triangle = t || null;

    /** @type {Node|null} */
    this.next = null;
    /** @type {Node|null} */
    this.prev = null;

    /** @type {number} */
    this.value = p.x;
};

// ---------------------------------------------------------------AdvancingFront
/**
 * @constructor
 * @private
 * @struct
 * @param {Node} head
 * @param {Node} tail
 */
var AdvancingFront = function(head, tail) {
    /** @type {Node} */
    this.head_ = head;
    /** @type {Node} */
    this.tail_ = tail;
    /** @type {Node} */
    this.search_node_ = head;
};

/** @return {Node} */
AdvancingFront.prototype.head = function() {
    return this.head_;
};

/** @param {Node} node */
AdvancingFront.prototype.setHead = function(node) {
    this.head_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.tail = function() {
    return this.tail_;
};

/** @param {Node} node */
AdvancingFront.prototype.setTail = function(node) {
    this.tail_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.search = function() {
    return this.search_node_;
};

/** @param {Node} node */
AdvancingFront.prototype.setSearch = function(node) {
    this.search_node_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.findSearchNode = function(/*x*/) {
    // TODO: implement BST index
    return this.search_node_;
};

/**
 * @param {number} x value
 * @return {Node}
 */
AdvancingFront.prototype.locateNode = function(x) {
    var node = this.search_node_;

    /* jshint boss:true */
    if (x < node.value) {
        while (node = node.prev) {
            if (x >= node.value) {
                this.search_node_ = node;
                return node;
            }
        }
    } else {
        while (node = node.next) {
            if (x < node.value) {
                this.search_node_ = node.prev;
                return node.prev;
            }
        }
    }
    return null;
};

/**
 * @param {!XY} point - Point
 * @return {Node}
 */
AdvancingFront.prototype.locatePoint = function(point) {
    var px = point.x;
    var node = this.findSearchNode(px);
    var nx = node.point.x;

    if (px === nx) {
        // Here we are comparing point references, not values
        if (point !== node.point) {
            // We might have two nodes with same x value for a short time
            if (point === node.prev.point) {
                node = node.prev;
            } else if (point === node.next.point) {
                node = node.next;
            } else {
                throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');
            }
        }
    } else if (px < nx) {
        /* jshint boss:true */
        while (node = node.prev) {
            if (point === node.point) {
                break;
            }
        }
    } else {
        while (node = node.next) {
            if (point === node.point) {
                break;
            }
        }
    }

    if (node) {
        this.search_node_ = node;
    }
    return node;
};


// ----------------------------------------------------------------------Exports

module.exports = AdvancingFront;
module.exports.Node = Node;


},{}],3:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 *
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 *
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/*
 * Function added in the JavaScript version (was not present in the c++ version)
 */

/**
 * assert and throw an exception.
 *
 * @private
 * @param {boolean} condition   the condition which is asserted
 * @param {string} message      the message which is display is condition is falsy
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || "Assert Failed");
    }
}
module.exports = assert;



},{}],4:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var xy = _dereq_('./xy');

// ------------------------------------------------------------------------Point
/**
 * Construct a point
 * @example
 *      var point = new poly2tri.Point(150, 150);
 * @public
 * @constructor
 * @struct
 * @param {number=} x    coordinate (0 if undefined)
 * @param {number=} y    coordinate (0 if undefined)
 */
var Point = function(x, y) {
    /**
     * @type {number}
     * @expose
     */
    this.x = +x || 0;
    /**
     * @type {number}
     * @expose
     */
    this.y = +y || 0;

    // All extra fields added to Point are prefixed with _p2t_
    // to avoid collisions if custom Point class is used.

    /**
     * The edges this point constitutes an upper ending point
     * @private
     * @type {Array.<Edge>}
     */
    this._p2t_edge_list = null;
};

/**
 * For pretty printing
 * @example
 *      "p=" + new poly2tri.Point(5,42)
 *      // → "p=(5;42)"
 * @returns {string} <code>"(x;y)"</code>
 */
Point.prototype.toString = function() {
    return xy.toStringBase(this);
};

/**
 * JSON output, only coordinates
 * @example
 *      JSON.stringify(new poly2tri.Point(1,2))
 *      // → '{"x":1,"y":2}'
 */
Point.prototype.toJSON = function() {
    return { x: this.x, y: this.y };
};

/**
 * Creates a copy of this Point object.
 * @return {Point} new cloned point
 */
Point.prototype.clone = function() {
    return new Point(this.x, this.y);
};

/**
 * Set this Point instance to the origo. <code>(0; 0)</code>
 * @return {Point} this (for chaining)
 */
Point.prototype.set_zero = function() {
    this.x = 0.0;
    this.y = 0.0;
    return this; // for chaining
};

/**
 * Set the coordinates of this instance.
 * @param {number} x   coordinate
 * @param {number} y   coordinate
 * @return {Point} this (for chaining)
 */
Point.prototype.set = function(x, y) {
    this.x = +x || 0;
    this.y = +y || 0;
    return this; // for chaining
};

/**
 * Negate this Point instance. (component-wise)
 * @return {Point} this (for chaining)
 */
Point.prototype.negate = function() {
    this.x = -this.x;
    this.y = -this.y;
    return this; // for chaining
};

/**
 * Add another Point object to this instance. (component-wise)
 * @param {!Point} n - Point object.
 * @return {Point} this (for chaining)
 */
Point.prototype.add = function(n) {
    this.x += n.x;
    this.y += n.y;
    return this; // for chaining
};

/**
 * Subtract this Point instance with another point given. (component-wise)
 * @param {!Point} n - Point object.
 * @return {Point} this (for chaining)
 */
Point.prototype.sub = function(n) {
    this.x -= n.x;
    this.y -= n.y;
    return this; // for chaining
};

/**
 * Multiply this Point instance by a scalar. (component-wise)
 * @param {number} s   scalar.
 * @return {Point} this (for chaining)
 */
Point.prototype.mul = function(s) {
    this.x *= s;
    this.y *= s;
    return this; // for chaining
};

/**
 * Return the distance of this Point instance from the origo.
 * @return {number} distance
 */
Point.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
};

/**
 * Normalize this Point instance (as a vector).
 * @return {number} The original distance of this instance from the origo.
 */
Point.prototype.normalize = function() {
    var len = this.length();
    this.x /= len;
    this.y /= len;
    return len;
};

/**
 * Test this Point object with another for equality.
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {boolean} <code>true</code> if same x and y coordinates, <code>false</code> otherwise.
 */
Point.prototype.equals = function(p) {
    return this.x === p.x && this.y === p.y;
};


// -----------------------------------------------------Point ("static" methods)

/**
 * Negate a point component-wise and return the result as a new Point object.
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.negate = function(p) {
    return new Point(-p.x, -p.y);
};

/**
 * Add two points component-wise and return the result as a new Point object.
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.add = function(a, b) {
    return new Point(a.x + b.x, a.y + b.y);
};

/**
 * Subtract two points component-wise and return the result as a new Point object.
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.sub = function(a, b) {
    return new Point(a.x - b.x, a.y - b.y);
};

/**
 * Multiply a point by a scalar and return the result as a new Point object.
 * @param {number} s - the scalar
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.mul = function(s, p) {
    return new Point(s * p.x, s * p.y);
};

/**
 * Perform the cross product on either two points (this produces a scalar)
 * or a point and a scalar (this produces a point).
 * This function requires two parameters, either may be a Point object or a
 * number.
 * @param  {XY|number} a - Point object or scalar.
 * @param  {XY|number} b - Point object or scalar.
 * @return {Point|number} a Point object or a number, depending on the parameters.
 */
Point.cross = function(a, b) {
    if (typeof(a) === 'number') {
        if (typeof(b) === 'number') {
            return a * b;
        } else {
            return new Point(-a * b.y, a * b.x);
        }
    } else {
        if (typeof(b) === 'number') {
            return new Point(b * a.y, -b * a.x);
        } else {
            return a.x * b.y - a.y * b.x;
        }
    }
};


// -----------------------------------------------------------------"Point-Like"
/*
 * The following functions operate on "Point" or any "Point like" object 
 * with {x,y} (duck typing).
 */

Point.toString = xy.toString;
Point.compare = xy.compare;
Point.cmp = xy.compare; // backward compatibility
Point.equals = xy.equals;

/**
 * Peform the dot product on two vectors.
 * @public
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {number} The dot product
 */
Point.dot = function(a, b) {
    return a.x * b.x + a.y * b.y;
};


// ---------------------------------------------------------Exports (public API)

module.exports = Point;

},{"./xy":11}],5:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/*
 * Class added in the JavaScript version (was not present in the c++ version)
 */

var xy = _dereq_('./xy');

/**
 * Custom exception class to indicate invalid Point values
 * @constructor
 * @public
 * @extends Error
 * @struct
 * @param {string=} message - error message
 * @param {Array.<XY>=} points - invalid points
 */
var PointError = function(message, points) {
    this.name = "PointError";
    /**
     * Invalid points
     * @public
     * @type {Array.<XY>}
     */
    this.points = points = points || [];
    /**
     * Error message
     * @public
     * @type {string}
     */
    this.message = message || "Invalid Points!";
    for (var i = 0; i < points.length; i++) {
        this.message += " " + xy.toString(points[i]);
    }
};
PointError.prototype = new Error();
PointError.prototype.constructor = PointError;


module.exports = PointError;

},{"./xy":11}],6:[function(_dereq_,module,exports){
(function (global){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of Poly2Tri nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without specific
 *   prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

"use strict";

/**
 * Public API for poly2tri.js
 * @module poly2tri
 */


/**
 * If you are not using a module system (e.g. CommonJS, RequireJS), you can access this library
 * as a global variable <code>poly2tri</code> i.e. <code>window.poly2tri</code> in a browser.
 * @name poly2tri
 * @global
 * @public
 * @type {module:poly2tri}
 */
var previousPoly2tri = global.poly2tri;
/**
 * For Browser + &lt;script&gt; :
 * reverts the {@linkcode poly2tri} global object to its previous value,
 * and returns a reference to the instance called.
 *
 * @example
 *              var p = poly2tri.noConflict();
 * @public
 * @return {module:poly2tri} instance called
 */
// (this feature is not automatically provided by browserify).
exports.noConflict = function() {
    global.poly2tri = previousPoly2tri;
    return exports;
};

/**
 * poly2tri library version
 * @public
 * @const {string}
 */
exports.VERSION = _dereq_('../dist/version.json').version;

/**
 * Exports the {@linkcode PointError} class.
 * @public
 * @typedef {PointError} module:poly2tri.PointError
 * @function
 */
exports.PointError = _dereq_('./pointerror');
/**
 * Exports the {@linkcode Point} class.
 * @public
 * @typedef {Point} module:poly2tri.Point
 * @function
 */
exports.Point = _dereq_('./point');
/**
 * Exports the {@linkcode Triangle} class.
 * @public
 * @typedef {Triangle} module:poly2tri.Triangle
 * @function
 */
exports.Triangle = _dereq_('./triangle');
/**
 * Exports the {@linkcode SweepContext} class.
 * @public
 * @typedef {SweepContext} module:poly2tri.SweepContext
 * @function
 */
exports.SweepContext = _dereq_('./sweepcontext');


// Backward compatibility
var sweep = _dereq_('./sweep');
/**
 * @function
 * @deprecated use {@linkcode SweepContext#triangulate} instead
 */
exports.triangulate = sweep.triangulate;
/**
 * @deprecated use {@linkcode SweepContext#triangulate} instead
 * @property {function} Triangulate - use {@linkcode SweepContext#triangulate} instead
 */
exports.sweep = {Triangulate: sweep.triangulate};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../dist/version.json":1,"./point":4,"./pointerror":5,"./sweep":7,"./sweepcontext":8,"./triangle":9}],7:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint latedef:nofunc, maxcomplexity:9 */

"use strict";

/**
 * This 'Sweep' module is present in order to keep this JavaScript version
 * as close as possible to the reference C++ version, even though almost all
 * functions could be declared as methods on the {@linkcode module:sweepcontext~SweepContext} object.
 * @module
 * @private
 */

/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var assert = _dereq_('./assert');
var PointError = _dereq_('./pointerror');
var Triangle = _dereq_('./triangle');
var Node = _dereq_('./advancingfront').Node;


// ------------------------------------------------------------------------utils

var utils = _dereq_('./utils');

/** @const */
var EPSILON = utils.EPSILON;

/** @const */
var Orientation = utils.Orientation;
/** @const */
var orient2d = utils.orient2d;
/** @const */
var inScanArea = utils.inScanArea;
/** @const */
var isAngleObtuse = utils.isAngleObtuse;


// ------------------------------------------------------------------------Sweep

/**
 * Triangulate the polygon with holes and Steiner points.
 * Do this AFTER you've added the polyline, holes, and Steiner points
 * @private
 * @param {!SweepContext} tcx - SweepContext object
 */
function triangulate(tcx) {
    tcx.initTriangulation();
    tcx.createAdvancingFront();
    // Sweep points; build mesh
    sweepPoints(tcx);
    // Clean up
    finalizationPolygon(tcx);
}

/**
 * Start sweeping the Y-sorted point set from bottom to top
 * @param {!SweepContext} tcx - SweepContext object
 */
function sweepPoints(tcx) {
    var i, len = tcx.pointCount();
    for (i = 1; i < len; ++i) {
        var point = tcx.getPoint(i);
        var node = pointEvent(tcx, point);
        var edges = point._p2t_edge_list;
        for (var j = 0; edges && j < edges.length; ++j) {
            edgeEventByEdge(tcx, edges[j], node);
        }
    }
}

/**
 * @param {!SweepContext} tcx - SweepContext object
 */
function finalizationPolygon(tcx) {
    // Get an Internal triangle to start with
    var t = tcx.front().head().next.triangle;
    var p = tcx.front().head().next.point;
    while (!t.getConstrainedEdgeCW(p)) {
        t = t.neighborCCW(p);
    }

    // Collect interior triangles constrained by edges
    tcx.meshClean(t);
}

/**
 * Find closes node to the left of the new point and
 * create a new triangle. If needed new holes and basins
 * will be filled to.
 * @param {!SweepContext} tcx - SweepContext object
 * @param {!XY} point   Point
 */
function pointEvent(tcx, point) {
    var node = tcx.locateNode(point);
    var new_node = newFrontTriangle(tcx, point, node);

    // Only need to check +epsilon since point never have smaller
    // x value than node due to how we fetch nodes from the front
    if (point.x <= node.point.x + (EPSILON)) {
        fill(tcx, node);
    }

    //tcx.AddNode(new_node);

    fillAdvancingFront(tcx, new_node);
    return new_node;
}

function edgeEventByEdge(tcx, edge, node) {
    tcx.edge_event.constrained_edge = edge;
    tcx.edge_event.right = (edge.p.x > edge.q.x);

    if (isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {
        return;
    }

    // For now we will do all needed filling
    // TODO: integrate with flip process might give some better performance
    //       but for now this avoid the issue with cases that needs both flips and fills
    fillEdgeEvent(tcx, edge, node);
    edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);
}

function edgeEventByPoints(tcx, ep, eq, triangle, point) {
    if (isEdgeSideOfTriangle(triangle, ep, eq)) {
        return;
    }

    var p1 = triangle.pointCCW(point);
    var o1 = orient2d(eq, p1, ep);
    if (o1 === Orientation.COLLINEAR) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision 09880a869095 dated March 8, 2011)
        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);
    }

    var p2 = triangle.pointCW(point);
    var o2 = orient2d(eq, p2, ep);
    if (o2 === Orientation.COLLINEAR) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision 09880a869095 dated March 8, 2011)
        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);
    }

    if (o1 === o2) {
        // Need to decide if we are rotating CW or CCW to get to a triangle
        // that will cross edge
        if (o1 === Orientation.CW) {
            triangle = triangle.neighborCCW(point);
        } else {
            triangle = triangle.neighborCW(point);
        }
        edgeEventByPoints(tcx, ep, eq, triangle, point);
    } else {
        // This triangle crosses constraint so lets flippin start!
        flipEdgeEvent(tcx, ep, eq, triangle, point);
    }
}

function isEdgeSideOfTriangle(triangle, ep, eq) {
    var index = triangle.edgeIndex(ep, eq);
    if (index !== -1) {
        triangle.markConstrainedEdgeByIndex(index);
        var t = triangle.getNeighbor(index);
        if (t) {
            t.markConstrainedEdgeByPoints(ep, eq);
        }
        return true;
    }
    return false;
}

/**
 * Creates a new front triangle and legalize it
 * @param {!SweepContext} tcx - SweepContext object
 */
function newFrontTriangle(tcx, point, node) {
    var triangle = new Triangle(point, node.point, node.next.point);

    triangle.markNeighbor(node.triangle);
    tcx.addToMap(triangle);

    var new_node = new Node(point);
    new_node.next = node.next;
    new_node.prev = node;
    node.next.prev = new_node;
    node.next = new_node;

    if (!legalize(tcx, triangle)) {
        tcx.mapTriangleToNodes(triangle);
    }

    return new_node;
}

/**
 * Adds a triangle to the advancing front to fill a hole.
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - middle node, that is the bottom of the hole
 */
function fill(tcx, node) {
    var triangle = new Triangle(node.prev.point, node.point, node.next.point);

    // TODO: should copy the constrained_edge value from neighbor triangles
    //       for now constrained_edge values are copied during the legalize
    triangle.markNeighbor(node.prev.triangle);
    triangle.markNeighbor(node.triangle);

    tcx.addToMap(triangle);

    // Update the advancing front
    node.prev.next = node.next;
    node.next.prev = node.prev;


    // If it was legalized the triangle has already been mapped
    if (!legalize(tcx, triangle)) {
        tcx.mapTriangleToNodes(triangle);
    }

    //tcx.removeNode(node);
}

/**
 * Fills holes in the Advancing Front
 * @param {!SweepContext} tcx - SweepContext object
 */
function fillAdvancingFront(tcx, n) {
    // Fill right holes
    var node = n.next;
    while (node.next) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
            break;
        }
        fill(tcx, node);
        node = node.next;
    }

    // Fill left holes
    node = n.prev;
    while (node.prev) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
            break;
        }
        fill(tcx, node);
        node = node.prev;
    }

    // Fill right basins
    if (n.next && n.next.next) {
        if (isBasinAngleRight(n)) {
            fillBasin(tcx, n);
        }
    }
}

/**
 * The basin angle is decided against the horizontal line [1,0].
 * @param {Node} node
 * @return {boolean} true if angle < 3*π/4
 */
function isBasinAngleRight(node) {
    var ax = node.point.x - node.next.next.point.x;
    var ay = node.point.y - node.next.next.point.y;
    assert(ay >= 0, "unordered y");
    return (ax >= 0 || Math.abs(ax) < ay);
}

/**
 * Returns true if triangle was legalized
 * @param {!SweepContext} tcx - SweepContext object
 * @return {boolean}
 */
function legalize(tcx, t) {
    // To legalize a triangle we start by finding if any of the three edges
    // violate the Delaunay condition
    for (var i = 0; i < 3; ++i) {
        if (t.delaunay_edge[i]) {
            continue;
        }
        var ot = t.getNeighbor(i);
        if (ot) {
            var p = t.getPoint(i);
            var op = ot.oppositePoint(t, p);
            var oi = ot.index(op);

            // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)
            // then we should not try to legalize
            if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {
                t.constrained_edge[i] = ot.constrained_edge[oi];
                continue;
            }

            var inside = inCircle(p, t.pointCCW(p), t.pointCW(p), op);
            if (inside) {
                // Lets mark this shared edge as Delaunay
                t.delaunay_edge[i] = true;
                ot.delaunay_edge[oi] = true;

                // Lets rotate shared edge one vertex CW to legalize it
                rotateTrianglePair(t, p, ot, op);

                // We now got one valid Delaunay Edge shared by two triangles
                // This gives us 4 new edges to check for Delaunay

                // Make sure that triangle to node mapping is done only one time for a specific triangle
                var not_legalized = !legalize(tcx, t);
                if (not_legalized) {
                    tcx.mapTriangleToNodes(t);
                }

                not_legalized = !legalize(tcx, ot);
                if (not_legalized) {
                    tcx.mapTriangleToNodes(ot);
                }
                // Reset the Delaunay edges, since they only are valid Delaunay edges
                // until we add a new triangle or point.
                // XXX: need to think about this. Can these edges be tried after we
                //      return to previous recursive level?
                t.delaunay_edge[i] = false;
                ot.delaunay_edge[oi] = false;

                // If triangle have been legalized no need to check the other edges since
                // the recursive legalization will handles those so we can end here.
                return true;
            }
        }
    }
    return false;
}

/**
 * <b>Requirement</b>:<br>
 * 1. a,b and c form a triangle.<br>
 * 2. a and d is know to be on opposite side of bc<br>
 * <pre>
 *                a
 *                +
 *               / \
 *              /   \
 *            b/     \c
 *            +-------+
 *           /    d    \
 *          /           \
 * </pre>
 * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by
 *  a,b and c<br>
 *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>
 *  This preknowledge gives us a way to optimize the incircle test
 * @param pa - triangle point, opposite d
 * @param pb - triangle point
 * @param pc - triangle point
 * @param pd - point opposite a
 * @return {boolean} true if d is inside circle, false if on circle edge
 */
function inCircle(pa, pb, pc, pd) {
    var adx = pa.x - pd.x;
    var ady = pa.y - pd.y;
    var bdx = pb.x - pd.x;
    var bdy = pb.y - pd.y;

    var adxbdy = adx * bdy;
    var bdxady = bdx * ady;
    var oabd = adxbdy - bdxady;
    if (oabd <= 0) {
        return false;
    }

    var cdx = pc.x - pd.x;
    var cdy = pc.y - pd.y;

    var cdxady = cdx * ady;
    var adxcdy = adx * cdy;
    var ocad = cdxady - adxcdy;
    if (ocad <= 0) {
        return false;
    }

    var bdxcdy = bdx * cdy;
    var cdxbdy = cdx * bdy;

    var alift = adx * adx + ady * ady;
    var blift = bdx * bdx + bdy * bdy;
    var clift = cdx * cdx + cdy * cdy;

    var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;
    return det > 0;
}

/**
 * Rotates a triangle pair one vertex CW
 *<pre>
 *       n2                    n2
 *  P +-----+             P +-----+
 *    | t  /|               |\  t |
 *    |   / |               | \   |
 *  n1|  /  |n3           n1|  \  |n3
 *    | /   |    after CW   |   \ |
 *    |/ oT |               | oT \|
 *    +-----+ oP            +-----+
 *       n4                    n4
 * </pre>
 */
function rotateTrianglePair(t, p, ot, op) {
    var n1, n2, n3, n4;
    n1 = t.neighborCCW(p);
    n2 = t.neighborCW(p);
    n3 = ot.neighborCCW(op);
    n4 = ot.neighborCW(op);

    var ce1, ce2, ce3, ce4;
    ce1 = t.getConstrainedEdgeCCW(p);
    ce2 = t.getConstrainedEdgeCW(p);
    ce3 = ot.getConstrainedEdgeCCW(op);
    ce4 = ot.getConstrainedEdgeCW(op);

    var de1, de2, de3, de4;
    de1 = t.getDelaunayEdgeCCW(p);
    de2 = t.getDelaunayEdgeCW(p);
    de3 = ot.getDelaunayEdgeCCW(op);
    de4 = ot.getDelaunayEdgeCW(op);

    t.legalize(p, op);
    ot.legalize(op, p);

    // Remap delaunay_edge
    ot.setDelaunayEdgeCCW(p, de1);
    t.setDelaunayEdgeCW(p, de2);
    t.setDelaunayEdgeCCW(op, de3);
    ot.setDelaunayEdgeCW(op, de4);

    // Remap constrained_edge
    ot.setConstrainedEdgeCCW(p, ce1);
    t.setConstrainedEdgeCW(p, ce2);
    t.setConstrainedEdgeCCW(op, ce3);
    ot.setConstrainedEdgeCW(op, ce4);

    // Remap neighbors
    // XXX: might optimize the markNeighbor by keeping track of
    //      what side should be assigned to what neighbor after the
    //      rotation. Now mark neighbor does lots of testing to find
    //      the right side.
    t.clearNeighbors();
    ot.clearNeighbors();
    if (n1) {
        ot.markNeighbor(n1);
    }
    if (n2) {
        t.markNeighbor(n2);
    }
    if (n3) {
        t.markNeighbor(n3);
    }
    if (n4) {
        ot.markNeighbor(n4);
    }
    t.markNeighbor(ot);
}

/**
 * Fills a basin that has formed on the Advancing Front to the right
 * of given node.<br>
 * First we decide a left,bottom and right node that forms the
 * boundaries of the basin. Then we do a reqursive fill.
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - starting node, this or next node will be left node
 */
function fillBasin(tcx, node) {
    if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
        tcx.basin.left_node = node.next.next;
    } else {
        tcx.basin.left_node = node.next;
    }

    // Find the bottom and right node
    tcx.basin.bottom_node = tcx.basin.left_node;
    while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {
        tcx.basin.bottom_node = tcx.basin.bottom_node.next;
    }
    if (tcx.basin.bottom_node === tcx.basin.left_node) {
        // No valid basin
        return;
    }

    tcx.basin.right_node = tcx.basin.bottom_node;
    while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {
        tcx.basin.right_node = tcx.basin.right_node.next;
    }
    if (tcx.basin.right_node === tcx.basin.bottom_node) {
        // No valid basins
        return;
    }

    tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;
    tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;

    fillBasinReq(tcx, tcx.basin.bottom_node);
}

/**
 * Recursive algorithm to fill a Basin with triangles
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - bottom_node
 */
function fillBasinReq(tcx, node) {
    // if shallow stop filling
    if (isShallow(tcx, node)) {
        return;
    }

    fill(tcx, node);

    var o;
    if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {
        return;
    } else if (node.prev === tcx.basin.left_node) {
        o = orient2d(node.point, node.next.point, node.next.next.point);
        if (o === Orientation.CW) {
            return;
        }
        node = node.next;
    } else if (node.next === tcx.basin.right_node) {
        o = orient2d(node.point, node.prev.point, node.prev.prev.point);
        if (o === Orientation.CCW) {
            return;
        }
        node = node.prev;
    } else {
        // Continue with the neighbor node with lowest Y value
        if (node.prev.point.y < node.next.point.y) {
            node = node.prev;
        } else {
            node = node.next;
        }
    }

    fillBasinReq(tcx, node);
}

function isShallow(tcx, node) {
    var height;
    if (tcx.basin.left_highest) {
        height = tcx.basin.left_node.point.y - node.point.y;
    } else {
        height = tcx.basin.right_node.point.y - node.point.y;
    }

    // if shallow stop filling
    if (tcx.basin.width > height) {
        return true;
    }
    return false;
}

function fillEdgeEvent(tcx, edge, node) {
    if (tcx.edge_event.right) {
        fillRightAboveEdgeEvent(tcx, edge, node);
    } else {
        fillLeftAboveEdgeEvent(tcx, edge, node);
    }
}

function fillRightAboveEdgeEvent(tcx, edge, node) {
    while (node.next.point.x < edge.p.x) {
        // Check if next node is below the edge
        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            fillRightBelowEdgeEvent(tcx, edge, node);
        } else {
            node = node.next;
        }
    }
}

function fillRightBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x < edge.p.x) {
        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
            // Concave
            fillRightConcaveEdgeEvent(tcx, edge, node);
        } else {
            // Convex
            fillRightConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillRightBelowEdgeEvent(tcx, edge, node);
        }
    }
}

function fillRightConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.next);
    if (node.next.point !== edge.p) {
        // Next above or below edge?
        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            // Below
            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
                // Next is concave
                fillRightConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Next is convex
                /* jshint noempty:false */
            }
        }
    }
}

function fillRightConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {
        // Concave
        fillRightConcaveEdgeEvent(tcx, edge, node.next);
    } else {
        // Convex
        // Next above or below edge?
        if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {
            // Below
            fillRightConvexEdgeEvent(tcx, edge, node.next);
        } else {
            // Above
            /* jshint noempty:false */
        }
    }
}

function fillLeftAboveEdgeEvent(tcx, edge, node) {
    while (node.prev.point.x > edge.p.x) {
        // Check if next node is below the edge
        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            fillLeftBelowEdgeEvent(tcx, edge, node);
        } else {
            node = node.prev;
        }
    }
}

function fillLeftBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x > edge.p.x) {
        if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
            // Concave
            fillLeftConcaveEdgeEvent(tcx, edge, node);
        } else {
            // Convex
            fillLeftConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillLeftBelowEdgeEvent(tcx, edge, node);
        }
    }
}

function fillLeftConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {
        // Concave
        fillLeftConcaveEdgeEvent(tcx, edge, node.prev);
    } else {
        // Convex
        // Next above or below edge?
        if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {
            // Below
            fillLeftConvexEdgeEvent(tcx, edge, node.prev);
        } else {
            // Above
            /* jshint noempty:false */
        }
    }
}

function fillLeftConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.prev);
    if (node.prev.point !== edge.p) {
        // Next above or below edge?
        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            // Below
            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
                // Next is concave
                fillLeftConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Next is convex
                /* jshint noempty:false */
            }
        }
    }
}

function flipEdgeEvent(tcx, ep, eq, t, p) {
    var ot = t.neighborAcross(p);
    assert(ot, "FLIP failed due to missing triangle!");

    var op = ot.oppositePoint(t, p);

    // Additional check from Java version (see issue #88)
    if (t.getConstrainedEdgeAcross(p)) {
        var index = t.index(p);
        throw new PointError("poly2tri Intersecting Constraints",
                [p, op, t.getPoint((index + 1) % 3), t.getPoint((index + 2) % 3)]);
    }

    if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {
        // Lets rotate shared edge one vertex CW
        rotateTrianglePair(t, p, ot, op);
        tcx.mapTriangleToNodes(t);
        tcx.mapTriangleToNodes(ot);

        // XXX: in the original C++ code for the next 2 lines, we are
        // comparing point values (and not pointers). In this JavaScript
        // code, we are comparing point references (pointers). This works
        // because we can't have 2 different points with the same values.
        // But to be really equivalent, we should use "Point.equals" here.
        if (p === eq && op === ep) {
            if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {
                t.markConstrainedEdgeByPoints(ep, eq);
                ot.markConstrainedEdgeByPoints(ep, eq);
                legalize(tcx, t);
                legalize(tcx, ot);
            } else {
                // XXX: I think one of the triangles should be legalized here?
                /* jshint noempty:false */
            }
        } else {
            var o = orient2d(eq, op, ep);
            t = nextFlipTriangle(tcx, o, t, ot, p, op);
            flipEdgeEvent(tcx, ep, eq, t, p);
        }
    } else {
        var newP = nextFlipPoint(ep, eq, ot, op);
        flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);
        edgeEventByPoints(tcx, ep, eq, t, p);
    }
}

/**
 * After a flip we have two triangles and know that only one will still be
 * intersecting the edge. So decide which to contiune with and legalize the other
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param o - should be the result of an orient2d( eq, op, ep )
 * @param t - triangle 1
 * @param ot - triangle 2
 * @param p - a point shared by both triangles
 * @param op - another point shared by both triangles
 * @return returns the triangle still intersecting the edge
 */
function nextFlipTriangle(tcx, o, t, ot, p, op) {
    var edge_index;
    if (o === Orientation.CCW) {
        // ot is not crossing edge after flip
        edge_index = ot.edgeIndex(p, op);
        ot.delaunay_edge[edge_index] = true;
        legalize(tcx, ot);
        ot.clearDelaunayEdges();
        return t;
    }

    // t is not crossing edge after flip
    edge_index = t.edgeIndex(p, op);

    t.delaunay_edge[edge_index] = true;
    legalize(tcx, t);
    t.clearDelaunayEdges();
    return ot;
}

/**
 * When we need to traverse from one triangle to the next we need
 * the point in current triangle that is the opposite point to the next
 * triangle.
 */
function nextFlipPoint(ep, eq, ot, op) {
    var o2d = orient2d(eq, op, ep);
    if (o2d === Orientation.CW) {
        // Right
        return ot.pointCCW(op);
    } else if (o2d === Orientation.CCW) {
        // Left
        return ot.pointCW(op);
    } else {
        throw new PointError("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [eq, op, ep]);
    }
}

/**
 * Scan part of the FlipScan algorithm<br>
 * When a triangle pair isn't flippable we will scan for the next
 * point that is inside the flip triangle scan area. When found
 * we generate a new flipEdgeEvent
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param ep - last point on the edge we are traversing
 * @param eq - first point on the edge we are traversing
 * @param {!Triangle} flip_triangle - the current triangle sharing the point eq with edge
 * @param t
 * @param p
 */
function flipScanEdgeEvent(tcx, ep, eq, flip_triangle, t, p) {
    var ot = t.neighborAcross(p);
    assert(ot, "FLIP failed due to missing triangle");

    var op = ot.oppositePoint(t, p);

    if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {
        // flip with new edge op.eq
        flipEdgeEvent(tcx, eq, op, ot, op);
    } else {
        var newP = nextFlipPoint(ep, eq, ot, op);
        flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);
    }
}


// ----------------------------------------------------------------------Exports

exports.triangulate = triangulate;

},{"./advancingfront":2,"./assert":3,"./pointerror":5,"./triangle":9,"./utils":10}],8:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:6 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var PointError = _dereq_('./pointerror');
var Point = _dereq_('./point');
var Triangle = _dereq_('./triangle');
var sweep = _dereq_('./sweep');
var AdvancingFront = _dereq_('./advancingfront');
var Node = AdvancingFront.Node;


// ------------------------------------------------------------------------utils

/**
 * Initial triangle factor, seed triangle will extend 30% of
 * PointSet width to both left and right.
 * @private
 * @const
 */
var kAlpha = 0.3;


// -------------------------------------------------------------------------Edge
/**
 * Represents a simple polygon's edge
 * @constructor
 * @struct
 * @private
 * @param {Point} p1
 * @param {Point} p2
 * @throw {PointError} if p1 is same as p2
 */
var Edge = function(p1, p2) {
    this.p = p1;
    this.q = p2;

    if (p1.y > p2.y) {
        this.q = p1;
        this.p = p2;
    } else if (p1.y === p2.y) {
        if (p1.x > p2.x) {
            this.q = p1;
            this.p = p2;
        } else if (p1.x === p2.x) {
            throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);
        }
    }

    if (!this.q._p2t_edge_list) {
        this.q._p2t_edge_list = [];
    }
    this.q._p2t_edge_list.push(this);
};


// ------------------------------------------------------------------------Basin
/**
 * @constructor
 * @struct
 * @private
 */
var Basin = function() {
    /** @type {Node} */
    this.left_node = null;
    /** @type {Node} */
    this.bottom_node = null;
    /** @type {Node} */
    this.right_node = null;
    /** @type {number} */
    this.width = 0.0;
    /** @type {boolean} */
    this.left_highest = false;
};

Basin.prototype.clear = function() {
    this.left_node = null;
    this.bottom_node = null;
    this.right_node = null;
    this.width = 0.0;
    this.left_highest = false;
};

// --------------------------------------------------------------------EdgeEvent
/**
 * @constructor
 * @struct
 * @private
 */
var EdgeEvent = function() {
    /** @type {Edge} */
    this.constrained_edge = null;
    /** @type {boolean} */
    this.right = false;
};

// ----------------------------------------------------SweepContext (public API)
/**
 * SweepContext constructor option
 * @typedef {Object} SweepContextOptions
 * @property {boolean=} cloneArrays - if <code>true</code>, do a shallow copy of the Array parameters
 *                  (contour, holes). Points inside arrays are never copied.
 *                  Default is <code>false</code> : keep a reference to the array arguments,
 *                  who will be modified in place.
 */
/**
 * Constructor for the triangulation context.
 * It accepts a simple polyline (with non repeating points), 
 * which defines the constrained edges.
 *
 * @example
 *          var contour = [
 *              new poly2tri.Point(100, 100),
 *              new poly2tri.Point(100, 300),
 *              new poly2tri.Point(300, 300),
 *              new poly2tri.Point(300, 100)
 *          ];
 *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
 * @example
 *          var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
 *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
 * @constructor
 * @public
 * @struct
 * @param {Array.<XY>} contour - array of point objects. The points can be either {@linkcode Point} instances,
 *          or any "Point like" custom class with <code>{x, y}</code> attributes.
 * @param {SweepContextOptions=} options - constructor options
 */
var SweepContext = function(contour, options) {
    options = options || {};
    this.triangles_ = [];
    this.map_ = [];
    this.points_ = (options.cloneArrays ? contour.slice(0) : contour);
    this.edge_list = [];

    // Bounding box of all points. Computed at the start of the triangulation, 
    // it is stored in case it is needed by the caller.
    this.pmin_ = this.pmax_ = null;

    /**
     * Advancing front
     * @private
     * @type {AdvancingFront}
     */
    this.front_ = null;

    /**
     * head point used with advancing front
     * @private
     * @type {Point}
     */
    this.head_ = null;

    /**
     * tail point used with advancing front
     * @private
     * @type {Point}
     */
    this.tail_ = null;

    /**
     * @private
     * @type {Node}
     */
    this.af_head_ = null;
    /**
     * @private
     * @type {Node}
     */
    this.af_middle_ = null;
    /**
     * @private
     * @type {Node}
     */
    this.af_tail_ = null;

    this.basin = new Basin();
    this.edge_event = new EdgeEvent();

    this.initEdges(this.points_);
};


/**
 * Add a hole to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var hole = [
 *          new poly2tri.Point(200, 200),
 *          new poly2tri.Point(200, 250),
 *          new poly2tri.Point(250, 250)
 *      ];
 *      swctx.addHole(hole);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addHole([{x:200, y:200}, {x:200, y:250}, {x:250, y:250}]);
 * @public
 * @param {Array.<XY>} polyline - array of "Point like" objects with {x,y}
 */
SweepContext.prototype.addHole = function(polyline) {
    this.initEdges(polyline);
    var i, len = polyline.length;
    for (i = 0; i < len; i++) {
        this.points_.push(polyline[i]);
    }
    return this; // for chaining
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#addHole} instead
 */
SweepContext.prototype.AddHole = SweepContext.prototype.addHole;


/**
 * Add several holes to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var holes = [
 *          [ new poly2tri.Point(200, 200), new poly2tri.Point(200, 250), new poly2tri.Point(250, 250) ],
 *          [ new poly2tri.Point(300, 300), new poly2tri.Point(300, 350), new poly2tri.Point(350, 350) ]
 *      ];
 *      swctx.addHoles(holes);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var holes = [
 *          [{x:200, y:200}, {x:200, y:250}, {x:250, y:250}],
 *          [{x:300, y:300}, {x:300, y:350}, {x:350, y:350}]
 *      ];
 *      swctx.addHoles(holes);
 * @public
 * @param {Array.<Array.<XY>>} holes - array of array of "Point like" objects with {x,y}
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.addHoles = function(holes) {
    var i, len = holes.length;
    for (i = 0; i < len; i++) {
        this.initEdges(holes[i]);
    }
    this.points_ = this.points_.concat.apply(this.points_, holes);
    return this; // for chaining
};


/**
 * Add a Steiner point to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var point = new poly2tri.Point(150, 150);
 *      swctx.addPoint(point);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addPoint({x:150, y:150});
 * @public
 * @param {XY} point - any "Point like" object with {x,y}
 */
SweepContext.prototype.addPoint = function(point) {
    this.points_.push(point);
    return this; // for chaining
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#addPoint} instead
 */
SweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;


/**
 * Add several Steiner points to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var points = [
 *          new poly2tri.Point(150, 150),
 *          new poly2tri.Point(200, 250),
 *          new poly2tri.Point(250, 250)
 *      ];
 *      swctx.addPoints(points);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addPoints([{x:150, y:150}, {x:200, y:250}, {x:250, y:250}]);
 * @public
 * @param {Array.<XY>} points - array of "Point like" object with {x,y}
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.addPoints = function(points) {
    this.points_ = this.points_.concat(points);
    return this; // for chaining
};


/**
 * Triangulate the polygon with holes and Steiner points.
 * Do this AFTER you've added the polyline, holes, and Steiner points
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 * @public
 */
// Shortcut method for sweep.triangulate(SweepContext).
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.triangulate = function() {
    sweep.triangulate(this);
    return this; // for chaining
};


/**
 * Get the bounding box of the provided constraints (contour, holes and 
 * Steinter points). Warning : these values are not available if the triangulation 
 * has not been done yet.
 * @public
 * @returns {{min:Point,max:Point}} object with 'min' and 'max' Point
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.getBoundingBox = function() {
    return {min: this.pmin_, max: this.pmax_};
};

/**
 * Get result of triangulation.
 * The output triangles have vertices which are references
 * to the initial input points (not copies): any custom fields in the
 * initial points can be retrieved in the output triangles.
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 * @example
 *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 *      typeof triangles[0].getPoint(0).id
 *      // → "number"
 * @public
 * @returns {array<Triangle>}   array of triangles
 */
SweepContext.prototype.getTriangles = function() {
    return this.triangles_;
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#getTriangles} instead
 */
SweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;


// ---------------------------------------------------SweepContext (private API)

/** @private */
SweepContext.prototype.front = function() {
    return this.front_;
};

/** @private */
SweepContext.prototype.pointCount = function() {
    return this.points_.length;
};

/** @private */
SweepContext.prototype.head = function() {
    return this.head_;
};

/** @private */
SweepContext.prototype.setHead = function(p1) {
    this.head_ = p1;
};

/** @private */
SweepContext.prototype.tail = function() {
    return this.tail_;
};

/** @private */
SweepContext.prototype.setTail = function(p1) {
    this.tail_ = p1;
};

/** @private */
SweepContext.prototype.getMap = function() {
    return this.map_;
};

/** @private */
SweepContext.prototype.initTriangulation = function() {
    var xmax = this.points_[0].x;
    var xmin = this.points_[0].x;
    var ymax = this.points_[0].y;
    var ymin = this.points_[0].y;

    // Calculate bounds
    var i, len = this.points_.length;
    for (i = 1; i < len; i++) {
        var p = this.points_[i];
        /* jshint expr:true */
        (p.x > xmax) && (xmax = p.x);
        (p.x < xmin) && (xmin = p.x);
        (p.y > ymax) && (ymax = p.y);
        (p.y < ymin) && (ymin = p.y);
    }
    this.pmin_ = new Point(xmin, ymin);
    this.pmax_ = new Point(xmax, ymax);

    var dx = kAlpha * (xmax - xmin);
    var dy = kAlpha * (ymax - ymin);
    this.head_ = new Point(xmax + dx, ymin - dy);
    this.tail_ = new Point(xmin - dx, ymin - dy);

    // Sort points along y-axis
    this.points_.sort(Point.compare);
};

/** @private */
SweepContext.prototype.initEdges = function(polyline) {
    var i, len = polyline.length;
    for (i = 0; i < len; ++i) {
        this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));
    }
};

/** @private */
SweepContext.prototype.getPoint = function(index) {
    return this.points_[index];
};

/** @private */
SweepContext.prototype.addToMap = function(triangle) {
    this.map_.push(triangle);
};

/** @private */
SweepContext.prototype.locateNode = function(point) {
    return this.front_.locateNode(point.x);
};

/** @private */
SweepContext.prototype.createAdvancingFront = function() {
    var head;
    var middle;
    var tail;
    // Initial triangle
    var triangle = new Triangle(this.points_[0], this.tail_, this.head_);

    this.map_.push(triangle);

    head = new Node(triangle.getPoint(1), triangle);
    middle = new Node(triangle.getPoint(0), triangle);
    tail = new Node(triangle.getPoint(2));

    this.front_ = new AdvancingFront(head, tail);

    head.next = middle;
    middle.next = tail;
    middle.prev = head;
    tail.prev = middle;
};

/** @private */
SweepContext.prototype.removeNode = function(node) {
    // do nothing
    /* jshint unused:false */
};

/** @private */
SweepContext.prototype.mapTriangleToNodes = function(t) {
    for (var i = 0; i < 3; ++i) {
        if (!t.getNeighbor(i)) {
            var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));
            if (n) {
                n.triangle = t;
            }
        }
    }
};

/** @private */
SweepContext.prototype.removeFromMap = function(triangle) {
    var i, map = this.map_, len = map.length;
    for (i = 0; i < len; i++) {
        if (map[i] === triangle) {
            map.splice(i, 1);
            break;
        }
    }
};

/**
 * Do a depth first traversal to collect triangles
 * @private
 * @param {Triangle} triangle start
 */
SweepContext.prototype.meshClean = function(triangle) {
    // New implementation avoids recursive calls and use a loop instead.
    // Cf. issues # 57, 65 and 69.
    var triangles = [triangle], t, i;
    /* jshint boss:true */
    while (t = triangles.pop()) {
        if (!t.isInterior()) {
            t.setInterior(true);
            this.triangles_.push(t);
            for (i = 0; i < 3; i++) {
                if (!t.constrained_edge[i]) {
                    triangles.push(t.getNeighbor(i));
                }
            }
        }
    }
};

// ----------------------------------------------------------------------Exports

module.exports = SweepContext;

},{"./advancingfront":2,"./point":4,"./pointerror":5,"./sweep":7,"./triangle":9}],9:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:10 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var xy = _dereq_("./xy");


// ---------------------------------------------------------------------Triangle
/**
 * Triangle class.<br>
 * Triangle-based data structures are known to have better performance than
 * quad-edge structures.
 * See: J. Shewchuk, "Triangle: Engineering a 2D Quality Mesh Generator and
 * Delaunay Triangulator", "Triangulations in CGAL"
 *
 * @constructor
 * @struct
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 */
var Triangle = function(a, b, c) {
    /**
     * Triangle points
     * @private
     * @type {Array.<XY>}
     */
    this.points_ = [a, b, c];

    /**
     * Neighbor list
     * @private
     * @type {Array.<Triangle>}
     */
    this.neighbors_ = [null, null, null];

    /**
     * Has this triangle been marked as an interior triangle?
     * @private
     * @type {boolean}
     */
    this.interior_ = false;

    /**
     * Flags to determine if an edge is a Constrained edge
     * @private
     * @type {Array.<boolean>}
     */
    this.constrained_edge = [false, false, false];

    /**
     * Flags to determine if an edge is a Delauney edge
     * @private
     * @type {Array.<boolean>}
     */
    this.delaunay_edge = [false, false, false];
};

var p2s = xy.toString;
/**
 * For pretty printing ex. <code>"[(5;42)(10;20)(21;30)]"</code>.
 * @public
 * @return {string}
 */
Triangle.prototype.toString = function() {
    return ("[" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + "]");
};

/**
 * Get one vertice of the triangle.
 * The output triangles of a triangulation have vertices which are references
 * to the initial input points (not copies): any custom fields in the
 * initial points can be retrieved in the output triangles.
 * @example
 *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 *      typeof triangles[0].getPoint(0).id
 *      // → "number"
 * @param {number} index - vertice index: 0, 1 or 2
 * @public
 * @returns {XY}
 */
Triangle.prototype.getPoint = function(index) {
    return this.points_[index];
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode Triangle#getPoint} instead
 */
Triangle.prototype.GetPoint = Triangle.prototype.getPoint;

/**
 * Get all 3 vertices of the triangle as an array
 * @public
 * @return {Array.<XY>}
 */
// Method added in the JavaScript version (was not present in the c++ version)
Triangle.prototype.getPoints = function() {
    return this.points_;
};

/**
 * @private
 * @param {number} index
 * @returns {?Triangle}
 */
Triangle.prototype.getNeighbor = function(index) {
    return this.neighbors_[index];
};

/**
 * Test if this Triangle contains the Point object given as parameter as one of its vertices.
 * Only point references are compared, not values.
 * @public
 * @param {XY} point - point object with {x,y}
 * @return {boolean} <code>True</code> if the Point object is of the Triangle's vertices,
 *         <code>false</code> otherwise.
 */
Triangle.prototype.containsPoint = function(point) {
    var points = this.points_;
    // Here we are comparing point references, not values
    return (point === points[0] || point === points[1] || point === points[2]);
};

/**
 * Test if this Triangle contains the Edge object given as parameter as its
 * bounding edges. Only point references are compared, not values.
 * @private
 * @param {Edge} edge
 * @return {boolean} <code>True</code> if the Edge object is of the Triangle's bounding
 *         edges, <code>false</code> otherwise.
 */
Triangle.prototype.containsEdge = function(edge) {
    return this.containsPoint(edge.p) && this.containsPoint(edge.q);
};

/**
 * Test if this Triangle contains the two Point objects given as parameters among its vertices.
 * Only point references are compared, not values.
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @return {boolean}
 */
Triangle.prototype.containsPoints = function(p1, p2) {
    return this.containsPoint(p1) && this.containsPoint(p2);
};

/**
 * Has this triangle been marked as an interior triangle?
 * @returns {boolean}
 */
Triangle.prototype.isInterior = function() {
    return this.interior_;
};

/**
 * Mark this triangle as an interior triangle
 * @private
 * @param {boolean} interior
 * @returns {Triangle} this
 */
Triangle.prototype.setInterior = function(interior) {
    this.interior_ = interior;
    return this;
};

/**
 * Update neighbor pointers.
 * @private
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @param {Triangle} t Triangle object.
 * @throws {Error} if can't find objects
 */
Triangle.prototype.markNeighborPointers = function(p1, p2, t) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if ((p1 === points[2] && p2 === points[1]) || (p1 === points[1] && p2 === points[2])) {
        this.neighbors_[0] = t;
    } else if ((p1 === points[0] && p2 === points[2]) || (p1 === points[2] && p2 === points[0])) {
        this.neighbors_[1] = t;
    } else if ((p1 === points[0] && p2 === points[1]) || (p1 === points[1] && p2 === points[0])) {
        this.neighbors_[2] = t;
    } else {
        throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');
    }
};

/**
 * Exhaustive search to update neighbor pointers
 * @private
 * @param {!Triangle} t
 */
Triangle.prototype.markNeighbor = function(t) {
    var points = this.points_;
    if (t.containsPoints(points[1], points[2])) {
        this.neighbors_[0] = t;
        t.markNeighborPointers(points[1], points[2], this);
    } else if (t.containsPoints(points[0], points[2])) {
        this.neighbors_[1] = t;
        t.markNeighborPointers(points[0], points[2], this);
    } else if (t.containsPoints(points[0], points[1])) {
        this.neighbors_[2] = t;
        t.markNeighborPointers(points[0], points[1], this);
    }
};


Triangle.prototype.clearNeighbors = function() {
    this.neighbors_[0] = null;
    this.neighbors_[1] = null;
    this.neighbors_[2] = null;
};

Triangle.prototype.clearDelaunayEdges = function() {
    this.delaunay_edge[0] = false;
    this.delaunay_edge[1] = false;
    this.delaunay_edge[2] = false;
};

/**
 * Returns the point clockwise to the given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.pointCW = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return points[2];
    } else if (p === points[1]) {
        return points[0];
    } else if (p === points[2]) {
        return points[1];
    } else {
        return null;
    }
};

/**
 * Returns the point counter-clockwise to the given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.pointCCW = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return points[1];
    } else if (p === points[1]) {
        return points[2];
    } else if (p === points[2]) {
        return points[0];
    } else {
        return null;
    }
};

/**
 * Returns the neighbor clockwise to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.neighborCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[1];
    } else if (p === this.points_[1]) {
        return this.neighbors_[2];
    } else {
        return this.neighbors_[0];
    }
};

/**
 * Returns the neighbor counter-clockwise to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.neighborCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[2];
    } else if (p === this.points_[1]) {
        return this.neighbors_[0];
    } else {
        return this.neighbors_[1];
    }
};

Triangle.prototype.getConstrainedEdgeCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[1];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[2];
    } else {
        return this.constrained_edge[0];
    }
};

Triangle.prototype.getConstrainedEdgeCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[2];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[0];
    } else {
        return this.constrained_edge[1];
    }
};

// Additional check from Java version (see issue #88)
Triangle.prototype.getConstrainedEdgeAcross = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[0];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[1];
    } else {
        return this.constrained_edge[2];
    }
};

Triangle.prototype.setConstrainedEdgeCW = function(p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.constrained_edge[1] = ce;
    } else if (p === this.points_[1]) {
        this.constrained_edge[2] = ce;
    } else {
        this.constrained_edge[0] = ce;
    }
};

Triangle.prototype.setConstrainedEdgeCCW = function(p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.constrained_edge[2] = ce;
    } else if (p === this.points_[1]) {
        this.constrained_edge[0] = ce;
    } else {
        this.constrained_edge[1] = ce;
    }
};

Triangle.prototype.getDelaunayEdgeCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.delaunay_edge[1];
    } else if (p === this.points_[1]) {
        return this.delaunay_edge[2];
    } else {
        return this.delaunay_edge[0];
    }
};

Triangle.prototype.getDelaunayEdgeCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.delaunay_edge[2];
    } else if (p === this.points_[1]) {
        return this.delaunay_edge[0];
    } else {
        return this.delaunay_edge[1];
    }
};

Triangle.prototype.setDelaunayEdgeCW = function(p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.delaunay_edge[1] = e;
    } else if (p === this.points_[1]) {
        this.delaunay_edge[2] = e;
    } else {
        this.delaunay_edge[0] = e;
    }
};

Triangle.prototype.setDelaunayEdgeCCW = function(p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.delaunay_edge[2] = e;
    } else if (p === this.points_[1]) {
        this.delaunay_edge[0] = e;
    } else {
        this.delaunay_edge[1] = e;
    }
};

/**
 * The neighbor across to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 * @returns {Triangle}
 */
Triangle.prototype.neighborAcross = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[0];
    } else if (p === this.points_[1]) {
        return this.neighbors_[1];
    } else {
        return this.neighbors_[2];
    }
};

/**
 * @private
 * @param {!Triangle} t Triangle object.
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.oppositePoint = function(t, p) {
    var cw = t.pointCW(p);
    return this.pointCW(cw);
};

/**
 * Legalize triangle by rotating clockwise around oPoint
 * @private
 * @param {XY} opoint - point object with {x,y}
 * @param {XY} npoint - point object with {x,y}
 * @throws {Error} if oPoint can not be found
 */
Triangle.prototype.legalize = function(opoint, npoint) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (opoint === points[0]) {
        points[1] = points[0];
        points[0] = points[2];
        points[2] = npoint;
    } else if (opoint === points[1]) {
        points[2] = points[1];
        points[1] = points[0];
        points[0] = npoint;
    } else if (opoint === points[2]) {
        points[0] = points[2];
        points[2] = points[1];
        points[1] = npoint;
    } else {
        throw new Error('poly2tri Invalid Triangle.legalize() call');
    }
};

/**
 * Returns the index of a point in the triangle. 
 * The point *must* be a reference to one of the triangle's vertices.
 * @private
 * @param {XY} p - point object with {x,y}
 * @returns {number} index 0, 1 or 2
 * @throws {Error} if p can not be found
 */
Triangle.prototype.index = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return 0;
    } else if (p === points[1]) {
        return 1;
    } else if (p === points[2]) {
        return 2;
    } else {
        throw new Error('poly2tri Invalid Triangle.index() call');
    }
};

/**
 * @private
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @return {number} index 0, 1 or 2, or -1 if errror
 */
Triangle.prototype.edgeIndex = function(p1, p2) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p1 === points[0]) {
        if (p2 === points[1]) {
            return 2;
        } else if (p2 === points[2]) {
            return 1;
        }
    } else if (p1 === points[1]) {
        if (p2 === points[2]) {
            return 0;
        } else if (p2 === points[0]) {
            return 2;
        }
    } else if (p1 === points[2]) {
        if (p2 === points[0]) {
            return 1;
        } else if (p2 === points[1]) {
            return 0;
        }
    }
    return -1;
};

/**
 * Mark an edge of this triangle as constrained.
 * @private
 * @param {number} index - edge index
 */
Triangle.prototype.markConstrainedEdgeByIndex = function(index) {
    this.constrained_edge[index] = true;
};
/**
 * Mark an edge of this triangle as constrained.
 * @private
 * @param {Edge} edge instance
 */
Triangle.prototype.markConstrainedEdgeByEdge = function(edge) {
    this.markConstrainedEdgeByPoints(edge.p, edge.q);
};
/**
 * Mark an edge of this triangle as constrained.
 * This method takes two Point instances defining the edge of the triangle.
 * @private
 * @param {XY} p - point object with {x,y}
 * @param {XY} q - point object with {x,y}
 */
Triangle.prototype.markConstrainedEdgeByPoints = function(p, q) {
    var points = this.points_;
    // Here we are comparing point references, not values        
    if ((q === points[0] && p === points[1]) || (q === points[1] && p === points[0])) {
        this.constrained_edge[2] = true;
    } else if ((q === points[0] && p === points[2]) || (q === points[2] && p === points[0])) {
        this.constrained_edge[1] = true;
    } else if ((q === points[1] && p === points[2]) || (q === points[2] && p === points[1])) {
        this.constrained_edge[0] = true;
    }
};


// ---------------------------------------------------------Exports (public API)

module.exports = Triangle;

},{"./xy":11}],10:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/**
 * Precision to detect repeated or collinear points
 * @private
 * @const {number}
 * @default
 */
var EPSILON = 1e-12;
exports.EPSILON = EPSILON;

/**
 * @private
 * @enum {number}
 * @readonly
 */
var Orientation = {
    "CW": 1,
    "CCW": -1,
    "COLLINEAR": 0
};
exports.Orientation = Orientation;


/**
 * Formula to calculate signed area<br>
 * Positive if CCW<br>
 * Negative if CW<br>
 * 0 if collinear<br>
 * <pre>
 * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
 *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
 * </pre>
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @return {Orientation}
 */
function orient2d(pa, pb, pc) {
    var detleft = (pa.x - pc.x) * (pb.y - pc.y);
    var detright = (pa.y - pc.y) * (pb.x - pc.x);
    var val = detleft - detright;
    if (val > -(EPSILON) && val < (EPSILON)) {
        return Orientation.COLLINEAR;
    } else if (val > 0) {
        return Orientation.CCW;
    } else {
        return Orientation.CW;
    }
}
exports.orient2d = orient2d;


/**
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @param {!XY} pd  point object with {x,y}
 * @return {boolean}
 */
function inScanArea(pa, pb, pc, pd) {
    var oadb = (pa.x - pb.x) * (pd.y - pb.y) - (pd.x - pb.x) * (pa.y - pb.y);
    if (oadb >= -EPSILON) {
        return false;
    }

    var oadc = (pa.x - pc.x) * (pd.y - pc.y) - (pd.x - pc.x) * (pa.y - pc.y);
    if (oadc <= EPSILON) {
        return false;
    }
    return true;
}
exports.inScanArea = inScanArea;


/**
 * Check if the angle between (pa,pb) and (pa,pc) is obtuse i.e. (angle > π/2 || angle < -π/2)
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @return {boolean} true if angle is obtuse
 */
function isAngleObtuse(pa, pb, pc) {
    var ax = pb.x - pa.x;
    var ay = pb.y - pa.y;
    var bx = pc.x - pa.x;
    var by = pc.y - pa.y;
    return (ax * bx + ay * by) < 0;
}
exports.isAngleObtuse = isAngleObtuse;


},{}],11:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/**
 * The following functions operate on "Point" or any "Point like" object with {x,y},
 * as defined by the {@link XY} type
 * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
 * @module
 * @private
 */

/**
 * poly2tri.js supports using custom point class instead of {@linkcode Point}.
 * Any "Point like" object with <code>{x, y}</code> attributes is supported
 * to initialize the SweepContext polylines and points
 * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
 *
 * poly2tri.js might add extra fields to the point objects when computing the
 * triangulation : they are prefixed with <code>_p2t_</code> to avoid collisions
 * with fields in the custom class.
 *
 * @example
 *      var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *
 * @typedef {Object} XY
 * @property {number} x - x coordinate
 * @property {number} y - y coordinate
 */


/**
 * Point pretty printing : prints x and y coordinates.
 * @example
 *      xy.toStringBase({x:5, y:42})
 *      // → "(5;42)"
 * @protected
 * @param {!XY} p - point object with {x,y}
 * @returns {string} <code>"(x;y)"</code>
 */
function toStringBase(p) {
    return ("(" + p.x + ";" + p.y + ")");
}

/**
 * Point pretty printing. Delegates to the point's custom "toString()" method if exists,
 * else simply prints x and y coordinates.
 * @example
 *      xy.toString({x:5, y:42})
 *      // → "(5;42)"
 * @example
 *      xy.toString({x:5,y:42,toString:function() {return this.x+":"+this.y;}})
 *      // → "5:42"
 * @param {!XY} p - point object with {x,y}
 * @returns {string} <code>"(x;y)"</code>
 */
function toString(p) {
    // Try a custom toString first, and fallback to own implementation if none
    var s = p.toString();
    return (s === '[object Object]' ? toStringBase(p) : s);
}


/**
 * Compare two points component-wise. Ordered by y axis first, then x axis.
 * @param {!XY} a - point object with {x,y}
 * @param {!XY} b - point object with {x,y}
 * @return {number} <code>&lt; 0</code> if <code>a &lt; b</code>,
 *         <code>&gt; 0</code> if <code>a &gt; b</code>, 
 *         <code>0</code> otherwise.
 */
function compare(a, b) {
    if (a.y === b.y) {
        return a.x - b.x;
    } else {
        return a.y - b.y;
    }
}

/**
 * Test two Point objects for equality.
 * @param {!XY} a - point object with {x,y}
 * @param {!XY} b - point object with {x,y}
 * @return {boolean} <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.
 */
function equals(a, b) {
    return a.x === b.x && a.y === b.y;
}


module.exports = {
    toString: toString,
    toStringBase: toStringBase,
    compare: compare,
    equals: equals
};

},{}]},{},[6])
(6)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/Lau/www/svjelly/src/core/Commands.js":[function(require,module,exports){
module.exports = {
	MOVE_TO: 1,
	LINE_TO: 2,
	BEZIER_TO: 3,
	QUADRA_TO: 4,
	CIRCLE: 5,
	ELLIPSE: 6
};

},{}],"/Users/Lau/www/svjelly/src/core/ConfObject.js":[function(require,module,exports){
module.exports = {

	definition: 1,
	worldWidth: 20,
	multiCanvas: true,
	wind: 3,
	debug: false,
	gravity: [0, -9.8],
	groups:
	{
		default: { fixed: true, physics: { bodyType: 'ghost' } },
		ghost: { fixed: true, physics: { bodyType: 'ghost' } },
		metal:
		{
			physics:
			{
				mass: 100,
				bodyType: 'hard'
			}
		},
		stone:
		{
			physics:
			{
				mass: 10,
				bodyType: 'hard'
			}
		},
		wood:
		{
			physics:
			{
				mass: 1,
				bodyType: 'hard'
			}
		},
		balloon:
		{
			physics:
			{
				mass: 1,
				gravityScale: -15,
				bodyType: 'hard'
			}
		},
		tree:
		{
			structure: 'triangulate',
			nodeRadius: 0.013,
			physics:
			{
				joints:
				{
					default:
					{
						distanceConstraint: null,
						lockConstraint:
						{
							stiffness: 10000,
							relaxation: 0.9
						}
					}
				},
				mass: 1,
				damping: 0.8,
				structuralMassDecay: 3,
				bodyType: 'soft'
			}
		},
		flora:
		{
			structure: 'line',
			nodeRadius: 0.013,
			physics:
			{
				joints:
				{
					default:
					{
						distanceConstraint: null,
						lockConstraint:
						{
							stiffness: 1000,
							relaxation: 1
						}
					}
				},
				mass: 1,
				structuralMassDecay: 3,
				bodyType: 'soft'
			}
		},
		rubber:
		{
			structure: 'triangulate',
			nodeRadius: 0.013,
			physics:
			{
				joints: {
					default: {
						distanceConstraint:
						{
							stiffness: 100000,
							relaxation: 1
						}
					}
				},
				mass: 0.1,
				bodyType: 'soft'
			}
		},
		jelly:
		{
			structure: 'hexaFill',
			innerStructureDef: 0.01,
			nodeRadius: 0.013,
			physics:
			{
				joints:
				{
					default:
					{
						distanceConstraint:
						{
							stiffness: 10000,
							relaxation: 30
						}
					}
				},
				mass: 0.13,
				bodyType: 'soft'
			}
		},
		sponge:
		{
			structure: 'preciseHexaFill',
			innerStructureDef: 0.02,
			nodeRadius: 0.013,
			physics:
			{
				joints:
				{
					default:
					{
						revoluteConstraint:
						{
							stiffness: 1000,
							relaxation: 5
						}
					}
				},
				material: 'rubber',
				mass: 0.13,
				bodyType: 'soft'
			}
		},
		liquid:
		{
			structure: 'hexaFill',
			innerStructureDef: 0.02,
			nodeRadius: 0.08,
			drawNodesSeparately: true,
			physics:
			{
				joints:
				{
				},
				mass: 0.013,
				material: 'liquid',
				bodyType: 'soft'
			}
		},
		rope:
		{
			structure: 'line',
			nodeRadius: 0.013,
			physics:
			{
				joints:
				{
					default:
					{
						distanceConstraint:
						{
							stiffness: 1000,
							relaxation: 1
						}
					}
				},
				mass: 1,
				bodyType: 'soft'
			}
		},
		static:
		{
			fixed: true,
			physics:
			{
				mass: 0,
				bodyType: 'hard'
			}
		},
		noCollide:
		{
			physics:
			{
				mass: 0.13,
				bodyType: 'hard',
				noCollide: true
			}
		},
		leaves:
		{
			physics:
			{
				mass: 0.00013,
				gravityScale: 0,
				bodyType: 'hard',
				noCollide: true
			}
		}
	},
	materials:
	{
		default:
		{
			bounciness: 1,
			friction: 0.5
		},
		rubber:
		{
			bounciness: 10,
			friction: 100
		},
		liquid:
		{
			bounciness: 1000,
			friction: 0
		}
	},
	constraints:
	{
		default:
		{
			lockConstraint:
			{
				stiffness: 10000000000000,
				relaxation: 0,
				collideConnected: false
			}
		},
		axis:
		{
			revoluteConstraint:
			{
				stiffness: 10000,
				relaxation: 0.1,
				motor: false,
				collideConnected: false
			}
		},
		shockAbsorber:
		{
			prismaticConstraint:
			{
				stiffness: 10000,
				relaxation: 0.1,
				canRotate: false
			},
			linearSpring:
			{
				stiffness: 400,
				damping: 0.4
			}
		},
		wire:
		{
			distanceConstraint:
			{
				stiffness: 1000,
				relaxation: 1
			}
		},
		spring:
		{
			distanceConstraint:
			{
				stiffness: 100000,
				relaxation: 0
			}
		},
		continuousMotor:
		{
			revoluteConstraint:
			{
				motor: true,
				continuousMotor: true,
				motorPower: 4
			}
		}
	}
};


},{}],"/Users/Lau/www/svjelly/src/core/DecorationDrawing.js":[function(require,module,exports){
var DecorationDrawing =
{
	setScale: function ($scaleX, $scaleY)
	{
		for (var i = 0, length = this.commands.length; i < length; i += 1)
		{
			var command = this.commands[i];
			command.setScale($scaleX, $scaleY);
		}
	}
};

module.exports = DecorationDrawing;

},{}],"/Users/Lau/www/svjelly/src/core/DecorationDrawingCommand.js":[function(require,module,exports){
var Commands = require('./Commands');

var DecorationDrawingCommand = function ($instructions, $physicsManager)
{
	this.physicsManager = $physicsManager;
	this.name = $instructions.name;
	this.point = $instructions.point;
	this.options = $instructions.options;
	var self = this;
	this.physicsManager.addedToWorld.then(function ()
	{
		self.relativePoint =
		[
			self.point[0] - $physicsManager.getX(),
			self.point[1] - $physicsManager.getY()
		];
		if (self.name === Commands.BEZIER_TO || self.name === Commands.QUADRA_TO)
		{
			self.cp1 =
			[
				self.relativePoint[0] + self.options[0][0],
				self.relativePoint[1] + self.options[0][1]
			];
		}
		if (self.name === Commands.BEZIER_TO)
		{
			self.cp2 =
			[
				self.relativePoint[0] + self.options[1][0],
				self.relativePoint[1] + self.options[1][1]
			];
		}
	});
};

DecorationDrawingCommand.prototype.setScale = function ($scaleX, $scaleY)
{
	this.scaleX = $scaleX;
	this.scaleY = $scaleY;

	if (this.name === Commands.CIRCLE || this.name === Commands.ELLIPSE)
	{
		this.radius = this.options[0] * this.scaleX;
	}
	if (this.name === Commands.ELLIPSE)
	{
		this.radiusB = this.options[1] * this.scaleX;
	}
};

DecorationDrawingCommand.prototype.getRotation = function ()
{
	var rota = (this.physicsManager.getAngle());
	return this.options[2] - rota;//this.physicsManager.getAngle() * 180 / Math.PI;
};

DecorationDrawingCommand.prototype.getControlPoint = function ($cp)
{
	var angle = -this.physicsManager.getAngle();
	var x = $cp[0];
	var y = $cp[1];
	return [
		(this.physicsManager.getX() + x * Math.cos(angle) - y * Math.sin(angle)) * this.scaleX,
		(this.physicsManager.getY() + y * Math.cos(angle) + x * Math.sin(angle)) * this.scaleY
	];
};

DecorationDrawingCommand.prototype.getCP1 = function ()
{
	return this.getControlPoint(this.cp1);
};

DecorationDrawingCommand.prototype.getCP2 = function ()
{
	return this.getControlPoint(this.cp2);
};

DecorationDrawingCommand.prototype.getX = function ()
{
	var angle = -this.physicsManager.getAngle();
	var x = this.relativePoint[0];
	var y = this.relativePoint[1];
	return (this.physicsManager.getX() + x * Math.cos(angle) - y * Math.sin(angle)) * this.scaleX;
};

DecorationDrawingCommand.prototype.getY = function ()
{
	var angle = -this.physicsManager.getAngle();
	var x = this.relativePoint[0];
	var y = this.relativePoint[1];
	return (this.physicsManager.getY() + y * Math.cos(angle) + x * Math.sin(angle)) * this.scaleY;
};

module.exports = DecorationDrawingCommand;

},{"./Commands":"/Users/Lau/www/svjelly/src/core/Commands.js"}],"/Users/Lau/www/svjelly/src/core/Grid.js":[function(require,module,exports){
var Grid =
{
	init: function ($graph)
	{
		this._graph = $graph;
		var nodesArray = this._nodesArray = [];
		this._graph.forEach(function ($line)
		{
			if ($line)
			{
				$line.forEach(function ($node)
				{
					if ($node) { nodesArray.push($node); }
				});
			}
		});
		return this;
	},

	createFromPolygon: function ($polygon, $def, $hexa)
	{
		var boundingBox = $polygon.getBoundingBox();

		var def = $def;
		//var def = width / $def;
		var toReturn = [];
		var yInc = $hexa ? def * (Math.sqrt(3) / 2) : def;
		var halfDef = def * 0.5;
		for (var yPos = boundingBox[0][1]; yPos <= boundingBox[1][1]; yPos += yInc)
		{
			var line = [];
			//var intersections = $polygon.getIntersectionsAtY(yPos);
			var xPos = boundingBox[0][0];
			xPos = ($hexa && toReturn.length % 2 !== 0) ? xPos + halfDef : xPos;
			for (xPos; xPos <= boundingBox[1][0] + halfDef; xPos += def)
			{
				if ($polygon.isInside([xPos, yPos])) { line.push([xPos, yPos]); }
				else { line.push(null); }
			}
			toReturn.push(line);
		}
		return Object.create(Grid).init(toReturn);
	},

	getGraph: function () { return this._graph; },

	getNodesArray: function () { return this._nodesArray; },

	getClosest: function ($x, $y, $size)
	{
		var size = $size || 1;
		var closest = this._nodesArray.concat();
		closest.sort(function ($a, $b)
		{
			if ($a === null || $b === null) { return true; }
			var sideX1 = Math.abs($a[0] - $x);
			var sideY1 = Math.abs($a[1] - $y);
			var dist1 = Math.sqrt(sideX1 * sideX1 + sideY1 * sideY1);

			var sideX2 = Math.abs($b[0] - $x);
			var sideY2 = Math.abs($b[1] - $y);
			var dist2 = Math.sqrt(sideX2 * sideX2 + sideY2 * sideY2);

			return dist1 - dist2;
		});
		return closest.slice(0, size);
	},

	getNeighbours: function ($x, $y, $returnEmpty)
	{
		var toReturn = [];
		var graph = this._graph;
		var even = $y % 2 > 0;
		var left = even ? $x : $x - 1;
		var right = even ? $x + 1 : $x;

		var NE = graph[$y - 1] && graph[$y - 1][right] ? graph[$y - 1][right] : null;
		var E = graph[$y + 0] && graph[$y + 0][$x + 1] ? graph[$y][$x + 1] : null;
		var SE = graph[$y + 1] && graph[$y + 1][right] ? graph[$y + 1][right] : null;
		var SW = graph[$y + 1] && graph[$y + 1][left] ? graph[$y + 1][left] : null;
		var W = graph[$y + 0] && graph[$y + 0][$x - 1] ? graph[$y][$x - 1] : null;
		var NW = graph[$y - 1] && graph[$y - 1][left] ? graph[$y - 1][left] : null;

		if (NE || $returnEmpty) { toReturn.push(NE); }
		if (E || $returnEmpty) { toReturn.push(E); }
		if (SE || $returnEmpty) { toReturn.push(SE); }
		if (SW || $returnEmpty) { toReturn.push(SW); }
		if (W || $returnEmpty) { toReturn.push(W); }
		if (NW || $returnEmpty) { toReturn.push(NW); }

		return toReturn;
	},

	getNetwork: function ()
	{
		var graph = this._graph;
		var network = [];
		var visited = [];
		var i = 0;
		var rowsLength = graph.length;
		for (i; i < rowsLength; i += 1)
		{
			var k = 0;
			var pointsLength = graph[i].length;
			for (k; k < pointsLength; k += 1)
			{
				var currPoint = graph[i][k];
				if (currPoint)
				{
					var currPointNeighbours = this.getNeighbours(k, i);
					for (var m = 0, neighboursLength = currPointNeighbours.length; m < neighboursLength; m += 1)
					{
						var currNeigh = currPointNeighbours[m];
						if (currNeigh && visited.indexOf(currNeigh) === -1)
						{
							network.push([currPoint, currNeigh]);
						}
					}
					visited.push(currPoint);
				}
			}
		}
		return network;
	},

	getOutline: function ()
	{
		if (!this.outline)
		{
			var graph = this._graph;
			var outlineGraph = [];
			for (var i = 0, rowsLength = graph.length; i < rowsLength; i += 1)
			{
				outlineGraph[i] = [];
				for (var k = 0, pointsLength = graph[i].length; k < pointsLength; k += 1)
				{
					var point = graph[i][k];
					outlineGraph[i][k] = null;
					if (point)
					{
						var isEdge = this.getNeighbours(k, i).length < 6;
						if (isEdge)
						{
							outlineGraph[i][k] = [k, i];
						}
					}
				}
			}
			this.outline = Object.create(Grid).init(outlineGraph);
		}

		return this.outline;
	},

	getShapePath: function ()
	{
		var path = [];
		var currentOutline = this.getOutlines()[0];
		var outlineGraph = currentOutline.getGraph();
		var getStartingIndex = function ()
		{
			for (var i = 0, length = outlineGraph.length; i < length; i += 1)
			{
				if (!outlineGraph[i]) { continue; }
				for (var k = 0, pointsLength = outlineGraph[i].length; k < pointsLength; k += 1)
				{
					var currPoint = outlineGraph[i][k];
					// if (currPoint)
					// {
					// 	console.log(currPoint, currentOutline.getNeighbours(currPoint[0], currPoint[1]));
					// }
					if (currPoint && currentOutline.getNeighbours(currPoint[0], currPoint[1]).length === 2)
					{
						return currPoint;
					}
				}
			}
		};

		var visited = [];
		var startingIndex = getStartingIndex.call(this);
		if (!startingIndex) { return; }

		var getAngle = function ($index)
		{
			var angle = ($index + 1) * 60;
			angle = angle === 0 ? 360 : angle;
			return angle;
		};
		var getNeighbourIndex = function ($point, $neighbour)
		{
			return currentOutline.getNeighbours($point[0], $point[1], true).indexOf($neighbour);
		};

		var next = currentOutline.getNeighbours(startingIndex[0], startingIndex[1])[0];
		var lastAngle = getAngle(getNeighbourIndex(startingIndex, next));
		var currIndex = next;
		path.push(this._graph[startingIndex[1]][startingIndex[0]]);
		path.push(this._graph[next[1]][next[0]]);
		visited.push(startingIndex);

		var best;
		var neighbours;
		var bestAngle;
		var outlineNodesArray = currentOutline.getNodesArray();
		var outlinePointsLength = outlineNodesArray.length;

		while (visited.length < outlinePointsLength - 1)//currIndex !== startingIndex)
		{
			neighbours = currentOutline.getNeighbours(currIndex[0], currIndex[1]);
			var bestScore = 0;
			best = undefined;

			for (var i = 0, length = neighbours.length; i < length; i += 1)
			{
				var currNeigh = neighbours[i];
				var currScore = 0;
				var currAngle = getAngle(getNeighbourIndex(currIndex, currNeigh));
				currScore = currAngle - lastAngle;
				if (currScore > 180) { currScore = currScore - 360; }
				if (currScore < -180) { currScore = currScore + 360; }
				var neighIndex = visited.indexOf(currNeigh);
				if (neighIndex !== -1) { currScore = neighIndex / visited.length * 10000 + 10000 + currScore; }
				if (!best || currScore < bestScore)
				{
					bestScore = currScore;
					best = currNeigh;
					bestAngle = currAngle;
				}
			}
			lastAngle = bestAngle;
			if (visited.indexOf(currIndex) !== -1) { visited.splice(visited.indexOf(currIndex), 1); }
			visited.push(currIndex);
			currIndex = best;

			path.push(this._graph[currIndex[1]][currIndex[0]]);
		}
		return path;
	},

	getOutlines: function ()
	{
		var toReturn = [];
		var currentGraph;
		var outline = this.getOutline();
		var remaining = outline.getNodesArray().concat();

		var recur = function ($point)
		{
			currentGraph[$point[1]] = currentGraph[$point[1]] || [];
			currentGraph[$point[1]][$point[0]] = $point;
			var neighbours = outline.getNeighbours($point[0], $point[1]);
			remaining.splice(remaining.indexOf($point), 1);
			for (var i = 0, length = neighbours.length; i < length; i += 1)
			{
				var neigh = neighbours[i];
				if (remaining.indexOf(neigh) !== -1) { recur(neigh); }
			}
		};

		while (remaining.length)
		{
			currentGraph = [];
			var startingPoint = remaining[0];
			recur(startingPoint);
			toReturn.push(Object.create(Grid).init(currentGraph));
		}
		return toReturn;
	}
};

module.exports = Grid;


},{}],"/Users/Lau/www/svjelly/src/core/NodeDrawingCommand.js":[function(require,module,exports){
var Commands = require('./Commands');

var NodeDrawingCommand = function ($name, $node, $instructions)
{
	this.node = $node;
	this.name = $name;
	if ($instructions)
	{
		this.point = $instructions.point;
		this.options = $instructions.options;
	}
	this.properties = {};
};

NodeDrawingCommand.prototype.setScale = function ($scaleX, $scaleY)
{
	this.scaleX = $scaleX;
	this.scaleY = $scaleY;

	if (this.name === Commands.CIRCLE || this.name === Commands.ELLIPSE)
	{
		this.radius = this.options[0] * this.scaleX;
	}
	if (this.name === Commands.ELLIPSE)
	{
		this.radiusB = this.options[1] * this.scaleX;
	}
};

NodeDrawingCommand.prototype.getControlPoint = function ($cp)
{
	return [
		(this.node.physicsManager.getX() + $cp[0]) * this.scaleX,
		(this.node.physicsManager.getY() + $cp[1]) * this.scaleY
	];
};

NodeDrawingCommand.prototype.getCP1 = function ()
{
	return this.getControlPoint(this.options[0]);
};

NodeDrawingCommand.prototype.getCP2 = function ()
{
	return this.getControlPoint(this.options[1]);
};

NodeDrawingCommand.prototype.getRotation = function ()
{
	return this.options[2] - this.node.physicsManager.getAngle();
};

NodeDrawingCommand.prototype.getX = function ()
{
	return this.node.physicsManager.getX() * this.scaleX;
};

NodeDrawingCommand.prototype.getY = function ()
{
	return this.node.physicsManager.getY() * this.scaleY;
};

module.exports = NodeDrawingCommand;

},{"./Commands":"/Users/Lau/www/svjelly/src/core/Commands.js"}],"/Users/Lau/www/svjelly/src/core/NodeGraph.js":[function(require,module,exports){
var NodeGraph = function ()
{
	this.vertices = [];
	this.edges = [];
};

NodeGraph.prototype.getVertex = function ($node)
{
	for (var i = 0, length = this.vertices.length; i < length; i += 1)
	{
		var vertex = this.vertices[i];
		if (vertex.node === $node)
		{
			return vertex;
		}
	}
};

NodeGraph.prototype.createVertex = function ($node)
{
	var vertex = { node: $node };
	this.vertices.push(vertex);
	return vertex;
};

NodeGraph.prototype.getEdgeWeight = function ($edge)
{
	var dX = Math.abs($edge.vertexA.node.oX - $edge.vertexB.node.oX);
	var dY = Math.abs($edge.vertexA.node.oY - $edge.vertexB.node.oY);
	var dist = Math.sqrt(dX * dX + dY * dY);
	return dist;
};

NodeGraph.prototype.getVertexEdges = function ($vertex)
{
	var toReturn = [];
	for (var i = 0, length = this.edges.length; i < length; i += 1)
	{
		var edge = this.edges[i];
		if (edge.vertexA === $vertex || edge.vertexB === $vertex)
		{
			toReturn.push(edge);
		}
	}
	return toReturn;
};

NodeGraph.prototype.connect = function ($ANode, $BNode)
{
	var vertexA = this.getVertex($ANode) || this.createVertex($ANode);
	var vertexB = this.getVertex($BNode) || this.createVertex($BNode);

	var exists = false;
	for (var i = 0, length = this.edges.length; i < length; i += 1)
	{
		var edge = this.edges[i];
		if ((edge.vertexA === vertexA &&
			edge.vertexB === vertexB) ||
			(edge.vertexA === vertexB &&
			edge.vertexB === vertexA))
		{
			exists = true;
		}
	}
	if (!exists)
	{
		this.edges.push({ vertexA: vertexA, vertexB: vertexB });
	}
};

NodeGraph.prototype.traverse = function ($startingVertices)
{
	var i;
	var openList = [];
	var edgesLength;
	var vertexEdges;
	var startingVerticesLength = $startingVertices.length;
	for (i = 0; i < startingVerticesLength; i += 1)
	{
		$startingVertices[i].mapValue = 0;
		$startingVertices[i].opened = true;
		openList.push($startingVertices[i]);
	}

	while (openList.length)
	{
		var closedVertex = openList.shift();
		closedVertex.closed = true;

		vertexEdges = this.getVertexEdges(closedVertex);
		edgesLength = vertexEdges.length;
		for (i = 0; i < edgesLength; i += 1)
		{
			var currEdge = vertexEdges[i];
			var otherVertex = currEdge.vertexA === closedVertex ? currEdge.vertexB : currEdge.vertexA;
			if (otherVertex.closed) { continue; }
			
			if (!otherVertex.opened)
			{
				otherVertex.opened = true;
				openList.push(otherVertex);
			}
			var val = closedVertex.mapValue + this.getEdgeWeight(currEdge);
			otherVertex.mapValue = otherVertex.mapValue < val ? otherVertex.mapValue : val; //works even if undefined
		}
	}
};

module.exports = NodeGraph;

},{}],"/Users/Lau/www/svjelly/src/core/ObjectDrawing.js":[function(require,module,exports){
var NodeDrawingCommand = require('./NodeDrawingCommand');
var Commands = require('./Commands');
var DecorationDrawing = require('./DecorationDrawing');

var ObjectDrawing = Object.create(DecorationDrawing);
ObjectDrawing.create = function ($group)
{
	var inst = Object.create(ObjectDrawing);
	inst.group = $group;
	inst.commands = [];
	inst.commandsLength = 0;
	inst.properties = undefined;
	return inst;
};

ObjectDrawing.setProperties = function ($properties)
{
	this.properties = $properties;
	this.useDynamicGradient = this.group.conf.structure === 'line' && this.properties.strokeGradient;
};

ObjectDrawing.setCommands = function ()
{
	for (var i = 0, length = this.group.structure.nodeProperties.length; i < length; i += 1)
	{
		var curr = this.group.structure.nodeProperties[i];
		this.addCommand(curr.node, curr.commandProperties, curr.isEnvelope);
	}
};

ObjectDrawing.addCommand = function ($node, $commandProperties, $envelope)
{
	var commandName;
	var properties = $commandProperties;
	if ($envelope === false && !this.group.conf.drawNodesSeparately)
	{
		return;
	}
	if (properties) { commandName = properties.name; }
	else
	{
		if (this.group.conf.drawNodesSeparately)
		{
			commandName = Commands.CIRCLE;
			properties = {};
			properties.options = [];
			properties.options[0] = this.group.conf.nodeRadius;
		}
		else
		{
			commandName = this.commandsLength === 0 ? Commands.MOVE_TO : Commands.LINE_TO;
		}
	}
	// commandName = Commands.CIRCLE;
	// $properties.options[0] = 5;
	// $properties.options[1] = 5;
	var command = new NodeDrawingCommand(commandName, $node, properties);
	this.commands.push(command);
	this.commands[0].endCommand = command;
	this.commandsLength += 1;
};

ObjectDrawing.getBoundingBox = function ()
{
	return this.group.physicsManager.getBoundingBox();
};

ObjectDrawing.isStatic = function ()
{
	return this.group.conf.fixed === true;
};

ObjectDrawing.willNotIntersect = function ()
{
	if (this.group.conf.physics.bodyType === 'hard')
	{
		return true;
	}
	return false;
};

ObjectDrawing.isSimpleDrawing = function ()
{
	if (this.group.conf.physics.bodyType === 'hard' || this.group.conf.physics.bodyType === 'soft')
	{
		return true;
	}
	return false;
};

module.exports = ObjectDrawing;

},{"./Commands":"/Users/Lau/www/svjelly/src/core/Commands.js","./DecorationDrawing":"/Users/Lau/www/svjelly/src/core/DecorationDrawing.js","./NodeDrawingCommand":"/Users/Lau/www/svjelly/src/core/NodeDrawingCommand.js"}],"/Users/Lau/www/svjelly/src/core/Polygon.js":[function(require,module,exports){
var Polygon =
{
	init: function ($points)
	{
		var polygon = Object.create(Polygon);
		polygon.points = $points;
		polygon._boundingBox = undefined;
		return polygon;
	},

	getArea: function ()
	{
		var sumA = 0;
		var sumB = 0;
		for (var i = 0, length = this.points.length; i < length; i += 1)
		{
			var currPoint = this.points[i];
			var next = i === length - 1 ? this.points[0] : this.points[i + 1];

			sumA += currPoint[0] * next[1];
			sumB += currPoint[1] * next[0];
		}

		return Math.abs((sumA - sumB) * 0.5);
	},

	getBoundingBox: function ()
	{
		if (!this._boundingBox)
		{
			var minX = this.points[0][0];
			var maxX = minX;
			var minY = this.points[0][1];
			var maxY = minY;

			for (var i = 0, length = this.points.length; i < length; i += 1)
			{
				var point = this.points[i];
				minX = Math.min(minX, point[0]);
				maxX = Math.max(maxX, point[0]);
				minY = Math.min(minY, point[1]);
				maxY = Math.max(maxY, point[1]);
			}
			this._boundingBox = [[minX, minY], [maxX, maxY]];
		}
		return this._boundingBox;
	},

	getCenter: function ()
	{
		var bounding = this.getBoundingBox();
		var x = bounding[0][0] + (bounding[1][0] - bounding[0][0]) / 2;
		var y = bounding[0][1] + (bounding[1][1] - bounding[0][1]) / 2;
		return [x, y];
	},

	getSegments: function ()
	{
		var segments = [];
		for (var i = 0, length = this.points.length - 1; i < length; i += 1)
		{
			segments.push([this.points[i], this.points[i + 1]]);
		}
		segments.push([this.points[this.points.length - 1], this.points[0]]);
		return segments;
	},

	getIntersectionsAtY: function ($testY)
	{
		var segments = this.getSegments();
		var intersections = [];
		for (var i = 0, length = segments.length; i < length; i += 1)
		{
			var currSegment = segments[i];
			var x1 = currSegment[0][0];
			var y1 = currSegment[0][1];
			var x2 = currSegment[1][0];
			var y2 = currSegment[1][1];
			var smallY = Math.min(y1, y2);
			var bigY = Math.max(y1, y2);

			if ($testY > smallY && $testY < bigY)
			{
				var pY = y2 - $testY;
				var segY = y2 - y1;
				var segX = x2 - x1;
				var pX = pY * segX / segY;
				intersections.push(x2 - pX);
			}
		}
		return intersections;
	},

	isInside: function ($point)
	{
		var infNumber = 0;
		var intersections = this.getIntersectionsAtY($point[1]);
		for (var i = 0, length = intersections.length; i < length; i += 1)
		{
			if ($point[0] < intersections[i]) { infNumber += 1; }
		}
		return infNumber % 2 > 0;
	}
};

module.exports = Polygon;


},{}],"/Users/Lau/www/svjelly/src/core/SVGParser.js":[function(require,module,exports){
var Commands = require('./Commands');
var ObjectDrawing = require('./ObjectDrawing');
var CIRCLE = Commands.CIRCLE;
var LINE_TO = Commands.LINE_TO;
var MOVE_TO = Commands.MOVE_TO;
var BEZIER_TO = Commands.BEZIER_TO;
var QUADRA_TO = Commands.QUADRA_TO;
var ELLIPSE = Commands.ELLIPSE;
var onlyDrawingElements = ':not(g):not(title):not([id*="joint"]):not([id*="constraint"]):not(title):not(linearGradient):not(radialGradient):not(stop)';

var SVGParser = function () {};
//var isPolygon = /polygon|rect/ig;
// var isLine = /polyline|line|path/ig;
// var lineTags = 'polyline, line, path';

SVGParser.prototype.parse = function ($world, $SVG)
{
	this.SVG = $SVG;
	var viewBoxAttr = this.SVG.getAttribute('viewBox');
	this.viewBoxWidth = viewBoxAttr ? Number(viewBoxAttr.split(' ')[2]) : Number(this.SVG.getAttribute('width'));
	this.viewBoxHeight = viewBoxAttr ? Number(viewBoxAttr.split(' ')[3]) : Number(this.SVG.getAttribute('height'));
	this.ratio = $world.getWidth() / this.viewBoxWidth;
	this.world = $world;
	this.world.setHeight(this.viewBoxHeight * this.ratio);

	//temp
	this.elementsQuery = 'g:not([id*="decoration"])>' + onlyDrawingElements + ',' + 'svg>' + onlyDrawingElements;
	// this.elementsQuery = '*:not(defs):not(g):not(title):not(linearGradient):not(radialGradient):not(stop):not([id*="joint"]):not([id*="constraint"])';
	var elemRaws = this.SVG.querySelectorAll(this.elementsQuery);

	var i = 0;
	var rawGroupPairings = [];
	var elemsLength = elemRaws.length;

	for (i = 0; i < elemsLength; i += 1)
	{
		var rawElement = elemRaws[i];
		//if (rawElement.nodeType === 3) { continue; }
		var groupInfos = this.getGroupInfos(rawElement);
		var currGroup = $world.createGroup(groupInfos.type, groupInfos.ID);
		currGroup.rawSVGElement = rawElement;

		var drawingCommands = this.parseElement(rawElement);
		currGroup.structure.create(drawingCommands);
		var objectDrawing = ObjectDrawing.create(currGroup);
		objectDrawing.setCommands();
		currGroup.drawing = objectDrawing;
		this.world.addDrawing(objectDrawing);
		this.setGraphicInstructions(objectDrawing, rawElement, drawingCommands);

		this.parseDecoration(currGroup, rawElement);
		rawGroupPairings.push({ group: currGroup, raw: rawElement.parentNode });
	}

	this.parseConstraints();
	this.parseCustomJoints();

	this.world.addGroupsToWorld();
};

SVGParser.prototype.parseDecoration = function ($group, $rawElement)
{
	var rawChildren = $rawElement.parentNode.childNodes;//('[id="decoration"] :not(g)');
	//if (!decorationRawElements) { return; }
	for (var i = 0, length = rawChildren.length; i < length; i += 1)
	{
		var rawChild = rawChildren[i];
		if (rawChild.nodeType === 3) { continue; }
		if (/decoration/.test(rawChild.id))
		{
			var rawElements = rawChild.querySelectorAll(onlyDrawingElements);
			if (!rawElements) { continue; }
			for (var k = 0, rawElementsLength = rawElements.length; k < rawElementsLength; k += 1)
			{
				var rawElement = rawElements[k];
				var drawingCommands = this.parseElement(rawElement);
				var decorationDrawing = $group.physicsManager.getDecorationDrawing($group);
				decorationDrawing.setDrawingCommands(drawingCommands);
				this.setGraphicInstructions(decorationDrawing, rawElement, drawingCommands);
				this.world.addDrawing(decorationDrawing);
			}
		}
	}
	return false;
};

SVGParser.prototype.getGroupInfos = function ($rawGroup)
{
	var groupElement = (!$rawGroup.id || $rawGroup.id.indexOf('svg') === 0) && $rawGroup.parentNode.tagName !== 'svg' ? $rawGroup.parentNode : $rawGroup;
	var type;
	var ID;
	var regex = /([a-z\d]+)\w*/igm;
	var first = regex.exec(groupElement.id);
	var second = regex.exec(groupElement.id);

	type = first ? first[1] : undefined;
	ID = second ? second[1] : null;
	var title = groupElement.querySelector('title');
	if (ID === null) { ID = title ? title.nodeValue : ID; }

	return { ID: ID, type: type };
};

SVGParser.prototype.getPoints = function ($pointCommands)
{
	var points = [];
	for (var i = 0, length = $pointCommands.length; i < length; i += 1)
	{
		var currPointCommand = $pointCommands[i];
		points.push(currPointCommand.point);
	}
	return points;
};

SVGParser.prototype.getGroupFromRawSVGElement = function ($raw)
{
	for (var i = 0, length = this.world.groups.length; i < length; i += 1)
	{
		var currGroup = this.world.groups[i];
		if (currGroup.rawSVGElement === $raw) { return currGroup; }
	}
};

SVGParser.prototype.parseConstraints = function ()
{
	var rawConstraints = this.SVG.querySelectorAll('[id*="constraint"]');
	for (var i = 0, length = rawConstraints.length; i < length; i += 1)
	{
		var currRawConstraint = rawConstraints[i];
		var rawElements = currRawConstraint.parentNode.querySelectorAll(this.elementsQuery);
		var points = this.getPoints(this.parseElement(currRawConstraint).pointCommands);
		var result = /constraint-([a-z\d]*)-?([a-z\d]*)?/ig.exec(currRawConstraint.id);
		var parentGroupID = result ? result[1] : undefined;
		if (parentGroupID === 'world') { parentGroupID = undefined; }
		var constraintType = result && result[2] ? result[2] : 'default';
		var parentGroup = parentGroupID ? this.world.getGroupByID(parentGroupID) : undefined;

		for (var k = 0, rawElementsLength = rawElements.length; k < rawElementsLength; k += 1)
		{
			var currRawElement = rawElements[k];
			var group = this.getGroupFromRawSVGElement(currRawElement);
			//console.log(group);
			try
			{
				this.world.constrainGroups(group, parentGroup, points, constraintType);
			}
			catch (e)
			{
				console.warn('constraining problem', group.type, group.ID);
				console.log(e);
			}
		}
	}
};

SVGParser.prototype.parseCustomJoints = function ()
{
	var rawJoint = this.SVG.querySelectorAll('[id*="joint"]');
	for (var i = 0, length = rawJoint.length; i < length; i += 1)
	{
		var currRawJoint = rawJoint[i];
		var rawElements = currRawJoint.parentNode.querySelectorAll(this.elementsQuery);
		var points = this.getPoints(this.parseElement(currRawJoint).pointCommands);
		var result = /joint-([a-z\d]*)/ig.exec(currRawJoint.id);
		var type = result ? result[1] : undefined;

		for (var k = 0, rawElementsLength = rawElements.length; k < rawElementsLength; k += 1)
		{
			var currRawElement = rawElements[k];
			var group = this.getGroupFromRawSVGElement(currRawElement);
			var nodeA = group.getNodeAtPoint(points[0][0], points[0][1]);
			var nodeB = group.getNodeAtPoint(points[1][0], points[1][1]);
			group.createJoint(nodeA, nodeB, type, true);
			//console.log(group);
			//this.world.constrainGroups(group, parentGroup, points);
		}
	}
	// var children = $rawGroup.childNodes;//$rawGroup.querySelectorAll('[id*="constraint"]');

	// for (var i = 0, childrenLength = children.length; i < childrenLength; i += 1)
	// {
	// 	if (children[i].nodeType === Node.TEXT_NODE || children[i].id.search(/joint/i) < 0) { continue; }

	// 	var currRawJoint = children[i];
	// 	var p1x = this.getCoord(currRawJoint.getAttribute('x1'));
	// 	var p1y = this.getCoord(currRawJoint.getAttribute('y1'));
	// 	var p2x = this.getCoord(currRawJoint.getAttribute('x2'));
	// 	var p2y = this.getCoord(currRawJoint.getAttribute('y2'));

	// 	var n1 = $group.getNodeAtPoint(p1x, p1y) || $group.createNode(p1x, p1y);
	// 	var n2 = $group.getNodeAtPoint(p2x, p2y) || $group.createNode(p2x, p2y);
	// 	$group.createJoint(n1, n2);
	// }
};

SVGParser.prototype.parseElement = function ($rawElement)
{
	var tagName = $rawElement.tagName;

	switch (tagName)
	{
		case 'line':
			return this.parseLine($rawElement);
		case 'rect':
			return this.parseRect($rawElement);

		case 'polygon':
		case 'polyline':
			return this.parsePoly($rawElement);

		case 'path':
			return this.parsePath($rawElement);

		case 'circle':
		case 'ellipse':
			return this.parseCircle($rawElement);
	}
};

SVGParser.prototype.setGraphicInstructions = function ($drawing, $raw, $drawingCommands)
{
	//drawing.commands = $nodesToDraw;
	var props = {};
	//sorting nodesToDraw so the path is drawn correctly
	// var start;
	// for (var i = 0, length = $nodesToDraw.length; i < length; i += 1)
	// {
	// 	var currNode = $nodesToDraw[i];
	// 	if (currNode.drawing.command === MOVE_TO || i === length - 1)
	// 	{
	// 		if (start) { start.drawing.endNode = currNode; }
	// 		start = currNode;
	// 	}

	// 	$group.nodes.splice($group.nodes.indexOf(currNode), 1);
	// 	$group.nodes.splice(i, 0, currNode);
	// }

	var rawFill = $raw.getAttribute('fill');
	var rawStroke = $raw.getAttribute('stroke');
	var rawLinecap = $raw.getAttribute('stroke-linecap');
	var rawLinejoin = $raw.getAttribute('stroke-linejoin');
	var rawOpacity = $raw.getAttribute('opacity');

	props.fill = rawFill || '#000000';
	props.lineWidth = this.getThickness($raw);//rawStrokeWidth * this.ratio || 0;
	props.stroke = rawStroke && props.lineWidth !== 0 ? rawStroke : 'none';
	props.lineCap = rawLinecap && rawLinecap !== 'null' ? rawLinecap : 'butt';
	props.lineJoin = rawLinejoin && rawLinejoin !== 'null' ? rawLinejoin : 'miter';
	props.opacity = rawOpacity !== null ? Number(rawOpacity) : 1;

	props.closePath = $drawingCommands.closePath;

	props.radiusX = $drawingCommands.radiusX;
	props.radiusY = $drawingCommands.radiusY;

	props.strokeGradient = this.getGradient(props.stroke);
	props.fillGradient = this.getGradient(props.fill);

	$drawing.setProperties(props);
};

SVGParser.prototype.getGradient = function ($value)
{
	var gradientID = /url\(#(.*)\)/im.exec($value);
	if (gradientID)
	{
		var gradientElement = this.SVG.querySelector('#' + gradientID[1]);
		var m = this.getMatrix(gradientElement.getAttribute('gradientTransform'));

		if (gradientElement.tagName !== 'linearGradient' && gradientElement.tagName !== 'radialGradient') { return; }

		var gradient = { stops: [], type: gradientElement.tagName };

		if (gradientElement.tagName === 'linearGradient')
		{
			gradient.x1 = this.getCoord(gradientElement.getAttribute('x1'));
			gradient.y1 = this.getCoord(gradientElement.getAttribute('y1'));
			gradient.x2 = this.getCoord(gradientElement.getAttribute('x2'));
			gradient.y2 = this.getCoord(gradientElement.getAttribute('y2'));

			if (m)
			{
				var p1 = this.multiplyPointByMatrix([gradient.x1, gradient.y1], m);
				var p2 = this.multiplyPointByMatrix([gradient.x2, gradient.y2], m);

				gradient.x1 = p1[0];
				gradient.y1 = p1[1];
				gradient.x2 = p2[0];
				gradient.y2 = p2[1];
			}
		}
		if (gradientElement.tagName === 'radialGradient')
		{
			gradient.cx = this.getCoord(gradientElement.getAttribute('cx'));
			gradient.cy = this.getCoord(gradientElement.getAttribute('cy'));
			gradient.fx = gradientElement.getAttribute('fx') ? this.getCoord(gradientElement.getAttribute('fx')) : gradient.cx;
			gradient.fy = gradientElement.getAttribute('fy') ? this.getCoord(gradientElement.getAttribute('fy')) : gradient.cy;
			gradient.r = this.getCoord(gradientElement.getAttribute('r'));

			if (m)
			{
				var c = this.multiplyPointByMatrix([gradient.cx, gradient.cy], m);
				var f = this.multiplyPointByMatrix([gradient.fx, gradient.fy], m);

				gradient.cx = c[0];
				gradient.cy = c[1];
				gradient.fx = f[0];
				gradient.fy = f[1];
			}
		}

		var stops = gradientElement.querySelectorAll('stop');
		for (var k = 0, stopLength = stops.length; k < stopLength; k += 1)
		{
			var currStop = stops[k];
			var offset = Number(currStop.getAttribute('offset'));
			var colorRegexResult = /stop-color:(.+?)(;|$)/g.exec(currStop.getAttribute('style'));
			var color = currStop.getAttribute('stop-color') || (colorRegexResult ? colorRegexResult[1] : undefined);
			var opacityRegexResult = /stop-opacity:([\d.-]+)/g.exec(currStop.getAttribute('style'));
			var opacity = currStop.getAttribute('stop-opacity') || (opacityRegexResult ? opacityRegexResult[1] : 1);
			if (color.indexOf('#') > -1)
			{
				var R = parseInt(color.substr(1, 2), 16);
				var G = parseInt(color.substr(3, 2), 16);
				var B = parseInt(color.substr(5, 2), 16);
				color = 'rgba(' + R + ',' + G + ',' + B + ',' + opacity + ')';
			}
			if (color.indexOf('rgb(') > -1) { color = 'rgba' + color.substring(4, -1) + ',' + opacity + ')'; }
			if (color.indexOf('hsl(') > -1) { color = 'hsla' + color.substring(4, -1) + ',' + opacity + ')'; }
			gradient.stops.push({ offset: offset, color: color, opacity: opacity });
		}

		return gradient;
	}
};

SVGParser.prototype.parseCircle = function ($rawCircle)
{
	var xPos = this.getCoord($rawCircle.getAttribute('cx') || 0);
	var yPos = this.getCoord($rawCircle.getAttribute('cy') || 0);
	var radiusAttrX = $rawCircle.getAttribute('r') || $rawCircle.getAttribute('rx');
	var radiusAttrY = $rawCircle.getAttribute('ry');
	var radiusX = this.getCoord(radiusAttrX);
	var radiusY = this.getCoord(radiusAttrY) || radiusX;
	var rotation = this.getRotation($rawCircle.getAttribute('transform'));
	var pointCommands = [{ name: radiusY !== radiusX ? ELLIPSE : CIRCLE, point: [xPos, yPos], options: [radiusX, radiusY, rotation] }];
	return { type: 'ellipse', pointCommands: pointCommands, radiusX: radiusX, radiusY: radiusY, closePath: false, thickness: this.getThickness($rawCircle) };
};

SVGParser.prototype.parseLine = function ($rawLine)
{
	var x1 = this.getCoord($rawLine.getAttribute('x1'));
	var x2 = this.getCoord($rawLine.getAttribute('x2'));
	var y1 = this.getCoord($rawLine.getAttribute('y1'));
	var y2 = this.getCoord($rawLine.getAttribute('y2'));
	var pointCommands = [];
	pointCommands.push({ name: MOVE_TO, point: [x1, y1], options: [] });
	pointCommands.push({ name: LINE_TO, point: [x2, y2], options: [] });
	return { type: 'line', pointCommands: pointCommands, closePath: false, thickness: this.getThickness($rawLine) };
};

SVGParser.prototype.parseRect = function ($rawRect)
{
	var x1 = $rawRect.getAttribute('x') ? this.getCoord($rawRect.getAttribute('x')) : 0;
	var y1 = $rawRect.getAttribute('y') ? this.getCoord($rawRect.getAttribute('y')) : 0;
	var x2 = x1 + this.getCoord($rawRect.getAttribute('width'));
	var y2 = y1 + this.getCoord($rawRect.getAttribute('height'));

	var points =
	[
		[x1, y1],
		[x1, y2],
		[x2, y2],
		[x2, y1]
	];

	var m = this.getMatrix($rawRect.getAttribute('transform'));
	if (m)
	{
		points =
		[
			this.multiplyPointByMatrix(points[0], m),
			this.multiplyPointByMatrix(points[1], m),
			this.multiplyPointByMatrix(points[2], m),
			this.multiplyPointByMatrix(points[3], m)
		];
	}

	var pointCommands = [];
	pointCommands.push({ name: MOVE_TO, point: points[0], options: [] });
	pointCommands.push({ name: LINE_TO, point: points[1], options: [] });
	pointCommands.push({ name: LINE_TO, point: points[2], options: [] });
	pointCommands.push({ name: LINE_TO, point: points[3], options: [] });

	return { type: 'polygon', pointCommands: pointCommands, closePath: true, thickness: this.getThickness($rawRect) };
};

SVGParser.prototype.parsePoly = function ($rawPoly)
{
	var regex = /([\-.\d]+)[, ]([\-.\d]+)/ig;
	var result = regex.exec($rawPoly.getAttribute('points'));
	var pointCommands = [];

	while (result)
	{
		var name = pointCommands.length === 0 ? MOVE_TO : LINE_TO;
		var point = [this.getCoord(result[1]), this.getCoord(result[2])];
		pointCommands.push({ name: name, point: point, options: [] });
		result = regex.exec($rawPoly.getAttribute('points'));
	}
	return { type: $rawPoly.tagName, pointCommands: pointCommands, closePath: $rawPoly.tagName !== 'polyline', thickness: this.getThickness($rawPoly) };
};

SVGParser.prototype.parsePath = function ($rawPath)
{
	var d = $rawPath.getAttribute('d');
	var pathReg = /([a-y])([.\-,\d]+)/igm;
	var result;
	var closePath = /z/igm.test(d);
	var coordsRegex = /-?[\d.]+/igm;
	var pointCommands = [];
	var lastX = this.getCoord(0);
	var lastY = this.getCoord(0);

	var self = this;
	var getPoint = function ($x, $y, $relative)
	{
		var x = $x === undefined ? lastX : self.getCoord($x);
		var y = $y === undefined ? lastY : self.getCoord($y);
		if ($relative)
		{
			x = $x === undefined ? x : lastX + x;
			y = $y === undefined ? y : lastY + y;
		}
		return [x, y];
	};

	var getRelativePoint = function ($point, $x, $y, $relative)
	{
		var x = self.getCoord($x);
		var y = self.getCoord($y);
		if ($relative)
		{
			x = lastX + x;
			y = lastY + y;
		}
		x = x - $point[0];
		y = y - $point[1];
		return [x, y];
	};

	var createPoint = function ($commandName, $point, $options)
	{
		var info = { name: $commandName, point: $point, options: $options || [] };
		lastX = info.point[0];
		lastY = info.point[1];
		pointCommands.push(info);
	};

	var point;
	var cubic1;
	var cubic2;
	var quadra1;

	result = pathReg.exec(d);

	while (result)
	{
		var instruction = result[1].toLowerCase();
		var coords = result[2].match(coordsRegex);
		var isLowserCase = /[a-z]/.test(result[1]);

		switch (instruction)
		{
			default:
			case 'm':
				quadra1 = null;
				cubic2 = null;
				point = getPoint(coords[0], coords[1], isLowserCase);
				createPoint(MOVE_TO, point);
				break;
			case 'l':
				quadra1 = null;
				cubic2 = null;
				point = getPoint(coords[0], coords[1], isLowserCase);
				createPoint(LINE_TO, point);
				break;
			case 'v':
				quadra1 = null;
				cubic2 = null;
				point = getPoint(undefined, coords[0], isLowserCase);
				createPoint(LINE_TO, point);
				break;
			case 'h':
				quadra1 = null;
				cubic2 = null;
				point = getPoint(coords[0], undefined, isLowserCase);
				createPoint(LINE_TO, point);
				break;
			case 'c':
				quadra1 = null;
				point = getPoint(coords[4], coords[5], isLowserCase);
				cubic1 = getRelativePoint(point, coords[0], coords[1], isLowserCase);
				cubic2 = getRelativePoint(point, coords[2], coords[3], isLowserCase);
				createPoint(BEZIER_TO, point, [cubic1, cubic2]);
				break;
			case 's':
				quadra1 = null;
				point = getPoint(coords[2], coords[3], isLowserCase);
				cubic1 = cubic2 ? [lastX - cubic2[0] - point[0], lastY - cubic2[1] - point[1]] : undefined;
				cubic2 = getRelativePoint(point, coords[0], coords[1], isLowserCase);
				cubic1 = cubic1 || [cubic2[0], cubic2[1]];
				createPoint(BEZIER_TO, point, [cubic1, cubic2]);
				break;
			case 'q':
				cubic2 = null;
				point = getPoint(coords[2], coords[3], isLowserCase);
				quadra1 = getRelativePoint(point, coords[0], coords[1], isLowserCase);
				createPoint(QUADRA_TO, point, [quadra1]);
				break;
			case 't':
				cubic2 = null;
				quadra1 = quadra1 ? quadra1 : point;
				point = getPoint(coords[0], coords[1], isLowserCase);
				createPoint(QUADRA_TO, point, [quadra1]);
				break;
			case 'a':
				cubic2 = null;
				quadra1 = null;
				point = getPoint(coords[5], coords[6], isLowserCase);
				createPoint('arcTo', point);
				console.warn('not supported');
				break;
		}

		result = pathReg.exec(d);
	}

	return { type: 'path', pointCommands: pointCommands, closePath: closePath, thickness: this.getThickness($rawPath) };
};

SVGParser.prototype.round = function ($number)
{
	// var number = Number($number);
	// return Math.floor(number * 100) / 100;
	return $number;
	//return Math.floor(Number($number));
};

SVGParser.prototype.getThickness = function ($raw)
{
	var rawThickness = $raw.getAttribute('stroke-width') || 1;
	return this.getCoord(rawThickness);
};

SVGParser.prototype.getMatrix = function ($attribute)
{
	if (!$attribute) { return null; }

	var TFType = $attribute.match(/([a-z]+)/igm)[0];
	var values = $attribute.match(/(-?[\d.]+)/igm);

	var matrices = [];
	var tX;
	var tY;
	var angle;

	if (TFType === 'matrix')
	{
		return [Number(values[0]), Number(values[2]), this.getCoord(values[4]), Number(values[1]), Number(values[3]), this.getCoord(values[5]), 0, 0, 1];
	}
	else if (TFType === 'rotate')
	{
		angle = Number(values[0]) * (Math.PI / 180);
		tX = this.getCoord(Number(values[1] || 0));
		tY = this.getCoord(Number(values[2] || 0));
		var m1 = [1, 0, tX, 0, 1, tY, 0, 0, 1];
		var m2 = [Math.cos(angle), -Math.sin(angle), 0, Math.sin(angle), Math.cos(angle), 0, 0, 0, 1];
		var m3 = [1, 0, -tX, 0, 1, -tY, 0, 0, 1];

		matrices.push(m1, m2, m3);
		var p = m1;

		for (var i = 1, matricesLength = matrices.length; i < matricesLength; i += 1)
		{
			var currMat = matrices[i];
			var newP = [0, 0, 0, 0, 0, 0, 0, 0, 0];
			for (var k = 0; k < 9; k += 1)
			{
				var row = Math.floor(k / 3);
				var col = k % 3;
				//var mVal = p[row * col - 1];
				for (var pos = 0; pos < 3; pos += 1)
				{
					newP[k] = newP[k] + p[row * 3 + pos] * currMat[pos * 3 + col];
				}
			}
			p = newP;
		}
		return p;
	}
	else if (TFType === 'translate')
	{
		tX = this.getCoord(Number(values[0] || 0));
		tY = this.getCoord(Number(values[1] || 0));
		return [1, 0, tX, 0, 1, tY, 0, 0, 1];
	}
	else if (TFType === 'scale')
	{
		var sX = this.getCoord(Number(values[0] || 0));
		var sY = this.getCoord(Number(values[1] || 0));
		return [sX, 0, 0, 0, sY, 0];
	}
	else if (TFType === 'skewX')
	{
		angle = Number(values[0]) * (Math.PI / 180);
		return [1, Math.tan(angle), 0, 0, 1, 0, 0, 0, 1];
	}
	else if (TFType === 'skewY')
	{
		angle = Number(values[0]) * (Math.PI / 180);
		return [1, 0, 0, Math.tan(angle), 1, 0, 0, 0, 1];
	}
};

SVGParser.prototype.multiplyPointByMatrix = function ($point, m)
{
	var h = [$point[0], $point[1], 1];
	var p =
	[
		m[0] * h[0] + m[1] * h[1] + m[2] * h[2],
		m[3] * h[0] + m[4] * h[1] + m[5] * h[2],
		m[6] * h[0] + m[7] * h[1] + m[8] * h[2]
	];
	return [p[0] / p[2], p[1] / p[2]];
};

SVGParser.prototype.getRotation = function ($attribute)
{
	var matrix = this.getMatrix($attribute);
	if (matrix)
	{
		return Math.atan2(matrix[0], matrix[3]);
	}
	return 0;
};

SVGParser.prototype.getCoord = function ($coordSTR)
{
	var number = this.round($coordSTR);
	return number * this.ratio;
};

module.exports = SVGParser;


},{"./Commands":"/Users/Lau/www/svjelly/src/core/Commands.js","./ObjectDrawing":"/Users/Lau/www/svjelly/src/core/ObjectDrawing.js"}],"/Users/Lau/www/svjelly/src/core/SVJellyGroup.js":[function(require,module,exports){
var SVJellyNode = require('./SVJellyNode');
var SVJellyJoint = require('./SVJellyJoint');

var SVJellyGroup = function ($type, $conf, $ID)
{
	this.physicsManager = undefined;
	this.structure = undefined;
	this.nodesLength = undefined;
	this.conf = $conf;
	this.drawing = undefined;
	this.fixed = this.conf.fixed;
	this.type = $type;
	this.nodes = [];
	this.joints = [];
	this.ID = $ID;
};

SVJellyGroup.prototype.getNodeAtPoint = function ($x, $y)
{
	for (var i = 0, nodesLength = this.nodes.length; i < nodesLength; i += 1)
	{
		var node = this.nodes[i];

		if (node.oX === $x && node.oY === $y)
		{
			return node;
		}
	}
};

SVJellyGroup.prototype.createNode = function ($px, $py, $options, $overwrite)
{
	var node = this.getNodeAtPoint($px, $py);
	if (node !== undefined && $overwrite)
	{
		node.setOptions($options);
	}
	else
	{
		node = new SVJellyNode($px, $py, $options);
		this.nodes.push(node);
	}

	node.ID = window.performance.now();
	node.physicsManager = this.physicsManager.getNodePhysicsManager(node);
	//this.physicsManager.addNodeToWorld(node);

	this.nodesLength = this.nodes.length;

	return node;
};

SVJellyGroup.prototype.getClosestPoint = function ($points, $nodes)
{
	var nodes = $nodes || this.nodes;
	var closestDist = Infinity;
	var closestPoint;
	var closestNode;
	var closestOffsetX;
	var closestOffsetY;

	for (var i = 0, length = $points.length; i < length; i += 1)
	{
		var currPoint = $points[i];
		for (var k = 0, nodesLength = nodes.length; k < nodesLength; k += 1)
		{
			var currNode = nodes[k];
			var offsetX = currPoint[0] - currNode.oX;
			var offsetY = currPoint[1] - currNode.oY;
			var cX = Math.abs(offsetX);
			var cY = Math.abs(offsetY);
			var dist = Math.sqrt(cX * cX + cY * cY);
			if (dist < closestDist)
			{
				closestNode = currNode;
				closestPoint = currPoint;
				closestDist = dist;
				closestOffsetX = offsetX;
				closestOffsetY = offsetY;
			}
		}
	}

	return closestPoint;
};

SVJellyGroup.prototype.getClosestNode = function ($coord, $nodes)
{
	var nodes = $nodes || this.nodes;
	var closestDist = Infinity;
	var closest;
	for (var i = 0, length = nodes.length; i < length; i += 1)
	{
		var node = nodes[i];
		var offsetX = $coord[0] - node.oX;
		var offsetY = $coord[1] - node.oY;
		var cX = Math.abs(offsetX);
		var cY = Math.abs(offsetY);
		var dist = Math.sqrt(cX * cX + cY * cY);
		if (dist < closestDist)
		{
			closest = node;
			closestDist = dist;
		}
	}
	return closest;
};

SVJellyGroup.prototype.getNodesInside = function ($points)
{
	var Polygon = require('./Polygon');
	var toReturn = [];
	var polygon = Polygon.init($points);
	for (var i = 0, length = this.nodes.length; i < length; i += 1)
	{
		var node = this.nodes[i];
		if (polygon.isInside([node.oX, node.oY]))
		{
			toReturn.push(node);
		}
	}
	return toReturn;
};

SVJellyGroup.prototype.createJoint = function ($nodeA, $nodeB, $type)
{
	for (var i = 0; i < this.joints.length; i += 1)
	{
		var currJoint = this.joints[i];
		if ((currJoint.nodeA === $nodeA && currJoint.nodeB === $nodeB) || (currJoint.nodeB === $nodeA && currJoint.nodeA === $nodeB))
		{
			//return;
			this.joints.splice(i, 1);
			i = i - 1;
		}
	}
	var joint = new SVJellyJoint($nodeA, $nodeB, $type);
	this.joints.push(joint);

	//this.physicsManager.addJointToWorld(joint);
};

SVJellyGroup.prototype.addNodesToWorld = function ()
{
	this.physicsManager.addNodesToWorld();
};

SVJellyGroup.prototype.addJointsToWorld = function ()
{
	this.physicsManager.addJointsToWorld();
};

module.exports = SVJellyGroup;


},{"./Polygon":"/Users/Lau/www/svjelly/src/core/Polygon.js","./SVJellyJoint":"/Users/Lau/www/svjelly/src/core/SVJellyJoint.js","./SVJellyNode":"/Users/Lau/www/svjelly/src/core/SVJellyNode.js"}],"/Users/Lau/www/svjelly/src/core/SVJellyJoint.js":[function(require,module,exports){
var SVJellyJoint = function ($nodeA, $nodeB, $type)
{
	this.nodeA = $nodeA;
	this.nodeB = $nodeB;
	this.type = $type || 'default';
};

module.exports = SVJellyJoint;


},{}],"/Users/Lau/www/svjelly/src/core/SVJellyNode.js":[function(require,module,exports){
var SVJellyNode = function ($oX, $oY, $options)
{
	this.jointsArray = [];
	this.oX = $oX;
	this.oY = $oY;
	this.fixed = false;
	this.drawing = undefined;
	this.setOptions($options);
};

//raccourci
SVJellyNode.prototype.setOptions = function ($options)
{
	if ($options)
	{
		// var = $ === undefined ? {} : $options;
		if ($options.fixed !== undefined) { this.fixed = $options.fixed; }
	}
};

SVJellyNode.prototype.setFixed = function ($fixed)
{
	this.fixed = $fixed;
	this.physicsManager.setFixed($fixed);
};

SVJellyNode.prototype.getX = function ()
{
	return this.physicsManager.getX();
};

//raccourci
SVJellyNode.prototype.getY = function ()
{
	return this.physicsManager.getY();
};

module.exports = SVJellyNode;


},{}],"/Users/Lau/www/svjelly/src/core/SVJellyUtils.js":[function(require,module,exports){
module.exports = {
	extend: function ($toExtend, $extension)
	{
		var recur = function ($object, $extend)
		{
			for (var name in $extend)
			{
				if (typeof $extend[name] === 'object' && !Array.isArray($extend[name]) && $extend[name] !== null)
				{
					if ($object[name] === undefined || $object[name] === null) { $object[name] = {}; }
					recur($object[name], $extend[name]);
				}
				else
				{
					$object[name] = $extend[name];
				}
			}
		};
		recur($toExtend, $extension);

		return $toExtend;
	}
};


},{}],"/Users/Lau/www/svjelly/src/core/SVJellyWorld.js":[function(require,module,exports){
var SVJellyGroup = require('./SVJellyGroup');
var Structure = require('./Structure');

var SVJellyWorld = function ($physicsManager, $conf)
{
	this.physicsManager = $physicsManager;
	this.groups = [];
	this.drawings = [];
	this.conf = $conf;
	this.worldNodes = [];
	this.groupConstraints = [];
	this.worldWidth = this.physicsManager.worldWidth = $conf.worldWidth;
};

SVJellyWorld.prototype.addDrawing = function ($drawing)
{
	this.drawings.push($drawing);
};

SVJellyWorld.prototype.setHeight = function ($height)
{
	this.worldHeight = this.physicsManager.worldHeight = $height;
};

SVJellyWorld.prototype.getWidth = function ()
{
	return this.worldWidth;
};

SVJellyWorld.prototype.getGroupByID = function ($ID)
{
	for (var i = 0, length = this.groups.length; i < length; i += 1)
	{
		var currGroup = this.groups[i];
		if (currGroup.ID === $ID) { return currGroup; }
	}
};

SVJellyWorld.prototype.createGroup = function ($type, $ID)
{
	var conf = this.conf.groups[$type] || this.conf.groups.default;
	var group = new SVJellyGroup($type, conf, $ID);
	group.physicsManager = this.physicsManager.getGroupPhysicsManager(group);
	group.structure = new Structure(group, this);
	this.groups.push(group);
	return group;
};

//maybe split this into two different features, stuff for making bodies fixed, and constraints
SVJellyWorld.prototype.constrainGroups = function ($groupA, $groupB, $points, $type)
{
	var points = $points;
	var groupA = $groupA;
	var groupB = $groupB;

	if (points.length < 3)
	{
		var anchorA = groupA.physicsManager.createAnchorFromLine(points);
		points.splice(points.indexOf(anchorA.point), 1);
		var anchorB = groupB ? groupB.physicsManager.createAnchorFromPoint(points[0]) : this.physicsManager.createGhostAnchorFromPoint(points[0]);
		this.groupConstraints.push({ anchorA: anchorA, anchorB: anchorB, type: $type });
	}
	else
	{
		var anchorsA = groupA.physicsManager.createAnchors(points);
		var anchorsB = groupB ? groupB.physicsManager.createAnchors(points) : [];
		//console.log('A', groupA.ID, anchorsA.length, 'B', groupB ? groupB.ID : groupB);
		for (var i = 0, nodesLength = anchorsA.length; i < nodesLength; i += 1)
		{
			var currAnchorA = anchorsA[i];
			if (!groupB)
			{
				if ($type === 'default')
				{
					currAnchorA.setFixed(true);
				}
				else
				{
					var ghostAnchor = this.physicsManager.createGhostAnchorFromPoints(points);
					this.groupConstraints.push({ anchorA: currAnchorA, anchorB: ghostAnchor, type: $type });
				}
			}
			else
			{
				for (var k = 0, anchorsBLength = anchorsB.length; k < anchorsBLength; k += 1)
				{
					var currAnchorB = anchorsB[k];
					this.groupConstraints.push({ anchorA: currAnchorA, anchorB: currAnchorB, type: $type });
				}
			}
		}
	}
};

SVJellyWorld.prototype.addGroupsToWorld = function ()
{
	for (var i = 0, groupsLength = this.groups.length; i < groupsLength; i += 1)
	{
		var currGroup = this.groups[i];
		currGroup.addNodesToWorld();
		currGroup.addJointsToWorld();
		this.worldNodes = this.worldNodes.concat(currGroup.nodes);
	}

	var toConstrainLength = this.groupConstraints.length;
	for (i = 0; i < toConstrainLength; i += 1)
	{
		var currToConstrain = this.groupConstraints[i];
		this.physicsManager.constrainGroups(currToConstrain.anchorA, currToConstrain.anchorB, currToConstrain.type);
	}
};

module.exports = SVJellyWorld;


},{"./SVJellyGroup":"/Users/Lau/www/svjelly/src/core/SVJellyGroup.js","./Structure":"/Users/Lau/www/svjelly/src/core/Structure.js"}],"/Users/Lau/www/svjelly/src/core/Structure.js":[function(require,module,exports){
var Triangulator = require('./Triangulator');
var Polygon = require('./Polygon');
var Grid = require('./Grid');

var Structure = function ($group, $world)
{
	this.world = $world;
	this.group = $group;
	this.innerStructure = undefined;
};

Structure.prototype.create = function ($drawingCommands)
{
	this.points = this.getPoints($drawingCommands);
	this.drawingCommands = $drawingCommands;
	this.nodeProperties = [];

	this.envelope = undefined;
	this.fillNodes = undefined;

	// console.log('points', points.length, this.group.conf.structure);

	this.area = this.calculateArea(this.points, $drawingCommands);
	this.radiusX = $drawingCommands.radiusX;
	this.radiusY = $drawingCommands.radiusY;

	switch (this.group.conf.structure)
	{
		case 'triangulate':
			this.removeDuplicates(this.drawingCommands);
			var triPoints = this.getPoints(this.drawingCommands);
			this.envelope = this.createNodesFromPoints(triPoints);
			this.setNodeDrawingCommands(this.envelope);
			this.createJointsFromTriangles(triPoints);
			break;
		case 'line':
			this.envelope = this.createNodesFromPoints(this.points);
			this.setNodeDrawingCommands(this.envelope);
			this.createJointsFromPoints(this.points, true);
			//envelope[0].fixed = true;//to remove later maybe ?
			break;
		case 'preciseHexaFill':
			this.envelope = this.createPreciseHexaFillStructure(this.points);
			// structureNodes.forEach(function ($element) { $element.drawing = { notToDraw: true }; });
			break;
		case 'hexaFill':
			this.envelope = this.createHexaFillStructure(this.points);
			break;
		case 'simple':
			this.envelope = this.createNodesFromPoints(this.points);
			this.createJointsFromPoints(this.points);
			this.setNodeDrawingCommands(this.envelope);
			break;
		default:
			this.envelope = this.createNodesFromPoints(this.points, true);
			this.setNodeDrawingCommands(this.envelope);
			break;
	}
};

Structure.prototype.calculateArea = function ($points, $drawingCommands)
{
	if ($drawingCommands.type === 'ellipse')
	{
		return Math.pow(Math.PI * $drawingCommands.radiusX, 2);
	}
	if (this.group.conf.structure !== 'line')
	{
		var polygon = Polygon.init($points);
		return polygon.getArea();
	}
	else
	{
		var area = 0;
		for (var i = 1, length = $points.length; i < length; i += 1)
		{
			var currPoint = $points[i];
			var lastPoint = $points[i - 1];
			var dX = Math.abs(currPoint[0] - lastPoint[0]);
			var dY = Math.abs(currPoint[1] - lastPoint[1]);
			area += Math.sqrt(dX * dX + dY * dY);
			area = area * 0.5 + area * $drawingCommands.thickness * 0.5;
		}
		return area;
	}
};

Structure.prototype.createHexaFillStructure = function ($points)
{
	this.fillNodes = this.createInnerStructure($points);
	var path = this.innerStructure.getShapePath();
	var envelope = [];
	for (var i = 0, length = path.length; i < length; i += 1)
	{
		var node = this.group.getNodeAtPoint(path[i][0], path[i][1]);
		envelope.push(node);
		this.nodeProperties.push({ node: node, commandProperties: undefined, isEnvelope: true });
	}
	return envelope;
};

Structure.prototype.setNodeDrawingCommands = function ($nodes)
{
	for (var i = 0, length = $nodes.length; i < length; i += 1)
	{
		var node = $nodes[i];
		var commandObject = this.drawingCommands.pointCommands[i];
		this.nodeProperties.push({ node: node, commandProperties: commandObject, isEnvelope: true });
	}
};

Structure.prototype.createPreciseHexaFillStructure = function ($points)
{
	var envelope = this.createNodesFromPoints($points, true);
	this.setNodeDrawingCommands(envelope);
	this.fillNodes = this.createInnerStructure($points);

	this.createJointsFromPoints($points, false);
	var i = 0;
	var length = $points.length;
	for (i; i < length; i += 1)
	{
		var currPoint = $points[i];
		var closest = this.innerStructure.getClosest(currPoint[0], currPoint[1], 2);
		for (var k = 0, closestLength = closest.length; k < closestLength; k += 1)
		{
			var currClosest = closest[k];
			var n1 = this.group.getNodeAtPoint(currPoint[0], currPoint[1]);
			var n2 = this.group.getNodeAtPoint(currClosest[0], currClosest[1]);
			this.group.createJoint(n1, n2);
		}
	}
	return envelope;
};

Structure.prototype.createJointsFromTriangles = function ($points)
{
	var triangulator = new Triangulator();
	var triangles = triangulator.triangulate($points);

	var trianglesLength = triangles.length;
	for (var i = 0; i < trianglesLength; i += 1)
	{
		var currTriangle = triangles[i];
		var n0 = this.group.getNodeAtPoint(currTriangle[0].x, currTriangle[0].y);
		var n1 = this.group.getNodeAtPoint(currTriangle[1].x, currTriangle[1].y);
		var n2 = this.group.getNodeAtPoint(currTriangle[2].x, currTriangle[2].y);
		this.group.createJoint(n0, n1);
		this.group.createJoint(n1, n2);
		this.group.createJoint(n2, n0);
	}
};

Structure.prototype.getPoints = function ($drawingCommands)
{
	var points = [];
	for (var i = 0, length = $drawingCommands.pointCommands.length; i < length; i += 1)
	{
		var curr = $drawingCommands.pointCommands[i];
		points.push(curr.point);
	}
	return points;
};

Structure.prototype.createNodesFromPoints = function ($points, $overwrite)
{
	var pointsLength = $points.length;
	var toReturn = [];
	for (var i = 0; i < pointsLength; i += 1)
	{
		var currPoint = $points[i];
		var node = this.group.createNode(currPoint[0], currPoint[1], undefined, $overwrite);
		toReturn.push(node);
	}
	return toReturn;
};

Structure.prototype.removeDuplicates = function ($drawingCommands)
{
	var visitedPoints = [];
	var commands = $drawingCommands.pointCommands;
	for (var i = 0; i < commands.length; i += 1)
	{
		var point = commands[i].point;
		for (var k = 0; k < visitedPoints.length; k += 1)
		{
			var visited = visitedPoints[k];
			if (visited[0] === point[0] && visited[1] === point[1])
			{
				console.log(i, 'duplicate found !', visited[0], visited[1], point[0], point[1]);
				commands.splice(i, 1);
				i = i - 1;
			}
		}
		visitedPoints.push(point);
	}
};

Structure.prototype.createInnerStructure = function ($points)
{
	var polygon = Polygon.init($points);
	var diam = this.world.getWidth() * this.group.conf.innerStructureDef;//width / 10;//this.world.getWidth() / 30;
	this.innerRadius = this.group.conf.nodeRadius || diam / 2;
	this.innerStructure = Grid.createFromPolygon(polygon, diam, true);
	this.structureNodes = this.createNodesFromPoints(this.innerStructure.getNodesArray());

	var network = this.innerStructure.getNetwork();
	var i = 0;
	var length = network.length;
	for (i; i < length; i += 1)
	{
		var currLink = network[i];
		var n1 = this.group.getNodeAtPoint(currLink[0][0], currLink[0][1]);
		var n2 = this.group.getNodeAtPoint(currLink[1][0], currLink[1][1]);
		this.group.createJoint(n1, n2);
	}
	length = this.structureNodes.length;
	for (i = 0; i < length; i += 1)
	{
		var node = this.structureNodes[i];
		this.nodeProperties.push({ node: node, commandProperties: undefined, isEnvelope: false });
	}

	return this.structureNodes;
};

Structure.prototype.createJointsFromPoints = function ($points, $noClose)
{
	var pointsLength = $points.length;
	for (var i = 1; i < pointsLength; i += 1)
	{
		var currPoint = $points[i];
		var lastPoint = $points[i - 1];
		var lastNode = this.group.getNodeAtPoint(lastPoint[0], lastPoint[1]);
		var currNode = this.group.getNodeAtPoint(currPoint[0], currPoint[1]);
		this.group.createJoint(lastNode, currNode);
		if (i === pointsLength - 1 && $noClose !== true)
		{
			var firstNode = this.group.getNodeAtPoint($points[0][0], $points[0][1]);
			this.group.createJoint(currNode, firstNode);
		}
	}
};

module.exports = Structure;


},{"./Grid":"/Users/Lau/www/svjelly/src/core/Grid.js","./Polygon":"/Users/Lau/www/svjelly/src/core/Polygon.js","./Triangulator":"/Users/Lau/www/svjelly/src/core/Triangulator.js"}],"/Users/Lau/www/svjelly/src/core/Triangulator.js":[function(require,module,exports){
var poly2tri = require('../../libs/poly2tri/dist/poly2tri');

var Triangulator = function ()
{
};

Triangulator.prototype.triangulate = function ($coords)
{
	var poly2triContour = [];
	//debugger;

	for (var i = 0, pointsLength = $coords.length; i < pointsLength; i += 1)
	{
		var point = $coords[i];
		poly2triContour.push(new poly2tri.Point(point[0], point[1]));
	}

	var swctx;
	try
	{
		// prepare SweepContext
		swctx = new poly2tri.SweepContext(poly2triContour, { cloneArrays: true });

		// triangulate
		swctx.triangulate();
	}
	catch (e)
	{
		throw e;
		// console.log(e);
		// console.log(e.points);
	}
	var triangles = swctx.getTriangles();

	var pointsArray = [];

	var trianglesLength = triangles.length;
	for (i = 0; i < trianglesLength; i += 1)
	{
		var currTriangle = triangles[i];
		/*jshint camelcase:false*/
		//jscs:disable disallowDanglingUnderscores
		pointsArray.push(currTriangle.points_);
		//jscs:enable disallowDanglingUnderscores
		/*jshint camelcase:true*/
	}

	return pointsArray;
};

module.exports = Triangulator;


},{"../../libs/poly2tri/dist/poly2tri":"/Users/Lau/www/svjelly/libs/poly2tri/dist/poly2tri.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2GhostPhysicsManager.js":[function(require,module,exports){
var AnchorP2GhostPhysicsManager = function ($p2, $p2World, $worldHeight)
{
	this.p2 = $p2;
	this.p2World = $p2World;
	this.offset = [0, 0];
	this.worldHeight = $worldHeight;
};

AnchorP2GhostPhysicsManager.prototype.setFromPoint = function ($point)
{
	this.point = $point;
};

AnchorP2GhostPhysicsManager.prototype.addToWorld = function ()
{
	this.body = new this.p2.Body({
		position: [this.point[0], this.worldHeight - this.point[1]]
	});
	this.p2World.addBody(this.body);
};

AnchorP2GhostPhysicsManager.prototype.getX = function ()
{
	return this.body.position[0];
};

AnchorP2GhostPhysicsManager.prototype.getY = function ()
{
	return this.worldHeight - this.body.position[1];
};

module.exports = AnchorP2GhostPhysicsManager;

},{}],"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2HardPhysicsManager.js":[function(require,module,exports){
var AnchorP2HardPhysicsManager = function ($group) { this.group = $group; };

AnchorP2HardPhysicsManager.prototype.setFromPoint = function ($point)
{
	this.point = $point;
};

AnchorP2HardPhysicsManager.prototype.addToWorld = function ()
{
	this.body = this.group.physicsManager.body;
	this.worldHeight = this.group.physicsManager.worldHeight;
	this.offset = [this.point[0] - this.body.interpolatedPosition[0], (this.worldHeight - this.point[1]) - this.body.interpolatedPosition[1]];
	var dX = this.offset[0];
	var dY = this.offset[1];
	this.angle = Math.atan2(dY, dX);
	this.hyp = Math.sqrt(dX * dX + dY * dY);
};

AnchorP2HardPhysicsManager.prototype.setFixed = function ($fixed)
{
	this.group.fixed = $fixed;
};

AnchorP2HardPhysicsManager.prototype.getX = function ()
{
	return this.body.interpolatedPosition[0] + this.hyp * Math.cos(this.body.angle + this.angle);
};

AnchorP2HardPhysicsManager.prototype.getY = function ()
{
	return this.worldHeight - (this.body.interpolatedPosition[1] + this.hyp * Math.sin(this.body.angle + this.angle));
};

module.exports = AnchorP2HardPhysicsManager;

},{}],"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2SoftPhysicsManager.js":[function(require,module,exports){
var AnchorP2SoftPhysicsManager = function ($group) { this.group = $group; };

AnchorP2SoftPhysicsManager.prototype.setFromPoint = function ($point)
{
	this.point = $point;
	this.node = this.group.getClosestNode($point);
	this.worldHeight = this.group.physicsManager.worldHeight;
	this.offset = [0, 0];
};

AnchorP2SoftPhysicsManager.prototype.addToWorld = function ()
{
	this.body = this.node.physicsManager.body;
};

AnchorP2SoftPhysicsManager.prototype.setFixed = function ($fixed)
{
	this.node.fixed = $fixed;
};

AnchorP2SoftPhysicsManager.prototype.getX = function ()
{
	return this.body.interpolatedPosition[0];
};

AnchorP2SoftPhysicsManager.prototype.getY = function ()
{
	return this.worldHeight - this.body.interpolatedPosition[1];
};

module.exports = AnchorP2SoftPhysicsManager;

},{}],"/Users/Lau/www/svjelly/src/physics/p2physics/GroupGhostPhysicsManager.js":[function(require,module,exports){
var HardDecorationDrawing = require('./HardDecorationDrawing');

var GroupGhostPhysicsManager = function ($group)
{
	this.group = $group;
	this._boundingBox = undefined;
	this._position = [];
	var self = this;
	this.nodesAddedPromise = new window.Promise(function (resolve) { self.resolveNodesAdded = resolve; });
};

GroupGhostPhysicsManager.prototype.getNodePhysicsManager = function ($node)
{
	var manager = {};
	var getX = function ($nodeOX) { return function () { return $nodeOX; }; };
	var getY = function ($nodeOY) { return function () { return $nodeOY; }; };
	for (var i = 0, length = this.group.nodes.length; i < length; i += 1)
	{
		manager.getX = getX($node.oX);
		manager.getY = getY($node.oY);
	}
	return manager;
};

GroupGhostPhysicsManager.prototype.getDecorationDrawing = function ()
{
	return HardDecorationDrawing.create(this.group);
};

GroupGhostPhysicsManager.prototype.getBoundingBox = function ()
{
	if (!this._boundingBox)
	{
		var minX = Infinity;
		var minY = Infinity;
		var maxX = -Infinity;
		var maxY = -Infinity;
		for (var i = 0, length = this.group.nodesLength; i < length; i += 1)
		{
			var currNode = this.group.nodes[i];
			minX = Math.min(currNode.physicsManager.getX(), minX);
			minY = Math.min(currNode.physicsManager.getY(), minY);
			maxX = Math.min(currNode.physicsManager.getX(), maxX);
			maxY = Math.min(currNode.physicsManager.getY(), maxY);
		}
		this._boundingBox = [[minX, minY], [maxX, maxY]];
	}
	return this._boundingBox;
};

GroupGhostPhysicsManager.prototype.addJointsToWorld = function ()
{
	return null;
};

GroupGhostPhysicsManager.prototype.getAngle = function () { return 0; };
GroupGhostPhysicsManager.prototype.getX = function () { return 0; };
GroupGhostPhysicsManager.prototype.getY = function () { return 0; };

GroupGhostPhysicsManager.prototype.getBoundingBox = function ()
{
	if (!this._boundingBox)
	{
		var minX = Infinity;
		var minY = Infinity;
		var maxX = -Infinity;
		var maxY = -Infinity;
		for (var i = 0, length = this.group.nodesLength; i < length; i += 1)
		{
			var currNode = this.group.nodes[i];
			minX = Math.min(currNode.physicsManager.getX(), minX);
			minY = Math.min(currNode.physicsManager.getY(), minY);
			maxX = Math.max(currNode.physicsManager.getX(), maxX);
			maxY = Math.max(currNode.physicsManager.getY(), maxY);
		}

		this._boundingBox = [[minX, minY], [maxX, maxY]];
	}
	return this._boundingBox;
};

GroupGhostPhysicsManager.prototype.addNodesToWorld = function ()
{
	this.resolveNodesAdded();
};

module.exports = GroupGhostPhysicsManager;


},{"./HardDecorationDrawing":"/Users/Lau/www/svjelly/src/physics/p2physics/HardDecorationDrawing.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/GroupP2HardPhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/

var p2 = require('../../../libs/p2');
var NodeP2HardPhysicsManager = require('./NodeP2HardPhysicsManager');
var AnchorP2HardPhysicsManager = require('./AnchorP2HardPhysicsManager');
var HardDecorationDrawing = require('./HardDecorationDrawing');

var GroupP2HardPhysicsManager = function ($group, $P2World, $worldHeight, $materialsList)
{
	this.group = $group;
	var self = this;
	this._position = [];
	this.addedToWorld = new window.Promise(function (resolve) { self.resolveAddedToWorld = resolve; });
	this.materialsList = $materialsList;
	this.worldHeight = $worldHeight;
	this.P2World = $P2World;
	this.conf = $group.conf.physics;
	this._boundingBox = [[0, 0], [0, 0]];
};

GroupP2HardPhysicsManager.prototype.getDecorationDrawing = function ()
{
	return HardDecorationDrawing.create(this.group);
};

GroupP2HardPhysicsManager.prototype.getNodePhysicsManager = function ()
{
	return new NodeP2HardPhysicsManager();
};

GroupP2HardPhysicsManager.prototype.getBoundingBox = function ()
{
	var AABB = this.body.getAABB();
	this._boundingBox[0][0] = AABB.lowerBound[0];
	this._boundingBox[0][1] = this.worldHeight - AABB.upperBound[1];
	this._boundingBox[1][0] = AABB.upperBound[0];
	this._boundingBox[1][1] = this.worldHeight - AABB.lowerBound[1];
	return this._boundingBox;
};

GroupP2HardPhysicsManager.prototype.getX = function () { return this.body.interpolatedPosition[0]; };
GroupP2HardPhysicsManager.prototype.getY = function () { return this.worldHeight - this.body.interpolatedPosition[1]; };

GroupP2HardPhysicsManager.prototype.getAngle = function ()
{
	return this.body.interpolatedAngle;
};

GroupP2HardPhysicsManager.prototype.createAnchorFromPoint = function ($point)
{
	var anchor = new AnchorP2HardPhysicsManager(this.group);
	anchor.setFromPoint($point);
	return anchor;
};

GroupP2HardPhysicsManager.prototype.createAnchorFromLine = function ($linePoints)
{
	var closestPoint = this.group.getClosestPoint($linePoints);
	var anchor = new AnchorP2HardPhysicsManager(this.group);
	anchor.setFromPoint(closestPoint);
	return anchor;
};

GroupP2HardPhysicsManager.prototype.createAnchors = function ($points)
{
	var toReturn = [];
	var nodes = this.group.getNodesInside($points);
	if (!nodes.length)
	{
		var defaultAnchor = new AnchorP2HardPhysicsManager(this.group);
		var Polygon = require('../../core/Polygon');
		var polygon = Polygon.init($points);
		var center = polygon.getCenter();
		//var closest = this.group.getClosestPoint($points);
		defaultAnchor.setFromPoint(center);
		return [defaultAnchor];
	}
	for (var i = 0, length = nodes.length; i < length; i += 1)
	{
		var node = nodes[i];
		var currAnchorA = new AnchorP2HardPhysicsManager(this.group);
		currAnchorA.setFromPoint([node.oX, node.oY]);
		toReturn.push(currAnchorA);
	}
	return toReturn;
};

GroupP2HardPhysicsManager.prototype.addJointsToWorld = function () { return; };

GroupP2HardPhysicsManager.prototype.addNodesToWorld = function ()
{
	var path = [];

	var startX = this.group.nodes[0].oX;
	var startY = this.group.nodes[0].oY;
	var initX = startX;
	var initY = this.worldHeight - startY;

	this.body = new p2.Body({
		mass: this.group.fixed ? 0 : 1,
		position: [startX, this.worldHeight - startY]
	});
	var node;
	for (var i = 0, length = this.group.nodes.length; i < length; i += 1)
	{
		node = this.group.nodes[i];
		var pos = [node.oX - startX, -(node.oY - startY)];
		node.physicsManager.addToWorld(this.body, pos, this.worldHeight);
		path.push(pos);
	}

	if (length > 1)
	{
		this.body.fromPolygon(path);
		var offset = [initX - this.body.position[0], this.body.position[1] - initY];
		i = 0;
		for (i; i < length; i += 1)
		{
			node = this.group.nodes[i];
			node.physicsManager.setOffset(offset);
		}
	}
	else
	{
		var radius = this.group.structure.radiusX;
		var circleShape = new p2.Circle(radius);
		this.body.addShape(circleShape);
	}

	this.body.gravityScale = this.conf.gravityScale !== undefined ? this.conf.gravityScale : 1;
	// console.log(startX, this.worldHeight - startY, this.body.position[0], this.body.position[1]);
	//this.body.mass = this.conf.mass;
	//if (this.group.conf.fixed) { node.physicsManager.setFixed(this.group.conf.fixed); }
	//this.body.updateMassProperties();
	var shapesLength = this.body.shapes.length;
	for (i = 0; i < shapesLength; i += 1)
	{
		var currShape = this.body.shapes[i];
		currShape.material = this.conf.material ? this.materialsList[this.conf.material].material : this.materialsList.default.material;
	}
	this.P2World.addBody(this.body);
	this.body.mass = this.body.getArea() * this.conf.mass;
	this.body.updateMassProperties();
	this.body.collisionResponse = !this.conf.noCollide;

	// if (this.group.ID === 'rearWheel')
	// {
	// 	console.log(this.body.mass);
	// }

	this.body.interpolatedPosition[0] = this.body.position[0];
	this.body.interpolatedPosition[1] = this.body.position[1];
	//node.physicsManager.setFixed(this.group.conf.fixed);
	// console.log(this.body.shapes);
	// debugger;

	this.resolveAddedToWorld();
};

GroupP2HardPhysicsManager.prototype.hitTest = function ($point)
{
	var result = this.P2World.hitTest([$point[0], this.worldHeight - $point[1]], [this.body]);
	return result ? result[0] : undefined;
};

module.exports = GroupP2HardPhysicsManager;


},{"../../../libs/p2":"/Users/Lau/www/svjelly/libs/p2.js","../../core/Polygon":"/Users/Lau/www/svjelly/src/core/Polygon.js","./AnchorP2HardPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2HardPhysicsManager.js","./HardDecorationDrawing":"/Users/Lau/www/svjelly/src/physics/p2physics/HardDecorationDrawing.js","./NodeP2HardPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/NodeP2HardPhysicsManager.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/GroupP2SoftPhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/

var p2 = require('../../../libs/p2');
// var Dispatcher = require('../../event/Dispatcher');
var NodeP2SoftPhysicsManager = require('./NodeP2SoftPhysicsManager');
var AnchorP2SoftPhysicsManager = require('./AnchorP2SoftPhysicsManager');
var JointP2PhysicsManager = require('./JointP2PhysicsManager');
var SoftDecorationDrawing = require('./SoftDecorationDrawing');

var GroupP2SoftPhysicsManager = function ($group, $world, $worldHeight, $materialsList)
{
	this.group = $group;
	this._boundingBox = [[0, 0], [0, 0]];
	this.materialsList = $materialsList;
	this._position = [];
	var self = this;
	this.addedToWorld = new window.Promise(function (resolve) { self.resolveAddedToWorld = resolve; });
	this.world = $world;
	this.worldHeight = $worldHeight;
	this.conf = $group.conf.physics;
	// this.constraints = [];
	//this.nodesDiameter = this.conf.nodesDiameter;
};

GroupP2SoftPhysicsManager.prototype.addNodesToWorld = function ()
{
	for (var i = 0, length = this.group.nodes.length; i < length; i += 1)
	{
		// this.baseBody = new p2.Body({
		// 	mass: 1
		// });
		var node = this.group.nodes[i];
		//var fractionMass = this.conf.mass / this.group.nodes.length;
		var area = this.group.structure.area;
		var nodeMass = area * this.conf.mass / this.group.nodes.length;
		//var mass = 500;
		//var mass = this.conf.mass;//Math.random() * 10 + 1;
		var body = new p2.Body({
			mass: node.fixed ? 0 : nodeMass,
			position: [node.oX, this.worldHeight - node.oY]
		});
		body.interpolatedPosition[0] = body.position[0];
		body.interpolatedPosition[1] = body.position[1];

		//if (node.fixed) { body.type = p2.Body.STATIC; }
		//console.log(node.oX, node.oY);
		//this.body.fixedRotation = true;

		// var radius = this.conf.nodeRadius;
		// var circleShape = new p2.Circle(radius);
		// body.addShape(circleShape);

		var radius = this.group.structure.innerRadius || this.group.conf.nodeRadius || 0.1;
		var shape = new p2.Circle(radius);
		body.addShape(shape);
		shape.material = this.conf.material ? this.materialsList[this.conf.material].material : this.materialsList.default.material;

		//console.log(this.body.getArea());

		//this.body.setDensity(node.type === 'line' ? 1 : 5000);

		//body.damping = 1;
		//body.mass = mass;
		node.physicsManager.addToWorld(p2, body, this.worldHeight);
		node.physicsManager.radius = radius;
		//node.physicsManager.setFixed(node.fixed);
		//body.setDensity(0.1);
		this.world.addBody(body);

		//body.mass = body.getArea() * this.conf.mass;
		//body.gravityScale = 0.1;
		//body.updateMassProperties();
		// body.mass = 0;
		// body.setDensity(0);
		//node.physicsManager.applyForce([0, 0]);
		// body.mass = 10;
		var massVariance = this.conf.massVariance || 0;
		var random = -massVariance + Math.random() * massVariance * 2;
		body.mass = body.mass + body.mass * random;
		//body.mass = body.mass;
		body.invMass = 1 / body.mass;
		body.inertia = body.mass * 0.5;
		body.invInertia = 1 / body.inertia;
		body.collisionResponse = !this.conf.noCollide;

		body.angularDamping = this.conf.angularDamping || body.angularDamping;
		body.damping = this.conf.damping || body.damping;

		body.gravityScale = this.conf.gravityScale !== undefined ? this.conf.gravityScale : 1;
	}

	var Polygon = require('../../core/Polygon');
	var points = [];
	var envelope = this.group.structure.envelope;
	var envelopeLength = this.group.structure.envelope.length;
	for (i = 0; i < envelopeLength; i += 1)
	{
		points.push(envelope[i].physicsManager.body.interpolatedPosition);
	}
	this.polygon = Polygon.init(points);
	//debugger;

	if (this.conf.structuralMassDecay) { this.setNodesMassFromJoints(); }

	this.resolveAddedToWorld();

	if (this.group.ID === 'smiley')
	{
		console.log(this.group.structure.area * this.conf.mass, this.getMass());
	}
};

GroupP2SoftPhysicsManager.prototype.getDecorationDrawing = function ()
{
	return SoftDecorationDrawing.create(this.group);
};

GroupP2SoftPhysicsManager.prototype.getNodePhysicsManager = function ()
{
	return new NodeP2SoftPhysicsManager();
};

GroupP2SoftPhysicsManager.prototype.getBoundingBox = function ()
{
	var minX = Infinity;
	var minY = Infinity;
	var maxX = -Infinity;
	var maxY = -Infinity;
	for (var i = 0, length = this.group.nodesLength; i < length; i += 1)
	{
		var currNode = this.group.nodes[i];
		minX = Math.min(currNode.physicsManager.getX(), minX);
		minY = Math.min(currNode.physicsManager.getY(), minY);
		maxX = Math.max(currNode.physicsManager.getX(), maxX);
		maxY = Math.max(currNode.physicsManager.getY(), maxY);
	}

	this._boundingBox[0][0] = minX;
	this._boundingBox[0][1] = minY;
	this._boundingBox[1][0] = maxX;
	this._boundingBox[1][1] = maxY;

	return this._boundingBox;
};

GroupP2SoftPhysicsManager.prototype.createAnchorFromPoint = function ($point)
{
	var anchor = new AnchorP2SoftPhysicsManager(this.group);
	anchor.setFromPoint($point);
	return anchor;
};

GroupP2SoftPhysicsManager.prototype.createAnchorFromLine = function ($linePoints)
{
	var closestPoint = this.group.getClosestPoint($linePoints);
	var anchor = new AnchorP2SoftPhysicsManager(this.group);
	anchor.setFromPoint(closestPoint);
	return anchor;
};

GroupP2SoftPhysicsManager.prototype.createAnchors = function ($points)
{
	var toReturn = [];
	var nodes = this.group.getNodesInside($points);
	for (var i = 0, length = nodes.length; i < length; i += 1)
	{
		var node = nodes[i];
		var currAnchorA = new AnchorP2SoftPhysicsManager(this.group);
		currAnchorA.setFromPoint([node.oX, node.oY]);
		toReturn.push(currAnchorA);
	}
	return toReturn;
};

GroupP2SoftPhysicsManager.prototype.addJointsToWorld = function ()
{
	for (var i = 0, length = this.group.joints.length; i < length; i += 1)
	{
		var joint = this.group.joints[i];
		joint.physicsManager = new JointP2PhysicsManager(joint, this.world, this.conf);
	}
};

GroupP2SoftPhysicsManager.prototype.setNodesMassFromJoints = function ()
{
	var NodeGraph = require('../../core/NodeGraph');
	var nodeGraph = new NodeGraph();
	var i;
	var startingVertices = [];
	var nodesLength = this.group.nodes.length;
	var jointsLength = this.group.joints.length;
	for (i = 0; i < jointsLength; i += 1)
	{
		var currJoint = this.group.joints[i];
		nodeGraph.connect(currJoint.nodeA, currJoint.nodeB);
	}
	for (i = 0; i < nodesLength; i += 1)
	{
		var node = this.group.nodes[i];
		if (node.fixed)
		{
			startingVertices.push(nodeGraph.getVertex(node));
		}
	}
	if (startingVertices.length === 0)
	{
		return;
	}
	nodeGraph.traverse(startingVertices);
	var verticesLength = nodeGraph.vertices.length;
	for (i = 0; i < verticesLength; i += 1)
	{
		var vertex = nodeGraph.vertices[i];
		var decay = Number(this.group.conf.physics.structuralMassDecay);
		var value = Math.pow(decay, vertex.mapValue / 5);//Math.pow(2, vertex.mapValue / 7.33);
		var body = vertex.node.physicsManager.body;
		if (!vertex.node.fixed)
		{
			//body.mass = this.conf.mass / this.group.nodes.length / value * body.getArea();
			//vertex.node.debugText = body.mass;
			//body.updateMassProperties();
			var massVariance = this.conf.massVariance || 0;
			var random = -massVariance + Math.random() * massVariance * 2;
			var baseMass = this.group.structure.area * this.conf.mass;
			var mass = baseMass + baseMass * random;
			body.mass = mass / value;
			body.invMass = 1 / body.mass;
			body.inertia = body.mass / 2;
			body.invInertia = 1 / body.inertia;
		}
	}
};

GroupP2SoftPhysicsManager.prototype.applyAngularForce = function ($value)
{
	//this.group.nodes[0].physicsManager.body.angularForce += $value;
	for (var i = 0, length = this.group.nodes.length; i < length; i += 1)
	{
		var currPhys = this.group.nodes[i].physicsManager;
		currPhys.body.angularForce += $value;
	}
};

GroupP2SoftPhysicsManager.prototype.applyForce = function ($vector)
{
	for (var i = 0, length = this.group.nodes.length; i < length; i += 1)
	{
		var currPhys = this.group.nodes[i].physicsManager;
		currPhys.body.force = [
			currPhys.body.force[0] + $vector[0],
			currPhys.body.force[1] + $vector[1]
		];
	}
};

GroupP2SoftPhysicsManager.prototype.getMass = function ()
{
	var mass = 0;
	for (var i = 0, length = this.group.nodes.length; i < length; i += 1)
	{
		var node = this.group.nodes[i];
		mass += node.physicsManager.body.mass;
	}

	return mass;
};

GroupP2SoftPhysicsManager.prototype.getX = function () { return this.group.nodes[0].physicsManager.body.interpolatedPosition[0]; };
GroupP2SoftPhysicsManager.prototype.getY = function () { return this.worldHeight - this.group.nodes[0].physicsManager.body.interpolatedPosition[1]; };

GroupP2SoftPhysicsManager.prototype.getAngle = function ()
{
	return this.group.nodes[0].physicsManager.body.interpolatedAngle;
};

GroupP2SoftPhysicsManager.prototype.hitTest = function ($point, $precision)
{
	$point[1] = this.worldHeight - $point[1];
	var dx;
	var dy;
	var nodesLength = this.group.nodes.length;

	for (var m = 0; m < nodesLength; m += 1)
	{
		var body = this.group.nodes[m].physicsManager.body;
		dx = Math.abs(body.interpolatedPosition[0] - $point[0]);
		dy = Math.abs(body.interpolatedPosition[1] - $point[1]);
		if (dx < $precision && dy < $precision)
		{
			return body;
		}
	}
	if (this.polygon.isInside($point))
	{
		var closest;
		var closestHyp;
		for (var i = 0, length = this.polygon.points.length; i < length; i += 1)
		{
			var currPoint = this.polygon.points[i];
			dx = Math.abs($point[0] - currPoint[0]);
			dy = Math.abs($point[1] - currPoint[1]);
			var hyp = Math.sqrt(dx * dx + dy * dy);
			if (closestHyp === undefined || hyp < closestHyp)
			{
				closest = currPoint;
				closestHyp = hyp;
			}
		}
		for (var k = 0; k < nodesLength; k += 1)
		{
			var currNode = this.group.nodes[k];
			if (currNode.physicsManager.body.interpolatedPosition[0] === closest[0] &&
				currNode.physicsManager.body.interpolatedPosition[1] === closest[1])
			{
				return currNode.physicsManager.body;
			}
		}
		return closest;
	}
};

module.exports = GroupP2SoftPhysicsManager;


},{"../../../libs/p2":"/Users/Lau/www/svjelly/libs/p2.js","../../core/NodeGraph":"/Users/Lau/www/svjelly/src/core/NodeGraph.js","../../core/Polygon":"/Users/Lau/www/svjelly/src/core/Polygon.js","./AnchorP2SoftPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2SoftPhysicsManager.js","./JointP2PhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/JointP2PhysicsManager.js","./NodeP2SoftPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/NodeP2SoftPhysicsManager.js","./SoftDecorationDrawing":"/Users/Lau/www/svjelly/src/physics/p2physics/SoftDecorationDrawing.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/HardDecorationDrawing.js":[function(require,module,exports){
var DecorationDrawingCommand = require('../../core/DecorationDrawingCommand');
var DecorationDrawing = require('../../core/DecorationDrawing');

var HardDecorationDrawing = Object.create(DecorationDrawing);
HardDecorationDrawing.create = function ($group)
{
	var inst = Object.create(HardDecorationDrawing);
	inst.group = $group;
	inst.commands = [];

	inst.properties = undefined;

	return inst;
};

HardDecorationDrawing.setDrawingCommands = function ($drawingCommands)
{
	for (var i = 0, length = $drawingCommands.pointCommands.length; i < length; i += 1)
	{
		var curr = $drawingCommands.pointCommands[i];
		this.commands.push(new DecorationDrawingCommand(curr, this.group.physicsManager));
	}
	this.commandsLength = this.commands.length;
};

HardDecorationDrawing.setProperties = function ($properties)
{
	this.properties = $properties;
	this.useDynamicGradient = false;
};

HardDecorationDrawing.getBoundingBox = function ()
{
	return this.group.physicsManager.getBoundingBox();
};

HardDecorationDrawing.isStatic = function ()
{
	return this.group.conf.fixed === true;
};

HardDecorationDrawing.willNotIntersect = function ()
{
	return false;
};

HardDecorationDrawing.isSimpleDrawing = function ()
{
	return false;
};

module.exports = HardDecorationDrawing;

},{"../../core/DecorationDrawing":"/Users/Lau/www/svjelly/src/core/DecorationDrawing.js","../../core/DecorationDrawingCommand":"/Users/Lau/www/svjelly/src/core/DecorationDrawingCommand.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/JointP2PhysicsManager.js":[function(require,module,exports){
//var p2 = require('../../../libs/p2');
var P2Utils = require('./P2Utils');

var JointP2PhysicsManager = function ($joint, $world, $conf)
{
	var jointConf = $conf.joints[$joint.type];
	var bodyA = $joint.nodeA.physicsManager.body;
	var bodyB = $joint.nodeB.physicsManager.body;
	this.constraints = P2Utils.createConstraints($world, bodyA, bodyB, jointConf);
};

module.exports = JointP2PhysicsManager;

},{"./P2Utils":"/Users/Lau/www/svjelly/src/physics/p2physics/P2Utils.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/NodeP2HardPhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/
var p2 = require('../../../libs/p2');

var NodeP2HardPhysicsManager = function ()
{
	this.getX = this.getXSimple;
	this.getY = this.getYSimple;
};

NodeP2HardPhysicsManager.prototype.addToWorld = function ($body, $position, $worldHeight)
{
	this.body = $body;
	this.position = $position;
	this.worldHeight = $worldHeight;
	this.offset = [0, 0];
};

NodeP2HardPhysicsManager.prototype.setFixed = function ($fixed)
{
	if ($fixed)
	{
		this.body.type = p2.Body.STATIC;
		this.body.updateMassProperties();
	}
};

NodeP2HardPhysicsManager.prototype.setOffset = function ($offset)
{
	var dX = this.position[0] + $offset[0];
	var dY = this.position[1] - $offset[1];
	this.angle = Math.atan2(dY, dX);
	this.hyp = Math.sqrt(dX * dX + dY * dY);
	this.getX = this.getXOffset;
	this.getY = this.getYOffset;
};

NodeP2HardPhysicsManager.prototype.getXSimple = function ()
{
	return this.body.interpolatedPosition[0];
};

NodeP2HardPhysicsManager.prototype.getYSimple = function ()
{
	return this.worldHeight - this.body.interpolatedPosition[1];
};

NodeP2HardPhysicsManager.prototype.getXOffset = function ()
{
	return this.body.interpolatedPosition[0] + this.hyp * Math.cos(this.body.interpolatedAngle + this.angle);
};

NodeP2HardPhysicsManager.prototype.getYOffset = function ()
{
	return this.worldHeight - (this.body.interpolatedPosition[1] + this.hyp * Math.sin(this.body.interpolatedAngle + this.angle));
};

module.exports = NodeP2HardPhysicsManager;


},{"../../../libs/p2":"/Users/Lau/www/svjelly/libs/p2.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/NodeP2SoftPhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/

var NodeP2SoftPhysicsManager = function ()
{
	var self = this;
	this.addedToWorld = new window.Promise(function (resolve) { self.resolveAddedToWorld = resolve; });
};

NodeP2SoftPhysicsManager.prototype.addToWorld = function ($p2, $body, $worldHeight)
{
	this.p2 = $p2;
	this.body = $body;
	this.worldHeight = $worldHeight;
	this.resolveAddedToWorld();
};

NodeP2SoftPhysicsManager.prototype.applyForce = function ($vec)
{
	//console.log('nop', this.body.applyForceLocal, $vec);
	var loc = [];
	this.body.toWorldFrame(loc, [0, 0]);
	this.body.applyForce($vec, loc);
};

NodeP2SoftPhysicsManager.prototype.setFixed = function ($fixed)
{
	if ($fixed)
	{
		this.body.type = this.p2.Body.STATIC;
	}
};

NodeP2SoftPhysicsManager.prototype.getAngle = function ()
{
	return this.body.interpolatedAngle;
};

NodeP2SoftPhysicsManager.prototype.getX = function ()
{
	//console.log(this.body.GetWorldCenter().get_x());
	return this.body.interpolatedPosition[0];
};

NodeP2SoftPhysicsManager.prototype.getY = function ()
{
	return this.worldHeight - this.body.interpolatedPosition[1];
};

module.exports = NodeP2SoftPhysicsManager;


},{}],"/Users/Lau/www/svjelly/src/physics/p2physics/P2MouseControls.js":[function(require,module,exports){
var p2 = require('../../../libs/p2');

var P2MouseControls = function ($world, $p2World, $renderer)
{
	this.renderer = $renderer;
	this.world = $world;
	this.p2World = $p2World;
	this.touchConstraints = {};
};

P2MouseControls.prototype.addBasicMouseControls = function ($stiffness, $relaxation)
{
	var p2World = this.p2World;
	var renderer = this.renderer;
	var container = this.renderer.container;
	var touchConstraints = this.touchConstraints;

	//prevent default scrolling
	document.body.addEventListener('touchmove', function (event) {
		event.preventDefault();
	}, false);

	var worldWidth = this.world.worldWidth;
	var worldHeight = this.world.physicsManager.worldHeight;
	//var bodies = this.p2World.bodies.concat();
	var groups = this.world.groups;

	var getPhysicsCoord = function ($contact)
	{
		var trgt = event.target;
		var pos = trgt.getBoundingClientRect();

		var x = ($contact.clientX - pos.left) / (pos.right - pos.left);
		var y = ($contact.clientY - pos.top) / (pos.bottom - pos.top);
		x = renderer.viewCenter[0] + (x - 0.5) * renderer.viewWidth;
		y = renderer.viewCenter[1] + (y - 0.5) * renderer.viewHeight;

		return [x, y];
	};

	var constrain = function ($contact, $identifier)
	{
		var body;
		var position = getPhysicsCoord($contact);
		for (var i = 0, length = groups.length; i < length; i += 1)
		{
			var currGroup = groups[i];
			if (currGroup.physicsManager.hitTest)
			{
				body = currGroup.physicsManager.hitTest(position, worldWidth / 50);
				if (body) { break; }
			}
		}

		if (body)
		{
			var touchBody = new p2.Body();
			p2World.addBody(touchBody);

			touchBody.position[0] = position[0];
			touchBody.position[1] = worldHeight - position[1];

			var touchConstraint = new p2.LockConstraint(touchBody, body,
			{
				//worldPivot: position,
				collideConnected: false
			});
			//touchConstraint.setLimits(0, 0);

			touchConstraint.setStiffness($stiffness || 200);
			touchConstraint.setRelaxation($relaxation || 1);

			p2World.addConstraint(touchConstraint);
			touchConstraints[$identifier] = touchConstraint;
		}
	};

	var touchMove = function (event)
	{
		event.preventDefault();

		var touches = event.changedTouches || [event];
		for (var i = 0, length = touches.length; i < length; i += 1)
		{
			var touch = touches[i];
			var identifier = touch.identifier || 'mouse';
			if (touchConstraints[identifier])
			{
				var position = getPhysicsCoord(touch);
				touchConstraints[identifier].bodyA.position[0] = position[0];
				touchConstraints[identifier].bodyA.position[1] = worldHeight - position[1];
			}
		}
	};

	var touchStart = function (event)
	{
		event.preventDefault();

		var touches = event.changedTouches || [event];
		for (var i = 0, length = touches.length; i < length; i += 1)
		{
			var touch = touches[i];
			var identifier = touch.identifier || 'mouse';
			if (!touchConstraints[identifier])
			{
				constrain(touch, identifier);
			}
		}
		container.addEventListener('mousemove', touchMove);
		window.addEventListener('mouseup', touchEnd);
	};

	var touchEnd = function (event)
	{
		event.preventDefault();
		var changedTouches = event.changedTouches || [event];
		for (var i = 0, length = changedTouches.length; i < length; i += 1)
		{
			var identifier = changedTouches[i].identifier || 'mouse';
			var constraint = touchConstraints[identifier];
			if (touchConstraints[identifier])
			{
				var touchBody = constraint.bodyA;
				p2World.removeConstraint(constraint);
				p2World.removeBody(touchBody);
				touchConstraints[identifier] = undefined;
			}
		}
		container.removeEventListener('mousemove', touchMove);
		window.removeEventListener('mouseup', touchEnd);
	};

	this.removeBasicMouseControls = function ()
	{
		container.removeEventListener('mousemove', touchMove);
		container.removeEventListener('mousedown', touchStart);
		window.removeEventListener('mouseup', touchEnd);
		container.removeEventListener('touchstart', touchStart);
		container.removeEventListener('touchend', touchEnd);
		container.removeEventListener('touchmove', touchMove);
	};

	container.addEventListener('mousedown', touchStart);
	container.addEventListener('touchstart', touchStart);
	container.addEventListener('touchmove', touchMove);
	container.addEventListener('touchend', touchEnd);
};

module.exports = P2MouseControls;


},{"../../../libs/p2":"/Users/Lau/www/svjelly/libs/p2.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/P2PhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/

var p2 = require('../../../libs/p2');
var P2Utils = require('./P2Utils');
var GroupP2SoftPhysicsManager = require('./GroupP2SoftPhysicsManager');
var GroupP2HardPhysicsManager = require('./GroupP2HardPhysicsManager');
var GroupGhostPhysicsManager = require('./GroupGhostPhysicsManager');
var AnchorP2GhostPhysicsManager = require('./AnchorP2GhostPhysicsManager');

var P2PhysicsManager = function ($conf, $p2World)
{
	this.p2World = $p2World || new p2.World($conf);
	this.p2 = p2;
	this.conf = $conf;
	this.worldWidth = undefined;
	this.worldHeight = undefined;
	this.newTime = undefined;
	this.lastTime = undefined;
	this.materialsList = [];

	//this.p2World.gravity = this.conf.gravity;

	this.setMaterials();
};

P2PhysicsManager.prototype.step = function ($time)
{
	this.newTime = $time - this.lastTime || 0;
	this.lastTime = $time;
	this.p2World.step(1 / 60, this.newTime / 1000, 5);
};

P2PhysicsManager.prototype.constrainGroups = function ($anchorA, $anchorB, $type)
{
	$anchorA.addToWorld();
	$anchorB.addToWorld();

	var constraintConfig = this.conf.constraints[$type];

	P2Utils.createConstraints(this.p2World, $anchorA.body, $anchorB.body, constraintConfig, [$anchorA.offset, $anchorB.offset]);
};

P2PhysicsManager.prototype.createGhostAnchorFromPoints = function ($points)
{
	var Polygon = require('../../core/Polygon');
	var polygon = Polygon.init($points);
	var center = polygon.getCenter();
	return this.createGhostAnchorFromPoint(center);
};

P2PhysicsManager.prototype.createGhostAnchorFromPoint = function ($point)
{
	var anchor = new AnchorP2GhostPhysicsManager(this.p2, this.p2World, this.worldHeight);
	anchor.setFromPoint($point);
	return anchor;
};

P2PhysicsManager.prototype.getGroupPhysicsManager = function ($group)
{
	switch ($group.conf.physics.bodyType)
	{
		case 'ghost': return new GroupGhostPhysicsManager($group);
		case 'hard': return new GroupP2HardPhysicsManager($group, this.p2World, this.worldHeight, this.materialsList);
		case 'soft': return new GroupP2SoftPhysicsManager($group, this.p2World, this.worldHeight, this.materialsList);
	}
};

P2PhysicsManager.prototype.setMaterials = function ()
{
	var materialName;
	for (materialName in this.conf.materials)
	{
		var materialConf = this.conf.materials[materialName];
		var currMaterial = new p2.Material();
		var curr = this.materialsList[materialName] = { material: currMaterial, materialConfig: materialConf };
		for (var otherName in this.materialsList)
		{
			var other = this.materialsList[otherName];
			var contactMaterial = new p2.ContactMaterial(curr.material, other.material, {
				friction: curr.materialConfig.friction + (other.materialConfig.friction - curr.materialConfig.friction) / 2,
				relaxation: curr.materialConfig.bounciness + (other.materialConfig.bounciness - curr.materialConfig.bounciness) / 2
			});
			this.p2World.addContactMaterial(contactMaterial);
		}
	}
};

module.exports = P2PhysicsManager;


},{"../../../libs/p2":"/Users/Lau/www/svjelly/libs/p2.js","../../core/Polygon":"/Users/Lau/www/svjelly/src/core/Polygon.js","./AnchorP2GhostPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2GhostPhysicsManager.js","./GroupGhostPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/GroupGhostPhysicsManager.js","./GroupP2HardPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/GroupP2HardPhysicsManager.js","./GroupP2SoftPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/GroupP2SoftPhysicsManager.js","./P2Utils":"/Users/Lau/www/svjelly/src/physics/p2physics/P2Utils.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/P2Utils.js":[function(require,module,exports){
var p2 = require('../../../libs/p2');
var P2Utils = {};

P2Utils.createConstraints = function ($world, $bodyA, $bodyB, $config, $options)
{
	if (!$config) { return; }

	var lock = $config.lockConstraint;
	var distance = $config.distanceConstraint;
	var revolute = $config.revoluteConstraint;
	var linearSpring = $config.linearSpring;
	var prismaticConstraint = $config.prismaticConstraint;
	var rotationalSpring = $config.rotationalSpring;
	var constraints = [];
	var constraint;

	if (revolute)
	{
		var vecWorldA = p2.vec2.create();
		var vecWorldB = p2.vec2.create();
		var vecLocA = p2.vec2.create();
		var vecLocB = p2.vec2.create();
		$bodyA.toWorldFrame(vecWorldA, [0, 0]);
		$bodyB.toWorldFrame(vecWorldB, [0, 0]);
		$bodyA.toLocalFrame(vecLocA, $bodyB.interpolatedPosition);
		$bodyB.toLocalFrame(vecLocB, $bodyA.interpolatedPosition);

		// console.log(revolute.autoPivot);
		if (!$options || !$options[0] || !$options[1]) { revolute.autoPivot = true; }
		var localPivotA = revolute.autoPivot ? undefined : $options[0];
		var localPivotB = revolute.autoPivot ? undefined : $options[1];
		var worldPivot = revolute.autoPivot ? $bodyA.interpolatedPosition : undefined;
		constraint = new p2.RevoluteConstraint($bodyA, $bodyB,
		{
			worldPivot: worldPivot,
			localPivotA: localPivotA,
			localPivotB: localPivotB
		});
		if (!revolute.motor)
		{
			//constraint.setLimits(0, 0);
			if (revolute.collideConnected !== undefined) { constraint.collideConnected = revolute.collideConnected; }
		}
		else
		{
			constraint.enableMotor();
			constraint.setMotorSpeed(-1);
			constraint.collideConnected = false;
		}
		if (revolute.noRotation) { constraint.setLimits(0, 0); }
		if (revolute.stiffness !== undefined) { constraint.setStiffness(revolute.stiffness); } //default 20
		if (revolute.relaxation !== undefined) { constraint.setRelaxation(revolute.relaxation); }
		$world.addConstraint(constraint);
		constraints.push(constraint);
	}
	if (prismaticConstraint)
	{
		var axisVec = p2.vec2.create();
		var worldOffsetB = p2.vec2.create();
		$bodyB.toWorldFrame(worldOffsetB, $options[1]);
		$bodyA.toLocalFrame(axisVec, worldOffsetB);//[$bodyB.interpolatedPosition[0] + $options[1][0] - ($bodyA.interpolatedPosition[0] + $options[0][0]), $bodyB.interpolatedPosition[1] - $bodyA.interpolatedPosition[1]];
		var sx = axisVec[0] - $options[0][0];
		var sy = axisVec[1] - $options[0][1];
		// var cx = Math.abs(sx);
		// var cy = Math.abs(sy);
		// var dist = Math.sqrt(cx * cx + cy * cy);
		//console.log(axisVec, $options[0]);
		//debugger;
		constraint = new p2.PrismaticConstraint($bodyA, $bodyB, {
			localAnchorA: $options[0],
			localAnchorB: $options[1],
			localAxisA: [sx, sy],
			upperLimit: 1,
			lowerLimit: 0,
			disableRotationalLock: prismaticConstraint.canRotate === true ? true : false
		});
		$world.addConstraint(constraint);
		constraints.push(constraint);
	}
	if (lock)
	{
		constraint = new p2.LockConstraint($bodyA, $bodyB);
		//if ($options && $options[0]) { constraint.localOffsetB = $options[0]; }
		if (lock.collideConnected !== undefined) { constraint.collideConnected = lock.collideConnected; }
		if (lock.stiffness) { constraint.setStiffness(lock.stiffness); } //default 20
		if (lock.relaxation) { constraint.setRelaxation(lock.relaxation); }
		$world.addConstraint(constraint);
		constraints.push(constraint);
	}
	if (linearSpring)
	{
		constraint = new p2.LinearSpring($bodyA, $bodyB, {
			localAnchorA: $options && $options[0] ? $options[0] : undefined,
			localAnchorB: $options && $options[1] ? $options[1] : undefined
		});
		if (linearSpring.stiffness) { constraint.stiffness = linearSpring.stiffness; }
		if (linearSpring.damping) { constraint.damping = linearSpring.damping; }
		$world.addSpring(constraint);
		constraints.push(constraint);
	}
	if (rotationalSpring)
	{
		constraint = new p2.RotationalSpring($bodyA, $bodyB);
		if (rotationalSpring.stiffness) { constraint.stiffness = rotationalSpring.stiffness; }
		if (rotationalSpring.damping) { constraint.damping = rotationalSpring.damping; }
		constraints.push(constraint);
		$world.addSpring(constraint);
	}
	if (distance)
	{
		constraint = new p2.DistanceConstraint($bodyA, $bodyB);
		if ($options && $options[0]) { constraint.localAnchorA = $options[0]; }
		if ($options && $options[1]) { constraint.localAnchorB = $options[1]; }
		if (distance && distance.stiffness) { constraint.setStiffness(distance.stiffness); } // default 500
		if (distance && distance.relaxation) { constraint.setRelaxation(distance.relaxation); }// default 0.1
		$world.addConstraint(constraint);
		constraints.push(constraint);
	}

	return constraints;
};

module.exports = P2Utils;

},{"../../../libs/p2":"/Users/Lau/www/svjelly/libs/p2.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/SoftDecorationDrawing.js":[function(require,module,exports){
var DecorationDrawingCommand = require('../../core/DecorationDrawingCommand');
var DecorationDrawing = require('../../core/DecorationDrawing');

var SoftDecorationDrawing = Object.create(DecorationDrawing);
SoftDecorationDrawing.create = function ($group)
{
	var inst = Object.create(SoftDecorationDrawing);
	inst.group = $group;
	inst.commands = [];

	inst.properties = undefined;

	return inst;
};

SoftDecorationDrawing.setDrawingCommands = function ($drawingCommands)
{
	for (var i = 0, length = $drawingCommands.pointCommands.length; i < length; i += 1)
	{
		var curr = $drawingCommands.pointCommands[i];
		var closestNode = this.group.getClosestNode(curr.point);
		console.log(closestNode.ID);
		this.commands.push(new DecorationDrawingCommand(curr, closestNode.physicsManager));
	}
	this.commandsLength = this.commands.length;
};

SoftDecorationDrawing.setProperties = function ($properties)
{
	this.properties = $properties;
	this.useDynamicGradient = false;
};

SoftDecorationDrawing.getBoundingBox = function ()
{
	return this.group.physicsManager.getBoundingBox();
};

SoftDecorationDrawing.isStatic = function ()
{
	return this.group.conf.fixed === true;
};

SoftDecorationDrawing.willNotIntersect = function ()
{
	return false;
};

SoftDecorationDrawing.isSimpleDrawing = function ()
{
	return false;
};

module.exports = SoftDecorationDrawing;

},{"../../core/DecorationDrawing":"/Users/Lau/www/svjelly/src/core/DecorationDrawing.js","../../core/DecorationDrawingCommand":"/Users/Lau/www/svjelly/src/core/DecorationDrawingCommand.js"}],"/Users/Lau/www/svjelly/src/renderer/svjelly/SVJellyRenderer.js":[function(require,module,exports){
var Commands = require('../../core/Commands');
var CIRCLE = Commands.CIRCLE;
var LINE_TO = Commands.LINE_TO;
var MOVE_TO = Commands.MOVE_TO;
var BEZIER_TO = Commands.BEZIER_TO;
var QUADRA_TO = Commands.QUADRA_TO;
var ELLIPSE = Commands.ELLIPSE;
var SVJellyUtils = require('../../core/SVJellyUtils');
var twoPIS = Math.PI * 2;

var SVJellyRenderer =//function ($world, $canvas)
{
	create: function ($world, $container)
	{
		//crude polyfill
		if (CanvasRenderingContext2D.prototype.ellipse === undefined) {
			CanvasRenderingContext2D.prototype.ellipse = function (x, y, rx, ry, rotation, startAngle, endAngle)
			{
				this.arc(x, y, rx, startAngle, endAngle);
			};
		}
		var inst = Object.create(SVJellyRenderer);

		inst.container = inst.mainCanvas = $container;
		inst.world = $world;
		inst.multiCanvas = $world.conf.multiCanvas;
		inst.debug = $world.conf.debug;

		//inst.setSize($width, $height);

		if (!inst.multiCanvas) { inst.container = inst.mainCanvas; }

		return inst;
	},

	setSize: function ($width, $height)
	{
		while (this.container.firstChild)
		{
			this.container.removeChild(this.container.firstChild);
		}

		this.staticCanvas = [];
		this.dynamicCanvas = [];
		this.canvases = [];
		this.layers = [];
		this.canvasesLength = 0;
		this.cachedHard = [];
		this.dynamicGroups = [];
		this.staticGroups = [];
		this.dynamicGroupsLength = undefined;

		this.width = $width;
		this.height = $height;

		this.ratio = this.width / this.world.physicsManager.worldWidth;

		this.previousViewCenter = [null, null];
		this.viewCenter = [0, 0];
		this.viewportScale = 1;
		this.previousViewportScale = undefined;

		this.scaleX = this.scaleY = 100;

		//creating drawing groups
		this.drawingGroups = [];
		var k = 0;
		var i;
		for (var groupsLength = this.world.drawings.length; k < groupsLength; k += 1)
		{
			var currDrawing = this.world.drawings[k];
			currDrawing.setScale(this.scaleX, this.scaleY);
			this.createDrawingGroup(currDrawing);
		}
		this.drawingGroupsLength = this.drawingGroups.length;

		var drawingGroup;

		//creating canvas and caching non moving groups
		i = 0;
		var canvas;
		var layer;
		for (i; i < this.drawingGroupsLength; i += 1)
		{
			drawingGroup = this.drawingGroups[i];
			if (drawingGroup.isStatic)
			{
				//if some static layers are on top of each other, no need to create
				//a new canvas, you can just draw the layers on the same one
				if (!this.staticCanvas[i - 1])
				{
					canvas = this.createCanvas();
					layer = this.createCanvas();
				}
				else
				{
					canvas = this.drawingGroups[i - 1].canvas;
					layer = this.drawingGroups[i - 1].layer;
				}
				//canvas = this.staticCanvas[i - 1] || this.createCanvas();
				this.staticCanvas[i] = canvas;
				this.staticGroups.push(drawingGroup);
			}
			else
			{
				canvas = this.dynamicCanvas[i - 1] || this.createCanvas();
				layer = canvas;
				this.dynamicCanvas[i] = canvas;
				this.dynamicGroups.push(drawingGroup);
			}
			drawingGroup.canvas = canvas;
			drawingGroup.layer = layer;
			drawingGroup.context = canvas.getContext('2d');
		}
		this.dynamicGroupsLength = this.dynamicGroups.length;
		this.staticGroupsLength = this.staticGroups.length;
		//

		//caching gradients and precalculating
		for (i = 0; i < this.drawingGroupsLength; i += 1)
		{
			drawingGroup = this.drawingGroups[i];
			this.precalculating(drawingGroup);
			drawingGroup.objectDrawingsLength = drawingGroup.objectDrawings.length;
			//
			if (drawingGroup.properties.strokeGradient)
			{
				drawingGroup.properties.stroke = this.createGradient(drawingGroup.context, drawingGroup.properties.strokeGradient);
			}
			if (drawingGroup.properties.fillGradient)
			{
				drawingGroup.properties.fill = this.createGradient(drawingGroup.context, drawingGroup.properties.fillGradient);
			}
		}

		// multi canvas
		if (this.multiCanvas)
		{
			this.container.style.position = 'relative';

			for (i = 0; i < this.drawingGroupsLength; i += 1)
			{
				drawingGroup = this.drawingGroups[i];
				layer = drawingGroup.layer;
				this.addLayer(this.container, layer, !drawingGroup.isStatic);
			}
		}
		this.draw = this.multiCanvas ? this.drawMultiCanvas : this.drawSingleCanvas;

		this.setViewCenter([this.world.physicsManager.worldWidth * 0.5, this.world.physicsManager.worldHeight * 0.5], this.ratio / this.scaleX);
		//this.setViewCenter([this.width * 0.5, this.height * 0.5], 1);

		if (this.debug)
		{
			this.debugCanvas = this.createCanvas();
			this.debugContext = this.debugCanvas.getContext('2d');
			this.addLayer(this.multiCanvas ? this.container : this.mainCanvas.parentNode, this.debugCanvas, false);
		}
	},

	setViewCenter: function ($vc, $scale)
	{
		this.viewCenter[0] = Math.round($vc[0] * 10) / 10;
		this.viewCenter[1] = Math.round($vc[1] * 10) / 10;
		this.viewportScale = $scale || this.viewportScale;
	},

	setScale: function ()
	{
		console.log('setscale');
		var previousStatic;
		for (var i = 0; i < this.staticGroupsLength; i += 1)
		{
			var staticGroup = this.staticGroups[i];
			if (staticGroup.canvas !== previousStatic)
			{
				staticGroup.canvas.width = this.world.physicsManager.worldWidth * this.scaleX * this.viewportScale;
				staticGroup.canvas.height = this.world.physicsManager.worldHeight * this.scaleY * this.viewportScale;
				staticGroup.context.scale(this.viewportScale, this.viewportScale);//this.contextScale, this.contextScale);
				// staticGroup.context.scale(1, 1);
				//staticGroup.canvas.width = this.width;
				//staticGroup.canvas.height = this.height;
				previousStatic = staticGroup.canvas;
			}
			this.drawGroup(staticGroup, staticGroup.context, true);
		}
		this.updateStaticLayers();
		this.updateDynamicLayers();
	},

	setTranslate: function ()
	{
		this.updateStaticLayers();
		this.updateDynamicLayers();
	},

	updateStaticLayers: function ()
	{
		var previous;
		var context;

		for (var i = 0; i < this.staticGroupsLength; i += 1)
		{
			var drawingGroup = this.staticGroups[i];
			var layer = drawingGroup.layer;
			//if (layer === previous) { continue; }

			context = layer.getContext('2d');
			context.clearRect(0, 0, this.width, this.height);
			var sx = this.viewCenter[0] * this.scaleX * this.viewportScale - this.width * 0.5;
			var sy = this.viewCenter[1] * this.scaleX * this.viewportScale - this.height * 0.5;
			context.drawImage(drawingGroup.canvas, sx, sy, this.width, this.height, 0, 0, this.width, this.height);
			//context.drawImage(drawingGroup.canvas, 0, 0, this.width, this.height, 0, 0, this.width, this.height);
			previous = layer;
		}
	},

	updateDynamicLayers: function ()
	{
		var previousDynamic;
		for (var i = 0; i < this.dynamicGroupsLength; i += 1)
		{
			var dynamicGroup = this.dynamicGroups[i];
			if (dynamicGroup.canvas === previousDynamic) { continue; }
			//dynamicGroup.context.scale(this.viewportScale, this.viewportScale);
			//dynamicGroup.context.setTransform(this.viewportScale, 0, 0, this.viewportScale, -this.viewCenter[0] * this.viewportScale, -this.viewY * this.viewportScale);
			dynamicGroup.context.setTransform(this.viewportScale, 0, 0, this.viewportScale, -this.viewCenter[0] * this.scaleX * this.viewportScale + this.width * 0.5, -this.viewCenter[1] * this.scaleX * this.viewportScale + this.height * 0.5);
			previousDynamic = dynamicGroup.canvas;
		}
	},

	checkViewport: function ()
	{
		if (this.viewCenter[0] !== this.previousViewCenter[0] ||
			this.viewCenter[1] !== this.previousViewCenter[1] ||
			this.viewportScale !== this.previousViewportScale)
		{
			this.viewHeight = this.height / this.scaleX / this.viewportScale;
			this.viewWidth = this.width / this.scaleX / this.viewportScale;

			if (this.viewportScale !== this.previousViewportScale)
			{
				this.setScale();
			}
			else
			{
				this.setTranslate();
			}
			this.previousViewCenter[0] = this.viewCenter[0];
			this.previousViewCenter[1] = this.viewCenter[1];
			this.previousViewportScale = this.viewportScale;
		}
		// if (this.viewport[0][0] !== this.previousViewport[0][0] ||
		// 	this.viewport[0][1] !== this.previousViewport[0][1] ||
		// 	this.viewport[1][0] !== this.previousViewport[1][0] ||
		// 	this.viewport[1][1] !== this.previousViewport[1][1])
		// {
		// 	var lastScale = this.viewportScale;
		// 	this.viewportScale = (this.width / (this.viewport[1][0] - this.viewport[0][0]));

		// 	if (lastScale === this.viewportScale)
		// 	{
		// 		this.setTranslate();
		// 	}
		// 	else
		// 	{
		// 		this.setScale();
		// 	}
		// 	this.previousViewport[0][0] = this.viewport[0][0];
		// 	this.previousViewport[0][1] = this.viewport[0][1];
		// 	this.previousViewport[1][0] = this.viewport[1][0];
		// 	this.previousViewport[1][1] = this.viewport[1][1];
		// }
	},

	drawMultiCanvas: function ()
	{
		//this.mainContext.clearRect(0, 0, this.width, this.height);
		this.checkViewport();
		var previous;
		for (var i = 0; i < this.dynamicGroupsLength; i += 1)
		{
			var drawingGroup = this.dynamicGroups[i];
			if (previous !== drawingGroup.context)
			{
				drawingGroup.context.save();
				drawingGroup.context.setTransform(1, 0, 0, 1, 0, 0);
				drawingGroup.context.clearRect(0, 0, this.width, this.height);
				drawingGroup.context.restore();
			}
			//drawingGroup.context.scale(this.contextScaleX, this.contextScaleY);
			previous = drawingGroup.context;
			this.drawGroup(drawingGroup, drawingGroup.context);
		}

		if (this.debug) { this.debugDraw(true); }
	},

	drawSingleCanvas: function ()
	{
		this.mainContext.clearRect(0, 0, this.width, this.height);
		//this.context.miterLimit = 1;
		var previousCached;
		for (var i = 0; i < this.drawingGroupsLength; i += 1)
		{
			var drawingGroup = this.drawingGroups[i];
			if (this.staticCanvas[i])
			{
				if (this.staticCanvas[i] === previousCached) { continue; }
				this.mainContext.drawImage(this.staticCanvas[i], 0, 0);
				previousCached = this.staticCanvas[i];
			}
			else
			{
				this.drawGroup(drawingGroup, this.mainContext);
			}
		}

		if (this.debug) { this.debugDraw(true); }
	},

	drawGroup: function (drawingGroup, context, force)
	{
		context.beginPath();

		if (context.fillStyle !== drawingGroup.properties.fill) { context.fillStyle = drawingGroup.properties.fill; }
		if (context.strokeStyle !== drawingGroup.properties.stroke) { context.strokeStyle = drawingGroup.properties.stroke; }
		if (context.lineWidth !== drawingGroup.properties.lineWidth) { context.lineWidth = drawingGroup.properties.lineWidth; }
		if (context.lineCap !== drawingGroup.properties.lineCap) { context.lineCap = drawingGroup.properties.lineCap; }
		if (context.lineJoin !== drawingGroup.properties.lineJoin) { context.lineJoin = drawingGroup.properties.lineJoin; }
		if (context.globalAlpha !== drawingGroup.properties.opacity) { context.globalAlpha = drawingGroup.properties.opacity; }

		for (var i = 0, length = drawingGroup.objectDrawingsLength; i < length; i += 1)
		{
			var currObjectDrawing = drawingGroup.objectDrawings[i];
			this.drawObject(currObjectDrawing, drawingGroup, context, force);
		}

		if (drawingGroup.properties.closePath) { context.closePath(); }
		if (drawingGroup.properties.fill !== 'none') { context.fill(); }
		if (drawingGroup.properties.stroke !== 'none') { context.stroke(); }
		if (drawingGroup.properties.opacity !== 1) { context.globalAlpha = 1; }
	},

	drawObject: function (objectDrawing, drawingGroup, context, force)
	{
		if (!force)
		{
			var toto = 'tut';
			toto += 1;
			// var boundingBox = objectDrawing.getBoundingBox();
			// if (boundingBox[1][0] * this.scaleX < this.viewX) { return; }
			// if (boundingBox[1][1] * this.scaleY < this.viewY) { return; }
			// if (boundingBox[0][0] * this.scaleX > this.viewX + this.viewWidth) { return; }
			// if (boundingBox[0][1] * this.scaleY > this.viewY + this.viewHeight) { return; }
		}

		for (var k = 0; k < objectDrawing.commandsLength; k += 1)
		{
			var currCommand = objectDrawing.commands[k];
			var point = [currCommand.getX(), currCommand.getY()];

			if (currCommand.name === MOVE_TO)
			{
				context.moveTo(point[0], point[1]);

				//special case for lines with nice dynamic gradients
				if (objectDrawing.useDynamicGradient)
				{
					var x1 = currCommand.getX();
					var y1 = currCommand.getY();
					//console.log(currCommand.endCommand, currCommand.endCommand.getX(), currCommand.endCommand.getY());
					var x2 = currCommand.endCommand.getX();
					var y2 = currCommand.endCommand.getY();
					var gradient = context.createLinearGradient(x1, y1, x2, y2);
					for (var stopN = 0, stopLength = objectDrawing.properties.strokeGradient.stops.length; stopN < stopLength; stopN += 1)
					{
						gradient.addColorStop(1 - objectDrawing.properties.strokeGradient.stops[stopN].offset, objectDrawing.properties.strokeGradient.stops[stopN].color);
					}
					context.strokeStyle = gradient;
				}
				//
			}
			else if (currCommand.name === LINE_TO)
			{
				context.lineTo(point[0], point[1]);
				continue;
			}
			else if (currCommand.name === CIRCLE)
			{
				context.moveTo(point[0] + currCommand.radius, point[1]);
				context.arc(point[0], point[1], currCommand.radius, 0, twoPIS);
			}
			if (!drawingGroup.isSimpleDrawing)
			{
				var cp1;

				if (currCommand.name === BEZIER_TO || currCommand.name === QUADRA_TO)
				{
					cp1 = currCommand.getCP1();
				}

				if (currCommand.name === BEZIER_TO)
				{
					var cp2 = currCommand.getCP2();
					context.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], point[0], point[1]);
				}
				else if (currCommand.name === QUADRA_TO)
				{
					context.quadraticCurveTo(cp1[0], cp1[1], point[0], point[1]);
				}
				else if (currCommand.name === ELLIPSE)
				{
					context.moveTo(point[0], point[1]);
					context.ellipse(point[0], point[1], currCommand.radius, currCommand.radiusB, currCommand.getRotation(), 0, twoPIS);
				}
			}
		}
	},

	precalculating: function ($drawingGroup)
	{
		//precalculating some instructions
		$drawingGroup.properties.lineWidth = $drawingGroup.properties.lineWidth * this.scaleX;
		$drawingGroup.properties.radiusX = $drawingGroup.properties.radiusX * this.scaleX;
		$drawingGroup.properties.radiusY = $drawingGroup.properties.radiusY * this.scaleY;
		for (var i = 0, objecDrawingsLength = $drawingGroup.objectDrawings.length; i < objecDrawingsLength; i += 1)
		{
			var currObjectDrawing = $drawingGroup.objectDrawings[i];
			var commandsLength = currObjectDrawing.commandsLength;
			for (var k = 0; k < commandsLength; k += 1)
			{
				var command = currObjectDrawing.commands[k];
				if ($drawingGroup.isSimpleDrawing && (command.name === BEZIER_TO || command.name === QUADRA_TO))
				{
					command.name = LINE_TO;
				}
				if ($drawingGroup.isSimpleDrawing && (command.name === ELLIPSE))
				{
					command.name = CIRCLE;
				}
			}
		}
	},

	addLayer: function ($parent, $canvas, $pointerEvents)
	{
		if ($parent.contains($canvas)) { return; }
		$parent.appendChild($canvas);
		$canvas.style.position = 'absolute';
		$canvas.style.pointerEvents = $pointerEvents ? 'auto' : 'none';
	},
	createCanvas: function ()
	{
		var canvas = window.document.createElement('canvas');
		canvas.width = this.width;
		canvas.height = this.height;
		this.canvases.push(canvas);
		this.canvasesLength += 1;
		return canvas;
	},

	createGradient: function ($context, $properties)
	{
		var x1 = $properties.x1 * this.scaleX;
		var y1 = $properties.y1 * this.scaleY;
		var x2 = $properties.x2 * this.scaleX;
		var y2 = $properties.y2 * this.scaleY;

		var cx = $properties.cx * this.scaleX;
		var cy = $properties.cy * this.scaleY;
		var fx = $properties.fx * this.scaleX || cx;
		var fy = $properties.fy * this.scaleY || cy;
		var r = $properties.r * this.scaleX;

		var gradient = $properties.type === 'linearGradient' ? $context.createLinearGradient(x1, y1, x2, y2) : $context.createRadialGradient(cx, cy, 0, fx, fy, r);

		for (var stopN = 0, stopLength = $properties.stops.length; stopN < stopLength; stopN += 1)
		{
			gradient.addColorStop($properties.stops[stopN].offset, $properties.stops[stopN].color);
		}

		return gradient;
	},

	createDrawingGroup: function ($objectDrawing)
	{
		var drawingGroup;
		if ($objectDrawing.properties.opacity === 0) { return; }

		for (var i = 0, length = this.drawingGroups.length; i < length; i += 1)
		{
			var currDrawingGroup = this.drawingGroups[i];
			if (this.compareProperties(currDrawingGroup.properties, $objectDrawing.properties) &&
				(currDrawingGroup.willNotIntersect || $objectDrawing.willNotIntersect()) &&
				($objectDrawing.isStatic() === false && currDrawingGroup.isStatic === false) &&
				currDrawingGroup.isSimpleDrawing === $objectDrawing.isSimpleDrawing() &&
				$objectDrawing.properties.opacity === 1)
			{
				drawingGroup = currDrawingGroup;
			}
		}
		if (!drawingGroup)
		{
			drawingGroup =
			{
				properties: SVJellyUtils.extend({}, $objectDrawing.properties),
				isStatic: $objectDrawing.isStatic(),
				willNotIntersect: $objectDrawing.willNotIntersect(),
				isSimpleDrawing: $objectDrawing.isSimpleDrawing(),
				objectDrawings: []
			};
			this.drawingGroups.push(drawingGroup);
		}
		drawingGroup.objectDrawings.push($objectDrawing);
		// drawingGroup.nodes = drawingGroup.nodes.concat($group.drawing.nodes);
		return drawingGroup;
	},

	compareProperties: function ($one, $two)
	{
		var comparison = true;
		for (var name in $two)
		{
			if ($one[name] !== $two[name]) { comparison = false; }
		}
		return comparison;
	},

	debugDraw: function ($clear)
	{
		this.debugContext.setTransform(1, 0, 0, 1, 0, 0);
		if ($clear !== undefined) { this.debugContext.clearRect(0, 0, this.width, this.height); }

		this.debugContext.setTransform(this.viewportScale, 0, 0, this.viewportScale, -this.viewCenter[0] * this.scaleX * this.viewportScale + this.width * 0.5, -this.viewCenter[1] * this.scaleX  * this.viewportScale + this.height * 0.5);

		this.debugContext.strokeStyle = 'yellow';
		this.debugContext.lineCap = 'butt';
		this.debugContext.lineJoin = 'miter';
		this.debugContext.lineWidth = 1 / this.viewportScale;
		this.debugContext.beginPath();
		var currGroup;
		var i;
		var k;
		var groupsLength = this.world.groups.length;
		var nodesLength;
		for (k = 0; k < groupsLength; k += 1)
		{
			currGroup = this.world.groups[k];

			nodesLength = currGroup.nodes.length;
			for (i = 0; i < nodesLength; i += 1)
			{
				var currNode = currGroup.nodes[i];
				var xPos = currNode.getX() * this.scaleX;
				var yPos = currNode.getY() * this.scaleY;
				var radius = currNode.physicsManager.radius || currGroup.structure.radiusX || 0.01;
				radius *= this.scaleX;
				radius = Math.max(radius, 1);
				// console.log(currGroup.structure.innerRadius, currGroup.conf.nodeRadius, currGroup.structure.radiusX);
				// console.log(radius);
				// debugger;
				this.debugContext.moveTo(xPos + radius, yPos);
				this.debugContext.arc(xPos, yPos, radius, 0, twoPIS);
				if (currNode.physicsManager.body)
				{
					this.debugContext.moveTo(xPos, yPos);
					var angle = twoPIS - currNode.physicsManager.body.angle;
					this.debugContext.lineTo(xPos + Math.cos(angle) * radius, yPos + Math.sin(angle) * radius);
				}
			}
		}
		this.debugContext.stroke();

		this.debugContext.strokeStyle = 'rgba(255,1,1,1)';
		this.debugContext.beginPath();
		for (k = 0; k < groupsLength; k += 1)
		{
			currGroup = this.world.groups[k];
			var jointsLength = currGroup.joints.length;

			for (i = 0; i < jointsLength; i += 1)
			{
				var currJoint = currGroup.joints[i];
				this.debugContext.moveTo(currJoint.nodeA.getX() * this.scaleX, currJoint.nodeA.getY() * this.scaleY);
				this.debugContext.lineTo(currJoint.nodeB.getX() * this.scaleX, currJoint.nodeB.getY() * this.scaleY);
			}
		}
		this.debugContext.stroke();

		this.debugContext.strokeStyle = 'blue';
		this.debugContext.beginPath();
		var length = this.world.groupConstraints.length;
		for (k = 0; k < length; k += 1)
		{
			var currLock = this.world.groupConstraints[k];
			this.debugContext.moveTo(currLock.anchorA.getX() * this.scaleX, currLock.anchorA.getY() * this.scaleY);
			this.debugContext.lineTo(currLock.anchorB.getX() * this.scaleX, currLock.anchorB.getY() * this.scaleY);
		}
		this.debugContext.stroke();

		this.debugContext.fillStyle = 'black';
		for (k = 0; k < groupsLength; k += 1)
		{
			var group = this.world.groups[k];
			nodesLength = group.nodes.length;
			for (i = 0; i < nodesLength; i += 1)
			{
				var node = group.nodes[i];
				if (node.debugText) { this.debugContext.fillText(node.debugText, node.getX() * this.scaleX, node.getY() * this.scaleY); }
			}
		}
	}
};

module.exports = SVJellyRenderer;


},{"../../core/Commands":"/Users/Lau/www/svjelly/src/core/Commands.js","../../core/SVJellyUtils":"/Users/Lau/www/svjelly/src/core/SVJellyUtils.js"}],"/Users/Lau/www/svjelly/src/svjellymaker.js":[function(require,module,exports){
var SVJellyWorld = require('./core/SVJellyWorld');
var SVJellyRenderer = require('./renderer/svjelly/SVJellyRenderer');
var SVGParser = require('./core/SVGParser');
var P2PhysicsManager = require('./physics/p2physics/P2PhysicsManager');
var P2MouseControls = require('./physics/p2physics/P2MouseControls');
var SVJellyUtils = require('./core/SVJellyUtils');
var confObject = require('./core/ConfObject');

var requestAnimFrame = window.requestAnimationFrame ||
						window.webkitRequestAnimationFrame ||
						window.mozRequestAnimationFrame;

var cancelAnimFrame = window.cancelAnimationFrame ||
						window.webkitCancelAnimationFrame ||
						window.mozCancelAnimationFrame;

//TODO promise polyfill
var SVJellyMaker =
{
	create: function ()
	{
		var svjellyMaker = Object.create(SVJellyMaker);
		svjellyMaker.initiated = new window.Promise(function (resolve) { svjellyMaker.initiatedResolve = resolve; });
		return svjellyMaker;
	},

	createFromURL: function ($container, $URL, $width, $height, $scaleMode)
	{
		var svjellyMaker = SVJellyMaker.create();
		svjellyMaker.loadFile($URL, function ($SVG)
		{
			svjellyMaker.init($container, $SVG, $width, $height, $scaleMode);
		}, true);
		return svjellyMaker;
	},
	createFromConfig: function ($container, $configURL, $width, $height, $scaleMode)
	{
		var svjellyMaker = SVJellyMaker.create();
		var loadConfigComplete = function ($configData)
		{
			var JSONConfig = JSON.parse($configData);
			svjellyMaker.conf = SVJellyUtils.extend(confObject, JSONConfig);

			SVJellyMaker.loadFile(svjellyMaker.conf.source, function ($SVG)
			{
				svjellyMaker.init($container, $SVG, $width, $height, $scaleMode);
			}, true);
		};
		SVJellyMaker.loadFile($configURL, loadConfigComplete);

		return svjellyMaker;
	},
	createFromString: function ($container, $string, $width, $height, $scaleMode)
	{
		var parser = new DOMParser();
		var doc = parser.parseFromString($string, 'image/svg+xml');
		var svjellyMaker = SVJellyMaker.create();
		svjellyMaker.init($container, doc, $width, $height, $scaleMode);
		return svjellyMaker;
	},
	createFromPageSVG: function ()
	{
		var svjellies = document.querySelectorAll('[data-svjelly]');

		var createViewer = function ($element)
		{
			var svjellyMaker = SVJellyMaker.create();
			var currSVG = $element;
			var appendCanvas = function ($config)
			{
				svjellyMaker.conf = $config;
				var container;
				if (svjellyMaker.conf.multiCanvas)
				{
					container = document.createElement('div');
					container.style.width = currSVG.clientWidth + 'px';
					container.style.height = currSVG.clientHeight + 'px';
				}
				else
				{
					container = document.createElement('canvas');
					container.width = currSVG.clientWidth;
					container.height = currSVG.clientHeight;
				}

				currSVG.parentElement.insertBefore(container, currSVG);
				currSVG.remove();
				svjellyMaker.container = container;
				var wrapper = document.createElement('div');
				wrapper.appendChild(currSVG);
				svjellyMaker.init(container, wrapper, container.clientWidth, container.clientHeight);
			};
			var configURL = currSVG.getAttribute('data-svjelly');
			if (configURL)
			{
				SVJellyMaker.loadFile(configURL, function ($configData)
				{
					var JSONConfig = JSON.parse($configData);
					appendCanvas(SVJellyUtils.extend(confObject, JSONConfig));
				});
			}
			else
			{
				appendCanvas();
			}
		};

		for (var i = 0, length = svjellies.length; i < length; i += 1)
		{
			var currSVG = svjellies[i];
			createViewer(currSVG);
		}
	},

	init: function ($container, $SVG, $width, $height, $scaleMode)
	{
		var conf = this.conf || confObject;
		this.container = $container;

		this.physicsManager = this.physicsManager || new P2PhysicsManager(conf);
		var svjellyWorld = this.svjellyWorld = new SVJellyWorld(this.physicsManager, conf);

		var canvasDefinition = conf.definition || 1;
		var svgDef = $SVG.querySelector('svg');
		var parser = new SVGParser();
		parser.parse(svjellyWorld, svgDef);

		var width = $width || this.container.clientWidth;
		var height = $height || this.container.clientHeight;

		var ratioCanvas = height / width;
		var ratioSVG = parser.viewBoxHeight / parser.viewBoxWidth;
		var canvasWidth;
		var canvasHeight;

		if ((ratioSVG < ratioCanvas && $scaleMode !== 'max') || (ratioSVG > ratioCanvas && $scaleMode === 'max'))
		{
			canvasWidth = width * canvasDefinition;
			canvasHeight = canvasWidth * ratioSVG;
		}
		else
		{
			canvasHeight = height * canvasDefinition;
			canvasWidth = canvasHeight / ratioSVG;
		}

		// this.container.width = canvasWidth;
		// this.container.height = canvasHeight;

		console.log(this.Renderer === true);
		this.renderer = this.Renderer ? this.Renderer.create(svjellyWorld, this.container) : SVJellyRenderer.create(svjellyWorld, this.container);
		this.renderer.setSize(canvasWidth, canvasHeight);

		if (canvasDefinition !== 1)
		{
			this.container.style.transformOrigin = '0 0';
			this.container.style.transform = 'scale(' + 1 / canvasDefinition + ')';
		}

		var requestID = '';
		var lastRender = window.performance.now();
		var diffRender;
		var renderTargetFPS = 0;
		var self = this;

		var update = function ($now)
		{
			if (self.updateCallback) { self.updateCallback($now); }

			diffRender = $now - lastRender;

			self.svjellyWorld.physicsManager.step($now);
			if (diffRender >= renderTargetFPS)
			{
				self.renderer.draw();
				lastRender = $now;
			}
			requestID = requestAnimFrame(update);
		};

		var addAnimRequest = function ()
		{
			cancelAnimFrame(requestID);
			requestID = requestAnimFrame(update);
		};
		var cancelAnimRequest = function ()
		{
			cancelAnimFrame(requestID);
		};

		window.addEventListener('focus', addAnimRequest);
		window.addEventListener('blur', cancelAnimRequest);
		addAnimRequest();

		this.remove = function ()
		{
			cancelAnimRequest();
			window.removeEventListener('focus', addAnimRequest);
			window.removeEventListener('blur', cancelAnimRequest);
		};

		this.initiatedResolve();
	},

	loadFile: function ($URL, $successCallback, $XML)
	{
		var error = function ()
		{
			console.log('error', $URL);
		};

		var handler = function ()
		{
			$successCallback($XML ? this.responseXML : this.responseText);
		};

		var request = new XMLHttpRequest();
		request.addEventListener('load', handler);
		request.addEventListener('error', error);
		request.open('get', $URL, true);
		request.send();
	},

	addBasicMouseControls: function ($stiffness, $relaxation)
	{
		var world = this.svjellyWorld;
		var p2World = world.physicsManager.p2World;
		if (this.mouseControls) { this.mouseControls.removeBasicMouseControls(); }
		this.mouseControls = new P2MouseControls(world, p2World, this.renderer);
		this.mouseControls.addBasicMouseControls($stiffness, $relaxation);
	},

	removeBasicMouseControls: function ()
	{
		this.mouseControls.removeBasicMouseControls();
	}
};

if (document.querySelector('[data-svjelly-auto]'))
{
	var windowLoadHandler = function ()
	{
		SVJellyMaker.createFromPageSVG();
	};
	window.addEventListener('load', windowLoadHandler);
}

module.exports = SVJellyMaker;

},{"./core/ConfObject":"/Users/Lau/www/svjelly/src/core/ConfObject.js","./core/SVGParser":"/Users/Lau/www/svjelly/src/core/SVGParser.js","./core/SVJellyUtils":"/Users/Lau/www/svjelly/src/core/SVJellyUtils.js","./core/SVJellyWorld":"/Users/Lau/www/svjelly/src/core/SVJellyWorld.js","./physics/p2physics/P2MouseControls":"/Users/Lau/www/svjelly/src/physics/p2physics/P2MouseControls.js","./physics/p2physics/P2PhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/P2PhysicsManager.js","./renderer/svjelly/SVJellyRenderer":"/Users/Lau/www/svjelly/src/renderer/svjelly/SVJellyRenderer.js"}]},{},["/Users/Lau/www/svjelly/src/svjellymaker.js"])("/Users/Lau/www/svjelly/src/svjellymaker.js")
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWJzL3AyLmpzIiwibGlicy9wb2x5MnRyaS9kaXN0L3BvbHkydHJpLmpzIiwic3JjL2NvcmUvQ29tbWFuZHMuanMiLCJzcmMvY29yZS9Db25mT2JqZWN0LmpzIiwic3JjL2NvcmUvRGVjb3JhdGlvbkRyYXdpbmcuanMiLCJzcmMvY29yZS9EZWNvcmF0aW9uRHJhd2luZ0NvbW1hbmQuanMiLCJzcmMvY29yZS9HcmlkLmpzIiwic3JjL2NvcmUvTm9kZURyYXdpbmdDb21tYW5kLmpzIiwic3JjL2NvcmUvTm9kZUdyYXBoLmpzIiwic3JjL2NvcmUvT2JqZWN0RHJhd2luZy5qcyIsInNyYy9jb3JlL1BvbHlnb24uanMiLCJzcmMvY29yZS9TVkdQYXJzZXIuanMiLCJzcmMvY29yZS9TVkplbGx5R3JvdXAuanMiLCJzcmMvY29yZS9TVkplbGx5Sm9pbnQuanMiLCJzcmMvY29yZS9TVkplbGx5Tm9kZS5qcyIsInNyYy9jb3JlL1NWSmVsbHlVdGlscy5qcyIsInNyYy9jb3JlL1NWSmVsbHlXb3JsZC5qcyIsInNyYy9jb3JlL1N0cnVjdHVyZS5qcyIsInNyYy9jb3JlL1RyaWFuZ3VsYXRvci5qcyIsInNyYy9waHlzaWNzL3AycGh5c2ljcy9BbmNob3JQMkdob3N0UGh5c2ljc01hbmFnZXIuanMiLCJzcmMvcGh5c2ljcy9wMnBoeXNpY3MvQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXIuanMiLCJzcmMvcGh5c2ljcy9wMnBoeXNpY3MvQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXIuanMiLCJzcmMvcGh5c2ljcy9wMnBoeXNpY3MvR3JvdXBHaG9zdFBoeXNpY3NNYW5hZ2VyLmpzIiwic3JjL3BoeXNpY3MvcDJwaHlzaWNzL0dyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXIuanMiLCJzcmMvcGh5c2ljcy9wMnBoeXNpY3MvR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlci5qcyIsInNyYy9waHlzaWNzL3AycGh5c2ljcy9IYXJkRGVjb3JhdGlvbkRyYXdpbmcuanMiLCJzcmMvcGh5c2ljcy9wMnBoeXNpY3MvSm9pbnRQMlBoeXNpY3NNYW5hZ2VyLmpzIiwic3JjL3BoeXNpY3MvcDJwaHlzaWNzL05vZGVQMkhhcmRQaHlzaWNzTWFuYWdlci5qcyIsInNyYy9waHlzaWNzL3AycGh5c2ljcy9Ob2RlUDJTb2Z0UGh5c2ljc01hbmFnZXIuanMiLCJzcmMvcGh5c2ljcy9wMnBoeXNpY3MvUDJNb3VzZUNvbnRyb2xzLmpzIiwic3JjL3BoeXNpY3MvcDJwaHlzaWNzL1AyUGh5c2ljc01hbmFnZXIuanMiLCJzcmMvcGh5c2ljcy9wMnBoeXNpY3MvUDJVdGlscy5qcyIsInNyYy9waHlzaWNzL3AycGh5c2ljcy9Tb2Z0RGVjb3JhdGlvbkRyYXdpbmcuanMiLCJzcmMvcmVuZGVyZXIvc3ZqZWxseS9TVkplbGx5UmVuZGVyZXIuanMiLCJzcmMvc3ZqZWxseW1ha2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzc5WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2p4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaHBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6bUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBwMi5qcyBhdXRob3JzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZmFsc2UpZGVmaW5lKGUpO2Vsc2V7dmFyIGY7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz9mPXdpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2Y9Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiYoZj1zZWxmKSxmLnAyPWUoKX19KGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNjYWxhciA9IF9kZXJlcV8oJy4vU2NhbGFyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZTtcblxuLyoqXG4gKiBDb250YWluZXIgZm9yIGxpbmUtcmVsYXRlZCBmdW5jdGlvbnNcbiAqIEBjbGFzcyBMaW5lXG4gKi9cbmZ1bmN0aW9uIExpbmUoKXt9O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHR3byBsaW5lcy5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbGluZUludFxuICogQHBhcmFtICB7QXJyYXl9ICBsMSAgICAgICAgICBMaW5lIHZlY3RvciAxXG4gKiBAcGFyYW0gIHtBcnJheX0gIGwyICAgICAgICAgIExpbmUgdmVjdG9yIDJcbiAqIEBwYXJhbSAge051bWJlcn0gcHJlY2lzaW9uICAgUHJlY2lzaW9uIHRvIHVzZSB3aGVuIGNoZWNraW5nIGlmIHRoZSBsaW5lcyBhcmUgcGFyYWxsZWxcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgVGhlIGludGVyc2VjdGlvbiBwb2ludC5cbiAqL1xuTGluZS5saW5lSW50ID0gZnVuY3Rpb24obDEsbDIscHJlY2lzaW9uKXtcbiAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gfHwgMDtcbiAgICB2YXIgaSA9IFswLDBdOyAvLyBwb2ludFxuICAgIHZhciBhMSwgYjEsIGMxLCBhMiwgYjIsIGMyLCBkZXQ7IC8vIHNjYWxhcnNcbiAgICBhMSA9IGwxWzFdWzFdIC0gbDFbMF1bMV07XG4gICAgYjEgPSBsMVswXVswXSAtIGwxWzFdWzBdO1xuICAgIGMxID0gYTEgKiBsMVswXVswXSArIGIxICogbDFbMF1bMV07XG4gICAgYTIgPSBsMlsxXVsxXSAtIGwyWzBdWzFdO1xuICAgIGIyID0gbDJbMF1bMF0gLSBsMlsxXVswXTtcbiAgICBjMiA9IGEyICogbDJbMF1bMF0gKyBiMiAqIGwyWzBdWzFdO1xuICAgIGRldCA9IGExICogYjIgLSBhMipiMTtcbiAgICBpZiAoIVNjYWxhci5lcShkZXQsIDAsIHByZWNpc2lvbikpIHsgLy8gbGluZXMgYXJlIG5vdCBwYXJhbGxlbFxuICAgICAgICBpWzBdID0gKGIyICogYzEgLSBiMSAqIGMyKSAvIGRldDtcbiAgICAgICAgaVsxXSA9IChhMSAqIGMyIC0gYTIgKiBjMSkgLyBkZXQ7XG4gICAgfVxuICAgIHJldHVybiBpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0cy5cbiAqIEBtZXRob2Qgc2VnbWVudHNJbnRlcnNlY3RcbiAqIEBwYXJhbSB7QXJyYXl9IHAxIFRoZSBzdGFydCB2ZXJ0ZXggb2YgdGhlIGZpcnN0IGxpbmUgc2VnbWVudC5cbiAqIEBwYXJhbSB7QXJyYXl9IHAyIFRoZSBlbmQgdmVydGV4IG9mIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuXG4gKiBAcGFyYW0ge0FycmF5fSBxMSBUaGUgc3RhcnQgdmVydGV4IG9mIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LlxuICogQHBhcmFtIHtBcnJheX0gcTIgVGhlIGVuZCB2ZXJ0ZXggb2YgdGhlIHNlY29uZCBsaW5lIHNlZ21lbnQuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSB0d28gbGluZSBzZWdtZW50cyBpbnRlcnNlY3RcbiAqL1xuTGluZS5zZWdtZW50c0ludGVyc2VjdCA9IGZ1bmN0aW9uKHAxLCBwMiwgcTEsIHEyKXtcbiAgIHZhciBkeCA9IHAyWzBdIC0gcDFbMF07XG4gICB2YXIgZHkgPSBwMlsxXSAtIHAxWzFdO1xuICAgdmFyIGRhID0gcTJbMF0gLSBxMVswXTtcbiAgIHZhciBkYiA9IHEyWzFdIC0gcTFbMV07XG5cbiAgIC8vIHNlZ21lbnRzIGFyZSBwYXJhbGxlbFxuICAgaWYoZGEqZHkgLSBkYipkeCA9PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICB2YXIgcyA9IChkeCAqIChxMVsxXSAtIHAxWzFdKSArIGR5ICogKHAxWzBdIC0gcTFbMF0pKSAvIChkYSAqIGR5IC0gZGIgKiBkeClcbiAgIHZhciB0ID0gKGRhICogKHAxWzFdIC0gcTFbMV0pICsgZGIgKiAocTFbMF0gLSBwMVswXSkpIC8gKGRiICogZHggLSBkYSAqIGR5KVxuXG4gICByZXR1cm4gKHM+PTAgJiYgczw9MSAmJiB0Pj0wICYmIHQ8PTEpO1xufTtcblxuXG59LHtcIi4vU2NhbGFyXCI6NH1dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuLyoqXG4gKiBQb2ludCByZWxhdGVkIGZ1bmN0aW9uc1xuICogQGNsYXNzIFBvaW50XG4gKi9cbmZ1bmN0aW9uIFBvaW50KCl7fTtcblxuLyoqXG4gKiBHZXQgdGhlIGFyZWEgb2YgYSB0cmlhbmdsZSBzcGFubmVkIGJ5IHRoZSB0aHJlZSBnaXZlbiBwb2ludHMuIE5vdGUgdGhhdCB0aGUgYXJlYSB3aWxsIGJlIG5lZ2F0aXZlIGlmIHRoZSBwb2ludHMgYXJlIG5vdCBnaXZlbiBpbiBjb3VudGVyLWNsb2Nrd2lzZSBvcmRlci5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgYXJlYVxuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEBwYXJhbSAge0FycmF5fSBiXG4gKiBAcGFyYW0gIHtBcnJheX0gY1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Qb2ludC5hcmVhID0gZnVuY3Rpb24oYSxiLGMpe1xuICAgIHJldHVybiAoKChiWzBdIC0gYVswXSkqKGNbMV0gLSBhWzFdKSktKChjWzBdIC0gYVswXSkqKGJbMV0gLSBhWzFdKSkpO1xufTtcblxuUG9pbnQubGVmdCA9IGZ1bmN0aW9uKGEsYixjKXtcbiAgICByZXR1cm4gUG9pbnQuYXJlYShhLGIsYykgPiAwO1xufTtcblxuUG9pbnQubGVmdE9uID0gZnVuY3Rpb24oYSxiLGMpIHtcbiAgICByZXR1cm4gUG9pbnQuYXJlYShhLCBiLCBjKSA+PSAwO1xufTtcblxuUG9pbnQucmlnaHQgPSBmdW5jdGlvbihhLGIsYykge1xuICAgIHJldHVybiBQb2ludC5hcmVhKGEsIGIsIGMpIDwgMDtcbn07XG5cblBvaW50LnJpZ2h0T24gPSBmdW5jdGlvbihhLGIsYykge1xuICAgIHJldHVybiBQb2ludC5hcmVhKGEsIGIsIGMpIDw9IDA7XG59O1xuXG52YXIgdG1wUG9pbnQxID0gW10sXG4gICAgdG1wUG9pbnQyID0gW107XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhyZWUgcG9pbnRzIGFyZSBjb2xsaW5lYXJcbiAqIEBtZXRob2QgY29sbGluZWFyXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7QXJyYXl9IGJcbiAqIEBwYXJhbSAge0FycmF5fSBjXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFt0aHJlc2hvbGRBbmdsZT0wXSBUaHJlc2hvbGQgYW5nbGUgdG8gdXNlIHdoZW4gY29tcGFyaW5nIHRoZSB2ZWN0b3JzLiBUaGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgcmVzdWx0aW5nIHZlY3RvcnMgaXMgbGVzcyB0aGFuIHRoaXMgdmFsdWUuIFVzZSB6ZXJvIGZvciBtYXggcHJlY2lzaW9uLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuUG9pbnQuY29sbGluZWFyID0gZnVuY3Rpb24oYSxiLGMsdGhyZXNob2xkQW5nbGUpIHtcbiAgICBpZighdGhyZXNob2xkQW5nbGUpXG4gICAgICAgIHJldHVybiBQb2ludC5hcmVhKGEsIGIsIGMpID09IDA7XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBhYiA9IHRtcFBvaW50MSxcbiAgICAgICAgICAgIGJjID0gdG1wUG9pbnQyO1xuXG4gICAgICAgIGFiWzBdID0gYlswXS1hWzBdO1xuICAgICAgICBhYlsxXSA9IGJbMV0tYVsxXTtcbiAgICAgICAgYmNbMF0gPSBjWzBdLWJbMF07XG4gICAgICAgIGJjWzFdID0gY1sxXS1iWzFdO1xuXG4gICAgICAgIHZhciBkb3QgPSBhYlswXSpiY1swXSArIGFiWzFdKmJjWzFdLFxuICAgICAgICAgICAgbWFnQSA9IE1hdGguc3FydChhYlswXSphYlswXSArIGFiWzFdKmFiWzFdKSxcbiAgICAgICAgICAgIG1hZ0IgPSBNYXRoLnNxcnQoYmNbMF0qYmNbMF0gKyBiY1sxXSpiY1sxXSksXG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguYWNvcyhkb3QvKG1hZ0EqbWFnQikpO1xuICAgICAgICByZXR1cm4gYW5nbGUgPCB0aHJlc2hvbGRBbmdsZTtcbiAgICB9XG59O1xuXG5Qb2ludC5zcWRpc3QgPSBmdW5jdGlvbihhLGIpe1xuICAgIHZhciBkeCA9IGJbMF0gLSBhWzBdO1xuICAgIHZhciBkeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn07XG5cbn0se31dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIExpbmUgPSBfZGVyZXFfKFwiLi9MaW5lXCIpXG4sICAgUG9pbnQgPSBfZGVyZXFfKFwiLi9Qb2ludFwiKVxuLCAgIFNjYWxhciA9IF9kZXJlcV8oXCIuL1NjYWxhclwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbHlnb247XG5cbi8qKlxuICogUG9seWdvbiBjbGFzcy5cbiAqIEBjbGFzcyBQb2x5Z29uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUG9seWdvbigpe1xuXG4gICAgLyoqXG4gICAgICogVmVydGljZXMgdGhhdCB0aGlzIHBvbHlnb24gY29uc2lzdHMgb2YuIEFuIGFycmF5IG9mIGFycmF5IG9mIG51bWJlcnMsIGV4YW1wbGU6IFtbMCwwXSxbMSwwXSwuLl1cbiAgICAgKiBAcHJvcGVydHkgdmVydGljZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xufVxuXG4vKipcbiAqIEdldCBhIHZlcnRleCBhdCBwb3NpdGlvbiBpLiBJdCBkb2VzIG5vdCBtYXR0ZXIgaWYgaSBpcyBvdXQgb2YgYm91bmRzLCB0aGlzIGZ1bmN0aW9uIHdpbGwganVzdCBjeWNsZS5cbiAqIEBtZXRob2QgYXRcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24oaSl7XG4gICAgdmFyIHYgPSB0aGlzLnZlcnRpY2VzLFxuICAgICAgICBzID0gdi5sZW5ndGg7XG4gICAgcmV0dXJuIHZbaSA8IDAgPyBpICUgcyArIHMgOiBpICUgc107XG59O1xuXG4vKipcbiAqIEdldCBmaXJzdCB2ZXJ0ZXhcbiAqIEBtZXRob2QgZmlyc3RcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5maXJzdCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMudmVydGljZXNbMF07XG59O1xuXG4vKipcbiAqIEdldCBsYXN0IHZlcnRleFxuICogQG1ldGhvZCBsYXN0XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMudmVydGljZXNbdGhpcy52ZXJ0aWNlcy5sZW5ndGgtMV07XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSBwb2x5Z29uIGRhdGFcbiAqIEBtZXRob2QgY2xlYXJcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy52ZXJ0aWNlcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBBcHBlbmQgcG9pbnRzIFwiZnJvbVwiIHRvIFwidG9cIi0xIGZyb20gYW4gb3RoZXIgcG9seWdvbiBcInBvbHlcIiBvbnRvIHRoaXMgb25lLlxuICogQG1ldGhvZCBhcHBlbmRcbiAqIEBwYXJhbSB7UG9seWdvbn0gcG9seSBUaGUgcG9seWdvbiB0byBnZXQgcG9pbnRzIGZyb20uXG4gKiBAcGFyYW0ge051bWJlcn0gIGZyb20gVGhlIHZlcnRleCBpbmRleCBpbiBcInBvbHlcIi5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgdG8gVGhlIGVuZCB2ZXJ0ZXggaW5kZXggaW4gXCJwb2x5XCIuIE5vdGUgdGhhdCB0aGlzIHZlcnRleCBpcyBOT1QgaW5jbHVkZWQgd2hlbiBhcHBlbmRpbmcuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24ocG9seSxmcm9tLHRvKXtcbiAgICBpZih0eXBlb2YoZnJvbSkgPT0gXCJ1bmRlZmluZWRcIikgdGhyb3cgbmV3IEVycm9yKFwiRnJvbSBpcyBub3QgZ2l2ZW4hXCIpO1xuICAgIGlmKHR5cGVvZih0bykgPT0gXCJ1bmRlZmluZWRcIikgICB0aHJvdyBuZXcgRXJyb3IoXCJUbyBpcyBub3QgZ2l2ZW4hXCIpO1xuXG4gICAgaWYodG8tMSA8IGZyb20pICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2wxXCIpO1xuICAgIGlmKHRvID4gcG9seS52ZXJ0aWNlcy5sZW5ndGgpICAgdGhyb3cgbmV3IEVycm9yKFwibG9sMlwiKTtcbiAgICBpZihmcm9tIDwgMCkgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxvbDNcIik7XG5cbiAgICBmb3IodmFyIGk9ZnJvbTsgaTx0bzsgaSsrKXtcbiAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKHBvbHkudmVydGljZXNbaV0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogTWFrZSBzdXJlIHRoYXQgdGhlIHBvbHlnb24gdmVydGljZXMgYXJlIG9yZGVyZWQgY291bnRlci1jbG9ja3dpc2UuXG4gKiBAbWV0aG9kIG1ha2VDQ1dcbiAqL1xuUG9seWdvbi5wcm90b3R5cGUubWFrZUNDVyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJyID0gMCxcbiAgICAgICAgdiA9IHRoaXMudmVydGljZXM7XG5cbiAgICAvLyBmaW5kIGJvdHRvbSByaWdodCBwb2ludFxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodltpXVsxXSA8IHZbYnJdWzFdIHx8ICh2W2ldWzFdID09IHZbYnJdWzFdICYmIHZbaV1bMF0gPiB2W2JyXVswXSkpIHtcbiAgICAgICAgICAgIGJyID0gaTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldmVyc2UgcG9seSBpZiBjbG9ja3dpc2VcbiAgICBpZiAoIVBvaW50LmxlZnQodGhpcy5hdChiciAtIDEpLCB0aGlzLmF0KGJyKSwgdGhpcy5hdChiciArIDEpKSkge1xuICAgICAgICB0aGlzLnJldmVyc2UoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldmVyc2UgdGhlIHZlcnRpY2VzIGluIHRoZSBwb2x5Z29uXG4gKiBAbWV0aG9kIHJldmVyc2VcbiAqL1xuUG9seWdvbi5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHRtcCA9IFtdO1xuICAgIGZvcih2YXIgaT0wLCBOPXRoaXMudmVydGljZXMubGVuZ3RoOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdG1wLnB1c2godGhpcy52ZXJ0aWNlcy5wb3AoKSk7XG4gICAgfVxuICAgIHRoaXMudmVydGljZXMgPSB0bXA7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgcG9pbnQgaW4gdGhlIHBvbHlnb24gaXMgYSByZWZsZXggcG9pbnRcbiAqIEBtZXRob2QgaXNSZWZsZXhcbiAqIEBwYXJhbSAge051bWJlcn0gIGlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmlzUmVmbGV4ID0gZnVuY3Rpb24oaSl7XG4gICAgcmV0dXJuIFBvaW50LnJpZ2h0KHRoaXMuYXQoaSAtIDEpLCB0aGlzLmF0KGkpLCB0aGlzLmF0KGkgKyAxKSk7XG59O1xuXG52YXIgdG1wTGluZTE9W10sXG4gICAgdG1wTGluZTI9W107XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZlcnRpY2VzIGluIHRoZSBwb2x5Z29uIGNhbiBzZWUgZWFjaCBvdGhlclxuICogQG1ldGhvZCBjYW5TZWVcbiAqIEBwYXJhbSAge051bWJlcn0gYSBWZXJ0ZXggaW5kZXggMVxuICogQHBhcmFtICB7TnVtYmVyfSBiIFZlcnRleCBpbmRleCAyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5jYW5TZWUgPSBmdW5jdGlvbihhLGIpIHtcbiAgICB2YXIgcCwgZGlzdCwgbDE9dG1wTGluZTEsIGwyPXRtcExpbmUyO1xuXG4gICAgaWYgKFBvaW50LmxlZnRPbih0aGlzLmF0KGEgKyAxKSwgdGhpcy5hdChhKSwgdGhpcy5hdChiKSkgJiYgUG9pbnQucmlnaHRPbih0aGlzLmF0KGEgLSAxKSwgdGhpcy5hdChhKSwgdGhpcy5hdChiKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkaXN0ID0gUG9pbnQuc3FkaXN0KHRoaXMuYXQoYSksIHRoaXMuYXQoYikpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgKytpKSB7IC8vIGZvciBlYWNoIGVkZ2VcbiAgICAgICAgaWYgKChpICsgMSkgJSB0aGlzLnZlcnRpY2VzLmxlbmd0aCA9PT0gYSB8fCBpID09PSBhKSAvLyBpZ25vcmUgaW5jaWRlbnQgZWRnZXNcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoUG9pbnQubGVmdE9uKHRoaXMuYXQoYSksIHRoaXMuYXQoYiksIHRoaXMuYXQoaSArIDEpKSAmJiBQb2ludC5yaWdodE9uKHRoaXMuYXQoYSksIHRoaXMuYXQoYiksIHRoaXMuYXQoaSkpKSB7IC8vIGlmIGRpYWcgaW50ZXJzZWN0cyBhbiBlZGdlXG4gICAgICAgICAgICBsMVswXSA9IHRoaXMuYXQoYSk7XG4gICAgICAgICAgICBsMVsxXSA9IHRoaXMuYXQoYik7XG4gICAgICAgICAgICBsMlswXSA9IHRoaXMuYXQoaSk7XG4gICAgICAgICAgICBsMlsxXSA9IHRoaXMuYXQoaSArIDEpO1xuICAgICAgICAgICAgcCA9IExpbmUubGluZUludChsMSxsMik7XG4gICAgICAgICAgICBpZiAoUG9pbnQuc3FkaXN0KHRoaXMuYXQoYSksIHApIDwgZGlzdCkgeyAvLyBpZiBlZGdlIGlzIGJsb2NraW5nIHZpc2liaWxpdHkgdG8gYlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSBwb2x5Z29uIGZyb20gdmVydGV4IGkgdG8gdmVydGV4IGouXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7TnVtYmVyfSBqXG4gKiBAcGFyYW0gIHtQb2x5Z29ufSBbdGFyZ2V0UG9seV0gICBPcHRpb25hbCB0YXJnZXQgcG9seWdvbiB0byBzYXZlIGluLlxuICogQHJldHVybiB7UG9seWdvbn0gICAgICAgICAgICAgICAgVGhlIHJlc3VsdGluZyBjb3B5LlxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oaSxqLHRhcmdldFBvbHkpe1xuICAgIHZhciBwID0gdGFyZ2V0UG9seSB8fCBuZXcgUG9seWdvbigpO1xuICAgIHAuY2xlYXIoKTtcbiAgICBpZiAoaSA8IGopIHtcbiAgICAgICAgLy8gSW5zZXJ0IGFsbCB2ZXJ0aWNlcyBmcm9tIGkgdG8galxuICAgICAgICBmb3IodmFyIGs9aTsgazw9ajsgaysrKVxuICAgICAgICAgICAgcC52ZXJ0aWNlcy5wdXNoKHRoaXMudmVydGljZXNba10pO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBJbnNlcnQgdmVydGljZXMgMCB0byBqXG4gICAgICAgIGZvcih2YXIgaz0wOyBrPD1qOyBrKyspXG4gICAgICAgICAgICBwLnZlcnRpY2VzLnB1c2godGhpcy52ZXJ0aWNlc1trXSk7XG5cbiAgICAgICAgLy8gSW5zZXJ0IHZlcnRpY2VzIGkgdG8gZW5kXG4gICAgICAgIGZvcih2YXIgaz1pOyBrPHRoaXMudmVydGljZXMubGVuZ3RoOyBrKyspXG4gICAgICAgICAgICBwLnZlcnRpY2VzLnB1c2godGhpcy52ZXJ0aWNlc1trXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG59O1xuXG4vKipcbiAqIERlY29tcG9zZXMgdGhlIHBvbHlnb24gaW50byBjb252ZXggcGllY2VzLiBSZXR1cm5zIGEgbGlzdCBvZiBlZGdlcyBbW3AxLHAyXSxbcDIscDNdLC4uLl0gdGhhdCBjdXRzIHRoZSBwb2x5Z29uLlxuICogTm90ZSB0aGF0IHRoaXMgYWxnb3JpdGhtIGhhcyBjb21wbGV4aXR5IE8oTl40KSBhbmQgd2lsbCBiZSB2ZXJ5IHNsb3cgZm9yIHBvbHlnb25zIHdpdGggbWFueSB2ZXJ0aWNlcy5cbiAqIEBtZXRob2QgZ2V0Q3V0RWRnZXNcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5nZXRDdXRFZGdlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtaW49W10sIHRtcDE9W10sIHRtcDI9W10sIHRtcFBvbHkgPSBuZXcgUG9seWdvbigpO1xuICAgIHZhciBuRGlhZ3MgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVmbGV4KGkpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMudmVydGljZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW5TZWUoaSwgaikpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wMSA9IHRoaXMuY29weShpLCBqLCB0bXBQb2x5KS5nZXRDdXRFZGdlcygpO1xuICAgICAgICAgICAgICAgICAgICB0bXAyID0gdGhpcy5jb3B5KGosIGksIHRtcFBvbHkpLmdldEN1dEVkZ2VzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBrPTA7IGs8dG1wMi5sZW5ndGg7IGsrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcDEucHVzaCh0bXAyW2tdKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodG1wMS5sZW5ndGggPCBuRGlhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbiA9IHRtcDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBuRGlhZ3MgPSB0bXAxLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbi5wdXNoKFt0aGlzLmF0KGkpLCB0aGlzLmF0KGopXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWluO1xufTtcblxuLyoqXG4gKiBEZWNvbXBvc2VzIHRoZSBwb2x5Z29uIGludG8gb25lIG9yIG1vcmUgY29udmV4IHN1Yi1Qb2x5Z29ucy5cbiAqIEBtZXRob2QgZGVjb21wXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb3IgUG9seWdvbiBvYmplY3RzLlxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5kZWNvbXAgPSBmdW5jdGlvbigpe1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZ2V0Q3V0RWRnZXMoKTtcbiAgICBpZihlZGdlcy5sZW5ndGggPiAwKVxuICAgICAgICByZXR1cm4gdGhpcy5zbGljZShlZGdlcyk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gW3RoaXNdO1xufTtcblxuLyoqXG4gKiBTbGljZXMgdGhlIHBvbHlnb24gZ2l2ZW4gb25lIG9yIG1vcmUgY3V0IGVkZ2VzLiBJZiBnaXZlbiBvbmUsIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdHdvIHBvbHlnb25zIChmYWxzZSBvbiBmYWlsdXJlKS4gSWYgbWFueSwgYW4gYXJyYXkgb2YgcG9seWdvbnMuXG4gKiBAbWV0aG9kIHNsaWNlXG4gKiBAcGFyYW0ge0FycmF5fSBjdXRFZGdlcyBBIGxpc3Qgb2YgZWRnZXMsIGFzIHJldHVybmVkIGJ5IC5nZXRDdXRFZGdlcygpXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihjdXRFZGdlcyl7XG4gICAgaWYoY3V0RWRnZXMubGVuZ3RoID09IDApIHJldHVybiBbdGhpc107XG4gICAgaWYoY3V0RWRnZXMgaW5zdGFuY2VvZiBBcnJheSAmJiBjdXRFZGdlcy5sZW5ndGggJiYgY3V0RWRnZXNbMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBjdXRFZGdlc1swXS5sZW5ndGg9PTIgJiYgY3V0RWRnZXNbMF1bMF0gaW5zdGFuY2VvZiBBcnJheSl7XG5cbiAgICAgICAgdmFyIHBvbHlzID0gW3RoaXNdO1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGN1dEVkZ2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBjdXRFZGdlID0gY3V0RWRnZXNbaV07XG4gICAgICAgICAgICAvLyBDdXQgYWxsIHBvbHlzXG4gICAgICAgICAgICBmb3IodmFyIGo9MDsgajxwb2x5cy5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICAgICAgdmFyIHBvbHkgPSBwb2x5c1tqXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcG9seS5zbGljZShjdXRFZGdlKTtcbiAgICAgICAgICAgICAgICBpZihyZXN1bHQpe1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBwb2x5ISBDdXQgYW5kIHF1aXRcbiAgICAgICAgICAgICAgICAgICAgcG9seXMuc3BsaWNlKGosMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlzLnB1c2gocmVzdWx0WzBdLHJlc3VsdFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2x5cztcbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIFdhcyBnaXZlbiBvbmUgZWRnZVxuICAgICAgICB2YXIgY3V0RWRnZSA9IGN1dEVkZ2VzO1xuICAgICAgICB2YXIgaSA9IHRoaXMudmVydGljZXMuaW5kZXhPZihjdXRFZGdlWzBdKTtcbiAgICAgICAgdmFyIGogPSB0aGlzLnZlcnRpY2VzLmluZGV4T2YoY3V0RWRnZVsxXSk7XG5cbiAgICAgICAgaWYoaSAhPSAtMSAmJiBqICE9IC0xKXtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5jb3B5KGksaiksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29weShqLGkpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQ2hlY2tzIHRoYXQgdGhlIGxpbmUgc2VnbWVudHMgb2YgdGhpcyBwb2x5Z29uIGRvIG5vdCBpbnRlcnNlY3QgZWFjaCBvdGhlci5cbiAqIEBtZXRob2QgaXNTaW1wbGVcbiAqIEBwYXJhbSAge0FycmF5fSBwYXRoIEFuIGFycmF5IG9mIHZlcnRpY2VzIGUuZy4gW1swLDBdLFswLDFdLC4uLl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAdG9kbyBTaG91bGQgaXQgY2hlY2sgYWxsIHNlZ21lbnRzIHdpdGggYWxsIG90aGVycz9cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuaXNTaW1wbGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXRoID0gdGhpcy52ZXJ0aWNlcztcbiAgICAvLyBDaGVja1xuICAgIGZvcih2YXIgaT0wOyBpPHBhdGgubGVuZ3RoLTE7IGkrKyl7XG4gICAgICAgIGZvcih2YXIgaj0wOyBqPGktMTsgaisrKXtcbiAgICAgICAgICAgIGlmKExpbmUuc2VnbWVudHNJbnRlcnNlY3QocGF0aFtpXSwgcGF0aFtpKzFdLCBwYXRoW2pdLCBwYXRoW2orMV0gKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdGhlIHNlZ21lbnQgYmV0d2VlbiB0aGUgbGFzdCBhbmQgdGhlIGZpcnN0IHBvaW50IHRvIGFsbCBvdGhlcnNcbiAgICBmb3IodmFyIGk9MTsgaTxwYXRoLmxlbmd0aC0yOyBpKyspe1xuICAgICAgICBpZihMaW5lLnNlZ21lbnRzSW50ZXJzZWN0KHBhdGhbMF0sIHBhdGhbcGF0aC5sZW5ndGgtMV0sIHBhdGhbaV0sIHBhdGhbaSsxXSApKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocDEsIHAyLCBxMSwgcTIsIGRlbHRhKXtcbiAgICBkZWx0YSA9IGRlbHRhIHx8IDA7XG4gICB2YXIgYTEgPSBwMlsxXSAtIHAxWzFdO1xuICAgdmFyIGIxID0gcDFbMF0gLSBwMlswXTtcbiAgIHZhciBjMSA9IChhMSAqIHAxWzBdKSArIChiMSAqIHAxWzFdKTtcbiAgIHZhciBhMiA9IHEyWzFdIC0gcTFbMV07XG4gICB2YXIgYjIgPSBxMVswXSAtIHEyWzBdO1xuICAgdmFyIGMyID0gKGEyICogcTFbMF0pICsgKGIyICogcTFbMV0pO1xuICAgdmFyIGRldCA9IChhMSAqIGIyKSAtIChhMiAqIGIxKTtcblxuICAgaWYoIVNjYWxhci5lcShkZXQsMCxkZWx0YSkpXG4gICAgICByZXR1cm4gWygoYjIgKiBjMSkgLSAoYjEgKiBjMikpIC8gZGV0LCAoKGExICogYzIpIC0gKGEyICogYzEpKSAvIGRldF1cbiAgIGVsc2VcbiAgICAgIHJldHVybiBbMCwwXVxufVxuXG4vKipcbiAqIFF1aWNrbHkgZGVjb21wb3NlIHRoZSBQb2x5Z29uIGludG8gY29udmV4IHN1Yi1wb2x5Z29ucy5cbiAqIEBtZXRob2QgcXVpY2tEZWNvbXBcbiAqIEBwYXJhbSAge0FycmF5fSByZXN1bHRcbiAqIEBwYXJhbSAge0FycmF5fSBbcmVmbGV4VmVydGljZXNdXG4gKiBAcGFyYW0gIHtBcnJheX0gW3N0ZWluZXJQb2ludHNdXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtkZWx0YV1cbiAqIEBwYXJhbSAge051bWJlcn0gW21heGxldmVsXVxuICogQHBhcmFtICB7TnVtYmVyfSBbbGV2ZWxdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUucXVpY2tEZWNvbXAgPSBmdW5jdGlvbihyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCl7XG4gICAgbWF4bGV2ZWwgPSBtYXhsZXZlbCB8fCAxMDA7XG4gICAgbGV2ZWwgPSBsZXZlbCB8fCAwO1xuICAgIGRlbHRhID0gZGVsdGEgfHwgMjU7XG4gICAgcmVzdWx0ID0gdHlwZW9mKHJlc3VsdCkhPVwidW5kZWZpbmVkXCIgPyByZXN1bHQgOiBbXTtcbiAgICByZWZsZXhWZXJ0aWNlcyA9IHJlZmxleFZlcnRpY2VzIHx8IFtdO1xuICAgIHN0ZWluZXJQb2ludHMgPSBzdGVpbmVyUG9pbnRzIHx8IFtdO1xuXG4gICAgdmFyIHVwcGVySW50PVswLDBdLCBsb3dlckludD1bMCwwXSwgcD1bMCwwXTsgLy8gUG9pbnRzXG4gICAgdmFyIHVwcGVyRGlzdD0wLCBsb3dlckRpc3Q9MCwgZD0wLCBjbG9zZXN0RGlzdD0wOyAvLyBzY2FsYXJzXG4gICAgdmFyIHVwcGVySW5kZXg9MCwgbG93ZXJJbmRleD0wLCBjbG9zZXN0SW5kZXg9MDsgLy8gSW50ZWdlcnNcbiAgICB2YXIgbG93ZXJQb2x5PW5ldyBQb2x5Z29uKCksIHVwcGVyUG9seT1uZXcgUG9seWdvbigpOyAvLyBwb2x5Z29uc1xuICAgIHZhciBwb2x5ID0gdGhpcyxcbiAgICAgICAgdiA9IHRoaXMudmVydGljZXM7XG5cbiAgICBpZih2Lmxlbmd0aCA8IDMpIHJldHVybiByZXN1bHQ7XG5cbiAgICBsZXZlbCsrO1xuICAgIGlmKGxldmVsID4gbWF4bGV2ZWwpe1xuICAgICAgICBjb25zb2xlLndhcm4oXCJxdWlja0RlY29tcDogbWF4IGxldmVsIChcIittYXhsZXZlbCtcIikgcmVhY2hlZC5cIik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChwb2x5LmlzUmVmbGV4KGkpKSB7XG4gICAgICAgICAgICByZWZsZXhWZXJ0aWNlcy5wdXNoKHBvbHkudmVydGljZXNbaV0pO1xuICAgICAgICAgICAgdXBwZXJEaXN0ID0gbG93ZXJEaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMudmVydGljZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAoUG9pbnQubGVmdChwb2x5LmF0KGkgLSAxKSwgcG9seS5hdChpKSwgcG9seS5hdChqKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIFBvaW50LnJpZ2h0T24ocG9seS5hdChpIC0gMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaiAtIDEpKSkgeyAvLyBpZiBsaW5lIGludGVyc2VjdHMgd2l0aCBhbiBlZGdlXG4gICAgICAgICAgICAgICAgICAgIHAgPSBnZXRJbnRlcnNlY3Rpb25Qb2ludChwb2x5LmF0KGkgLSAxKSwgcG9seS5hdChpKSwgcG9seS5hdChqKSwgcG9seS5hdChqIC0gMSkpOyAvLyBmaW5kIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKFBvaW50LnJpZ2h0KHBvbHkuYXQoaSArIDEpLCBwb2x5LmF0KGkpLCBwKSkgeyAvLyBtYWtlIHN1cmUgaXQncyBpbnNpZGUgdGhlIHBvbHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBQb2ludC5zcWRpc3QocG9seS52ZXJ0aWNlc1tpXSwgcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IGxvd2VyRGlzdCkgeyAvLyBrZWVwIG9ubHkgdGhlIGNsb3Nlc3QgaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJEaXN0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckludCA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJbmRleCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFBvaW50LmxlZnQocG9seS5hdChpICsgMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaiArIDEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgUG9pbnQucmlnaHRPbihwb2x5LmF0KGkgKyAxKSwgcG9seS5hdChpKSwgcG9seS5hdChqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IGdldEludGVyc2VjdGlvblBvaW50KHBvbHkuYXQoaSArIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGopLCBwb2x5LmF0KGogKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChQb2ludC5sZWZ0KHBvbHkuYXQoaSAtIDEpLCBwb2x5LmF0KGkpLCBwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IFBvaW50LnNxZGlzdChwb2x5LnZlcnRpY2VzW2ldLCBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkIDwgdXBwZXJEaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJEaXN0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckludCA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJJbmRleCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyB2ZXJ0aWNlcyB0byBjb25uZWN0IHRvLCBjaG9vc2UgYSBwb2ludCBpbiB0aGUgbWlkZGxlXG4gICAgICAgICAgICBpZiAobG93ZXJJbmRleCA9PSAodXBwZXJJbmRleCArIDEpICUgdGhpcy52ZXJ0aWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2FzZSAxOiBWZXJ0ZXgoXCIraStcIiksIGxvd2VySW5kZXgoXCIrbG93ZXJJbmRleCtcIiksIHVwcGVySW5kZXgoXCIrdXBwZXJJbmRleCtcIiksIHBvbHkuc2l6ZShcIit0aGlzLnZlcnRpY2VzLmxlbmd0aCtcIilcIik7XG4gICAgICAgICAgICAgICAgcFswXSA9IChsb3dlckludFswXSArIHVwcGVySW50WzBdKSAvIDI7XG4gICAgICAgICAgICAgICAgcFsxXSA9IChsb3dlckludFsxXSArIHVwcGVySW50WzFdKSAvIDI7XG4gICAgICAgICAgICAgICAgc3RlaW5lclBvaW50cy5wdXNoKHApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPCB1cHBlckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vbG93ZXJQb2x5Lmluc2VydChsb3dlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGksIHBvbHkuYmVnaW4oKSArIHVwcGVySW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LmFwcGVuZChwb2x5LCBpLCB1cHBlckluZGV4KzEpO1xuICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkudmVydGljZXMucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LnZlcnRpY2VzLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dlckluZGV4ICE9IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgbG93ZXJJbmRleCwgcG9seS5lbmQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkuYXBwZW5kKHBvbHksbG93ZXJJbmRleCxwb2x5LnZlcnRpY2VzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpLCBwb2x5LmJlZ2luKCkgKyBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5hcHBlbmQocG9seSwwLGkrMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xvd2VyUG9seS5pbnNlcnQobG93ZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBpLCBwb2x5LmVuZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5hcHBlbmQocG9seSxpLHBvbHkudmVydGljZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2xvd2VyUG9seS5pbnNlcnQobG93ZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCksIHBvbHkuYmVnaW4oKSArIHVwcGVySW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LmFwcGVuZChwb2x5LDAsdXBwZXJJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LnZlcnRpY2VzLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS52ZXJ0aWNlcy5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICAvL3VwcGVyUG9seS5pbnNlcnQodXBwZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBsb3dlckluZGV4LCBwb2x5LmJlZ2luKCkgKyBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5hcHBlbmQocG9seSxsb3dlckluZGV4LGkrMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjb25uZWN0IHRvIHRoZSBjbG9zZXN0IHBvaW50IHdpdGhpbiB0aGUgdHJpYW5nbGVcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2FzZSAyOiBWZXJ0ZXgoXCIraStcIiksIGNsb3Nlc3RJbmRleChcIitjbG9zZXN0SW5kZXgrXCIpLCBwb2x5LnNpemUoXCIrdGhpcy52ZXJ0aWNlcy5sZW5ndGgrXCIpXFxuXCIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxvd2VySW5kZXggPiB1cHBlckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVySW5kZXggKz0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgICAgICAgICAgIGlmKHVwcGVySW5kZXggPCBsb3dlckluZGV4KXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gbG93ZXJJbmRleDsgaiA8PSB1cHBlckluZGV4OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFBvaW50LmxlZnRPbihwb2x5LmF0KGkgLSAxKSwgcG9seS5hdChpKSwgcG9seS5hdChqKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBQb2ludC5yaWdodE9uKHBvbHkuYXQoaSArIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGopKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IFBvaW50LnNxZGlzdChwb2x5LmF0KGkpLCBwb2x5LmF0KGopKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkIDwgY2xvc2VzdERpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdEluZGV4ID0gaiAlIHRoaXMudmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGkgPCBjbG9zZXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LmFwcGVuZChwb2x5LGksY2xvc2VzdEluZGV4KzEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VzdEluZGV4ICE9IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LmFwcGVuZChwb2x5LGNsb3Nlc3RJbmRleCx2Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LmFwcGVuZChwb2x5LDAsaSsxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5hcHBlbmQocG9seSxpLHYubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkuYXBwZW5kKHBvbHksMCxjbG9zZXN0SW5kZXgrMSk7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5hcHBlbmQocG9seSxjbG9zZXN0SW5kZXgsaSsxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNvbHZlIHNtYWxsZXN0IHBvbHkgZmlyc3RcbiAgICAgICAgICAgIGlmIChsb3dlclBvbHkudmVydGljZXMubGVuZ3RoIDwgdXBwZXJQb2x5LnZlcnRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxvd2VyUG9seS5xdWlja0RlY29tcChyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICAgICAgdXBwZXJQb2x5LnF1aWNrRGVjb21wKHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBwZXJQb2x5LnF1aWNrRGVjb21wKHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgICAgICBsb3dlclBvbHkucXVpY2tEZWNvbXAocmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHRoaXMpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGNvbGxpbmVhciBwb2ludHMgaW4gdGhlIHBvbHlnb24uXG4gKiBAbWV0aG9kIHJlbW92ZUNvbGxpbmVhclBvaW50c1xuICogQHBhcmFtICB7TnVtYmVyfSBbcHJlY2lzaW9uXSBUaGUgdGhyZXNob2xkIGFuZ2xlIHRvIHVzZSB3aGVuIGRldGVybWluaW5nIHdoZXRoZXIgdHdvIGVkZ2VzIGFyZSBjb2xsaW5lYXIuIFVzZSB6ZXJvIGZvciBmaW5lc3QgcHJlY2lzaW9uLlxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgVGhlIG51bWJlciBvZiBwb2ludHMgcmVtb3ZlZFxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5yZW1vdmVDb2xsaW5lYXJQb2ludHMgPSBmdW5jdGlvbihwcmVjaXNpb24pe1xuICAgIHZhciBudW0gPSAwO1xuICAgIGZvcih2YXIgaT10aGlzLnZlcnRpY2VzLmxlbmd0aC0xOyB0aGlzLnZlcnRpY2VzLmxlbmd0aD4zICYmIGk+PTA7IC0taSl7XG4gICAgICAgIGlmKFBvaW50LmNvbGxpbmVhcih0aGlzLmF0KGktMSksdGhpcy5hdChpKSx0aGlzLmF0KGkrMSkscHJlY2lzaW9uKSl7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG1pZGRsZSBwb2ludFxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5zcGxpY2UoaSV0aGlzLnZlcnRpY2VzLmxlbmd0aCwxKTtcbiAgICAgICAgICAgIGktLTsgLy8gSnVtcCBvbmUgcG9pbnQgZm9yd2FyZC4gT3RoZXJ3aXNlIHdlIG1heSBnZXQgYSBjaGFpbiByZW1vdmFsXG4gICAgICAgICAgICBudW0rKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVtO1xufTtcblxufSx7XCIuL0xpbmVcIjoxLFwiLi9Qb2ludFwiOjIsXCIuL1NjYWxhclwiOjR9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gU2NhbGFyO1xuXG4vKipcbiAqIFNjYWxhciBmdW5jdGlvbnNcbiAqIEBjbGFzcyBTY2FsYXJcbiAqL1xuZnVuY3Rpb24gU2NhbGFyKCl7fVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byBzY2FsYXJzIGFyZSBlcXVhbFxuICogQHN0YXRpY1xuICogQG1ldGhvZCBlcVxuICogQHBhcmFtICB7TnVtYmVyfSBhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGJcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblNjYWxhci5lcSA9IGZ1bmN0aW9uKGEsYixwcmVjaXNpb24pe1xuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuICAgIHJldHVybiBNYXRoLmFicyhhLWIpIDwgcHJlY2lzaW9uO1xufTtcblxufSx7fV0sNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQb2x5Z29uIDogX2RlcmVxXyhcIi4vUG9seWdvblwiKSxcbiAgICBQb2ludCA6IF9kZXJlcV8oXCIuL1BvaW50XCIpLFxufTtcblxufSx7XCIuL1BvaW50XCI6MixcIi4vUG9seWdvblwiOjN9XSw2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwicDJcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMC42LjFcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkEgSmF2YVNjcmlwdCAyRCBwaHlzaWNzIGVuZ2luZS5cIixcbiAgXCJhdXRob3JcIjogXCJTdGVmYW4gSGVkbWFuIDxzY2h0ZXBwZUBnbWFpbC5jb20+IChodHRwOi8vc3RlZmZlLnNlKVwiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcInAyLmpzXCIsXG4gICAgXCJwMlwiLFxuICAgIFwicGh5c2ljc1wiLFxuICAgIFwiZW5naW5lXCIsXG4gICAgXCIyZFwiXG4gIF0sXG4gIFwibWFpblwiOiBcIi4vc3JjL3AyLmpzXCIsXG4gIFwiZW5naW5lc1wiOiB7XG4gICAgXCJub2RlXCI6IFwiKlwiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUvcDIuanMuZ2l0XCJcbiAgfSxcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZS9wMi5qcy9pc3N1ZXNcIlxuICB9LFxuICBcImxpY2Vuc2VzXCI6IFtcbiAgICB7XG4gICAgICBcInR5cGVcIjogXCJNSVRcIlxuICAgIH1cbiAgXSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiZ3J1bnRcIjogXCJ+MC40LjBcIixcbiAgICBcImdydW50LWNvbnRyaWItanNoaW50XCI6IFwifjAuOS4yXCIsXG4gICAgXCJncnVudC1jb250cmliLW5vZGV1bml0XCI6IFwifjAuMS4yXCIsXG4gICAgXCJncnVudC1jb250cmliLXVnbGlmeVwiOiBcIn4wLjQuMFwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi13YXRjaFwiOiBcIn4wLjUuMFwiLFxuICAgIFwiZ3J1bnQtYnJvd3NlcmlmeVwiOiBcIn4yLjAuMVwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi1jb25jYXRcIjogXCJeMC40LjBcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJwb2x5LWRlY29tcFwiOiBcIjAuMS4wXCJcbiAgfVxufVxuXG59LHt9XSw3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQUFCQjtcblxuLyoqXG4gKiBBeGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGNsYXNzLlxuICogQGNsYXNzIEFBQkJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9ICBbb3B0aW9uc11cbiAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMudXBwZXJCb3VuZF1cbiAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMubG93ZXJCb3VuZF1cbiAqL1xuZnVuY3Rpb24gQUFCQihvcHRpb25zKXtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb3dlciBib3VuZCBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICAqIEBwcm9wZXJ0eSBsb3dlckJvdW5kXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG93ZXJCb3VuZCA9IHZlYzIuY3JlYXRlKCk7XG4gICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLmxvd2VyQm91bmQpe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy5sb3dlckJvdW5kLCBvcHRpb25zLmxvd2VyQm91bmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB1cHBlciBib3VuZCBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICAqIEBwcm9wZXJ0eSB1cHBlckJvdW5kXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudXBwZXJCb3VuZCA9IHZlYzIuY3JlYXRlKCk7XG4gICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLnVwcGVyQm91bmQpe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy51cHBlckJvdW5kLCBvcHRpb25zLnVwcGVyQm91bmQpO1xuICAgIH1cbn1cblxudmFyIHRtcCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogU2V0IHRoZSBBQUJCIGJvdW5kcyBmcm9tIGEgc2V0IG9mIHBvaW50cy5cbiAqIEBtZXRob2Qgc2V0RnJvbVBvaW50c1xuICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIEFuIGFycmF5IG9mIHZlYzIncy5cbiAqL1xuQUFCQi5wcm90b3R5cGUuc2V0RnJvbVBvaW50cyA9IGZ1bmN0aW9uKHBvaW50cywgcG9zaXRpb24sIGFuZ2xlLCBza2luU2l6ZSl7XG4gICAgdmFyIGwgPSB0aGlzLmxvd2VyQm91bmQsXG4gICAgICAgIHUgPSB0aGlzLnVwcGVyQm91bmQ7XG5cbiAgICBpZih0eXBlb2YoYW5nbGUpICE9PSBcIm51bWJlclwiKXtcbiAgICAgICAgYW5nbGUgPSAwO1xuICAgIH1cblxuICAgIC8vIFNldCB0byB0aGUgZmlyc3QgcG9pbnRcbiAgICBpZihhbmdsZSAhPT0gMCl7XG4gICAgICAgIHZlYzIucm90YXRlKGwsIHBvaW50c1swXSwgYW5nbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZlYzIuY29weShsLCBwb2ludHNbMF0pO1xuICAgIH1cbiAgICB2ZWMyLmNvcHkodSwgbCk7XG5cbiAgICAvLyBDb21wdXRlIGNvc2luZXMgYW5kIHNpbmVzIGp1c3Qgb25jZVxuICAgIHZhciBjb3NBbmdsZSA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgc2luQW5nbGUgPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgZm9yKHZhciBpID0gMTsgaTxwb2ludHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgcCA9IHBvaW50c1tpXTtcblxuICAgICAgICBpZihhbmdsZSAhPT0gMCl7XG4gICAgICAgICAgICB2YXIgeCA9IHBbMF0sXG4gICAgICAgICAgICAgICAgeSA9IHBbMV07XG4gICAgICAgICAgICB0bXBbMF0gPSBjb3NBbmdsZSAqIHggLXNpbkFuZ2xlICogeTtcbiAgICAgICAgICAgIHRtcFsxXSA9IHNpbkFuZ2xlICogeCArY29zQW5nbGUgKiB5O1xuICAgICAgICAgICAgcCA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcih2YXIgaj0wOyBqPDI7IGorKyl7XG4gICAgICAgICAgICBpZihwW2pdID4gdVtqXSl7XG4gICAgICAgICAgICAgICAgdVtqXSA9IHBbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihwW2pdIDwgbFtqXSl7XG4gICAgICAgICAgICAgICAgbFtqXSA9IHBbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgb2Zmc2V0XG4gICAgaWYocG9zaXRpb24pe1xuICAgICAgICB2ZWMyLmFkZCh0aGlzLmxvd2VyQm91bmQsIHRoaXMubG93ZXJCb3VuZCwgcG9zaXRpb24pO1xuICAgICAgICB2ZWMyLmFkZCh0aGlzLnVwcGVyQm91bmQsIHRoaXMudXBwZXJCb3VuZCwgcG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmKHNraW5TaXplKXtcbiAgICAgICAgdGhpcy5sb3dlckJvdW5kWzBdIC09IHNraW5TaXplO1xuICAgICAgICB0aGlzLmxvd2VyQm91bmRbMV0gLT0gc2tpblNpemU7XG4gICAgICAgIHRoaXMudXBwZXJCb3VuZFswXSArPSBza2luU2l6ZTtcbiAgICAgICAgdGhpcy51cHBlckJvdW5kWzFdICs9IHNraW5TaXplO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29weSBib3VuZHMgZnJvbSBhbiBBQUJCIHRvIHRoaXMgQUFCQlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKi9cbkFBQkIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihhYWJiKXtcbiAgICB2ZWMyLmNvcHkodGhpcy5sb3dlckJvdW5kLCBhYWJiLmxvd2VyQm91bmQpO1xuICAgIHZlYzIuY29weSh0aGlzLnVwcGVyQm91bmQsIGFhYmIudXBwZXJCb3VuZCk7XG59O1xuXG4vKipcbiAqIEV4dGVuZCB0aGlzIEFBQkIgc28gdGhhdCBpdCBjb3ZlcnMgdGhlIGdpdmVuIEFBQkIgdG9vLlxuICogQG1ldGhvZCBleHRlbmRcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqL1xuQUFCQi5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24oYWFiYil7XG4gICAgLy8gTG9vcCBvdmVyIHggYW5kIHlcbiAgICB2YXIgaSA9IDI7XG4gICAgd2hpbGUoaS0tKXtcbiAgICAgICAgLy8gRXh0ZW5kIGxvd2VyIGJvdW5kXG4gICAgICAgIHZhciBsID0gYWFiYi5sb3dlckJvdW5kW2ldO1xuICAgICAgICBpZih0aGlzLmxvd2VyQm91bmRbaV0gPiBsKXtcbiAgICAgICAgICAgIHRoaXMubG93ZXJCb3VuZFtpXSA9IGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcHBlclxuICAgICAgICB2YXIgdSA9IGFhYmIudXBwZXJCb3VuZFtpXTtcbiAgICAgICAgaWYodGhpcy51cHBlckJvdW5kW2ldIDwgdSl7XG4gICAgICAgICAgICB0aGlzLnVwcGVyQm91bmRbaV0gPSB1O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIEFBQkIgb3ZlcmxhcHMgdGhpcyBBQUJCLlxuICogQG1ldGhvZCBvdmVybGFwc1xuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuQUFCQi5wcm90b3R5cGUub3ZlcmxhcHMgPSBmdW5jdGlvbihhYWJiKXtcbiAgICB2YXIgbDEgPSB0aGlzLmxvd2VyQm91bmQsXG4gICAgICAgIHUxID0gdGhpcy51cHBlckJvdW5kLFxuICAgICAgICBsMiA9IGFhYmIubG93ZXJCb3VuZCxcbiAgICAgICAgdTIgPSBhYWJiLnVwcGVyQm91bmQ7XG5cbiAgICAvLyAgICAgIGwyICAgICAgICB1MlxuICAgIC8vICAgICAgfC0tLS0tLS0tLXxcbiAgICAvLyB8LS0tLS0tLS18XG4gICAgLy8gbDEgICAgICAgdTFcblxuICAgIHJldHVybiAoKGwyWzBdIDw9IHUxWzBdICYmIHUxWzBdIDw9IHUyWzBdKSB8fCAobDFbMF0gPD0gdTJbMF0gJiYgdTJbMF0gPD0gdTFbMF0pKSAmJlxuICAgICAgICAgICAoKGwyWzFdIDw9IHUxWzFdICYmIHUxWzFdIDw9IHUyWzFdKSB8fCAobDFbMV0gPD0gdTJbMV0gJiYgdTJbMV0gPD0gdTFbMV0pKTtcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi91dGlscy9VdGlsc1wiOjUwfV0sODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xudmFyIEJvZHkgPSBfZGVyZXFfKCcuLi9vYmplY3RzL0JvZHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCcm9hZHBoYXNlO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGJyb2FkcGhhc2UgaW1wbGVtZW50YXRpb25zLlxuICogQGNsYXNzIEJyb2FkcGhhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCcm9hZHBoYXNlKHR5cGUpe1xuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHRpbmcgb3ZlcmxhcHBpbmcgcGFpcnMuIFdpbGwgYmUgZmlsbGVkIHdpdGggcmVzdWx0cyBkdXJpbmcgLmdldENvbGxpc2lvblBhaXJzKCkuXG4gICAgICogQHByb3BlcnR5IHJlc3VsdFxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdCA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdvcmxkIHRvIHNlYXJjaCBmb3IgY29sbGlzaW9uIHBhaXJzIGluLiBUbyBjaGFuZ2UgaXQsIHVzZSAuc2V0V29ybGQoKVxuICAgICAqIEBwcm9wZXJ0eSB3b3JsZFxuICAgICAqIEB0eXBlIHtXb3JsZH1cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLndvcmxkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBib3VuZGluZyB2b2x1bWUgdHlwZSB0byB1c2UgaW4gdGhlIGJyb2FkcGhhc2UgYWxnb3JpdGhtcy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gYm91bmRpbmdWb2x1bWVUeXBlXG4gICAgICovXG4gICAgdGhpcy5ib3VuZGluZ1ZvbHVtZVR5cGUgPSBCcm9hZHBoYXNlLkFBQkI7XG59XG5cbi8qKlxuICogQXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCB0eXBlLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IEFBQkJcbiAqL1xuQnJvYWRwaGFzZS5BQUJCID0gMTtcblxuLyoqXG4gKiBCb3VuZGluZyBjaXJjbGUgdHlwZS5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBCT1VORElOR19DSVJDTEVcbiAqL1xuQnJvYWRwaGFzZS5CT1VORElOR19DSVJDTEUgPSAyO1xuXG4vKipcbiAqIFNldCB0aGUgd29ybGQgdGhhdCB3ZSBhcmUgc2VhcmNoaW5nIGZvciBjb2xsaXNpb24gcGFpcnMgaW5cbiAqIEBtZXRob2Qgc2V0V29ybGRcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICovXG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5zZXRXb3JsZCA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG59O1xuXG4vKipcbiAqIEdldCBhbGwgcG90ZW50aWFsIGludGVyc2VjdGluZyBib2R5IHBhaXJzLlxuICogQG1ldGhvZCBnZXRDb2xsaXNpb25QYWlyc1xuICogQHBhcmFtICB7V29ybGR9IHdvcmxkIFRoZSB3b3JsZCB0byBzZWFyY2ggaW4uXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdGhlIGJvZGllcywgb3JkZXJlZCBpbiBwYWlycy4gRXhhbXBsZTogQSByZXN1bHQgb2YgW2EsYixjLGRdIG1lYW5zIHRoYXQgdGhlIHBvdGVudGlhbCBwYWlycyBhcmU6IChhLGIpLCAoYyxkKS5cbiAqL1xuQnJvYWRwaGFzZS5wcm90b3R5cGUuZ2V0Q29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0Q29sbGlzaW9uUGFpcnMgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBhIHN1YmNsYXNzIVwiKTtcbn07XG5cbnZhciBkaXN0ID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxuICogQG1ldGhvZCAgYm91bmRpbmdSYWRpdXNDaGVja1xuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Ccm9hZHBoYXNlLmJvdW5kaW5nUmFkaXVzQ2hlY2sgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpe1xuICAgIHZlYzIuc3ViKGRpc3QsIGJvZHlBLnBvc2l0aW9uLCBib2R5Qi5wb3NpdGlvbik7XG4gICAgdmFyIGQyID0gdmVjMi5zcXVhcmVkTGVuZ3RoKGRpc3QpLFxuICAgICAgICByID0gYm9keUEuYm91bmRpbmdSYWRpdXMgKyBib2R5Qi5ib3VuZGluZ1JhZGl1cztcbiAgICByZXR1cm4gZDIgPD0gcipyO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxuICogQG1ldGhvZCAgYm91bmRpbmdSYWRpdXNDaGVja1xuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Ccm9hZHBoYXNlLmFhYmJDaGVjayA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgcmV0dXJuIGJvZHlBLmdldEFBQkIoKS5vdmVybGFwcyhib2R5Qi5nZXRBQUJCKCkpO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxuICogQG1ldGhvZCAgYm91bmRpbmdSYWRpdXNDaGVja1xuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5ib3VuZGluZ1ZvbHVtZUNoZWNrID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKXtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgc3dpdGNoKHRoaXMuYm91bmRpbmdWb2x1bWVUeXBlKXtcbiAgICBjYXNlIEJyb2FkcGhhc2UuQk9VTkRJTkdfQ0lSQ0xFOlxuICAgICAgICByZXN1bHQgPSAgQnJvYWRwaGFzZS5ib3VuZGluZ1JhZGl1c0NoZWNrKGJvZHlBLGJvZHlCKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBCcm9hZHBoYXNlLkFBQkI6XG4gICAgICAgIHJlc3VsdCA9IEJyb2FkcGhhc2UuYWFiYkNoZWNrKGJvZHlBLGJvZHlCKTtcbiAgICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3VuZGluZyB2b2x1bWUgdHlwZSBub3QgcmVjb2duaXplZDogJyt0aGlzLmJvdW5kaW5nVm9sdW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdHdvIGJvZGllcyBhcmUgYWxsb3dlZCB0byBjb2xsaWRlIGF0IGFsbC5cbiAqIEBtZXRob2QgIGNhbkNvbGxpZGVcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuQnJvYWRwaGFzZS5jYW5Db2xsaWRlID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKXtcblxuICAgIC8vIENhbm5vdCBjb2xsaWRlIHN0YXRpYyBib2RpZXNcbiAgICBpZihib2R5QS50eXBlID09PSBCb2R5LlNUQVRJQyAmJiBib2R5Qi50eXBlID09PSBCb2R5LlNUQVRJQyl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDYW5ub3QgY29sbGlkZSBzdGF0aWMgdnMga2luZW1hdGljIGJvZGllc1xuICAgIGlmKCAoYm9keUEudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMgJiYgYm9keUIudHlwZSA9PT0gQm9keS5TVEFUSUMpIHx8XG4gICAgICAgIChib2R5QS50eXBlID09PSBCb2R5LlNUQVRJQyAgICAmJiBib2R5Qi50eXBlID09PSBCb2R5LktJTkVNQVRJQykpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2Fubm90IGNvbGxpZGUga2luZW1hdGljIHZzIGtpbmVtYXRpY1xuICAgIGlmKGJvZHlBLnR5cGUgPT09IEJvZHkuS0lORU1BVElDICYmIGJvZHlCLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENhbm5vdCBjb2xsaWRlIGJvdGggc2xlZXBpbmcgYm9kaWVzXG4gICAgaWYoYm9keUEuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyAmJiBib2R5Qi5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENhbm5vdCBjb2xsaWRlIGlmIG9uZSBpcyBzdGF0aWMgYW5kIHRoZSBvdGhlciBpcyBzbGVlcGluZ1xuICAgIGlmKCAoYm9keUEuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyAmJiBib2R5Qi50eXBlID09PSBCb2R5LlNUQVRJQykgfHxcbiAgICAgICAgKGJvZHlCLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcgJiYgYm9keUEudHlwZSA9PT0gQm9keS5TVEFUSUMpKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuQnJvYWRwaGFzZS5OQUlWRSA9IDE7XG5Ccm9hZHBoYXNlLlNBUCA9IDI7XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi9vYmplY3RzL0JvZHlcIjozMn1dLDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIENpcmNsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9DaXJjbGUnKVxuLCAgIFBsYW5lID0gX2RlcmVxXygnLi4vc2hhcGVzL1BsYW5lJylcbiwgICBQYXJ0aWNsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9QYXJ0aWNsZScpXG4sICAgQnJvYWRwaGFzZSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9Ccm9hZHBoYXNlJylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gR3JpZEJyb2FkcGhhc2U7XG5cbi8qKlxuICogQnJvYWRwaGFzZSB0aGF0IHVzZXMgYXhpcy1hbGlnbmVkIGJpbnMuXG4gKiBAY2xhc3MgR3JpZEJyb2FkcGhhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQnJvYWRwaGFzZVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnhtaW5dICAgTG93ZXIgeCBib3VuZCBvZiB0aGUgZ3JpZFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnhtYXhdICAgVXBwZXIgeCBib3VuZFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnltaW5dICAgTG93ZXIgeSBib3VuZFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnltYXhdICAgVXBwZXIgeSBib3VuZFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm54XSAgICAgTnVtYmVyIG9mIGJpbnMgYWxvbmcgeCBheGlzXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubnldICAgICBOdW1iZXIgb2YgYmlucyBhbG9uZyB5IGF4aXNcbiAqIEB0b2RvIFNob3VsZCBoYXZlIGFuIG9wdGlvbiBmb3IgZHluYW1pYyBzY2VuZSBzaXplXG4gKi9cbmZ1bmN0aW9uIEdyaWRCcm9hZHBoYXNlKG9wdGlvbnMpe1xuICAgIEJyb2FkcGhhc2UuYXBwbHkodGhpcyk7XG5cbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucyx7XG4gICAgICAgIHhtaW46ICAgLTEwMCxcbiAgICAgICAgeG1heDogICAxMDAsXG4gICAgICAgIHltaW46ICAgLTEwMCxcbiAgICAgICAgeW1heDogICAxMDAsXG4gICAgICAgIG54OiAgICAgMTAsXG4gICAgICAgIG55OiAgICAgMTBcbiAgICB9KTtcblxuICAgIHRoaXMueG1pbiA9IG9wdGlvbnMueG1pbjtcbiAgICB0aGlzLnltaW4gPSBvcHRpb25zLnltaW47XG4gICAgdGhpcy54bWF4ID0gb3B0aW9ucy54bWF4O1xuICAgIHRoaXMueW1heCA9IG9wdGlvbnMueW1heDtcbiAgICB0aGlzLm54ID0gb3B0aW9ucy5ueDtcbiAgICB0aGlzLm55ID0gb3B0aW9ucy5ueTtcblxuICAgIHRoaXMuYmluc2l6ZVggPSAodGhpcy54bWF4LXRoaXMueG1pbikgLyB0aGlzLm54O1xuICAgIHRoaXMuYmluc2l6ZVkgPSAodGhpcy55bWF4LXRoaXMueW1pbikgLyB0aGlzLm55O1xufVxuR3JpZEJyb2FkcGhhc2UucHJvdG90eXBlID0gbmV3IEJyb2FkcGhhc2UoKTtcbkdyaWRCcm9hZHBoYXNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyaWRCcm9hZHBoYXNlO1xuXG4vKipcbiAqIEdldCBjb2xsaXNpb24gcGFpcnMuXG4gKiBAbWV0aG9kIGdldENvbGxpc2lvblBhaXJzXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5HcmlkQnJvYWRwaGFzZS5wcm90b3R5cGUuZ2V0Q29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICBib2RpZXMgPSB3b3JsZC5ib2RpZXMsXG4gICAgICAgIE5jb2xsaWRpbmcgPSBib2RpZXMubGVuZ3RoLFxuICAgICAgICBiaW5zaXplWCA9IHRoaXMuYmluc2l6ZVgsXG4gICAgICAgIGJpbnNpemVZID0gdGhpcy5iaW5zaXplWSxcbiAgICAgICAgbnggPSB0aGlzLm54LFxuICAgICAgICBueSA9IHRoaXMubnksXG4gICAgICAgIHhtaW4gPSB0aGlzLnhtaW4sXG4gICAgICAgIHltaW4gPSB0aGlzLnltaW4sXG4gICAgICAgIHhtYXggPSB0aGlzLnhtYXgsXG4gICAgICAgIHltYXggPSB0aGlzLnltYXg7XG5cbiAgICAvLyBUb2RvOiBtYWtlIGdhcmJhZ2UgZnJlZVxuICAgIHZhciBiaW5zPVtdLCBOYmlucz1ueCpueTtcbiAgICBmb3IodmFyIGk9MDsgaTxOYmluczsgaSsrKXtcbiAgICAgICAgYmlucy5wdXNoKFtdKTtcbiAgICB9XG5cbiAgICB2YXIgeG11bHQgPSBueCAvICh4bWF4LXhtaW4pO1xuICAgIHZhciB5bXVsdCA9IG55IC8gKHltYXgteW1pbik7XG5cbiAgICAvLyBQdXQgYWxsIGJvZGllcyBpbnRvIGJpbnNcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5jb2xsaWRpbmc7IGkrKyl7XG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcbiAgICAgICAgdmFyIGFhYmIgPSBiaS5hYWJiO1xuICAgICAgICB2YXIgbG93ZXJYID0gTWF0aC5tYXgoYWFiYi5sb3dlckJvdW5kWzBdLCB4bWluKTtcbiAgICAgICAgdmFyIGxvd2VyWSA9IE1hdGgubWF4KGFhYmIubG93ZXJCb3VuZFsxXSwgeW1pbik7XG4gICAgICAgIHZhciB1cHBlclggPSBNYXRoLm1pbihhYWJiLnVwcGVyQm91bmRbMF0sIHhtYXgpO1xuICAgICAgICB2YXIgdXBwZXJZID0gTWF0aC5taW4oYWFiYi51cHBlckJvdW5kWzFdLCB5bWF4KTtcbiAgICAgICAgdmFyIHhpMSA9IE1hdGguZmxvb3IoeG11bHQgKiAobG93ZXJYIC0geG1pbikpO1xuICAgICAgICB2YXIgeWkxID0gTWF0aC5mbG9vcih5bXVsdCAqIChsb3dlclkgLSB5bWluKSk7XG4gICAgICAgIHZhciB4aTIgPSBNYXRoLmZsb29yKHhtdWx0ICogKHVwcGVyWCAtIHhtaW4pKTtcbiAgICAgICAgdmFyIHlpMiA9IE1hdGguZmxvb3IoeW11bHQgKiAodXBwZXJZIC0geW1pbikpO1xuXG4gICAgICAgIC8vIFB1dCBpbiBiaW5cbiAgICAgICAgZm9yKHZhciBqPXhpMTsgajw9eGkyOyBqKyspe1xuICAgICAgICAgICAgZm9yKHZhciBrPXlpMTsgazw9eWkyOyBrKyspe1xuICAgICAgICAgICAgICAgIHZhciB4aSA9IGo7XG4gICAgICAgICAgICAgICAgdmFyIHlpID0gaztcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0geGkqKG55LTEpICsgeWk7XG4gICAgICAgICAgICAgICAgaWYoaWR4ID49IDAgJiYgaWR4IDwgTmJpbnMpe1xuICAgICAgICAgICAgICAgICAgICBiaW5zWyBpZHggXS5wdXNoKGJpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBlYWNoIGJpblxuICAgIGZvcih2YXIgaT0wOyBpIT09TmJpbnM7IGkrKyl7XG4gICAgICAgIHZhciBiaW4gPSBiaW5zW2ldO1xuXG4gICAgICAgIGZvcih2YXIgaj0wLCBOYm9kaWVzSW5CaW49YmluLmxlbmd0aDsgaiE9PU5ib2RpZXNJbkJpbjsgaisrKXtcbiAgICAgICAgICAgIHZhciBiaSA9IGJpbltqXTtcbiAgICAgICAgICAgIGZvcih2YXIgaz0wOyBrIT09ajsgaysrKXtcbiAgICAgICAgICAgICAgICB2YXIgYmogPSBiaW5ba107XG4gICAgICAgICAgICAgICAgaWYoQnJvYWRwaGFzZS5jYW5Db2xsaWRlKGJpLGJqKSAmJiB0aGlzLmJvdW5kaW5nVm9sdW1lQ2hlY2soYmksYmopKXtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmksYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxufSx7XCIuLi9jb2xsaXNpb24vQnJvYWRwaGFzZVwiOjgsXCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4uL3NoYXBlcy9DaXJjbGVcIjozOCxcIi4uL3NoYXBlcy9QYXJ0aWNsZVwiOjQyLFwiLi4vc2hhcGVzL1BsYW5lXCI6NDMsXCIuLi91dGlscy9VdGlsc1wiOjUwfV0sMTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIENpcmNsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9DaXJjbGUnKSxcbiAgICBQbGFuZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9QbGFuZScpLFxuICAgIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyksXG4gICAgUGFydGljbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvUGFydGljbGUnKSxcbiAgICBCcm9hZHBoYXNlID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2UnKSxcbiAgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTmFpdmVCcm9hZHBoYXNlO1xuXG4vKipcbiAqIE5haXZlIGJyb2FkcGhhc2UgaW1wbGVtZW50YXRpb24uIERvZXMgTl4yIHRlc3RzLlxuICpcbiAqIEBjbGFzcyBOYWl2ZUJyb2FkcGhhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQnJvYWRwaGFzZVxuICovXG5mdW5jdGlvbiBOYWl2ZUJyb2FkcGhhc2UoKXtcbiAgICBCcm9hZHBoYXNlLmNhbGwodGhpcywgQnJvYWRwaGFzZS5OQUlWRSk7XG59XG5OYWl2ZUJyb2FkcGhhc2UucHJvdG90eXBlID0gbmV3IEJyb2FkcGhhc2UoKTtcbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOYWl2ZUJyb2FkcGhhc2U7XG5cbi8qKlxuICogR2V0IHRoZSBjb2xsaWRpbmcgcGFpcnNcbiAqIEBtZXRob2QgZ2V0Q29sbGlzaW9uUGFpcnNcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUuZ2V0Q29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIGJvZGllcyA9IHdvcmxkLmJvZGllcyxcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7XG5cbiAgICByZXN1bHQubGVuZ3RoID0gMDtcblxuICAgIGZvcih2YXIgaT0wLCBOY29sbGlkaW5nPWJvZGllcy5sZW5ndGg7IGkhPT1OY29sbGlkaW5nOyBpKyspe1xuICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgZm9yKHZhciBqPTA7IGo8aTsgaisrKXtcbiAgICAgICAgICAgIHZhciBiaiA9IGJvZGllc1tqXTtcblxuICAgICAgICAgICAgaWYoQnJvYWRwaGFzZS5jYW5Db2xsaWRlKGJpLGJqKSAmJiB0aGlzLmJvdW5kaW5nVm9sdW1lQ2hlY2soYmksYmopKXtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiaSxiaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLlxuICogQG1ldGhvZCBhYWJiUXVlcnlcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICogQHBhcmFtIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZS5hYWJiUXVlcnkgPSBmdW5jdGlvbih3b3JsZCwgYWFiYiwgcmVzdWx0KXtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XG5cbiAgICB2YXIgYm9kaWVzID0gd29ybGQuYm9kaWVzO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcblxuICAgICAgICBpZihiLmFhYmJOZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBiLnVwZGF0ZUFBQkIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGIuYWFiYi5vdmVybGFwcyhhYWJiKSl7XG4gICAgICAgICAgICByZXN1bHQucHVzaChiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xufSx7XCIuLi9jb2xsaXNpb24vQnJvYWRwaGFzZVwiOjgsXCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4uL3NoYXBlcy9DaXJjbGVcIjozOCxcIi4uL3NoYXBlcy9QYXJ0aWNsZVwiOjQyLFwiLi4vc2hhcGVzL1BsYW5lXCI6NDMsXCIuLi9zaGFwZXMvU2hhcGVcIjo0NX1dLDExOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBzdWIgPSB2ZWMyLnN1YlxuLCAgIGFkZCA9IHZlYzIuYWRkXG4sICAgZG90ID0gdmVjMi5kb3RcbiwgICBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJylcbiwgICBUdXBsZURpY3Rpb25hcnkgPSBfZGVyZXFfKCcuLi91dGlscy9UdXBsZURpY3Rpb25hcnknKVxuLCAgIEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0VxdWF0aW9uJylcbiwgICBDb250YWN0RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJylcbiwgICBGcmljdGlvbkVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKVxuLCAgIENpcmNsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9DaXJjbGUnKVxuLCAgIENvbnZleCA9IF9kZXJlcV8oJy4uL3NoYXBlcy9Db252ZXgnKVxuLCAgIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJylcbiwgICBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5JylcbiwgICBSZWN0YW5nbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvUmVjdGFuZ2xlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTmFycm93cGhhc2U7XG5cbi8vIFRlbXAgdGhpbmdzXG52YXIgeUF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwxKTtcblxudmFyIHRtcDEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDQgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDUgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDYgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDcgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDggPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDkgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDEwID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxMSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDEzID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxNCA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTUgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDE2ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxNyA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTggPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcEFycmF5ID0gW107XG5cbi8qKlxuICogTmFycm93cGhhc2UuIENyZWF0ZXMgY29udGFjdHMgYW5kIGZyaWN0aW9uIGdpdmVuIHNoYXBlcyBhbmQgdHJhbnNmb3Jtcy5cbiAqIEBjbGFzcyBOYXJyb3dwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE5hcnJvd3BoYXNlKCl7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgY29udGFjdEVxdWF0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvbkVxdWF0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIG1ha2UgZnJpY3Rpb24gZXF1YXRpb25zIGluIHRoZSB1cGNvbWluZyBjb250YWN0cy5cbiAgICAgKiBAcHJvcGVydHkgZW5hYmxlRnJpY3Rpb25cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gbWFrZSBlcXVhdGlvbnMgZW5hYmxlZCBpbiB1cGNvbWluZyBjb250YWN0cy5cbiAgICAgKiBAcHJvcGVydHkgZW5hYmxlZEVxdWF0aW9uc1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZW5hYmxlZEVxdWF0aW9ucyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJpY3Rpb24gc2xpcCBmb3JjZSB0byB1c2Ugd2hlbiBjcmVhdGluZyBmcmljdGlvbiBlcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHNsaXBGb3JjZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zbGlwRm9yY2UgPSAxMC4wO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyaWN0aW9uIHZhbHVlIHRvIHVzZSBpbiB0aGUgdXBjb21pbmcgZnJpY3Rpb24gZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvbkNvZWZmaWNpZW50XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uQ29lZmZpY2llbnQgPSAwLjM7XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIGJlIHRoZSAucmVsYXRpdmVWZWxvY2l0eSBpbiBlYWNoIHByb2R1Y2VkIEZyaWN0aW9uRXF1YXRpb24uXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHN1cmZhY2VWZWxvY2l0eVxuICAgICAqL1xuICAgIHRoaXMuc3VyZmFjZVZlbG9jaXR5ID0gMDtcblxuICAgIHRoaXMucmV1c2VPYmplY3RzID0gdHJ1ZTtcbiAgICB0aGlzLnJldXNhYmxlQ29udGFjdEVxdWF0aW9ucyA9IFtdO1xuICAgIHRoaXMucmV1c2FibGVGcmljdGlvbkVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3RpdHV0aW9uIHZhbHVlIHRvIHVzZSBpbiB0aGUgbmV4dCBjb250YWN0IGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkgcmVzdGl0dXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzdGl0dXRpb24gPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0aWZmbmVzcyB2YWx1ZSB0byB1c2UgaW4gdGhlIG5leHQgY29udGFjdCBlcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHN0aWZmbmVzc1xuICAgICAqL1xuICAgIHRoaXMuc3RpZmZuZXNzID0gRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1M7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RpZmZuZXNzIHZhbHVlIHRvIHVzZSBpbiB0aGUgbmV4dCBjb250YWN0IGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc3RpZmZuZXNzXG4gICAgICovXG4gICAgdGhpcy5yZWxheGF0aW9uID0gRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0aWZmbmVzcyB2YWx1ZSB0byB1c2UgaW4gdGhlIG5leHQgZnJpY3Rpb24gZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblN0aWZmbmVzc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvblN0aWZmbmVzcyA9IEVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlbGF4YXRpb24gdmFsdWUgdG8gdXNlIGluIHRoZSBuZXh0IGZyaWN0aW9uIGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25SZWxheGF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uUmVsYXhhdGlvbiA9IEVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTjtcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSByZWR1Y3Rpb24gb2YgZnJpY3Rpb24gZXF1YXRpb25zLiBJZiBkaXNhYmxlZCwgYSBib3ggb24gYSBwbGFuZSB3aWxsIGdlbmVyYXRlIDIgY29udGFjdCBlcXVhdGlvbnMgYW5kIDIgZnJpY3Rpb24gZXF1YXRpb25zLiBJZiBlbmFibGVkLCB0aGVyZSB3aWxsIGJlIG9ubHkgb25lIGZyaWN0aW9uIGVxdWF0aW9uLiBTYW1lIGtpbmQgb2Ygc2ltcGxpZmljYXRpb25zIGFyZSBtYWRlICBmb3IgYWxsIGNvbGxpc2lvbiB0eXBlcy5cbiAgICAgKiBAcHJvcGVydHkgZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb25cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIGZsYWcgd2lsbCBiZSByZW1vdmVkIHdoZW4gdGhlIGZlYXR1cmUgaXMgc3RhYmxlIGVub3VnaC5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgY29sbGlkaW5nIGJvZGllcyBsYXN0IHN0ZXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkgY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXBcbiAgICAgKiBAdHlwZSB7VHVwbGVEaWN0aW9uYXJ5fVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXAgPSBuZXcgVHVwbGVEaWN0aW9uYXJ5KCk7XG5cbiAgICAvKipcbiAgICAgKiBDb250YWN0IHNraW4gc2l6ZSB2YWx1ZSB0byB1c2UgaW4gdGhlIG5leHQgY29udGFjdCBlcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbnRhY3RTa2luU2l6ZVxuICAgICAqIEBkZWZhdWx0IDAuMDFcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RTa2luU2l6ZSA9IDAuMDE7XG59XG5cbnZhciBib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25BID0gdmVjMi5jcmVhdGUoKTtcbnZhciBib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25CID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGJvZGllc092ZXJsYXBcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLmJvZGllc092ZXJsYXAgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpe1xuICAgIHZhciBzaGFwZVBvc2l0aW9uQSA9IGJvZGllc092ZXJsYXBfc2hhcGVQb3NpdGlvbkE7XG4gICAgdmFyIHNoYXBlUG9zaXRpb25CID0gYm9kaWVzT3ZlcmxhcF9zaGFwZVBvc2l0aW9uQjtcblxuICAgIC8vIExvb3Agb3ZlciBhbGwgc2hhcGVzIG9mIGJvZHlBXG4gICAgZm9yKHZhciBrPTAsIE5zaGFwZXNpPWJvZHlBLnNoYXBlcy5sZW5ndGg7IGshPT1Oc2hhcGVzaTsgaysrKXtcbiAgICAgICAgdmFyIHNoYXBlQSA9IGJvZHlBLnNoYXBlc1trXSxcbiAgICAgICAgICAgIHBvc2l0aW9uQSA9IGJvZHlBLnNoYXBlT2Zmc2V0c1trXSxcbiAgICAgICAgICAgIGFuZ2xlQSA9IGJvZHlBLnNoYXBlQW5nbGVzW2tdO1xuXG4gICAgICAgIGJvZHlBLnRvV29ybGRGcmFtZShzaGFwZVBvc2l0aW9uQSwgcG9zaXRpb25BKTtcblxuICAgICAgICAvLyBBbGwgc2hhcGVzIG9mIGJvZHkgalxuICAgICAgICBmb3IodmFyIGw9MCwgTnNoYXBlc2o9Ym9keUIuc2hhcGVzLmxlbmd0aDsgbCE9PU5zaGFwZXNqOyBsKyspe1xuICAgICAgICAgICAgdmFyIHNoYXBlQiA9IGJvZHlCLnNoYXBlc1tsXSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkIgPSBib2R5Qi5zaGFwZU9mZnNldHNbbF0sXG4gICAgICAgICAgICAgICAgYW5nbGVCID0gYm9keUIuc2hhcGVBbmdsZXNbbF07XG5cbiAgICAgICAgICAgIGJvZHlCLnRvV29ybGRGcmFtZShzaGFwZVBvc2l0aW9uQiwgcG9zaXRpb25CKTtcblxuICAgICAgICAgICAgaWYodGhpc1tzaGFwZUEudHlwZSB8IHNoYXBlQi50eXBlXShcbiAgICAgICAgICAgICAgICBib2R5QSxcbiAgICAgICAgICAgICAgICBzaGFwZUEsXG4gICAgICAgICAgICAgICAgc2hhcGVQb3NpdGlvbkEsXG4gICAgICAgICAgICAgICAgc2hhcGVBLmFuZ2xlICsgYm9keUEuYW5nbGUsXG4gICAgICAgICAgICAgICAgYm9keUIsXG4gICAgICAgICAgICAgICAgc2hhcGVCLFxuICAgICAgICAgICAgICAgIHNoYXBlUG9zaXRpb25CLFxuICAgICAgICAgICAgICAgIHNoYXBlQi5hbmdsZSArIGJvZHlCLmFuZ2xlLFxuICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICkpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYm9kaWVzIHdlcmUgaW4gY29udGFjdCBzaW5jZSB0aGUgbGFzdCByZXNldCgpLlxuICogQG1ldGhvZCBjb2xsaWRlZExhc3RTdGVwXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb2xsaWRlZExhc3RTdGVwID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKXtcbiAgICB2YXIgaWQxID0gYm9keUEuaWR8MCxcbiAgICAgICAgaWQyID0gYm9keUIuaWR8MDtcbiAgICByZXR1cm4gISF0aGlzLmNvbGxpZGluZ0JvZGllc0xhc3RTdGVwLmdldChpZDEsIGlkMik7XG59O1xuXG4vKipcbiAqIFRocm93cyBhd2F5IHRoZSBvbGQgZXF1YXRpb25zIGFuZCBnZXRzIHJlYWR5IHRvIGNyZWF0ZSBuZXdcbiAqIEBtZXRob2QgcmVzZXRcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmNvbGxpZGluZ0JvZGllc0xhc3RTdGVwLnJlc2V0KCk7XG5cbiAgICB2YXIgZXFzID0gdGhpcy5jb250YWN0RXF1YXRpb25zO1xuICAgIHZhciBsID0gZXFzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIgZXEgPSBlcXNbbF0sXG4gICAgICAgICAgICBpZDEgPSBlcS5ib2R5QS5pZCxcbiAgICAgICAgICAgIGlkMiA9IGVxLmJvZHlCLmlkO1xuICAgICAgICB0aGlzLmNvbGxpZGluZ0JvZGllc0xhc3RTdGVwLnNldChpZDEsIGlkMiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYodGhpcy5yZXVzZU9iamVjdHMpe1xuICAgICAgICB2YXIgY2UgPSB0aGlzLmNvbnRhY3RFcXVhdGlvbnMsXG4gICAgICAgICAgICBmZSA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMsXG4gICAgICAgICAgICByZmUgPSB0aGlzLnJldXNhYmxlRnJpY3Rpb25FcXVhdGlvbnMsXG4gICAgICAgICAgICByY2UgPSB0aGlzLnJldXNhYmxlQ29udGFjdEVxdWF0aW9ucztcbiAgICAgICAgVXRpbHMuYXBwZW5kQXJyYXkocmNlLGNlKTtcbiAgICAgICAgVXRpbHMuYXBwZW5kQXJyYXkocmZlLGZlKTtcbiAgICB9XG5cbiAgICAvLyBSZXNldFxuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggPSB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBDb250YWN0RXF1YXRpb24sIGVpdGhlciBieSByZXVzaW5nIGFuIGV4aXN0aW5nIG9iamVjdCBvciBjcmVhdGluZyBhIG5ldyBvbmUuXG4gKiBAbWV0aG9kIGNyZWF0ZUNvbnRhY3RFcXVhdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtDb250YWN0RXF1YXRpb259XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jcmVhdGVDb250YWN0RXF1YXRpb24gPSBmdW5jdGlvbihib2R5QSwgYm9keUIsIHNoYXBlQSwgc2hhcGVCKXtcbiAgICB2YXIgYyA9IHRoaXMucmV1c2FibGVDb250YWN0RXF1YXRpb25zLmxlbmd0aCA/IHRoaXMucmV1c2FibGVDb250YWN0RXF1YXRpb25zLnBvcCgpIDogbmV3IENvbnRhY3RFcXVhdGlvbihib2R5QSxib2R5Qik7XG4gICAgYy5ib2R5QSA9IGJvZHlBO1xuICAgIGMuYm9keUIgPSBib2R5QjtcbiAgICBjLnNoYXBlQSA9IHNoYXBlQTtcbiAgICBjLnNoYXBlQiA9IHNoYXBlQjtcbiAgICBjLnJlc3RpdHV0aW9uID0gdGhpcy5yZXN0aXR1dGlvbjtcbiAgICBjLmZpcnN0SW1wYWN0ID0gIXRoaXMuY29sbGlkZWRMYXN0U3RlcChib2R5QSxib2R5Qik7XG4gICAgYy5zdGlmZm5lc3MgPSB0aGlzLnN0aWZmbmVzcztcbiAgICBjLnJlbGF4YXRpb24gPSB0aGlzLnJlbGF4YXRpb247XG4gICAgYy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgYy5lbmFibGVkID0gdGhpcy5lbmFibGVkRXF1YXRpb25zO1xuICAgIGMub2Zmc2V0ID0gdGhpcy5jb250YWN0U2tpblNpemU7XG5cbiAgICByZXR1cm4gYztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIEZyaWN0aW9uRXF1YXRpb24sIGVpdGhlciBieSByZXVzaW5nIGFuIGV4aXN0aW5nIG9iamVjdCBvciBjcmVhdGluZyBhIG5ldyBvbmUuXG4gKiBAbWV0aG9kIGNyZWF0ZUZyaWN0aW9uRXF1YXRpb25cbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7RnJpY3Rpb25FcXVhdGlvbn1cbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb24gPSBmdW5jdGlvbihib2R5QSwgYm9keUIsIHNoYXBlQSwgc2hhcGVCKXtcbiAgICB2YXIgYyA9IHRoaXMucmV1c2FibGVGcmljdGlvbkVxdWF0aW9ucy5sZW5ndGggPyB0aGlzLnJldXNhYmxlRnJpY3Rpb25FcXVhdGlvbnMucG9wKCkgOiBuZXcgRnJpY3Rpb25FcXVhdGlvbihib2R5QSxib2R5Qik7XG4gICAgYy5ib2R5QSA9IGJvZHlBO1xuICAgIGMuYm9keUIgPSBib2R5QjtcbiAgICBjLnNoYXBlQSA9IHNoYXBlQTtcbiAgICBjLnNoYXBlQiA9IHNoYXBlQjtcbiAgICBjLnNldFNsaXBGb3JjZSh0aGlzLnNsaXBGb3JjZSk7XG4gICAgYy5mcmljdGlvbkNvZWZmaWNpZW50ID0gdGhpcy5mcmljdGlvbkNvZWZmaWNpZW50O1xuICAgIGMucmVsYXRpdmVWZWxvY2l0eSA9IHRoaXMuc3VyZmFjZVZlbG9jaXR5O1xuICAgIGMuZW5hYmxlZCA9IHRoaXMuZW5hYmxlZEVxdWF0aW9ucztcbiAgICBjLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBjLnN0aWZmbmVzcyA9IHRoaXMuZnJpY3Rpb25TdGlmZm5lc3M7XG4gICAgYy5yZWxheGF0aW9uID0gdGhpcy5mcmljdGlvblJlbGF4YXRpb247XG4gICAgYy5jb250YWN0RXF1YXRpb25zLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIGM7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBGcmljdGlvbkVxdWF0aW9uIGdpdmVuIHRoZSBkYXRhIGluIHRoZSBDb250YWN0RXF1YXRpb24uIFVzZXMgc2FtZSBvZmZzZXQgdmVjdG9ycyByaSBhbmQgcmosIGJ1dCB0aGUgdGFuZ2VudCB2ZWN0b3Igd2lsbCBiZSBjb25zdHJ1Y3RlZCBmcm9tIHRoZSBjb2xsaXNpb24gbm9ybWFsLlxuICogQG1ldGhvZCBjcmVhdGVGcmljdGlvbkZyb21Db250YWN0XG4gKiBAcGFyYW0gIHtDb250YWN0RXF1YXRpb259IGNvbnRhY3RFcXVhdGlvblxuICogQHJldHVybiB7RnJpY3Rpb25FcXVhdGlvbn1cbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QgPSBmdW5jdGlvbihjKXtcbiAgICB2YXIgZXEgPSB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb24oYy5ib2R5QSwgYy5ib2R5QiwgYy5zaGFwZUEsIGMuc2hhcGVCKTtcbiAgICB2ZWMyLmNvcHkoZXEuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBKTtcbiAgICB2ZWMyLmNvcHkoZXEuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCKTtcbiAgICB2ZWMyLnJvdGF0ZTkwY3coZXEudCwgYy5ub3JtYWxBKTtcbiAgICBlcS5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG4gICAgcmV0dXJuIGVxO1xufTtcblxuLy8gVGFrZSB0aGUgYXZlcmFnZSBOIGxhdGVzdCBjb250YWN0IHBvaW50IG9uIHRoZSBwbGFuZS5cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlID0gZnVuY3Rpb24obnVtQ29udGFjdHMpe1xuICAgIHZhciBjID0gdGhpcy5jb250YWN0RXF1YXRpb25zW3RoaXMuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggLSAxXTtcbiAgICB2YXIgZXEgPSB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb24oYy5ib2R5QSwgYy5ib2R5QiwgYy5zaGFwZUEsIGMuc2hhcGVCKTtcbiAgICB2YXIgYm9keUEgPSBjLmJvZHlBO1xuICAgIHZhciBib2R5QiA9IGMuYm9keUI7XG4gICAgdmVjMi5zZXQoZXEuY29udGFjdFBvaW50QSwgMCwgMCk7XG4gICAgdmVjMi5zZXQoZXEuY29udGFjdFBvaW50QiwgMCwgMCk7XG4gICAgdmVjMi5zZXQoZXEudCwgMCwgMCk7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1udW1Db250YWN0czsgaSsrKXtcbiAgICAgICAgYyA9IHRoaXMuY29udGFjdEVxdWF0aW9uc1t0aGlzLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICBpZihjLmJvZHlBID09PSBib2R5QSl7XG4gICAgICAgICAgICB2ZWMyLmFkZChlcS50LCBlcS50LCBjLm5vcm1hbEEpO1xuICAgICAgICAgICAgdmVjMi5hZGQoZXEuY29udGFjdFBvaW50QSwgZXEuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKGVxLmNvbnRhY3RQb2ludEIsIGVxLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50Qik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZWMyLnN1YihlcS50LCBlcS50LCBjLm5vcm1hbEEpO1xuICAgICAgICAgICAgdmVjMi5hZGQoZXEuY29udGFjdFBvaW50QSwgZXEuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRCKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKGVxLmNvbnRhY3RQb2ludEIsIGVxLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QSk7XG4gICAgICAgIH1cbiAgICAgICAgZXEuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuICAgIH1cblxuICAgIHZhciBpbnZOdW1Db250YWN0cyA9IDEvbnVtQ29udGFjdHM7XG4gICAgdmVjMi5zY2FsZShlcS5jb250YWN0UG9pbnRBLCBlcS5jb250YWN0UG9pbnRBLCBpbnZOdW1Db250YWN0cyk7XG4gICAgdmVjMi5zY2FsZShlcS5jb250YWN0UG9pbnRCLCBlcS5jb250YWN0UG9pbnRCLCBpbnZOdW1Db250YWN0cyk7XG4gICAgdmVjMi5ub3JtYWxpemUoZXEudCwgZXEudCk7XG4gICAgdmVjMi5yb3RhdGU5MGN3KGVxLnQsIGVxLnQpO1xuICAgIHJldHVybiBlcTtcbn07XG5cbi8qKlxuICogQ29udmV4L2xpbmUgbmFycm93cGhhc2VcbiAqIEBtZXRob2QgY29udmV4TGluZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgY29udmV4Qm9keVxuICogQHBhcmFtICB7Q29udmV4fSAgICAgY29udmV4U2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGNvbnZleE9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgY29udmV4QW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGxpbmVCb2R5XG4gKiBAcGFyYW0gIHtMaW5lfSAgICAgICBsaW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGxpbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGxpbmVBbmdsZVxuICogQHBhcmFtIHtib29sZWFufSAgICAganVzdFRlc3RcbiAqIEB0b2RvIEltcGxlbWVudCBtZSFcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkxJTkUgfCBTaGFwZS5DT05WRVhdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhMaW5lID0gZnVuY3Rpb24oXG4gICAgY29udmV4Qm9keSxcbiAgICBjb252ZXhTaGFwZSxcbiAgICBjb252ZXhPZmZzZXQsXG4gICAgY29udmV4QW5nbGUsXG4gICAgbGluZUJvZHksXG4gICAgbGluZVNoYXBlLFxuICAgIGxpbmVPZmZzZXQsXG4gICAgbGluZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIC8vIFRPRE9cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpbmUvcmVjdGFuZ2xlIG5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGxpbmVSZWN0YW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGxpbmVCb2R5XG4gKiBAcGFyYW0gIHtMaW5lfSAgICAgICBsaW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGxpbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGxpbmVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgcmVjdGFuZ2xlQm9keVxuICogQHBhcmFtICB7UmVjdGFuZ2xlfSAgcmVjdGFuZ2xlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHJlY3RhbmdsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgcmVjdGFuZ2xlQW5nbGVcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgIGp1c3RUZXN0XG4gKiBAdG9kbyBJbXBsZW1lbnQgbWUhXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5MSU5FIHwgU2hhcGUuUkVDVEFOR0xFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUubGluZVJlY3RhbmdsZSA9IGZ1bmN0aW9uKFxuICAgIGxpbmVCb2R5LFxuICAgIGxpbmVTaGFwZSxcbiAgICBsaW5lT2Zmc2V0LFxuICAgIGxpbmVBbmdsZSxcbiAgICByZWN0YW5nbGVCb2R5LFxuICAgIHJlY3RhbmdsZVNoYXBlLFxuICAgIHJlY3RhbmdsZU9mZnNldCxcbiAgICByZWN0YW5nbGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICAvLyBUT0RPXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gc2V0Q29udmV4VG9DYXBzdWxlU2hhcGVNaWRkbGUoY29udmV4U2hhcGUsIGNhcHN1bGVTaGFwZSl7XG4gICAgdmVjMi5zZXQoY29udmV4U2hhcGUudmVydGljZXNbMF0sIC1jYXBzdWxlU2hhcGUubGVuZ3RoICogMC41LCAtY2Fwc3VsZVNoYXBlLnJhZGl1cyk7XG4gICAgdmVjMi5zZXQoY29udmV4U2hhcGUudmVydGljZXNbMV0sICBjYXBzdWxlU2hhcGUubGVuZ3RoICogMC41LCAtY2Fwc3VsZVNoYXBlLnJhZGl1cyk7XG4gICAgdmVjMi5zZXQoY29udmV4U2hhcGUudmVydGljZXNbMl0sICBjYXBzdWxlU2hhcGUubGVuZ3RoICogMC41LCAgY2Fwc3VsZVNoYXBlLnJhZGl1cyk7XG4gICAgdmVjMi5zZXQoY29udmV4U2hhcGUudmVydGljZXNbM10sIC1jYXBzdWxlU2hhcGUubGVuZ3RoICogMC41LCAgY2Fwc3VsZVNoYXBlLnJhZGl1cyk7XG59XG5cbnZhciBjb252ZXhDYXBzdWxlX3RlbXBSZWN0ID0gbmV3IFJlY3RhbmdsZSgxLDEpLFxuICAgIGNvbnZleENhcHN1bGVfdGVtcFZlYyA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQ29udmV4L2NhcHN1bGUgbmFycm93cGhhc2VcbiAqIEBtZXRob2QgY29udmV4Q2Fwc3VsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgY29udmV4Qm9keVxuICogQHBhcmFtICB7Q29udmV4fSAgICAgY29udmV4U2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGNvbnZleFBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBjb252ZXhBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgY2Fwc3VsZUJvZHlcbiAqIEBwYXJhbSAge0NhcHN1bGV9ICAgIGNhcHN1bGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgY2Fwc3VsZVBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBjYXBzdWxlQW5nbGVcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNBUFNVTEUgfCBTaGFwZS5DT05WRVhdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DQVBTVUxFIHwgU2hhcGUuUkVDVEFOR0xFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4Q2Fwc3VsZSA9IGZ1bmN0aW9uKFxuICAgIGNvbnZleEJvZHksXG4gICAgY29udmV4U2hhcGUsXG4gICAgY29udmV4UG9zaXRpb24sXG4gICAgY29udmV4QW5nbGUsXG4gICAgY2Fwc3VsZUJvZHksXG4gICAgY2Fwc3VsZVNoYXBlLFxuICAgIGNhcHN1bGVQb3NpdGlvbixcbiAgICBjYXBzdWxlQW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG5cbiAgICAvLyBDaGVjayB0aGUgY2lyY2xlc1xuICAgIC8vIEFkZCBvZmZzZXRzIVxuICAgIHZhciBjaXJjbGVQb3MgPSBjb252ZXhDYXBzdWxlX3RlbXBWZWM7XG4gICAgdmVjMi5zZXQoY2lyY2xlUG9zLCBjYXBzdWxlU2hhcGUubGVuZ3RoLzIsMCk7XG4gICAgdmVjMi5yb3RhdGUoY2lyY2xlUG9zLGNpcmNsZVBvcyxjYXBzdWxlQW5nbGUpO1xuICAgIHZlYzIuYWRkKGNpcmNsZVBvcyxjaXJjbGVQb3MsY2Fwc3VsZVBvc2l0aW9uKTtcbiAgICB2YXIgcmVzdWx0MSA9IHRoaXMuY2lyY2xlQ29udmV4KGNhcHN1bGVCb2R5LGNhcHN1bGVTaGFwZSxjaXJjbGVQb3MsY2Fwc3VsZUFuZ2xlLCBjb252ZXhCb2R5LGNvbnZleFNoYXBlLGNvbnZleFBvc2l0aW9uLGNvbnZleEFuZ2xlLCBqdXN0VGVzdCwgY2Fwc3VsZVNoYXBlLnJhZGl1cyk7XG5cbiAgICB2ZWMyLnNldChjaXJjbGVQb3MsLWNhcHN1bGVTaGFwZS5sZW5ndGgvMiwgMCk7XG4gICAgdmVjMi5yb3RhdGUoY2lyY2xlUG9zLGNpcmNsZVBvcyxjYXBzdWxlQW5nbGUpO1xuICAgIHZlYzIuYWRkKGNpcmNsZVBvcyxjaXJjbGVQb3MsY2Fwc3VsZVBvc2l0aW9uKTtcbiAgICB2YXIgcmVzdWx0MiA9IHRoaXMuY2lyY2xlQ29udmV4KGNhcHN1bGVCb2R5LGNhcHN1bGVTaGFwZSxjaXJjbGVQb3MsY2Fwc3VsZUFuZ2xlLCBjb252ZXhCb2R5LGNvbnZleFNoYXBlLGNvbnZleFBvc2l0aW9uLGNvbnZleEFuZ2xlLCBqdXN0VGVzdCwgY2Fwc3VsZVNoYXBlLnJhZGl1cyk7XG5cbiAgICBpZihqdXN0VGVzdCAmJiAocmVzdWx0MSB8fCByZXN1bHQyKSl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGNlbnRlciByZWN0XG4gICAgdmFyIHIgPSBjb252ZXhDYXBzdWxlX3RlbXBSZWN0O1xuICAgIHNldENvbnZleFRvQ2Fwc3VsZVNoYXBlTWlkZGxlKHIsY2Fwc3VsZVNoYXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5jb252ZXhDb252ZXgoY29udmV4Qm9keSxjb252ZXhTaGFwZSxjb252ZXhQb3NpdGlvbixjb252ZXhBbmdsZSwgY2Fwc3VsZUJvZHkscixjYXBzdWxlUG9zaXRpb24sY2Fwc3VsZUFuZ2xlLCBqdXN0VGVzdCk7XG5cbiAgICByZXR1cm4gcmVzdWx0ICsgcmVzdWx0MSArIHJlc3VsdDI7XG59O1xuXG4vKipcbiAqIENhcHN1bGUvbGluZSBuYXJyb3dwaGFzZVxuICogQG1ldGhvZCBsaW5lQ2Fwc3VsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgbGluZUJvZHlcbiAqIEBwYXJhbSAge0xpbmV9ICAgICAgIGxpbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgbGluZVBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBsaW5lQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGNhcHN1bGVCb2R5XG4gKiBAcGFyYW0gIHtDYXBzdWxlfSAgICBjYXBzdWxlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGNhcHN1bGVQb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgY2Fwc3VsZUFuZ2xlXG4gKiBAdG9kbyBJbXBsZW1lbnQgbWUhXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DQVBTVUxFIHwgU2hhcGUuTElORV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmxpbmVDYXBzdWxlID0gZnVuY3Rpb24oXG4gICAgbGluZUJvZHksXG4gICAgbGluZVNoYXBlLFxuICAgIGxpbmVQb3NpdGlvbixcbiAgICBsaW5lQW5nbGUsXG4gICAgY2Fwc3VsZUJvZHksXG4gICAgY2Fwc3VsZVNoYXBlLFxuICAgIGNhcHN1bGVQb3NpdGlvbixcbiAgICBjYXBzdWxlQW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgLy8gVE9ET1xuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG5cbnZhciBjYXBzdWxlQ2Fwc3VsZV90ZW1wVmVjMSA9IHZlYzIuY3JlYXRlKCk7XG52YXIgY2Fwc3VsZUNhcHN1bGVfdGVtcFZlYzIgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGNhcHN1bGVDYXBzdWxlX3RlbXBSZWN0MSA9IG5ldyBSZWN0YW5nbGUoMSwxKTtcblxuLyoqXG4gKiBDYXBzdWxlL2NhcHN1bGUgbmFycm93cGhhc2VcbiAqIEBtZXRob2QgY2Fwc3VsZUNhcHN1bGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gKiBAcGFyYW0gIHtDYXBzdWxlfSAgICBzaVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgeGlcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGFpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICogQHBhcmFtICB7Q2Fwc3VsZX0gICAgc2pcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHhqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhalxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0FQU1VMRSB8IFNoYXBlLkNBUFNVTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jYXBzdWxlQ2Fwc3VsZSA9IGZ1bmN0aW9uKGJpLHNpLHhpLGFpLCBiaixzaix4aixhaiwganVzdFRlc3Qpe1xuXG4gICAgdmFyIGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xuXG4gICAgLy8gQ2hlY2sgdGhlIGNpcmNsZXNcbiAgICAvLyBBZGQgb2Zmc2V0cyFcbiAgICB2YXIgY2lyY2xlUG9zaSA9IGNhcHN1bGVDYXBzdWxlX3RlbXBWZWMxLFxuICAgICAgICBjaXJjbGVQb3NqID0gY2Fwc3VsZUNhcHN1bGVfdGVtcFZlYzI7XG5cbiAgICB2YXIgbnVtQ29udGFjdHMgPSAwO1xuXG5cbiAgICAvLyBOZWVkIDQgY2lyY2xlIGNoZWNrcywgYmV0d2VlbiBhbGxcbiAgICBmb3IodmFyIGk9MDsgaTwyOyBpKyspe1xuXG4gICAgICAgIHZlYzIuc2V0KGNpcmNsZVBvc2ksKGk9PT0wPy0xOjEpKnNpLmxlbmd0aC8yLDApO1xuICAgICAgICB2ZWMyLnJvdGF0ZShjaXJjbGVQb3NpLGNpcmNsZVBvc2ksYWkpO1xuICAgICAgICB2ZWMyLmFkZChjaXJjbGVQb3NpLGNpcmNsZVBvc2kseGkpO1xuXG4gICAgICAgIGZvcih2YXIgaj0wOyBqPDI7IGorKyl7XG5cbiAgICAgICAgICAgIHZlYzIuc2V0KGNpcmNsZVBvc2osKGo9PT0wPy0xOjEpKnNqLmxlbmd0aC8yLCAwKTtcbiAgICAgICAgICAgIHZlYzIucm90YXRlKGNpcmNsZVBvc2osY2lyY2xlUG9zaixhaik7XG4gICAgICAgICAgICB2ZWMyLmFkZChjaXJjbGVQb3NqLGNpcmNsZVBvc2oseGopO1xuXG4gICAgICAgICAgICAvLyBUZW1wb3JhcmlseSB0dXJuIG9mZiBmcmljdGlvblxuICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgICAgICAgICAgZW5hYmxlRnJpY3Rpb25CZWZvcmUgPSB0aGlzLmVuYWJsZUZyaWN0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2lyY2xlQ2lyY2xlKGJpLHNpLGNpcmNsZVBvc2ksYWksIGJqLHNqLGNpcmNsZVBvc2osYWosIGp1c3RUZXN0LCBzaS5yYWRpdXMsIHNqLnJhZGl1cyk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBlbmFibGVGcmljdGlvbkJlZm9yZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoanVzdFRlc3QgJiYgcmVzdWx0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbnVtQ29udGFjdHMgKz0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIC8vIFRlbXBvcmFyaWx5IHR1cm4gb2ZmIGZyaWN0aW9uXG4gICAgICAgIGVuYWJsZUZyaWN0aW9uQmVmb3JlID0gdGhpcy5lbmFibGVGcmljdGlvbjtcbiAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGNpcmNsZXMgYWdhaW5zdCB0aGUgY2VudGVyIHJlY3RhbmdsZXNcbiAgICB2YXIgcmVjdCA9IGNhcHN1bGVDYXBzdWxlX3RlbXBSZWN0MTtcbiAgICBzZXRDb252ZXhUb0NhcHN1bGVTaGFwZU1pZGRsZShyZWN0LHNpKTtcbiAgICB2YXIgcmVzdWx0MSA9IHRoaXMuY29udmV4Q2Fwc3VsZShiaSxyZWN0LHhpLGFpLCBiaixzaix4aixhaiwganVzdFRlc3QpO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBlbmFibGVGcmljdGlvbkJlZm9yZTtcbiAgICB9XG5cbiAgICBpZihqdXN0VGVzdCAmJiByZXN1bHQxKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG51bUNvbnRhY3RzICs9IHJlc3VsdDE7XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgLy8gVGVtcG9yYXJpbHkgdHVybiBvZmYgZnJpY3Rpb25cbiAgICAgICAgdmFyIGVuYWJsZUZyaWN0aW9uQmVmb3JlID0gdGhpcy5lbmFibGVGcmljdGlvbjtcbiAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIHNldENvbnZleFRvQ2Fwc3VsZVNoYXBlTWlkZGxlKHJlY3Qsc2opO1xuICAgIHZhciByZXN1bHQyID0gdGhpcy5jb252ZXhDYXBzdWxlKGJqLHJlY3QseGosYWosIGJpLHNpLHhpLGFpLCBqdXN0VGVzdCk7XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xuICAgIH1cblxuICAgIGlmKGp1c3RUZXN0ICYmIHJlc3VsdDIpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbnVtQ29udGFjdHMgKz0gcmVzdWx0MjtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICBpZihudW1Db250YWN0cyAmJiB0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtQ29udGFjdHMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudW1Db250YWN0cztcbn07XG5cbi8qKlxuICogTGluZS9saW5lIG5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGxpbmVMaW5lXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBib2R5QVxuICogQHBhcmFtICB7TGluZX0gICAgICAgc2hhcGVBXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBwb3NpdGlvbkFcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGFuZ2xlQVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYm9keUJcbiAqIEBwYXJhbSAge0xpbmV9ICAgICAgIHNoYXBlQlxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcG9zaXRpb25CXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhbmdsZUJcbiAqIEB0b2RvIEltcGxlbWVudCBtZSFcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkxJTkUgfCBTaGFwZS5MSU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUubGluZUxpbmUgPSBmdW5jdGlvbihcbiAgICBib2R5QSxcbiAgICBzaGFwZUEsXG4gICAgcG9zaXRpb25BLFxuICAgIGFuZ2xlQSxcbiAgICBib2R5QixcbiAgICBzaGFwZUIsXG4gICAgcG9zaXRpb25CLFxuICAgIGFuZ2xlQixcbiAgICBqdXN0VGVzdFxuKXtcbiAgICAvLyBUT0RPXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBQbGFuZS9saW5lIE5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIHBsYW5lTGluZVxuICogQHBhcmFtICB7Qm9keX0gICBwbGFuZUJvZHlcbiAqIEBwYXJhbSAge1BsYW5lfSAgcGxhbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICBwbGFuZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBwbGFuZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSAgIGxpbmVCb2R5XG4gKiBAcGFyYW0gIHtMaW5lfSAgIGxpbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICBsaW5lT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGxpbmVBbmdsZVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUExBTkUgfCBTaGFwZS5MSU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVMaW5lID0gZnVuY3Rpb24ocGxhbmVCb2R5LCBwbGFuZVNoYXBlLCBwbGFuZU9mZnNldCwgcGxhbmVBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lQm9keSwgIGxpbmVTaGFwZSwgIGxpbmVPZmZzZXQsICBsaW5lQW5nbGUsIGp1c3RUZXN0KXtcbiAgICB2YXIgd29ybGRWZXJ0ZXgwID0gdG1wMSxcbiAgICAgICAgd29ybGRWZXJ0ZXgxID0gdG1wMixcbiAgICAgICAgd29ybGRWZXJ0ZXgwMSA9IHRtcDMsXG4gICAgICAgIHdvcmxkVmVydGV4MTEgPSB0bXA0LFxuICAgICAgICB3b3JsZEVkZ2UgPSB0bXA1LFxuICAgICAgICB3b3JsZEVkZ2VVbml0ID0gdG1wNixcbiAgICAgICAgZGlzdCA9IHRtcDcsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gdG1wOCxcbiAgICAgICAgd29ybGRUYW5nZW50ID0gdG1wOSxcbiAgICAgICAgdmVydHMgPSB0bXBBcnJheSxcbiAgICAgICAgbnVtQ29udGFjdHMgPSAwO1xuXG4gICAgLy8gR2V0IHN0YXJ0IGFuZCBlbmQgcG9pbnRzXG4gICAgdmVjMi5zZXQod29ybGRWZXJ0ZXgwLCAtbGluZVNoYXBlLmxlbmd0aC8yLCAwKTtcbiAgICB2ZWMyLnNldCh3b3JsZFZlcnRleDEsICBsaW5lU2hhcGUubGVuZ3RoLzIsIDApO1xuXG4gICAgLy8gTm90IHN1cmUgd2h5IHdlIGhhdmUgdG8gdXNlIHdvcmxkVmVydGV4KjEgaGVyZSwgYnV0IGl0IHdvbid0IHdvcmsgb3RoZXJ3aXNlLiBUaXJlZC5cbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDAxLCB3b3JsZFZlcnRleDAsIGxpbmVBbmdsZSk7XG4gICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgxMSwgd29ybGRWZXJ0ZXgxLCBsaW5lQW5nbGUpO1xuXG4gICAgYWRkKHdvcmxkVmVydGV4MDEsIHdvcmxkVmVydGV4MDEsIGxpbmVPZmZzZXQpO1xuICAgIGFkZCh3b3JsZFZlcnRleDExLCB3b3JsZFZlcnRleDExLCBsaW5lT2Zmc2V0KTtcblxuICAgIHZlYzIuY29weSh3b3JsZFZlcnRleDAsd29ybGRWZXJ0ZXgwMSk7XG4gICAgdmVjMi5jb3B5KHdvcmxkVmVydGV4MSx3b3JsZFZlcnRleDExKTtcblxuICAgIC8vIEdldCB2ZWN0b3IgYWxvbmcgdGhlIGxpbmVcbiAgICBzdWIod29ybGRFZGdlLCB3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MCk7XG4gICAgdmVjMi5ub3JtYWxpemUod29ybGRFZGdlVW5pdCwgd29ybGRFZGdlKTtcblxuICAgIC8vIEdldCB0YW5nZW50IHRvIHRoZSBlZGdlLlxuICAgIHZlYzIucm90YXRlOTBjdyh3b3JsZFRhbmdlbnQsIHdvcmxkRWRnZVVuaXQpO1xuXG4gICAgdmVjMi5yb3RhdGUod29ybGROb3JtYWwsIHlBeGlzLCBwbGFuZUFuZ2xlKTtcblxuICAgIC8vIENoZWNrIGxpbmUgZW5kc1xuICAgIHZlcnRzWzBdID0gd29ybGRWZXJ0ZXgwO1xuICAgIHZlcnRzWzFdID0gd29ybGRWZXJ0ZXgxO1xuICAgIGZvcih2YXIgaT0wOyBpPHZlcnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSB2ZXJ0c1tpXTtcblxuICAgICAgICBzdWIoZGlzdCwgdiwgcGxhbmVPZmZzZXQpO1xuXG4gICAgICAgIHZhciBkID0gZG90KGRpc3Qsd29ybGROb3JtYWwpO1xuXG4gICAgICAgIGlmKGQgPCAwKXtcblxuICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBsYW5lQm9keSxsaW5lQm9keSxwbGFuZVNoYXBlLGxpbmVTaGFwZSk7XG4gICAgICAgICAgICBudW1Db250YWN0cysrO1xuXG4gICAgICAgICAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCB3b3JsZE5vcm1hbCk7XG4gICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsYy5ub3JtYWxBKTtcblxuICAgICAgICAgICAgLy8gZGlzdGFuY2UgdmVjdG9yIGFsb25nIHBsYW5lIG5vcm1hbFxuICAgICAgICAgICAgdmVjMi5zY2FsZShkaXN0LCB3b3JsZE5vcm1hbCwgZCk7XG5cbiAgICAgICAgICAgIC8vIFZlY3RvciBmcm9tIHBsYW5lIGNlbnRlciB0byBjb250YWN0XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCB2LCBkaXN0KTtcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGxhbmVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgLy8gRnJvbSBsaW5lIGNlbnRlciB0byBjb250YWN0XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCB2LCAgICBsaW5lT2Zmc2V0KTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZU9mZnNldCk7XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgIGlmKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYoIXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICBpZihudW1Db250YWN0cyAmJiB0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtQ29udGFjdHMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudW1Db250YWN0cztcbn07XG5cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QQVJUSUNMRSB8IFNoYXBlLkNBUFNVTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wYXJ0aWNsZUNhcHN1bGUgPSBmdW5jdGlvbihcbiAgICBwYXJ0aWNsZUJvZHksXG4gICAgcGFydGljbGVTaGFwZSxcbiAgICBwYXJ0aWNsZVBvc2l0aW9uLFxuICAgIHBhcnRpY2xlQW5nbGUsXG4gICAgY2Fwc3VsZUJvZHksXG4gICAgY2Fwc3VsZVNoYXBlLFxuICAgIGNhcHN1bGVQb3NpdGlvbixcbiAgICBjYXBzdWxlQW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgcmV0dXJuIHRoaXMuY2lyY2xlTGluZShwYXJ0aWNsZUJvZHkscGFydGljbGVTaGFwZSxwYXJ0aWNsZVBvc2l0aW9uLHBhcnRpY2xlQW5nbGUsIGNhcHN1bGVCb2R5LGNhcHN1bGVTaGFwZSxjYXBzdWxlUG9zaXRpb24sY2Fwc3VsZUFuZ2xlLCBqdXN0VGVzdCwgY2Fwc3VsZVNoYXBlLnJhZGl1cywgMCk7XG59O1xuXG4vKipcbiAqIENpcmNsZS9saW5lIE5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGNpcmNsZUxpbmVcbiAqIEBwYXJhbSAge0JvZHl9IGNpcmNsZUJvZHlcbiAqIEBwYXJhbSAge0NpcmNsZX0gY2lyY2xlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBjaXJjbGVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gY2lyY2xlQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9IGxpbmVCb2R5XG4gKiBAcGFyYW0gIHtMaW5lfSBsaW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBsaW5lT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGxpbmVBbmdsZVxuICogQHBhcmFtIHtCb29sZWFufSBqdXN0VGVzdCBJZiBzZXQgdG8gdHJ1ZSwgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IChpbnRlcnNlY3Rpb24gb3Igbm90KSB3aXRob3V0IGFkZGluZyBlcXVhdGlvbnMuXG4gKiBAcGFyYW0ge051bWJlcn0gbGluZVJhZGl1cyBSYWRpdXMgdG8gYWRkIHRvIHRoZSBsaW5lLiBDYW4gYmUgdXNlZCB0byB0ZXN0IENhcHN1bGVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNpcmNsZVJhZGl1cyBJZiBzZXQsIHRoaXMgdmFsdWUgb3ZlcnJpZGVzIHRoZSBjaXJjbGUgc2hhcGUgcmFkaXVzLlxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuTElORV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZUxpbmUgPSBmdW5jdGlvbihcbiAgICBjaXJjbGVCb2R5LFxuICAgIGNpcmNsZVNoYXBlLFxuICAgIGNpcmNsZU9mZnNldCxcbiAgICBjaXJjbGVBbmdsZSxcbiAgICBsaW5lQm9keSxcbiAgICBsaW5lU2hhcGUsXG4gICAgbGluZU9mZnNldCxcbiAgICBsaW5lQW5nbGUsXG4gICAganVzdFRlc3QsXG4gICAgbGluZVJhZGl1cyxcbiAgICBjaXJjbGVSYWRpdXNcbil7XG4gICAgdmFyIGxpbmVSYWRpdXMgPSBsaW5lUmFkaXVzIHx8IDAsXG4gICAgICAgIGNpcmNsZVJhZGl1cyA9IHR5cGVvZihjaXJjbGVSYWRpdXMpIT09XCJ1bmRlZmluZWRcIiA/IGNpcmNsZVJhZGl1cyA6IGNpcmNsZVNoYXBlLnJhZGl1cyxcblxuICAgICAgICBvcnRob0Rpc3QgPSB0bXAxLFxuICAgICAgICBsaW5lVG9DaXJjbGVPcnRob1VuaXQgPSB0bXAyLFxuICAgICAgICBwcm9qZWN0ZWRQb2ludCA9IHRtcDMsXG4gICAgICAgIGNlbnRlckRpc3QgPSB0bXA0LFxuICAgICAgICB3b3JsZFRhbmdlbnQgPSB0bXA1LFxuICAgICAgICB3b3JsZEVkZ2UgPSB0bXA2LFxuICAgICAgICB3b3JsZEVkZ2VVbml0ID0gdG1wNyxcbiAgICAgICAgd29ybGRWZXJ0ZXgwID0gdG1wOCxcbiAgICAgICAgd29ybGRWZXJ0ZXgxID0gdG1wOSxcbiAgICAgICAgd29ybGRWZXJ0ZXgwMSA9IHRtcDEwLFxuICAgICAgICB3b3JsZFZlcnRleDExID0gdG1wMTEsXG4gICAgICAgIGRpc3QgPSB0bXAxMixcbiAgICAgICAgbGluZVRvQ2lyY2xlID0gdG1wMTMsXG4gICAgICAgIGxpbmVFbmRUb0xpbmVSYWRpdXMgPSB0bXAxNCxcblxuICAgICAgICB2ZXJ0cyA9IHRtcEFycmF5O1xuXG4gICAgLy8gR2V0IHN0YXJ0IGFuZCBlbmQgcG9pbnRzXG4gICAgdmVjMi5zZXQod29ybGRWZXJ0ZXgwLCAtbGluZVNoYXBlLmxlbmd0aC8yLCAwKTtcbiAgICB2ZWMyLnNldCh3b3JsZFZlcnRleDEsICBsaW5lU2hhcGUubGVuZ3RoLzIsIDApO1xuXG4gICAgLy8gTm90IHN1cmUgd2h5IHdlIGhhdmUgdG8gdXNlIHdvcmxkVmVydGV4KjEgaGVyZSwgYnV0IGl0IHdvbid0IHdvcmsgb3RoZXJ3aXNlLiBUaXJlZC5cbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDAxLCB3b3JsZFZlcnRleDAsIGxpbmVBbmdsZSk7XG4gICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgxMSwgd29ybGRWZXJ0ZXgxLCBsaW5lQW5nbGUpO1xuXG4gICAgYWRkKHdvcmxkVmVydGV4MDEsIHdvcmxkVmVydGV4MDEsIGxpbmVPZmZzZXQpO1xuICAgIGFkZCh3b3JsZFZlcnRleDExLCB3b3JsZFZlcnRleDExLCBsaW5lT2Zmc2V0KTtcblxuICAgIHZlYzIuY29weSh3b3JsZFZlcnRleDAsd29ybGRWZXJ0ZXgwMSk7XG4gICAgdmVjMi5jb3B5KHdvcmxkVmVydGV4MSx3b3JsZFZlcnRleDExKTtcblxuICAgIC8vIEdldCB2ZWN0b3IgYWxvbmcgdGhlIGxpbmVcbiAgICBzdWIod29ybGRFZGdlLCB3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MCk7XG4gICAgdmVjMi5ub3JtYWxpemUod29ybGRFZGdlVW5pdCwgd29ybGRFZGdlKTtcblxuICAgIC8vIEdldCB0YW5nZW50IHRvIHRoZSBlZGdlLlxuICAgIHZlYzIucm90YXRlOTBjdyh3b3JsZFRhbmdlbnQsIHdvcmxkRWRnZVVuaXQpO1xuXG4gICAgLy8gQ2hlY2sgZGlzdGFuY2UgZnJvbSB0aGUgcGxhbmUgc3Bhbm5lZCBieSB0aGUgZWRnZSB2cyB0aGUgY2lyY2xlXG4gICAgc3ViKGRpc3QsIGNpcmNsZU9mZnNldCwgd29ybGRWZXJ0ZXgwKTtcbiAgICB2YXIgZCA9IGRvdChkaXN0LCB3b3JsZFRhbmdlbnQpOyAvLyBEaXN0YW5jZSBmcm9tIGNlbnRlciBvZiBsaW5lIHRvIGNpcmNsZSBjZW50ZXJcbiAgICBzdWIoY2VudGVyRGlzdCwgd29ybGRWZXJ0ZXgwLCBsaW5lT2Zmc2V0KTtcblxuICAgIHN1YihsaW5lVG9DaXJjbGUsIGNpcmNsZU9mZnNldCwgbGluZU9mZnNldCk7XG5cbiAgICB2YXIgcmFkaXVzU3VtID0gY2lyY2xlUmFkaXVzICsgbGluZVJhZGl1cztcblxuICAgIGlmKE1hdGguYWJzKGQpIDwgcmFkaXVzU3VtKXtcblxuICAgICAgICAvLyBOb3cgcHJvamVjdCB0aGUgY2lyY2xlIG9udG8gdGhlIGVkZ2VcbiAgICAgICAgdmVjMi5zY2FsZShvcnRob0Rpc3QsIHdvcmxkVGFuZ2VudCwgZCk7XG4gICAgICAgIHN1Yihwcm9qZWN0ZWRQb2ludCwgY2lyY2xlT2Zmc2V0LCBvcnRob0Rpc3QpO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgbWlzc2luZyBsaW5lIHJhZGl1c1xuICAgICAgICB2ZWMyLnNjYWxlKGxpbmVUb0NpcmNsZU9ydGhvVW5pdCwgd29ybGRUYW5nZW50LCBkb3Qod29ybGRUYW5nZW50LCBsaW5lVG9DaXJjbGUpKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUobGluZVRvQ2lyY2xlT3J0aG9Vbml0LGxpbmVUb0NpcmNsZU9ydGhvVW5pdCk7XG4gICAgICAgIHZlYzIuc2NhbGUobGluZVRvQ2lyY2xlT3J0aG9Vbml0LCBsaW5lVG9DaXJjbGVPcnRob1VuaXQsIGxpbmVSYWRpdXMpO1xuICAgICAgICBhZGQocHJvamVjdGVkUG9pbnQscHJvamVjdGVkUG9pbnQsbGluZVRvQ2lyY2xlT3J0aG9Vbml0KTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBlZGdlIHNwYW5cbiAgICAgICAgdmFyIHBvcyA9ICBkb3Qod29ybGRFZGdlVW5pdCwgcHJvamVjdGVkUG9pbnQpO1xuICAgICAgICB2YXIgcG9zMCA9IGRvdCh3b3JsZEVkZ2VVbml0LCB3b3JsZFZlcnRleDApO1xuICAgICAgICB2YXIgcG9zMSA9IGRvdCh3b3JsZEVkZ2VVbml0LCB3b3JsZFZlcnRleDEpO1xuXG4gICAgICAgIGlmKHBvcyA+IHBvczAgJiYgcG9zIDwgcG9zMSl7XG4gICAgICAgICAgICAvLyBXZSBnb3QgY29udGFjdCFcblxuICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGNpcmNsZUJvZHksbGluZUJvZHksY2lyY2xlU2hhcGUsbGluZVNoYXBlKTtcblxuICAgICAgICAgICAgdmVjMi5zY2FsZShjLm5vcm1hbEEsIG9ydGhvRGlzdCwgLTEpO1xuICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLCBjLm5vcm1hbEEpO1xuXG4gICAgICAgICAgICB2ZWMyLnNjYWxlKCBjLmNvbnRhY3RQb2ludEEsIGMubm9ybWFsQSwgIGNpcmNsZVJhZGl1cyk7XG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZU9mZnNldCk7XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBwcm9qZWN0ZWRQb2ludCwgbGluZU9mZnNldCk7XG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVPZmZzZXQpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgY29ybmVyXG4gICAgdmVydHNbMF0gPSB3b3JsZFZlcnRleDA7XG4gICAgdmVydHNbMV0gPSB3b3JsZFZlcnRleDE7XG5cbiAgICBmb3IodmFyIGk9MDsgaTx2ZXJ0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB2ID0gdmVydHNbaV07XG5cbiAgICAgICAgc3ViKGRpc3QsIHYsIGNpcmNsZU9mZnNldCk7XG5cbiAgICAgICAgaWYodmVjMi5zcXVhcmVkTGVuZ3RoKGRpc3QpIDwgTWF0aC5wb3cocmFkaXVzU3VtLCAyKSl7XG5cbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihjaXJjbGVCb2R5LGxpbmVCb2R5LGNpcmNsZVNoYXBlLGxpbmVTaGFwZSk7XG5cbiAgICAgICAgICAgIHZlYzIuY29weShjLm5vcm1hbEEsIGRpc3QpO1xuICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLGMubm9ybWFsQSk7XG5cbiAgICAgICAgICAgIC8vIFZlY3RvciBmcm9tIGNpcmNsZSB0byBjb250YWN0IHBvaW50IGlzIHRoZSBub3JtYWwgdGltZXMgdGhlIGNpcmNsZSByYWRpdXNcbiAgICAgICAgICAgIHZlYzIuc2NhbGUoYy5jb250YWN0UG9pbnRBLCBjLm5vcm1hbEEsIGNpcmNsZVJhZGl1cyk7XG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZU9mZnNldCk7XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCB2LCBsaW5lT2Zmc2V0KTtcbiAgICAgICAgICAgIHZlYzIuc2NhbGUobGluZUVuZFRvTGluZVJhZGl1cywgYy5ub3JtYWxBLCAtbGluZVJhZGl1cyk7XG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVFbmRUb0xpbmVSYWRpdXMpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lT2Zmc2V0KTtcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59O1xuXG4vKipcbiAqIENpcmNsZS9jYXBzdWxlIE5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGNpcmNsZUNhcHN1bGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgYmlcbiAqIEBwYXJhbSAge0NpcmNsZX0gc2lcbiAqIEBwYXJhbSAge0FycmF5fSAgeGlcbiAqIEBwYXJhbSAge051bWJlcn0gYWlcbiAqIEBwYXJhbSAge0JvZHl9ICAgYmpcbiAqIEBwYXJhbSAge0xpbmV9ICAgc2pcbiAqIEBwYXJhbSAge0FycmF5fSAgeGpcbiAqIEBwYXJhbSAge051bWJlcn0gYWpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkNBUFNVTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVDYXBzdWxlID0gZnVuY3Rpb24oYmksc2kseGksYWksIGJqLHNqLHhqLGFqLCBqdXN0VGVzdCl7XG4gICAgcmV0dXJuIHRoaXMuY2lyY2xlTGluZShiaSxzaSx4aSxhaSwgYmosc2oseGosYWosIGp1c3RUZXN0LCBzai5yYWRpdXMpO1xufTtcblxuLyoqXG4gKiBDaXJjbGUvY29udmV4IE5hcnJvd3BoYXNlLlxuICogQG1ldGhvZCBjaXJjbGVDb252ZXhcbiAqIEBwYXJhbSAge0JvZHl9IGNpcmNsZUJvZHlcbiAqIEBwYXJhbSAge0NpcmNsZX0gY2lyY2xlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBjaXJjbGVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gY2lyY2xlQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9IGNvbnZleEJvZHlcbiAqIEBwYXJhbSAge0NvbnZleH0gY29udmV4U2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBjb252ZXhPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gY29udmV4QW5nbGVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGp1c3RUZXN0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNpcmNsZVJhZGl1c1xuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuQ09OVkVYXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuUkVDVEFOR0xFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlQ29udmV4ID0gZnVuY3Rpb24oXG4gICAgY2lyY2xlQm9keSxcbiAgICBjaXJjbGVTaGFwZSxcbiAgICBjaXJjbGVPZmZzZXQsXG4gICAgY2lyY2xlQW5nbGUsXG4gICAgY29udmV4Qm9keSxcbiAgICBjb252ZXhTaGFwZSxcbiAgICBjb252ZXhPZmZzZXQsXG4gICAgY29udmV4QW5nbGUsXG4gICAganVzdFRlc3QsXG4gICAgY2lyY2xlUmFkaXVzXG4pe1xuICAgIHZhciBjaXJjbGVSYWRpdXMgPSB0eXBlb2YoY2lyY2xlUmFkaXVzKT09PVwibnVtYmVyXCIgPyBjaXJjbGVSYWRpdXMgOiBjaXJjbGVTaGFwZS5yYWRpdXM7XG5cbiAgICB2YXIgd29ybGRWZXJ0ZXgwID0gdG1wMSxcbiAgICAgICAgd29ybGRWZXJ0ZXgxID0gdG1wMixcbiAgICAgICAgd29ybGRFZGdlID0gdG1wMyxcbiAgICAgICAgd29ybGRFZGdlVW5pdCA9IHRtcDQsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gdG1wNSxcbiAgICAgICAgY2VudGVyRGlzdCA9IHRtcDYsXG4gICAgICAgIGNvbnZleFRvQ2lyY2xlID0gdG1wNyxcbiAgICAgICAgb3J0aG9EaXN0ID0gdG1wOCxcbiAgICAgICAgcHJvamVjdGVkUG9pbnQgPSB0bXA5LFxuICAgICAgICBkaXN0ID0gdG1wMTAsXG4gICAgICAgIHdvcmxkVmVydGV4ID0gdG1wMTEsXG5cbiAgICAgICAgY2xvc2VzdEVkZ2UgPSAtMSxcbiAgICAgICAgY2xvc2VzdEVkZ2VEaXN0YW5jZSA9IG51bGwsXG4gICAgICAgIGNsb3Nlc3RFZGdlT3J0aG9EaXN0ID0gdG1wMTIsXG4gICAgICAgIGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQgPSB0bXAxMyxcbiAgICAgICAgY2FuZGlkYXRlID0gdG1wMTQsXG4gICAgICAgIGNhbmRpZGF0ZURpc3QgPSB0bXAxNSxcbiAgICAgICAgbWluQ2FuZGlkYXRlID0gdG1wMTYsXG5cbiAgICAgICAgZm91bmQgPSBmYWxzZSxcbiAgICAgICAgbWluQ2FuZGlkYXRlRGlzdGFuY2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgdmFyIG51bVJlcG9ydGVkID0gMDtcblxuICAgIC8vIE5ldyBhbGdvcml0aG06XG4gICAgLy8gMS4gQ2hlY2sgc28gY2VudGVyIG9mIGNpcmNsZSBpcyBub3QgaW5zaWRlIHRoZSBwb2x5Z29uLiBJZiBpdCBpcywgdGhpcyB3b250IHdvcmsuLi5cbiAgICAvLyAyLiBGb3IgZWFjaCBlZGdlXG4gICAgLy8gMi4gMS4gR2V0IHBvaW50IG9uIGNpcmNsZSB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIGVkZ2UgKHNjYWxlIG5vcm1hbCB3aXRoIC1yYWRpdXMpXG4gICAgLy8gMi4gMi4gQ2hlY2sgaWYgcG9pbnQgaXMgaW5zaWRlLlxuXG4gICAgdmFyIHZlcnRzID0gY29udmV4U2hhcGUudmVydGljZXM7XG5cbiAgICAvLyBDaGVjayBhbGwgZWRnZXMgZmlyc3RcbiAgICBmb3IodmFyIGk9MDsgaSE9PXZlcnRzLmxlbmd0aCsxOyBpKyspe1xuICAgICAgICB2YXIgdjAgPSB2ZXJ0c1tpJXZlcnRzLmxlbmd0aF0sXG4gICAgICAgICAgICB2MSA9IHZlcnRzWyhpKzEpJXZlcnRzLmxlbmd0aF07XG5cbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgwLCB2MCwgY29udmV4QW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDEsIHYxLCBjb252ZXhBbmdsZSk7XG4gICAgICAgIGFkZCh3b3JsZFZlcnRleDAsIHdvcmxkVmVydGV4MCwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgYWRkKHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgxLCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBzdWIod29ybGRFZGdlLCB3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MCk7XG5cbiAgICAgICAgdmVjMi5ub3JtYWxpemUod29ybGRFZGdlVW5pdCwgd29ybGRFZGdlKTtcblxuICAgICAgICAvLyBHZXQgdGFuZ2VudCB0byB0aGUgZWRnZS4gUG9pbnRzIG91dCBvZiB0aGUgQ29udmV4XG4gICAgICAgIHZlYzIucm90YXRlOTBjdyh3b3JsZE5vcm1hbCwgd29ybGRFZGdlVW5pdCk7XG5cbiAgICAgICAgLy8gR2V0IHBvaW50IG9uIGNpcmNsZSwgY2xvc2VzdCB0byB0aGUgcG9seWdvblxuICAgICAgICB2ZWMyLnNjYWxlKGNhbmRpZGF0ZSx3b3JsZE5vcm1hbCwtY2lyY2xlU2hhcGUucmFkaXVzKTtcbiAgICAgICAgYWRkKGNhbmRpZGF0ZSxjYW5kaWRhdGUsY2lyY2xlT2Zmc2V0KTtcblxuICAgICAgICBpZihwb2ludEluQ29udmV4KGNhbmRpZGF0ZSxjb252ZXhTaGFwZSxjb252ZXhPZmZzZXQsY29udmV4QW5nbGUpKXtcblxuICAgICAgICAgICAgdmVjMi5zdWIoY2FuZGlkYXRlRGlzdCx3b3JsZFZlcnRleDAsY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGVEaXN0YW5jZSA9IE1hdGguYWJzKHZlYzIuZG90KGNhbmRpZGF0ZURpc3Qsd29ybGROb3JtYWwpKTtcblxuICAgICAgICAgICAgaWYoY2FuZGlkYXRlRGlzdGFuY2UgPCBtaW5DYW5kaWRhdGVEaXN0YW5jZSl7XG4gICAgICAgICAgICAgICAgdmVjMi5jb3B5KG1pbkNhbmRpZGF0ZSxjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIG1pbkNhbmRpZGF0ZURpc3RhbmNlID0gY2FuZGlkYXRlRGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdmVjMi5zY2FsZShjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LHdvcmxkTm9ybWFsLGNhbmRpZGF0ZURpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB2ZWMyLmFkZChjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihmb3VuZCl7XG5cbiAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGNpcmNsZUJvZHksY29udmV4Qm9keSxjaXJjbGVTaGFwZSxjb252ZXhTaGFwZSk7XG4gICAgICAgIHZlYzIuc3ViKGMubm9ybWFsQSwgbWluQ2FuZGlkYXRlLCBjaXJjbGVPZmZzZXQpO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsIGMubm9ybWFsQSk7XG5cbiAgICAgICAgdmVjMi5zY2FsZShjLmNvbnRhY3RQb2ludEEsICBjLm5vcm1hbEEsIGNpcmNsZVJhZGl1cyk7XG4gICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlT2Zmc2V0KTtcbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4Qm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2goIHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgYWxsIHZlcnRpY2VzXG4gICAgaWYoY2lyY2xlUmFkaXVzID4gMCl7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHZlcnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBsb2NhbFZlcnRleCA9IHZlcnRzW2ldO1xuICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgsIGxvY2FsVmVydGV4LCBjb252ZXhBbmdsZSk7XG4gICAgICAgICAgICBhZGQod29ybGRWZXJ0ZXgsIHdvcmxkVmVydGV4LCBjb252ZXhPZmZzZXQpO1xuXG4gICAgICAgICAgICBzdWIoZGlzdCwgd29ybGRWZXJ0ZXgsIGNpcmNsZU9mZnNldCk7XG4gICAgICAgICAgICBpZih2ZWMyLnNxdWFyZWRMZW5ndGgoZGlzdCkgPCBNYXRoLnBvdyhjaXJjbGVSYWRpdXMsIDIpKXtcblxuICAgICAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihjaXJjbGVCb2R5LGNvbnZleEJvZHksY2lyY2xlU2hhcGUsY29udmV4U2hhcGUpO1xuXG4gICAgICAgICAgICAgICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgZGlzdCk7XG4gICAgICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLGMubm9ybWFsQSk7XG5cbiAgICAgICAgICAgICAgICAvLyBWZWN0b3IgZnJvbSBjaXJjbGUgdG8gY29udGFjdCBwb2ludCBpcyB0aGUgbm9ybWFsIHRpbWVzIHRoZSBjaXJjbGUgcmFkaXVzXG4gICAgICAgICAgICAgICAgdmVjMi5zY2FsZShjLmNvbnRhY3RQb2ludEEsIGMubm9ybWFsQSwgY2lyY2xlUmFkaXVzKTtcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHdvcmxkVmVydGV4LCBjb252ZXhPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleEJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn07XG5cbnZhciBwaWNfd29ybGRWZXJ0ZXgwID0gdmVjMi5jcmVhdGUoKSxcbiAgICBwaWNfd29ybGRWZXJ0ZXgxID0gdmVjMi5jcmVhdGUoKSxcbiAgICBwaWNfcjAgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHBpY19yMSA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qXG4gKiBDaGVjayBpZiBhIHBvaW50IGlzIGluIGEgcG9seWdvblxuICovXG5mdW5jdGlvbiBwb2ludEluQ29udmV4KHdvcmxkUG9pbnQsY29udmV4U2hhcGUsY29udmV4T2Zmc2V0LGNvbnZleEFuZ2xlKXtcbiAgICB2YXIgd29ybGRWZXJ0ZXgwID0gcGljX3dvcmxkVmVydGV4MCxcbiAgICAgICAgd29ybGRWZXJ0ZXgxID0gcGljX3dvcmxkVmVydGV4MSxcbiAgICAgICAgcjAgPSBwaWNfcjAsXG4gICAgICAgIHIxID0gcGljX3IxLFxuICAgICAgICBwb2ludCA9IHdvcmxkUG9pbnQsXG4gICAgICAgIHZlcnRzID0gY29udmV4U2hhcGUudmVydGljZXMsXG4gICAgICAgIGxhc3RDcm9zcyA9IG51bGw7XG4gICAgZm9yKHZhciBpPTA7IGkhPT12ZXJ0cy5sZW5ndGgrMTsgaSsrKXtcbiAgICAgICAgdmFyIHYwID0gdmVydHNbaSV2ZXJ0cy5sZW5ndGhdLFxuICAgICAgICAgICAgdjEgPSB2ZXJ0c1soaSsxKSV2ZXJ0cy5sZW5ndGhdO1xuXG4gICAgICAgIC8vIFRyYW5zZm9ybSB2ZXJ0aWNlcyB0byB3b3JsZFxuICAgICAgICAvLyBAdG9kbyBUaGUgcG9pbnQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkIHRvIGxvY2FsIGNvb3JkaW5hdGVzIGluIHRoZSBjb252ZXgsIG5vIG5lZWQgdG8gdHJhbnNmb3JtIGVhY2ggdmVydGV4XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MCwgdjAsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgxLCB2MSwgY29udmV4QW5nbGUpO1xuICAgICAgICBhZGQod29ybGRWZXJ0ZXgwLCB3b3JsZFZlcnRleDAsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIGFkZCh3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MSwgY29udmV4T2Zmc2V0KTtcblxuICAgICAgICBzdWIocjAsIHdvcmxkVmVydGV4MCwgcG9pbnQpO1xuICAgICAgICBzdWIocjEsIHdvcmxkVmVydGV4MSwgcG9pbnQpO1xuICAgICAgICB2YXIgY3Jvc3MgPSB2ZWMyLmNyb3NzTGVuZ3RoKHIwLHIxKTtcblxuICAgICAgICBpZihsYXN0Q3Jvc3M9PT1udWxsKXtcbiAgICAgICAgICAgIGxhc3RDcm9zcyA9IGNyb3NzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgZ290IGEgZGlmZmVyZW50IHNpZ24gb2YgdGhlIGRpc3RhbmNlIHZlY3RvciwgdGhlIHBvaW50IGlzIG91dCBvZiB0aGUgcG9seWdvblxuICAgICAgICBpZihjcm9zcypsYXN0Q3Jvc3MgPD0gMCl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdENyb3NzID0gY3Jvc3M7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFBhcnRpY2xlL2NvbnZleCBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBwYXJ0aWNsZUNvbnZleFxuICogQHBhcmFtICB7Qm9keX0gcGFydGljbGVCb2R5XG4gKiBAcGFyYW0gIHtQYXJ0aWNsZX0gcGFydGljbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IHBhcnRpY2xlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBhcnRpY2xlQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9IGNvbnZleEJvZHlcbiAqIEBwYXJhbSAge0NvbnZleH0gY29udmV4U2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBjb252ZXhPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gY29udmV4QW5nbGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0ganVzdFRlc3RcbiAqIEB0b2RvIHVzZSBwb2ludEluQ29udmV4IGFuZCBjb2RlIG1vcmUgc2ltaWxhciB0byBjaXJjbGVDb252ZXhcbiAqIEB0b2RvIGRvbid0IHRyYW5zZm9ybSBlYWNoIHZlcnRleCwgYnV0IHRyYW5zZm9ybSB0aGUgcGFydGljbGUgcG9zaXRpb24gdG8gY29udmV4LWxvY2FsIGluc3RlYWRcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBBUlRJQ0xFIHwgU2hhcGUuQ09OVkVYXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUEFSVElDTEUgfCBTaGFwZS5SRUNUQU5HTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wYXJ0aWNsZUNvbnZleCA9IGZ1bmN0aW9uKFxuICAgIHBhcnRpY2xlQm9keSxcbiAgICBwYXJ0aWNsZVNoYXBlLFxuICAgIHBhcnRpY2xlT2Zmc2V0LFxuICAgIHBhcnRpY2xlQW5nbGUsXG4gICAgY29udmV4Qm9keSxcbiAgICBjb252ZXhTaGFwZSxcbiAgICBjb252ZXhPZmZzZXQsXG4gICAgY29udmV4QW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgdmFyIHdvcmxkVmVydGV4MCA9IHRtcDEsXG4gICAgICAgIHdvcmxkVmVydGV4MSA9IHRtcDIsXG4gICAgICAgIHdvcmxkRWRnZSA9IHRtcDMsXG4gICAgICAgIHdvcmxkRWRnZVVuaXQgPSB0bXA0LFxuICAgICAgICB3b3JsZFRhbmdlbnQgPSB0bXA1LFxuICAgICAgICBjZW50ZXJEaXN0ID0gdG1wNixcbiAgICAgICAgY29udmV4VG9wYXJ0aWNsZSA9IHRtcDcsXG4gICAgICAgIG9ydGhvRGlzdCA9IHRtcDgsXG4gICAgICAgIHByb2plY3RlZFBvaW50ID0gdG1wOSxcbiAgICAgICAgZGlzdCA9IHRtcDEwLFxuICAgICAgICB3b3JsZFZlcnRleCA9IHRtcDExLFxuICAgICAgICBjbG9zZXN0RWRnZSA9IC0xLFxuICAgICAgICBjbG9zZXN0RWRnZURpc3RhbmNlID0gbnVsbCxcbiAgICAgICAgY2xvc2VzdEVkZ2VPcnRob0Rpc3QgPSB0bXAxMixcbiAgICAgICAgY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCA9IHRtcDEzLFxuICAgICAgICByMCA9IHRtcDE0LCAvLyB2ZWN0b3IgZnJvbSBwYXJ0aWNsZSB0byB2ZXJ0ZXgwXG4gICAgICAgIHIxID0gdG1wMTUsXG4gICAgICAgIGxvY2FsUG9pbnQgPSB0bXAxNixcbiAgICAgICAgY2FuZGlkYXRlRGlzdCA9IHRtcDE3LFxuICAgICAgICBtaW5FZGdlTm9ybWFsID0gdG1wMTgsXG4gICAgICAgIG1pbkNhbmRpZGF0ZURpc3RhbmNlID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIHZhciBudW1SZXBvcnRlZCA9IDAsXG4gICAgICAgIGZvdW5kID0gZmFsc2UsXG4gICAgICAgIHZlcnRzID0gY29udmV4U2hhcGUudmVydGljZXM7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgcGFydGljbGUgaXMgaW4gdGhlIHBvbHlnb24gYXQgYWxsXG4gICAgaWYoIXBvaW50SW5Db252ZXgocGFydGljbGVPZmZzZXQsY29udmV4U2hhcGUsY29udmV4T2Zmc2V0LGNvbnZleEFuZ2xlKSl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZWRnZXMgZmlyc3RcbiAgICB2YXIgbGFzdENyb3NzID0gbnVsbDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PXZlcnRzLmxlbmd0aCsxOyBpKyspe1xuICAgICAgICB2YXIgdjAgPSB2ZXJ0c1tpJXZlcnRzLmxlbmd0aF0sXG4gICAgICAgICAgICB2MSA9IHZlcnRzWyhpKzEpJXZlcnRzLmxlbmd0aF07XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtIHZlcnRpY2VzIHRvIHdvcmxkXG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MCwgdjAsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgxLCB2MSwgY29udmV4QW5nbGUpO1xuICAgICAgICBhZGQod29ybGRWZXJ0ZXgwLCB3b3JsZFZlcnRleDAsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIGFkZCh3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MSwgY29udmV4T2Zmc2V0KTtcblxuICAgICAgICAvLyBHZXQgd29ybGQgZWRnZVxuICAgICAgICBzdWIod29ybGRFZGdlLCB3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MCk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKHdvcmxkRWRnZVVuaXQsIHdvcmxkRWRnZSk7XG5cbiAgICAgICAgLy8gR2V0IHRhbmdlbnQgdG8gdGhlIGVkZ2UuIFBvaW50cyBvdXQgb2YgdGhlIENvbnZleFxuICAgICAgICB2ZWMyLnJvdGF0ZTkwY3cod29ybGRUYW5nZW50LCB3b3JsZEVkZ2VVbml0KTtcblxuICAgICAgICAvLyBDaGVjayBkaXN0YW5jZSBmcm9tIHRoZSBpbmZpbml0ZSBsaW5lIChzcGFubmVkIGJ5IHRoZSBlZGdlKSB0byB0aGUgcGFydGljbGVcbiAgICAgICAgc3ViKGRpc3QsIHBhcnRpY2xlT2Zmc2V0LCB3b3JsZFZlcnRleDApO1xuICAgICAgICB2YXIgZCA9IGRvdChkaXN0LCB3b3JsZFRhbmdlbnQpO1xuICAgICAgICBzdWIoY2VudGVyRGlzdCwgd29ybGRWZXJ0ZXgwLCBjb252ZXhPZmZzZXQpO1xuXG4gICAgICAgIHN1Yihjb252ZXhUb3BhcnRpY2xlLCBwYXJ0aWNsZU9mZnNldCwgY29udmV4T2Zmc2V0KTtcblxuICAgICAgICB2ZWMyLnN1YihjYW5kaWRhdGVEaXN0LHdvcmxkVmVydGV4MCxwYXJ0aWNsZU9mZnNldCk7XG4gICAgICAgIHZhciBjYW5kaWRhdGVEaXN0YW5jZSA9IE1hdGguYWJzKHZlYzIuZG90KGNhbmRpZGF0ZURpc3Qsd29ybGRUYW5nZW50KSk7XG5cbiAgICAgICAgaWYoY2FuZGlkYXRlRGlzdGFuY2UgPCBtaW5DYW5kaWRhdGVEaXN0YW5jZSl7XG4gICAgICAgICAgICBtaW5DYW5kaWRhdGVEaXN0YW5jZSA9IGNhbmRpZGF0ZURpc3RhbmNlO1xuICAgICAgICAgICAgdmVjMi5zY2FsZShjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LHdvcmxkVGFuZ2VudCxjYW5kaWRhdGVEaXN0YW5jZSk7XG4gICAgICAgICAgICB2ZWMyLmFkZChjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQscGFydGljbGVPZmZzZXQpO1xuICAgICAgICAgICAgdmVjMi5jb3B5KG1pbkVkZ2VOb3JtYWwsd29ybGRUYW5nZW50KTtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGZvdW5kKXtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwYXJ0aWNsZUJvZHksY29udmV4Qm9keSxwYXJ0aWNsZVNoYXBlLGNvbnZleFNoYXBlKTtcblxuICAgICAgICB2ZWMyLnNjYWxlKGMubm9ybWFsQSwgbWluRWRnZU5vcm1hbCwgLTEpO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsIGMubm9ybWFsQSk7XG5cbiAgICAgICAgLy8gUGFydGljbGUgaGFzIG5vIGV4dGVudCB0byB0aGUgY29udGFjdCBwb2ludFxuICAgICAgICB2ZWMyLnNldChjLmNvbnRhY3RQb2ludEEsICAwLCAwKTtcbiAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwYXJ0aWNsZU9mZnNldCk7XG4gICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGFydGljbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAvLyBGcm9tIGNvbnZleCBjZW50ZXIgdG8gcG9pbnRcbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleEJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKCB0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuXG4gICAgcmV0dXJuIDA7XG59O1xuXG4vKipcbiAqIENpcmNsZS9jaXJjbGUgTmFycm93cGhhc2VcbiAqIEBtZXRob2QgY2lyY2xlQ2lyY2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Q2lyY2xlfSBzaGFwZUFcbiAqIEBwYXJhbSAge0FycmF5fSBvZmZzZXRBXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlQVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSAge0NpcmNsZX0gc2hhcGVCXG4gKiBAcGFyYW0gIHtBcnJheX0gb2Zmc2V0QlxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZUJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0ganVzdFRlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcmFkaXVzQV0gT3B0aW9uYWwgcmFkaXVzIHRvIHVzZSBmb3Igc2hhcGVBXG4gKiBAcGFyYW0ge051bWJlcn0gW3JhZGl1c0JdIE9wdGlvbmFsIHJhZGl1cyB0byB1c2UgZm9yIHNoYXBlQlxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlQ2lyY2xlID0gZnVuY3Rpb24oXG4gICAgYm9keUEsXG4gICAgc2hhcGVBLFxuICAgIG9mZnNldEEsXG4gICAgYW5nbGVBLFxuICAgIGJvZHlCLFxuICAgIHNoYXBlQixcbiAgICBvZmZzZXRCLFxuICAgIGFuZ2xlQixcbiAgICBqdXN0VGVzdCxcbiAgICByYWRpdXNBLFxuICAgIHJhZGl1c0Jcbil7XG5cbiAgICB2YXIgZGlzdCA9IHRtcDEsXG4gICAgICAgIHJhZGl1c0EgPSByYWRpdXNBIHx8IHNoYXBlQS5yYWRpdXMsXG4gICAgICAgIHJhZGl1c0IgPSByYWRpdXNCIHx8IHNoYXBlQi5yYWRpdXM7XG5cbiAgICBzdWIoZGlzdCxvZmZzZXRBLG9mZnNldEIpO1xuICAgIHZhciByID0gcmFkaXVzQSArIHJhZGl1c0I7XG4gICAgaWYodmVjMi5zcXVhcmVkTGVuZ3RoKGRpc3QpID4gTWF0aC5wb3cociwyKSl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihib2R5QSxib2R5QixzaGFwZUEsc2hhcGVCKTtcbiAgICBzdWIoYy5ub3JtYWxBLCBvZmZzZXRCLCBvZmZzZXRBKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsYy5ub3JtYWxBKTtcblxuICAgIHZlYzIuc2NhbGUoIGMuY29udGFjdFBvaW50QSwgYy5ub3JtYWxBLCAgcmFkaXVzQSk7XG4gICAgdmVjMi5zY2FsZSggYy5jb250YWN0UG9pbnRCLCBjLm5vcm1hbEEsIC1yYWRpdXNCKTtcblxuICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgb2Zmc2V0QSk7XG4gICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBib2R5QS5wb3NpdGlvbik7XG5cbiAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIG9mZnNldEIpO1xuICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgYm9keUIucG9zaXRpb24pO1xuXG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgfVxuICAgIHJldHVybiAxO1xufTtcblxuLyoqXG4gKiBQbGFuZS9Db252ZXggTmFycm93cGhhc2VcbiAqIEBtZXRob2QgcGxhbmVDb252ZXhcbiAqIEBwYXJhbSAge0JvZHl9IHBsYW5lQm9keVxuICogQHBhcmFtICB7UGxhbmV9IHBsYW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBwbGFuZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBwbGFuZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBjb252ZXhCb2R5XG4gKiBAcGFyYW0gIHtDb252ZXh9IGNvbnZleFNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY29udmV4T2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbnZleEFuZ2xlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QTEFORSB8IFNoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBMQU5FIHwgU2hhcGUuUkVDVEFOR0xFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVDb252ZXggPSBmdW5jdGlvbihcbiAgICBwbGFuZUJvZHksXG4gICAgcGxhbmVTaGFwZSxcbiAgICBwbGFuZU9mZnNldCxcbiAgICBwbGFuZUFuZ2xlLFxuICAgIGNvbnZleEJvZHksXG4gICAgY29udmV4U2hhcGUsXG4gICAgY29udmV4T2Zmc2V0LFxuICAgIGNvbnZleEFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIHZhciB3b3JsZFZlcnRleCA9IHRtcDEsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gdG1wMixcbiAgICAgICAgZGlzdCA9IHRtcDM7XG5cbiAgICB2YXIgbnVtUmVwb3J0ZWQgPSAwO1xuICAgIHZlYzIucm90YXRlKHdvcmxkTm9ybWFsLCB5QXhpcywgcGxhbmVBbmdsZSk7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PWNvbnZleFNoYXBlLnZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSBjb252ZXhTaGFwZS52ZXJ0aWNlc1tpXTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgsIHYsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgYWRkKHdvcmxkVmVydGV4LCB3b3JsZFZlcnRleCwgY29udmV4T2Zmc2V0KTtcblxuICAgICAgICBzdWIoZGlzdCwgd29ybGRWZXJ0ZXgsIHBsYW5lT2Zmc2V0KTtcblxuICAgICAgICBpZihkb3QoZGlzdCx3b3JsZE5vcm1hbCkgPD0gMCl7XG5cbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRm91bmQgdmVydGV4XG4gICAgICAgICAgICBudW1SZXBvcnRlZCsrO1xuXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBsYW5lQm9keSxjb252ZXhCb2R5LHBsYW5lU2hhcGUsY29udmV4U2hhcGUpO1xuXG4gICAgICAgICAgICBzdWIoZGlzdCwgd29ybGRWZXJ0ZXgsIHBsYW5lT2Zmc2V0KTtcblxuICAgICAgICAgICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgd29ybGROb3JtYWwpO1xuXG4gICAgICAgICAgICB2YXIgZCA9IGRvdChkaXN0LCBjLm5vcm1hbEEpO1xuICAgICAgICAgICAgdmVjMi5zY2FsZShkaXN0LCBjLm5vcm1hbEEsIGQpO1xuXG4gICAgICAgICAgICAvLyByaiBpcyBmcm9tIGNvbnZleCBjZW50ZXIgdG8gY29udGFjdFxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50Qiwgd29ybGRWZXJ0ZXgsIGNvbnZleEJvZHkucG9zaXRpb24pO1xuXG5cbiAgICAgICAgICAgIC8vIHJpIGlzIGZyb20gcGxhbmUgY2VudGVyIHRvIGNvbnRhY3RcbiAgICAgICAgICAgIHN1YiggYy5jb250YWN0UG9pbnRBLCB3b3JsZFZlcnRleCwgZGlzdCk7XG4gICAgICAgICAgICBzdWIoIGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwbGFuZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgaWYoIXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbiAmJiBudW1SZXBvcnRlZCl7XG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bVJlcG9ydGVkKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVtUmVwb3J0ZWQ7XG59O1xuXG4vKipcbiAqIE5hcnJvd3BoYXNlIGZvciBwYXJ0aWNsZSB2cyBwbGFuZVxuICogQG1ldGhvZCBwYXJ0aWNsZVBsYW5lXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBwYXJ0aWNsZUJvZHlcbiAqIEBwYXJhbSAge1BhcnRpY2xlfSAgIHBhcnRpY2xlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHBhcnRpY2xlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBwYXJ0aWNsZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBwbGFuZUJvZHlcbiAqIEBwYXJhbSAge1BsYW5lfSAgICAgIHBsYW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHBsYW5lT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBwbGFuZUFuZ2xlXG4gKiBAcGFyYW0ge0Jvb2xlYW59ICAgICBqdXN0VGVzdFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUEFSVElDTEUgfCBTaGFwZS5QTEFORV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBhcnRpY2xlUGxhbmUgPSBmdW5jdGlvbihcbiAgICBwYXJ0aWNsZUJvZHksXG4gICAgcGFydGljbGVTaGFwZSxcbiAgICBwYXJ0aWNsZU9mZnNldCxcbiAgICBwYXJ0aWNsZUFuZ2xlLFxuICAgIHBsYW5lQm9keSxcbiAgICBwbGFuZVNoYXBlLFxuICAgIHBsYW5lT2Zmc2V0LFxuICAgIHBsYW5lQW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgdmFyIGRpc3QgPSB0bXAxLFxuICAgICAgICB3b3JsZE5vcm1hbCA9IHRtcDI7XG5cbiAgICBwbGFuZUFuZ2xlID0gcGxhbmVBbmdsZSB8fCAwO1xuXG4gICAgc3ViKGRpc3QsIHBhcnRpY2xlT2Zmc2V0LCBwbGFuZU9mZnNldCk7XG4gICAgdmVjMi5yb3RhdGUod29ybGROb3JtYWwsIHlBeGlzLCBwbGFuZUFuZ2xlKTtcblxuICAgIHZhciBkID0gZG90KGRpc3QsIHdvcmxkTm9ybWFsKTtcblxuICAgIGlmKGQgPiAwKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHkscGFydGljbGVCb2R5LHBsYW5lU2hhcGUscGFydGljbGVTaGFwZSk7XG5cbiAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCB3b3JsZE5vcm1hbCk7XG4gICAgdmVjMi5zY2FsZSggZGlzdCwgYy5ub3JtYWxBLCBkICk7XG4gICAgLy8gZGlzdCBpcyBub3cgdGhlIGRpc3RhbmNlIHZlY3RvciBpbiB0aGUgbm9ybWFsIGRpcmVjdGlvblxuXG4gICAgLy8gcmkgaXMgdGhlIHBhcnRpY2xlIHBvc2l0aW9uIHByb2plY3RlZCBkb3duIG9udG8gdGhlIHBsYW5lLCBmcm9tIHRoZSBwbGFuZSBjZW50ZXJcbiAgICBzdWIoIGMuY29udGFjdFBvaW50QSwgcGFydGljbGVPZmZzZXQsIGRpc3QpO1xuICAgIHN1YiggYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIHBsYW5lQm9keS5wb3NpdGlvbik7XG5cbiAgICAvLyByaiBpcyBmcm9tIHRoZSBib2R5IGNlbnRlciB0byB0aGUgcGFydGljbGUgY2VudGVyXG4gICAgc3ViKCBjLmNvbnRhY3RQb2ludEIsIHBhcnRpY2xlT2Zmc2V0LCBwYXJ0aWNsZUJvZHkucG9zaXRpb24gKTtcblxuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbn07XG5cbi8qKlxuICogQ2lyY2xlL1BhcnRpY2xlIE5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGNpcmNsZVBhcnRpY2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBjaXJjbGVCb2R5XG4gKiBAcGFyYW0gIHtDaXJjbGV9IGNpcmNsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY2lyY2xlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNpcmNsZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBwYXJ0aWNsZUJvZHlcbiAqIEBwYXJhbSAge1BhcnRpY2xlfSBwYXJ0aWNsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gcGFydGljbGVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gcGFydGljbGVBbmdsZVxuICogQHBhcmFtICB7Qm9vbGVhbn0ganVzdFRlc3RcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLlBBUlRJQ0xFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlUGFydGljbGUgPSBmdW5jdGlvbihcbiAgICBjaXJjbGVCb2R5LFxuICAgIGNpcmNsZVNoYXBlLFxuICAgIGNpcmNsZU9mZnNldCxcbiAgICBjaXJjbGVBbmdsZSxcbiAgICBwYXJ0aWNsZUJvZHksXG4gICAgcGFydGljbGVTaGFwZSxcbiAgICBwYXJ0aWNsZU9mZnNldCxcbiAgICBwYXJ0aWNsZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIHZhciBkaXN0ID0gdG1wMTtcblxuICAgIHN1YihkaXN0LCBwYXJ0aWNsZU9mZnNldCwgY2lyY2xlT2Zmc2V0KTtcbiAgICBpZih2ZWMyLnNxdWFyZWRMZW5ndGgoZGlzdCkgPiBNYXRoLnBvdyhjaXJjbGVTaGFwZS5yYWRpdXMsIDIpKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihjaXJjbGVCb2R5LHBhcnRpY2xlQm9keSxjaXJjbGVTaGFwZSxwYXJ0aWNsZVNoYXBlKTtcbiAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCBkaXN0KTtcbiAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsYy5ub3JtYWxBKTtcblxuICAgIC8vIFZlY3RvciBmcm9tIGNpcmNsZSB0byBjb250YWN0IHBvaW50IGlzIHRoZSBub3JtYWwgdGltZXMgdGhlIGNpcmNsZSByYWRpdXNcbiAgICB2ZWMyLnNjYWxlKGMuY29udGFjdFBvaW50QSwgYy5ub3JtYWxBLCBjaXJjbGVTaGFwZS5yYWRpdXMpO1xuICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlT2Zmc2V0KTtcbiAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgLy8gVmVjdG9yIGZyb20gcGFydGljbGUgY2VudGVyIHRvIGNvbnRhY3QgcG9pbnQgaXMgemVyb1xuICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHBhcnRpY2xlT2Zmc2V0LCBwYXJ0aWNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG59O1xuXG52YXIgcGxhbmVDYXBzdWxlX3RtcENpcmNsZSA9IG5ldyBDaXJjbGUoMSksXG4gICAgcGxhbmVDYXBzdWxlX3RtcDEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHBsYW5lQ2Fwc3VsZV90bXAyID0gdmVjMi5jcmVhdGUoKSxcbiAgICBwbGFuZUNhcHN1bGVfdG1wMyA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQG1ldGhvZCBwbGFuZUNhcHN1bGVcbiAqIEBwYXJhbSAge0JvZHl9IHBsYW5lQm9keVxuICogQHBhcmFtICB7Q2lyY2xlfSBwbGFuZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gcGxhbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gcGxhbmVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gY2Fwc3VsZUJvZHlcbiAqIEBwYXJhbSAge1BhcnRpY2xlfSBjYXBzdWxlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBjYXBzdWxlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNhcHN1bGVBbmdsZVxuICogQHBhcmFtIHtCb29sZWFufSBqdXN0VGVzdFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUExBTkUgfCBTaGFwZS5DQVBTVUxFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVDYXBzdWxlID0gZnVuY3Rpb24oXG4gICAgcGxhbmVCb2R5LFxuICAgIHBsYW5lU2hhcGUsXG4gICAgcGxhbmVPZmZzZXQsXG4gICAgcGxhbmVBbmdsZSxcbiAgICBjYXBzdWxlQm9keSxcbiAgICBjYXBzdWxlU2hhcGUsXG4gICAgY2Fwc3VsZU9mZnNldCxcbiAgICBjYXBzdWxlQW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgdmFyIGVuZDEgPSBwbGFuZUNhcHN1bGVfdG1wMSxcbiAgICAgICAgZW5kMiA9IHBsYW5lQ2Fwc3VsZV90bXAyLFxuICAgICAgICBjaXJjbGUgPSBwbGFuZUNhcHN1bGVfdG1wQ2lyY2xlLFxuICAgICAgICBkc3QgPSBwbGFuZUNhcHN1bGVfdG1wMztcblxuICAgIC8vIENvbXB1dGUgd29ybGQgZW5kIHBvc2l0aW9uc1xuICAgIHZlYzIuc2V0KGVuZDEsIC1jYXBzdWxlU2hhcGUubGVuZ3RoLzIsIDApO1xuICAgIHZlYzIucm90YXRlKGVuZDEsZW5kMSxjYXBzdWxlQW5nbGUpO1xuICAgIGFkZChlbmQxLGVuZDEsY2Fwc3VsZU9mZnNldCk7XG5cbiAgICB2ZWMyLnNldChlbmQyLCAgY2Fwc3VsZVNoYXBlLmxlbmd0aC8yLCAwKTtcbiAgICB2ZWMyLnJvdGF0ZShlbmQyLGVuZDIsY2Fwc3VsZUFuZ2xlKTtcbiAgICBhZGQoZW5kMixlbmQyLGNhcHN1bGVPZmZzZXQpO1xuXG4gICAgY2lyY2xlLnJhZGl1cyA9IGNhcHN1bGVTaGFwZS5yYWRpdXM7XG5cbiAgICB2YXIgZW5hYmxlRnJpY3Rpb25CZWZvcmU7XG5cbiAgICAvLyBUZW1wb3JhcmlseSB0dXJuIG9mZiBmcmljdGlvblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICBlbmFibGVGcmljdGlvbkJlZm9yZSA9IHRoaXMuZW5hYmxlRnJpY3Rpb247XG4gICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBEbyBOYXJyb3dwaGFzZSBhcyB0d28gY2lyY2xlc1xuICAgIHZhciBudW1Db250YWN0czEgPSB0aGlzLmNpcmNsZVBsYW5lKGNhcHN1bGVCb2R5LGNpcmNsZSxlbmQxLDAsIHBsYW5lQm9keSxwbGFuZVNoYXBlLHBsYW5lT2Zmc2V0LHBsYW5lQW5nbGUsIGp1c3RUZXN0KSxcbiAgICAgICAgbnVtQ29udGFjdHMyID0gdGhpcy5jaXJjbGVQbGFuZShjYXBzdWxlQm9keSxjaXJjbGUsZW5kMiwwLCBwbGFuZUJvZHkscGxhbmVTaGFwZSxwbGFuZU9mZnNldCxwbGFuZUFuZ2xlLCBqdXN0VGVzdCk7XG5cbiAgICAvLyBSZXN0b3JlIGZyaWN0aW9uXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBlbmFibGVGcmljdGlvbkJlZm9yZTtcbiAgICB9XG5cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiBudW1Db250YWN0czEgfHwgbnVtQ29udGFjdHMyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBudW1Ub3RhbCA9IG51bUNvbnRhY3RzMSArIG51bUNvbnRhY3RzMjtcbiAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgICAgICBpZihudW1Ub3RhbCl7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Ub3RhbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW1Ub3RhbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgQ29udGFjdEVxdWF0aW9ucyBhbmQgRnJpY3Rpb25FcXVhdGlvbnMgZm9yIGEgY29sbGlzaW9uLlxuICogQG1ldGhvZCBjaXJjbGVQbGFuZVxuICogQHBhcmFtICB7Qm9keX0gICAgYmkgICAgIFRoZSBmaXJzdCBib2R5IHRoYXQgc2hvdWxkIGJlIGNvbm5lY3RlZCB0byB0aGUgZXF1YXRpb25zLlxuICogQHBhcmFtICB7Q2lyY2xlfSAgc2kgICAgIFRoZSBjaXJjbGUgc2hhcGUgcGFydGljaXBhdGluZyBpbiB0aGUgY29sbGlzaW9uLlxuICogQHBhcmFtICB7QXJyYXl9ICAgeGkgICAgIEV4dHJhIG9mZnNldCB0byB0YWtlIGludG8gYWNjb3VudCBmb3IgdGhlIFNoYXBlLCBpbiBhZGRpdGlvbiB0byB0aGUgb25lIGluIGNpcmNsZUJvZHkucG9zaXRpb24uIFdpbGwgKm5vdCogYmUgcm90YXRlZCBieSBjaXJjbGVCb2R5LmFuZ2xlIChtYXliZSBpdCBzaG91bGQsIGZvciBzYWtlIG9mIGhvbW9nZW5pdHk/KS4gU2V0IHRvIG51bGwgaWYgbm9uZS5cbiAqIEBwYXJhbSAge0JvZHl9ICAgIGJqICAgICBUaGUgc2Vjb25kIGJvZHkgdGhhdCBzaG91bGQgYmUgY29ubmVjdGVkIHRvIHRoZSBlcXVhdGlvbnMuXG4gKiBAcGFyYW0gIHtQbGFuZX0gICBzaiAgICAgVGhlIFBsYW5lIHNoYXBlIHRoYXQgaXMgcGFydGljaXBhdGluZ1xuICogQHBhcmFtICB7QXJyYXl9ICAgeGogICAgIEV4dHJhIG9mZnNldCBmb3IgdGhlIHBsYW5lIHNoYXBlLlxuICogQHBhcmFtICB7TnVtYmVyfSAgYWogICAgIEV4dHJhIGFuZ2xlIHRvIGFwcGx5IHRvIHRoZSBwbGFuZVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuUExBTkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVQbGFuZSA9IGZ1bmN0aW9uKCAgIGJpLHNpLHhpLGFpLCBiaixzaix4aixhaiwganVzdFRlc3QgKXtcbiAgICB2YXIgY2lyY2xlQm9keSA9IGJpLFxuICAgICAgICBjaXJjbGVTaGFwZSA9IHNpLFxuICAgICAgICBjaXJjbGVPZmZzZXQgPSB4aSwgLy8gT2Zmc2V0IGZyb20gYm9keSBjZW50ZXIsIHJvdGF0ZWQhXG4gICAgICAgIHBsYW5lQm9keSA9IGJqLFxuICAgICAgICBzaGFwZUIgPSBzaixcbiAgICAgICAgcGxhbmVPZmZzZXQgPSB4aixcbiAgICAgICAgcGxhbmVBbmdsZSA9IGFqO1xuXG4gICAgcGxhbmVBbmdsZSA9IHBsYW5lQW5nbGUgfHwgMDtcblxuICAgIC8vIFZlY3RvciBmcm9tIHBsYW5lIHRvIGNpcmNsZVxuICAgIHZhciBwbGFuZVRvQ2lyY2xlID0gdG1wMSxcbiAgICAgICAgd29ybGROb3JtYWwgPSB0bXAyLFxuICAgICAgICB0ZW1wID0gdG1wMztcblxuICAgIHN1YihwbGFuZVRvQ2lyY2xlLCBjaXJjbGVPZmZzZXQsIHBsYW5lT2Zmc2V0KTtcblxuICAgIC8vIFdvcmxkIHBsYW5lIG5vcm1hbFxuICAgIHZlYzIucm90YXRlKHdvcmxkTm9ybWFsLCB5QXhpcywgcGxhbmVBbmdsZSk7XG5cbiAgICAvLyBOb3JtYWwgZGlyZWN0aW9uIGRpc3RhbmNlXG4gICAgdmFyIGQgPSBkb3Qod29ybGROb3JtYWwsIHBsYW5lVG9DaXJjbGUpO1xuXG4gICAgaWYoZCA+IGNpcmNsZVNoYXBlLnJhZGl1cyl7XG4gICAgICAgIHJldHVybiAwOyAvLyBObyBvdmVybGFwLiBBYm9ydC5cbiAgICB9XG5cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBjb250YWN0XG4gICAgdmFyIGNvbnRhY3QgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksY2lyY2xlQm9keSxzaixzaSk7XG5cbiAgICAvLyBuaSBpcyB0aGUgcGxhbmUgd29ybGQgbm9ybWFsXG4gICAgdmVjMi5jb3B5KGNvbnRhY3Qubm9ybWFsQSwgd29ybGROb3JtYWwpO1xuXG4gICAgLy8gcmogaXMgdGhlIHZlY3RvciBmcm9tIGNpcmNsZSBjZW50ZXIgdG8gdGhlIGNvbnRhY3QgcG9pbnRcbiAgICB2ZWMyLnNjYWxlKGNvbnRhY3QuY29udGFjdFBvaW50QiwgY29udGFjdC5ub3JtYWxBLCAtY2lyY2xlU2hhcGUucmFkaXVzKTtcbiAgICBhZGQoY29udGFjdC5jb250YWN0UG9pbnRCLCBjb250YWN0LmNvbnRhY3RQb2ludEIsIGNpcmNsZU9mZnNldCk7XG4gICAgc3ViKGNvbnRhY3QuY29udGFjdFBvaW50QiwgY29udGFjdC5jb250YWN0UG9pbnRCLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgIC8vIHJpIGlzIHRoZSBkaXN0YW5jZSBmcm9tIHBsYW5lIGNlbnRlciB0byBjb250YWN0LlxuICAgIHZlYzIuc2NhbGUodGVtcCwgY29udGFjdC5ub3JtYWxBLCBkKTtcbiAgICBzdWIoY29udGFjdC5jb250YWN0UG9pbnRBLCBwbGFuZVRvQ2lyY2xlLCB0ZW1wICk7IC8vIFN1YnRyYWN0IG5vcm1hbCBkaXN0YW5jZSB2ZWN0b3IgZnJvbSB0aGUgZGlzdGFuY2UgdmVjdG9yXG4gICAgYWRkKGNvbnRhY3QuY29udGFjdFBvaW50QSwgY29udGFjdC5jb250YWN0UG9pbnRBLCBwbGFuZU9mZnNldCk7XG4gICAgc3ViKGNvbnRhY3QuY29udGFjdFBvaW50QSwgY29udGFjdC5jb250YWN0UG9pbnRBLCBwbGFuZUJvZHkucG9zaXRpb24pO1xuXG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goY29udGFjdCk7XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKCB0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoY29udGFjdCkgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbn07XG5cbi8qKlxuICogQ29udmV4L2NvbnZleCBOYXJyb3dwaGFzZS5TZWUgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWx0ZGV2YmxvZ2FkYXkuY29tLzIwMTEvMDUvMTMvY29udGFjdC1nZW5lcmF0aW9uLWJldHdlZW4tM2QtY29udmV4LW1lc2hlcy9cIj50aGlzIGFydGljbGU8L2E+IGZvciBtb3JlIGluZm8uXG4gKiBAbWV0aG9kIGNvbnZleENvbnZleFxuICogQHBhcmFtICB7Qm9keX0gYmlcbiAqIEBwYXJhbSAge0NvbnZleH0gc2lcbiAqIEBwYXJhbSAge0FycmF5fSB4aVxuICogQHBhcmFtICB7TnVtYmVyfSBhaVxuICogQHBhcmFtICB7Qm9keX0gYmpcbiAqIEBwYXJhbSAge0NvbnZleH0gc2pcbiAqIEBwYXJhbSAge0FycmF5fSB4alxuICogQHBhcmFtICB7TnVtYmVyfSBhalxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ09OVkVYXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ09OVkVYIHwgU2hhcGUuUkVDVEFOR0xFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUkVDVEFOR0xFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4Q29udmV4ID0gZnVuY3Rpb24oICBiaSxzaSx4aSxhaSwgYmosc2oseGosYWosIGp1c3RUZXN0LCBwcmVjaXNpb24gKXtcbiAgICB2YXIgc2VwQXhpcyA9IHRtcDEsXG4gICAgICAgIHdvcmxkUG9pbnQgPSB0bXAyLFxuICAgICAgICB3b3JsZFBvaW50MCA9IHRtcDMsXG4gICAgICAgIHdvcmxkUG9pbnQxID0gdG1wNCxcbiAgICAgICAgd29ybGRFZGdlID0gdG1wNSxcbiAgICAgICAgcHJvamVjdGVkID0gdG1wNixcbiAgICAgICAgcGVuZXRyYXRpb25WZWMgPSB0bXA3LFxuICAgICAgICBkaXN0ID0gdG1wOCxcbiAgICAgICAgd29ybGROb3JtYWwgPSB0bXA5LFxuICAgICAgICBudW1Db250YWN0cyA9IDAsXG4gICAgICAgIHByZWNpc2lvbiA9IHR5cGVvZihwcmVjaXNpb24pID09PSAnbnVtYmVyJyA/IHByZWNpc2lvbiA6IDA7XG5cbiAgICB2YXIgZm91bmQgPSBOYXJyb3dwaGFzZS5maW5kU2VwYXJhdGluZ0F4aXMoc2kseGksYWksc2oseGosYWosc2VwQXhpcyk7XG4gICAgaWYoIWZvdW5kKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBzZXBhcmF0aW5nIGF4aXMgaXMgZGlyZWN0ZWQgZnJvbSBzaGFwZSBpIHRvIHNoYXBlIGpcbiAgICBzdWIoZGlzdCx4aix4aSk7XG4gICAgaWYoZG90KHNlcEF4aXMsZGlzdCkgPiAwKXtcbiAgICAgICAgdmVjMi5zY2FsZShzZXBBeGlzLHNlcEF4aXMsLTEpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgZWRnZXMgd2l0aCBub3JtYWxzIGNsb3Nlc3QgdG8gdGhlIHNlcGFyYXRpbmcgYXhpc1xuICAgIHZhciBjbG9zZXN0RWRnZTEgPSBOYXJyb3dwaGFzZS5nZXRDbG9zZXN0RWRnZShzaSxhaSxzZXBBeGlzLHRydWUpLCAvLyBGbGlwcGVkIGF4aXNcbiAgICAgICAgY2xvc2VzdEVkZ2UyID0gTmFycm93cGhhc2UuZ2V0Q2xvc2VzdEVkZ2Uoc2osYWosc2VwQXhpcyk7XG5cbiAgICBpZihjbG9zZXN0RWRnZTEgPT09IC0xIHx8IGNsb3Nlc3RFZGdlMiA9PT0gLTEpe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBMb29wIG92ZXIgdGhlIHNoYXBlc1xuICAgIGZvcih2YXIgaz0wOyBrPDI7IGsrKyl7XG5cbiAgICAgICAgdmFyIGNsb3Nlc3RFZGdlQSA9IGNsb3Nlc3RFZGdlMSxcbiAgICAgICAgICAgIGNsb3Nlc3RFZGdlQiA9IGNsb3Nlc3RFZGdlMixcbiAgICAgICAgICAgIHNoYXBlQSA9ICBzaSwgc2hhcGVCID0gIHNqLFxuICAgICAgICAgICAgb2Zmc2V0QSA9IHhpLCBvZmZzZXRCID0geGosXG4gICAgICAgICAgICBhbmdsZUEgPSBhaSwgYW5nbGVCID0gYWosXG4gICAgICAgICAgICBib2R5QSA9IGJpLCBib2R5QiA9IGJqO1xuXG4gICAgICAgIGlmKGsgPT09IDApe1xuICAgICAgICAgICAgLy8gU3dhcCFcbiAgICAgICAgICAgIHZhciB0bXA7XG4gICAgICAgICAgICB0bXAgPSBjbG9zZXN0RWRnZUE7XG4gICAgICAgICAgICBjbG9zZXN0RWRnZUEgPSBjbG9zZXN0RWRnZUI7XG4gICAgICAgICAgICBjbG9zZXN0RWRnZUIgPSB0bXA7XG5cbiAgICAgICAgICAgIHRtcCA9IHNoYXBlQTtcbiAgICAgICAgICAgIHNoYXBlQSA9IHNoYXBlQjtcbiAgICAgICAgICAgIHNoYXBlQiA9IHRtcDtcblxuICAgICAgICAgICAgdG1wID0gb2Zmc2V0QTtcbiAgICAgICAgICAgIG9mZnNldEEgPSBvZmZzZXRCO1xuICAgICAgICAgICAgb2Zmc2V0QiA9IHRtcDtcblxuICAgICAgICAgICAgdG1wID0gYW5nbGVBO1xuICAgICAgICAgICAgYW5nbGVBID0gYW5nbGVCO1xuICAgICAgICAgICAgYW5nbGVCID0gdG1wO1xuXG4gICAgICAgICAgICB0bXAgPSBib2R5QTtcbiAgICAgICAgICAgIGJvZHlBID0gYm9keUI7XG4gICAgICAgICAgICBib2R5QiA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvb3Agb3ZlciAyIHBvaW50cyBpbiBjb252ZXggQlxuICAgICAgICBmb3IodmFyIGo9Y2xvc2VzdEVkZ2VCOyBqPGNsb3Nlc3RFZGdlQisyOyBqKyspe1xuXG4gICAgICAgICAgICAvLyBHZXQgd29ybGQgcG9pbnRcbiAgICAgICAgICAgIHZhciB2ID0gc2hhcGVCLnZlcnRpY2VzWyhqK3NoYXBlQi52ZXJ0aWNlcy5sZW5ndGgpJXNoYXBlQi52ZXJ0aWNlcy5sZW5ndGhdO1xuICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb2ludCwgdiwgYW5nbGVCKTtcbiAgICAgICAgICAgIGFkZCh3b3JsZFBvaW50LCB3b3JsZFBvaW50LCBvZmZzZXRCKTtcblxuICAgICAgICAgICAgdmFyIGluc2lkZU51bUVkZ2VzID0gMDtcblxuICAgICAgICAgICAgLy8gTG9vcCBvdmVyIHRoZSAzIGNsb3Nlc3QgZWRnZXMgaW4gY29udmV4IEFcbiAgICAgICAgICAgIGZvcih2YXIgaT1jbG9zZXN0RWRnZUEtMTsgaTxjbG9zZXN0RWRnZUErMjsgaSsrKXtcblxuICAgICAgICAgICAgICAgIHZhciB2MCA9IHNoYXBlQS52ZXJ0aWNlc1soaSAgK3NoYXBlQS52ZXJ0aWNlcy5sZW5ndGgpJXNoYXBlQS52ZXJ0aWNlcy5sZW5ndGhdLFxuICAgICAgICAgICAgICAgICAgICB2MSA9IHNoYXBlQS52ZXJ0aWNlc1soaSsxK3NoYXBlQS52ZXJ0aWNlcy5sZW5ndGgpJXNoYXBlQS52ZXJ0aWNlcy5sZW5ndGhdO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBlZGdlXG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb2ludDAsIHYwLCBhbmdsZUEpO1xuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9pbnQxLCB2MSwgYW5nbGVBKTtcbiAgICAgICAgICAgICAgICBhZGQod29ybGRQb2ludDAsIHdvcmxkUG9pbnQwLCBvZmZzZXRBKTtcbiAgICAgICAgICAgICAgICBhZGQod29ybGRQb2ludDEsIHdvcmxkUG9pbnQxLCBvZmZzZXRBKTtcblxuICAgICAgICAgICAgICAgIHN1Yih3b3JsZEVkZ2UsIHdvcmxkUG9pbnQxLCB3b3JsZFBvaW50MCk7XG5cbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZTkwY3cod29ybGROb3JtYWwsIHdvcmxkRWRnZSk7IC8vIE5vcm1hbCBwb2ludHMgb3V0IG9mIGNvbnZleCAxXG4gICAgICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUod29ybGROb3JtYWwsd29ybGROb3JtYWwpO1xuXG4gICAgICAgICAgICAgICAgc3ViKGRpc3QsIHdvcmxkUG9pbnQsIHdvcmxkUG9pbnQwKTtcblxuICAgICAgICAgICAgICAgIHZhciBkID0gZG90KHdvcmxkTm9ybWFsLGRpc3QpO1xuXG4gICAgICAgICAgICAgICAgaWYoKGkgPT09IGNsb3Nlc3RFZGdlQSAmJiBkIDw9IHByZWNpc2lvbikgfHwgKGkgIT09IGNsb3Nlc3RFZGdlQSAmJiBkIDw9IDApKXtcbiAgICAgICAgICAgICAgICAgICAgaW5zaWRlTnVtRWRnZXMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGluc2lkZU51bUVkZ2VzID49IDMpe1xuXG4gICAgICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB3b3JsZFBvaW50IHdhcyBvbiB0aGUgXCJpbnNpZGVcIiBzaWRlIG9mIGVhY2ggb2YgdGhlIDMgY2hlY2tlZCBlZGdlcy5cbiAgICAgICAgICAgICAgICAvLyBQcm9qZWN0IGl0IHRvIHRoZSBjZW50ZXIgZWRnZSBhbmQgdXNlIHRoZSBwcm9qZWN0aW9uIGRpcmVjdGlvbiBhcyBub3JtYWxcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBjb250YWN0XG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihib2R5QSxib2R5QixzaGFwZUEsc2hhcGVCKTtcbiAgICAgICAgICAgICAgICBudW1Db250YWN0cysrO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IGNlbnRlciBlZGdlIGZyb20gYm9keSBBXG4gICAgICAgICAgICAgICAgdmFyIHYwID0gc2hhcGVBLnZlcnRpY2VzWyhjbG9zZXN0RWRnZUEpICAgJSBzaGFwZUEudmVydGljZXMubGVuZ3RoXSxcbiAgICAgICAgICAgICAgICAgICAgdjEgPSBzaGFwZUEudmVydGljZXNbKGNsb3Nlc3RFZGdlQSsxKSAlIHNoYXBlQS52ZXJ0aWNlcy5sZW5ndGhdO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBlZGdlXG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb2ludDAsIHYwLCBhbmdsZUEpO1xuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9pbnQxLCB2MSwgYW5nbGVBKTtcbiAgICAgICAgICAgICAgICBhZGQod29ybGRQb2ludDAsIHdvcmxkUG9pbnQwLCBvZmZzZXRBKTtcbiAgICAgICAgICAgICAgICBhZGQod29ybGRQb2ludDEsIHdvcmxkUG9pbnQxLCBvZmZzZXRBKTtcblxuICAgICAgICAgICAgICAgIHN1Yih3b3JsZEVkZ2UsIHdvcmxkUG9pbnQxLCB3b3JsZFBvaW50MCk7XG5cbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZTkwY3coYy5ub3JtYWxBLCB3b3JsZEVkZ2UpOyAvLyBOb3JtYWwgcG9pbnRzIG91dCBvZiBjb252ZXggQVxuICAgICAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgICAgICAgICAgICAgc3ViKGRpc3QsIHdvcmxkUG9pbnQsIHdvcmxkUG9pbnQwKTsgLy8gRnJvbSBlZGdlIHBvaW50IHRvIHRoZSBwZW5ldHJhdGluZyBwb2ludFxuICAgICAgICAgICAgICAgIHZhciBkID0gZG90KGMubm9ybWFsQSxkaXN0KTsgICAgICAgICAgICAgLy8gUGVuZXRyYXRpb25cbiAgICAgICAgICAgICAgICB2ZWMyLnNjYWxlKHBlbmV0cmF0aW9uVmVjLCBjLm5vcm1hbEEsIGQpOyAgICAgLy8gVmVjdG9yIHBlbmV0cmF0aW9uXG5cbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCB3b3JsZFBvaW50LCBvZmZzZXRBKTtcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIHBlbmV0cmF0aW9uVmVjKTtcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIG9mZnNldEEpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgYm9keUEucG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50Qiwgd29ybGRQb2ludCwgb2Zmc2V0Qik7XG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBvZmZzZXRCKTtcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGJvZHlCLnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICAgICAgLy8gVG9kbyByZWR1Y2UgdG8gMSBmcmljdGlvbiBlcXVhdGlvbiBpZiB3ZSBoYXZlIDIgY29udGFjdCBwb2ludHNcbiAgICAgICAgICAgICAgICBpZighdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbiAmJiBudW1Db250YWN0cyl7XG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bUNvbnRhY3RzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVtQ29udGFjdHM7XG59O1xuXG4vLyAucHJvamVjdENvbnZleCBpcyBjYWxsZWQgYnkgb3RoZXIgZnVuY3Rpb25zLCBuZWVkIGxvY2FsIHRtcCB2ZWN0b3JzXG52YXIgcGNvYV90bXAxID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbi8qKlxuICogUHJvamVjdCBhIENvbnZleCBvbnRvIGEgd29ybGQtb3JpZW50ZWQgYXhpc1xuICogQG1ldGhvZCBwcm9qZWN0Q29udmV4T250b0F4aXNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0NvbnZleH0gY29udmV4U2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBjb252ZXhPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gY29udmV4QW5nbGVcbiAqIEBwYXJhbSAge0FycmF5fSB3b3JsZEF4aXNcbiAqIEBwYXJhbSAge0FycmF5fSByZXN1bHRcbiAqL1xuTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzID0gZnVuY3Rpb24oY29udmV4U2hhcGUsIGNvbnZleE9mZnNldCwgY29udmV4QW5nbGUsIHdvcmxkQXhpcywgcmVzdWx0KXtcbiAgICB2YXIgbWF4PW51bGwsXG4gICAgICAgIG1pbj1udWxsLFxuICAgICAgICB2LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbG9jYWxBeGlzID0gcGNvYV90bXAxO1xuXG4gICAgLy8gQ29udmVydCB0aGUgYXhpcyB0byBsb2NhbCBjb29yZHMgb2YgdGhlIGJvZHlcbiAgICB2ZWMyLnJvdGF0ZShsb2NhbEF4aXMsIHdvcmxkQXhpcywgLWNvbnZleEFuZ2xlKTtcblxuICAgIC8vIEdldCBwcm9qZWN0ZWQgcG9zaXRpb24gb2YgYWxsIHZlcnRpY2VzXG4gICAgZm9yKHZhciBpPTA7IGk8Y29udmV4U2hhcGUudmVydGljZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2ID0gY29udmV4U2hhcGUudmVydGljZXNbaV07XG4gICAgICAgIHZhbHVlID0gZG90KHYsbG9jYWxBeGlzKTtcbiAgICAgICAgaWYobWF4ID09PSBudWxsIHx8IHZhbHVlID4gbWF4KXtcbiAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKG1pbiA9PT0gbnVsbCB8fCB2YWx1ZSA8IG1pbil7XG4gICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKG1pbiA+IG1heCl7XG4gICAgICAgIHZhciB0ID0gbWluO1xuICAgICAgICBtaW4gPSBtYXg7XG4gICAgICAgIG1heCA9IHQ7XG4gICAgfVxuXG4gICAgLy8gUHJvamVjdCB0aGUgcG9zaXRpb24gb2YgdGhlIGJvZHkgb250byB0aGUgYXhpcyAtIG5lZWQgdG8gYWRkIHRoaXMgdG8gdGhlIHJlc3VsdFxuICAgIHZhciBvZmZzZXQgPSBkb3QoY29udmV4T2Zmc2V0LCB3b3JsZEF4aXMpO1xuXG4gICAgdmVjMi5zZXQoIHJlc3VsdCwgbWluICsgb2Zmc2V0LCBtYXggKyBvZmZzZXQpO1xufTtcblxuLy8gLmZpbmRTZXBhcmF0aW5nQXhpcyBpcyBjYWxsZWQgYnkgb3RoZXIgZnVuY3Rpb25zLCBuZWVkIGxvY2FsIHRtcCB2ZWN0b3JzXG52YXIgZnNhX3RtcDEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIGZzYV90bXAyID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICBmc2FfdG1wMyA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgZnNhX3RtcDQgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIGZzYV90bXA1ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICBmc2FfdG1wNiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4vKipcbiAqIEZpbmQgYSBzZXBhcmF0aW5nIGF4aXMgYmV0d2VlbiB0aGUgc2hhcGVzLCB0aGF0IG1heGltaXplcyB0aGUgc2VwYXJhdGluZyBkaXN0YW5jZSBiZXR3ZWVuIHRoZW0uXG4gKiBAbWV0aG9kIGZpbmRTZXBhcmF0aW5nQXhpc1xuICogQHN0YXRpY1xuICogQHBhcmFtICB7Q29udmV4fSAgICAgYzFcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIG9mZnNldDFcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGFuZ2xlMVxuICogQHBhcmFtICB7Q29udmV4fSAgICAgYzJcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIG9mZnNldDJcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGFuZ2xlMlxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgc2VwQXhpcyAgICAgVGhlIHJlc3VsdGluZyBheGlzXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgICAgICBXaGV0aGVyIHRoZSBheGlzIGNvdWxkIGJlIGZvdW5kLlxuICovXG5OYXJyb3dwaGFzZS5maW5kU2VwYXJhdGluZ0F4aXMgPSBmdW5jdGlvbihjMSxvZmZzZXQxLGFuZ2xlMSxjMixvZmZzZXQyLGFuZ2xlMixzZXBBeGlzKXtcbiAgICB2YXIgbWF4RGlzdCA9IG51bGwsXG4gICAgICAgIG92ZXJsYXAgPSBmYWxzZSxcbiAgICAgICAgZm91bmQgPSBmYWxzZSxcbiAgICAgICAgZWRnZSA9IGZzYV90bXAxLFxuICAgICAgICB3b3JsZFBvaW50MCA9IGZzYV90bXAyLFxuICAgICAgICB3b3JsZFBvaW50MSA9IGZzYV90bXAzLFxuICAgICAgICBub3JtYWwgPSBmc2FfdG1wNCxcbiAgICAgICAgc3BhbjEgPSBmc2FfdG1wNSxcbiAgICAgICAgc3BhbjIgPSBmc2FfdG1wNjtcblxuICAgIGlmKGMxIGluc3RhbmNlb2YgUmVjdGFuZ2xlICYmIGMyIGluc3RhbmNlb2YgUmVjdGFuZ2xlKXtcblxuICAgICAgICBmb3IodmFyIGo9MDsgaiE9PTI7IGorKyl7XG4gICAgICAgICAgICB2YXIgYyA9IGMxLFxuICAgICAgICAgICAgICAgIGFuZ2xlID0gYW5nbGUxO1xuICAgICAgICAgICAgaWYoaj09PTEpe1xuICAgICAgICAgICAgICAgIGMgPSBjMjtcbiAgICAgICAgICAgICAgICBhbmdsZSA9IGFuZ2xlMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGkhPT0yOyBpKyspe1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB3b3JsZCBlZGdlXG4gICAgICAgICAgICAgICAgaWYoaSA9PT0gMCl7XG4gICAgICAgICAgICAgICAgICAgIHZlYzIuc2V0KG5vcm1hbCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKGkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5zZXQobm9ybWFsLCAxLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoYW5nbGUgIT09IDApe1xuICAgICAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZShub3JtYWwsIG5vcm1hbCwgYW5nbGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFByb2plY3QgaHVsbHMgb250byB0aGF0IG5vcm1hbFxuICAgICAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb2plY3RDb252ZXhPbnRvQXhpcyhjMSxvZmZzZXQxLGFuZ2xlMSxub3JtYWwsc3BhbjEpO1xuICAgICAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb2plY3RDb252ZXhPbnRvQXhpcyhjMixvZmZzZXQyLGFuZ2xlMixub3JtYWwsc3BhbjIpO1xuXG4gICAgICAgICAgICAgICAgLy8gT3JkZXIgYnkgc3BhbiBwb3NpdGlvblxuICAgICAgICAgICAgICAgIHZhciBhPXNwYW4xLFxuICAgICAgICAgICAgICAgICAgICBiPXNwYW4yLFxuICAgICAgICAgICAgICAgICAgICBzd2FwcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYoc3BhbjFbMF0gPiBzcGFuMlswXSl7XG4gICAgICAgICAgICAgICAgICAgIGI9c3BhbjE7XG4gICAgICAgICAgICAgICAgICAgIGE9c3BhbjI7XG4gICAgICAgICAgICAgICAgICAgIHN3YXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEdldCBzZXBhcmF0aW5nIGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBiWzBdIC0gYVsxXTtcbiAgICAgICAgICAgICAgICBvdmVybGFwID0gKGRpc3QgPD0gMCk7XG5cbiAgICAgICAgICAgICAgICBpZihtYXhEaXN0PT09bnVsbCB8fCBkaXN0ID4gbWF4RGlzdCl7XG4gICAgICAgICAgICAgICAgICAgIHZlYzIuY29weShzZXBBeGlzLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICBtYXhEaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBmb3IodmFyIGo9MDsgaiE9PTI7IGorKyl7XG4gICAgICAgICAgICB2YXIgYyA9IGMxLFxuICAgICAgICAgICAgICAgIGFuZ2xlID0gYW5nbGUxO1xuICAgICAgICAgICAgaWYoaj09PTEpe1xuICAgICAgICAgICAgICAgIGMgPSBjMjtcbiAgICAgICAgICAgICAgICBhbmdsZSA9IGFuZ2xlMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1jLnZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHdvcmxkIGVkZ2VcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50MCwgYy52ZXJ0aWNlc1tpXSwgYW5nbGUpO1xuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9pbnQxLCBjLnZlcnRpY2VzWyhpKzEpJWMudmVydGljZXMubGVuZ3RoXSwgYW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgc3ViKGVkZ2UsIHdvcmxkUG9pbnQxLCB3b3JsZFBvaW50MCk7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgbm9ybWFsIC0ganVzdCByb3RhdGUgOTAgZGVncmVlcyBzaW5jZSB2ZXJ0aWNlcyBhcmUgZ2l2ZW4gaW4gQ0NXXG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGU5MGN3KG5vcm1hbCwgZWRnZSk7XG4gICAgICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLG5vcm1hbCk7XG5cbiAgICAgICAgICAgICAgICAvLyBQcm9qZWN0IGh1bGxzIG9udG8gdGhhdCBub3JtYWxcbiAgICAgICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm9qZWN0Q29udmV4T250b0F4aXMoYzEsb2Zmc2V0MSxhbmdsZTEsbm9ybWFsLHNwYW4xKTtcbiAgICAgICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm9qZWN0Q29udmV4T250b0F4aXMoYzIsb2Zmc2V0MixhbmdsZTIsbm9ybWFsLHNwYW4yKTtcblxuICAgICAgICAgICAgICAgIC8vIE9yZGVyIGJ5IHNwYW4gcG9zaXRpb25cbiAgICAgICAgICAgICAgICB2YXIgYT1zcGFuMSxcbiAgICAgICAgICAgICAgICAgICAgYj1zcGFuMixcbiAgICAgICAgICAgICAgICAgICAgc3dhcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmKHNwYW4xWzBdID4gc3BhbjJbMF0pe1xuICAgICAgICAgICAgICAgICAgICBiPXNwYW4xO1xuICAgICAgICAgICAgICAgICAgICBhPXNwYW4yO1xuICAgICAgICAgICAgICAgICAgICBzd2FwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgc2VwYXJhdGluZyBkaXN0YW5jZVxuICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gYlswXSAtIGFbMV07XG4gICAgICAgICAgICAgICAgb3ZlcmxhcCA9IChkaXN0IDw9IDApO1xuXG4gICAgICAgICAgICAgICAgaWYobWF4RGlzdD09PW51bGwgfHwgZGlzdCA+IG1heERpc3Qpe1xuICAgICAgICAgICAgICAgICAgICB2ZWMyLmNvcHkoc2VwQXhpcywgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgbWF4RGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qXG4gICAgLy8gTmVlZHMgdG8gYmUgdGVzdGVkIHNvbWUgbW9yZVxuICAgIGZvcih2YXIgaj0wOyBqIT09MjsgaisrKXtcbiAgICAgICAgdmFyIGMgPSBjMSxcbiAgICAgICAgICAgIGFuZ2xlID0gYW5nbGUxO1xuICAgICAgICBpZihqPT09MSl7XG4gICAgICAgICAgICBjID0gYzI7XG4gICAgICAgICAgICBhbmdsZSA9IGFuZ2xlMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09Yy5heGVzLmxlbmd0aDsgaSsrKXtcblxuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IGMuYXhlc1tpXTtcblxuICAgICAgICAgICAgLy8gUHJvamVjdCBodWxscyBvbnRvIHRoYXQgbm9ybWFsXG4gICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm9qZWN0Q29udmV4T250b0F4aXMoYzEsIG9mZnNldDEsIGFuZ2xlMSwgbm9ybWFsLCBzcGFuMSk7XG4gICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm9qZWN0Q29udmV4T250b0F4aXMoYzIsIG9mZnNldDIsIGFuZ2xlMiwgbm9ybWFsLCBzcGFuMik7XG5cbiAgICAgICAgICAgIC8vIE9yZGVyIGJ5IHNwYW4gcG9zaXRpb25cbiAgICAgICAgICAgIHZhciBhPXNwYW4xLFxuICAgICAgICAgICAgICAgIGI9c3BhbjIsXG4gICAgICAgICAgICAgICAgc3dhcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYoc3BhbjFbMF0gPiBzcGFuMlswXSl7XG4gICAgICAgICAgICAgICAgYj1zcGFuMTtcbiAgICAgICAgICAgICAgICBhPXNwYW4yO1xuICAgICAgICAgICAgICAgIHN3YXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgc2VwYXJhdGluZyBkaXN0YW5jZVxuICAgICAgICAgICAgdmFyIGRpc3QgPSBiWzBdIC0gYVsxXTtcbiAgICAgICAgICAgIG92ZXJsYXAgPSAoZGlzdCA8PSBOYXJyb3dwaGFzZS5jb252ZXhQcmVjaXNpb24pO1xuXG4gICAgICAgICAgICBpZihtYXhEaXN0PT09bnVsbCB8fCBkaXN0ID4gbWF4RGlzdCl7XG4gICAgICAgICAgICAgICAgdmVjMi5jb3B5KHNlcEF4aXMsIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgbWF4RGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBvdmVybGFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICovXG5cbiAgICByZXR1cm4gZm91bmQ7XG59O1xuXG4vLyAuZ2V0Q2xvc2VzdEVkZ2UgaXMgY2FsbGVkIGJ5IG90aGVyIGZ1bmN0aW9ucywgbmVlZCBsb2NhbCB0bXAgdmVjdG9yc1xudmFyIGdjZV90bXAxID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICBnY2VfdG1wMiA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgZ2NlX3RtcDMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuLyoqXG4gKiBHZXQgdGhlIGVkZ2UgdGhhdCBoYXMgYSBub3JtYWwgY2xvc2VzdCB0byBhbiBheGlzLlxuICogQG1ldGhvZCBnZXRDbG9zZXN0RWRnZVxuICogQHN0YXRpY1xuICogQHBhcmFtICB7Q29udmV4fSAgICAgY1xuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYW5nbGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGF4aXNcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgIGZsaXBcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgSW5kZXggb2YgdGhlIGVkZ2UgdGhhdCBpcyBjbG9zZXN0LiBUaGlzIGluZGV4IGFuZCB0aGUgbmV4dCBzcGFucyB0aGUgcmVzdWx0aW5nIGVkZ2UuIFJldHVybnMgLTEgaWYgZmFpbGVkLlxuICovXG5OYXJyb3dwaGFzZS5nZXRDbG9zZXN0RWRnZSA9IGZ1bmN0aW9uKGMsYW5nbGUsYXhpcyxmbGlwKXtcbiAgICB2YXIgbG9jYWxBeGlzID0gZ2NlX3RtcDEsXG4gICAgICAgIGVkZ2UgPSBnY2VfdG1wMixcbiAgICAgICAgbm9ybWFsID0gZ2NlX3RtcDM7XG5cbiAgICAvLyBDb252ZXJ0IHRoZSBheGlzIHRvIGxvY2FsIGNvb3JkcyBvZiB0aGUgYm9keVxuICAgIHZlYzIucm90YXRlKGxvY2FsQXhpcywgYXhpcywgLWFuZ2xlKTtcbiAgICBpZihmbGlwKXtcbiAgICAgICAgdmVjMi5zY2FsZShsb2NhbEF4aXMsbG9jYWxBeGlzLC0xKTtcbiAgICB9XG5cbiAgICB2YXIgY2xvc2VzdEVkZ2UgPSAtMSxcbiAgICAgICAgTiA9IGMudmVydGljZXMubGVuZ3RoLFxuICAgICAgICBtYXhEb3QgPSAtMTtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIC8vIEdldCB0aGUgZWRnZVxuICAgICAgICBzdWIoZWRnZSwgYy52ZXJ0aWNlc1soaSsxKSVOXSwgYy52ZXJ0aWNlc1tpJU5dKTtcblxuICAgICAgICAvLyBHZXQgbm9ybWFsIC0ganVzdCByb3RhdGUgOTAgZGVncmVlcyBzaW5jZSB2ZXJ0aWNlcyBhcmUgZ2l2ZW4gaW4gQ0NXXG4gICAgICAgIHZlYzIucm90YXRlOTBjdyhub3JtYWwsIGVkZ2UpO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShub3JtYWwsbm9ybWFsKTtcblxuICAgICAgICB2YXIgZCA9IGRvdChub3JtYWwsbG9jYWxBeGlzKTtcbiAgICAgICAgaWYoY2xvc2VzdEVkZ2UgPT09IC0xIHx8IGQgPiBtYXhEb3Qpe1xuICAgICAgICAgICAgY2xvc2VzdEVkZ2UgPSBpICUgTjtcbiAgICAgICAgICAgIG1heERvdCA9IGQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xvc2VzdEVkZ2U7XG59O1xuXG52YXIgY2lyY2xlSGVpZ2h0ZmllbGRfY2FuZGlkYXRlID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjaXJjbGVIZWlnaHRmaWVsZF9kaXN0ID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjaXJjbGVIZWlnaHRmaWVsZF92MCA9IHZlYzIuY3JlYXRlKCksXG4gICAgY2lyY2xlSGVpZ2h0ZmllbGRfdjEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNpcmNsZUhlaWdodGZpZWxkX21pbkNhbmRpZGF0ZSA9IHZlYzIuY3JlYXRlKCksXG4gICAgY2lyY2xlSGVpZ2h0ZmllbGRfd29ybGROb3JtYWwgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNpcmNsZUhlaWdodGZpZWxkX21pbkNhbmRpZGF0ZU5vcm1hbCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQG1ldGhvZCBjaXJjbGVIZWlnaHRmaWVsZFxuICogQHBhcmFtICB7Qm9keX0gICAgICAgICAgIGJpXG4gKiBAcGFyYW0gIHtDaXJjbGV9ICAgICAgICAgc2lcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICB4aVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgICAgIGJqXG4gKiBAcGFyYW0gIHtIZWlnaHRmaWVsZH0gICAgc2pcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICB4alxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgIGFqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5IRUlHSFRGSUVMRF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZUhlaWdodGZpZWxkID0gZnVuY3Rpb24oIGNpcmNsZUJvZHksY2lyY2xlU2hhcGUsY2lyY2xlUG9zLGNpcmNsZUFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhmQm9keSxoZlNoYXBlLGhmUG9zLGhmQW5nbGUsIGp1c3RUZXN0LCByYWRpdXMgKXtcbiAgICB2YXIgZGF0YSA9IGhmU2hhcGUuZGF0YSxcbiAgICAgICAgcmFkaXVzID0gcmFkaXVzIHx8IGNpcmNsZVNoYXBlLnJhZGl1cyxcbiAgICAgICAgdyA9IGhmU2hhcGUuZWxlbWVudFdpZHRoLFxuICAgICAgICBkaXN0ID0gY2lyY2xlSGVpZ2h0ZmllbGRfZGlzdCxcbiAgICAgICAgY2FuZGlkYXRlID0gY2lyY2xlSGVpZ2h0ZmllbGRfY2FuZGlkYXRlLFxuICAgICAgICBtaW5DYW5kaWRhdGUgPSBjaXJjbGVIZWlnaHRmaWVsZF9taW5DYW5kaWRhdGUsXG4gICAgICAgIG1pbkNhbmRpZGF0ZU5vcm1hbCA9IGNpcmNsZUhlaWdodGZpZWxkX21pbkNhbmRpZGF0ZU5vcm1hbCxcbiAgICAgICAgd29ybGROb3JtYWwgPSBjaXJjbGVIZWlnaHRmaWVsZF93b3JsZE5vcm1hbCxcbiAgICAgICAgdjAgPSBjaXJjbGVIZWlnaHRmaWVsZF92MCxcbiAgICAgICAgdjEgPSBjaXJjbGVIZWlnaHRmaWVsZF92MTtcblxuICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIHBvaW50cyB0byB0ZXN0IGFnYWluc3RcbiAgICB2YXIgaWR4QSA9IE1hdGguZmxvb3IoIChjaXJjbGVQb3NbMF0gLSByYWRpdXMgLSBoZlBvc1swXSkgLyB3ICksXG4gICAgICAgIGlkeEIgPSBNYXRoLmNlaWwoICAoY2lyY2xlUG9zWzBdICsgcmFkaXVzIC0gaGZQb3NbMF0pIC8gdyApO1xuXG4gICAgLyppZihpZHhCIDwgMCB8fCBpZHhBID49IGRhdGEubGVuZ3RoKVxuICAgICAgICByZXR1cm4ganVzdFRlc3QgPyBmYWxzZSA6IDA7Ki9cblxuICAgIGlmKGlkeEEgPCAwKXtcbiAgICAgICAgaWR4QSA9IDA7XG4gICAgfVxuICAgIGlmKGlkeEIgPj0gZGF0YS5sZW5ndGgpe1xuICAgICAgICBpZHhCID0gZGF0YS5sZW5ndGgtMTtcbiAgICB9XG5cbiAgICAvLyBHZXQgbWF4IGFuZCBtaW5cbiAgICB2YXIgbWF4ID0gZGF0YVtpZHhBXSxcbiAgICAgICAgbWluID0gZGF0YVtpZHhCXTtcbiAgICBmb3IodmFyIGk9aWR4QTsgaTxpZHhCOyBpKyspe1xuICAgICAgICBpZihkYXRhW2ldIDwgbWluKXtcbiAgICAgICAgICAgIG1pbiA9IGRhdGFbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYoZGF0YVtpXSA+IG1heCl7XG4gICAgICAgICAgICBtYXggPSBkYXRhW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoY2lyY2xlUG9zWzFdLXJhZGl1cyA+IG1heCl7XG4gICAgICAgIHJldHVybiBqdXN0VGVzdCA/IGZhbHNlIDogMDtcbiAgICB9XG5cbiAgICAvKlxuICAgIGlmKGNpcmNsZVBvc1sxXStyYWRpdXMgPCBtaW4pe1xuICAgICAgICAvLyBCZWxvdyB0aGUgbWluaW11bSBwb2ludC4uLiBXZSBjYW4ganVzdCBndWVzcy5cbiAgICAgICAgLy8gVE9ET1xuICAgIH1cbiAgICAqL1xuXG4gICAgLy8gMS4gQ2hlY2sgc28gY2VudGVyIG9mIGNpcmNsZSBpcyBub3QgaW5zaWRlIHRoZSBmaWVsZC4gSWYgaXQgaXMsIHRoaXMgd29udCB3b3JrLi4uXG4gICAgLy8gMi4gRm9yIGVhY2ggZWRnZVxuICAgIC8vIDIuIDEuIEdldCBwb2ludCBvbiBjaXJjbGUgdGhhdCBpcyBjbG9zZXN0IHRvIHRoZSBlZGdlIChzY2FsZSBub3JtYWwgd2l0aCAtcmFkaXVzKVxuICAgIC8vIDIuIDIuIENoZWNrIGlmIHBvaW50IGlzIGluc2lkZS5cblxuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgYWxsIGVkZ2VzIGZpcnN0XG4gICAgZm9yKHZhciBpPWlkeEE7IGk8aWR4QjsgaSsrKXtcblxuICAgICAgICAvLyBHZXQgcG9pbnRzXG4gICAgICAgIHZlYzIuc2V0KHYwLCAgICAgaSp3LCBkYXRhW2ldICApO1xuICAgICAgICB2ZWMyLnNldCh2MSwgKGkrMSkqdywgZGF0YVtpKzFdKTtcbiAgICAgICAgdmVjMi5hZGQodjAsdjAsaGZQb3MpO1xuICAgICAgICB2ZWMyLmFkZCh2MSx2MSxoZlBvcyk7XG5cbiAgICAgICAgLy8gR2V0IG5vcm1hbFxuICAgICAgICB2ZWMyLnN1Yih3b3JsZE5vcm1hbCwgdjEsIHYwKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGROb3JtYWwsIHdvcmxkTm9ybWFsLCBNYXRoLlBJLzIpO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZSh3b3JsZE5vcm1hbCx3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgLy8gR2V0IHBvaW50IG9uIGNpcmNsZSwgY2xvc2VzdCB0byB0aGUgZWRnZVxuICAgICAgICB2ZWMyLnNjYWxlKGNhbmRpZGF0ZSx3b3JsZE5vcm1hbCwtcmFkaXVzKTtcbiAgICAgICAgdmVjMi5hZGQoY2FuZGlkYXRlLGNhbmRpZGF0ZSxjaXJjbGVQb3MpO1xuXG4gICAgICAgIC8vIERpc3RhbmNlIGZyb20gdjAgdG8gdGhlIGNhbmRpZGF0ZSBwb2ludFxuICAgICAgICB2ZWMyLnN1YihkaXN0LGNhbmRpZGF0ZSx2MCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQgaXMgaW4gdGhlIGVsZW1lbnQgXCJzdGlja1wiXG4gICAgICAgIHZhciBkID0gdmVjMi5kb3QoZGlzdCx3b3JsZE5vcm1hbCk7XG4gICAgICAgIGlmKGNhbmRpZGF0ZVswXSA+PSB2MFswXSAmJiBjYW5kaWRhdGVbMF0gPCB2MVswXSAmJiBkIDw9IDApe1xuXG4gICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGNhbmRpZGF0ZSBwb2ludCwgcHJvamVjdGVkIHRvIHRoZSBlZGdlXG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGRpc3Qsd29ybGROb3JtYWwsLWQpO1xuICAgICAgICAgICAgdmVjMi5hZGQobWluQ2FuZGlkYXRlLGNhbmRpZGF0ZSxkaXN0KTtcbiAgICAgICAgICAgIHZlYzIuY29weShtaW5DYW5kaWRhdGVOb3JtYWwsd29ybGROb3JtYWwpO1xuXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGhmQm9keSxjaXJjbGVCb2R5LGhmU2hhcGUsY2lyY2xlU2hhcGUpO1xuXG4gICAgICAgICAgICAvLyBOb3JtYWwgaXMgb3V0IG9mIHRoZSBoZWlnaHRmaWVsZFxuICAgICAgICAgICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgbWluQ2FuZGlkYXRlTm9ybWFsKTtcblxuICAgICAgICAgICAgLy8gVmVjdG9yIGZyb20gY2lyY2xlIHRvIGhlaWdodGZpZWxkXG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGMuY29udGFjdFBvaW50QiwgIGMubm9ybWFsQSwgLXJhZGl1cyk7XG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNpcmNsZVBvcyk7XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICB2ZWMyLmNvcHkoYy5jb250YWN0UG9pbnRBLCBtaW5DYW5kaWRhdGUpO1xuICAgICAgICAgICAgdmVjMi5zdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGhmQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2goIHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgYWxsIHZlcnRpY2VzXG4gICAgZm91bmQgPSBmYWxzZTtcbiAgICBpZihyYWRpdXMgPiAwKXtcbiAgICAgICAgZm9yKHZhciBpPWlkeEE7IGk8PWlkeEI7IGkrKyl7XG5cbiAgICAgICAgICAgIC8vIEdldCBwb2ludFxuICAgICAgICAgICAgdmVjMi5zZXQodjAsIGkqdywgZGF0YVtpXSk7XG4gICAgICAgICAgICB2ZWMyLmFkZCh2MCx2MCxoZlBvcyk7XG5cbiAgICAgICAgICAgIHZlYzIuc3ViKGRpc3QsIGNpcmNsZVBvcywgdjApO1xuXG4gICAgICAgICAgICBpZih2ZWMyLnNxdWFyZWRMZW5ndGgoZGlzdCkgPCBNYXRoLnBvdyhyYWRpdXMsIDIpKXtcblxuICAgICAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihoZkJvZHksY2lyY2xlQm9keSxoZlNoYXBlLGNpcmNsZVNoYXBlKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCBub3JtYWwgLSBvdXQgb2YgaGVpZ2h0ZmllbGRcbiAgICAgICAgICAgICAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCBkaXN0KTtcbiAgICAgICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsYy5ub3JtYWxBKTtcblxuICAgICAgICAgICAgICAgIHZlYzIuc2NhbGUoYy5jb250YWN0UG9pbnRCLCBjLm5vcm1hbEEsIC1yYWRpdXMpO1xuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY2lyY2xlUG9zKTtcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgdjAsIGhmUG9zKTtcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGhmUG9zKTtcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGhmQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihmb3VuZCl7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuXG59O1xuXG52YXIgY29udmV4SGVpZ2h0ZmllbGRfdjAgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvbnZleEhlaWdodGZpZWxkX3YxID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjb252ZXhIZWlnaHRmaWVsZF90aWxlUG9zID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjb252ZXhIZWlnaHRmaWVsZF90ZW1wQ29udmV4U2hhcGUgPSBuZXcgQ29udmV4KFt2ZWMyLmNyZWF0ZSgpLHZlYzIuY3JlYXRlKCksdmVjMi5jcmVhdGUoKSx2ZWMyLmNyZWF0ZSgpXSk7XG4vKipcbiAqIEBtZXRob2QgY2lyY2xlSGVpZ2h0ZmllbGRcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgICAgICBiaVxuICogQHBhcmFtICB7Q2lyY2xlfSAgICAgICAgIHNpXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgeGlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgICAgICBialxuICogQHBhcmFtICB7SGVpZ2h0ZmllbGR9ICAgIHNqXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICAgICAgeGpcbiAqIEBwYXJhbSAge051bWJlcn0gICAgICAgICBhalxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUkVDVEFOR0xFIHwgU2hhcGUuSEVJR0hURklFTERdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DT05WRVggfCBTaGFwZS5IRUlHSFRGSUVMRF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleEhlaWdodGZpZWxkID0gZnVuY3Rpb24oIGNvbnZleEJvZHksY29udmV4U2hhcGUsY29udmV4UG9zLGNvbnZleEFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhmQm9keSxoZlNoYXBlLGhmUG9zLGhmQW5nbGUsIGp1c3RUZXN0ICl7XG4gICAgdmFyIGRhdGEgPSBoZlNoYXBlLmRhdGEsXG4gICAgICAgIHcgPSBoZlNoYXBlLmVsZW1lbnRXaWR0aCxcbiAgICAgICAgdjAgPSBjb252ZXhIZWlnaHRmaWVsZF92MCxcbiAgICAgICAgdjEgPSBjb252ZXhIZWlnaHRmaWVsZF92MSxcbiAgICAgICAgdGlsZVBvcyA9IGNvbnZleEhlaWdodGZpZWxkX3RpbGVQb3MsXG4gICAgICAgIHRpbGVDb252ZXggPSBjb252ZXhIZWlnaHRmaWVsZF90ZW1wQ29udmV4U2hhcGU7XG5cbiAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XG4gICAgdmFyIGlkeEEgPSBNYXRoLmZsb29yKCAoY29udmV4Qm9keS5hYWJiLmxvd2VyQm91bmRbMF0gLSBoZlBvc1swXSkgLyB3ICksXG4gICAgICAgIGlkeEIgPSBNYXRoLmNlaWwoICAoY29udmV4Qm9keS5hYWJiLnVwcGVyQm91bmRbMF0gLSBoZlBvc1swXSkgLyB3ICk7XG5cbiAgICBpZihpZHhBIDwgMCl7XG4gICAgICAgIGlkeEEgPSAwO1xuICAgIH1cbiAgICBpZihpZHhCID49IGRhdGEubGVuZ3RoKXtcbiAgICAgICAgaWR4QiA9IGRhdGEubGVuZ3RoLTE7XG4gICAgfVxuXG4gICAgLy8gR2V0IG1heCBhbmQgbWluXG4gICAgdmFyIG1heCA9IGRhdGFbaWR4QV0sXG4gICAgICAgIG1pbiA9IGRhdGFbaWR4Ql07XG4gICAgZm9yKHZhciBpPWlkeEE7IGk8aWR4QjsgaSsrKXtcbiAgICAgICAgaWYoZGF0YVtpXSA8IG1pbil7XG4gICAgICAgICAgICBtaW4gPSBkYXRhW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmKGRhdGFbaV0gPiBtYXgpe1xuICAgICAgICAgICAgbWF4ID0gZGF0YVtpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGNvbnZleEJvZHkuYWFiYi5sb3dlckJvdW5kWzFdID4gbWF4KXtcbiAgICAgICAgcmV0dXJuIGp1c3RUZXN0ID8gZmFsc2UgOiAwO1xuICAgIH1cblxuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgIHZhciBudW1Db250YWN0cyA9IDA7XG5cbiAgICAvLyBMb29wIG92ZXIgYWxsIGVkZ2VzXG4gICAgLy8gVE9ETzogSWYgcG9zc2libGUsIGNvbnN0cnVjdCBhIGNvbnZleCBmcm9tIHNldmVyYWwgZGF0YSBwb2ludHMgKG5lZWQgbyBjaGVjayBpZiB0aGUgcG9pbnRzIG1ha2UgYSBjb252ZXggc2hhcGUpXG4gICAgZm9yKHZhciBpPWlkeEE7IGk8aWR4QjsgaSsrKXtcblxuICAgICAgICAvLyBHZXQgcG9pbnRzXG4gICAgICAgIHZlYzIuc2V0KHYwLCAgICAgaSp3LCBkYXRhW2ldICApO1xuICAgICAgICB2ZWMyLnNldCh2MSwgKGkrMSkqdywgZGF0YVtpKzFdKTtcbiAgICAgICAgdmVjMi5hZGQodjAsdjAsaGZQb3MpO1xuICAgICAgICB2ZWMyLmFkZCh2MSx2MSxoZlBvcyk7XG5cbiAgICAgICAgLy8gQ29uc3RydWN0IGEgY29udmV4XG4gICAgICAgIHZhciB0aWxlSGVpZ2h0ID0gMTAwOyAvLyB0b2RvXG4gICAgICAgIHZlYzIuc2V0KHRpbGVQb3MsICh2MVswXSArIHYwWzBdKSowLjUsICh2MVsxXSArIHYwWzFdIC0gdGlsZUhlaWdodCkqMC41KTtcblxuICAgICAgICB2ZWMyLnN1Yih0aWxlQ29udmV4LnZlcnRpY2VzWzBdLCB2MSwgdGlsZVBvcyk7XG4gICAgICAgIHZlYzIuc3ViKHRpbGVDb252ZXgudmVydGljZXNbMV0sIHYwLCB0aWxlUG9zKTtcbiAgICAgICAgdmVjMi5jb3B5KHRpbGVDb252ZXgudmVydGljZXNbMl0sIHRpbGVDb252ZXgudmVydGljZXNbMV0pO1xuICAgICAgICB2ZWMyLmNvcHkodGlsZUNvbnZleC52ZXJ0aWNlc1szXSwgdGlsZUNvbnZleC52ZXJ0aWNlc1swXSk7XG4gICAgICAgIHRpbGVDb252ZXgudmVydGljZXNbMl1bMV0gLT0gdGlsZUhlaWdodDtcbiAgICAgICAgdGlsZUNvbnZleC52ZXJ0aWNlc1szXVsxXSAtPSB0aWxlSGVpZ2h0O1xuXG4gICAgICAgIC8vIERvIGNvbnZleCBjb2xsaXNpb25cbiAgICAgICAgbnVtQ29udGFjdHMgKz0gdGhpcy5jb252ZXhDb252ZXgoICAgY29udmV4Qm9keSwgY29udmV4U2hhcGUsIGNvbnZleFBvcywgY29udmV4QW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhmQm9keSwgdGlsZUNvbnZleCwgdGlsZVBvcywgMCwganVzdFRlc3QpO1xuICAgIH1cblxuICAgIHJldHVybiBudW1Db250YWN0cztcbn07XG59LHtcIi4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb25cIjoyMixcIi4uL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIzLFwiLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb25cIjoyNCxcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vb2JqZWN0cy9Cb2R5XCI6MzIsXCIuLi9zaGFwZXMvQ2lyY2xlXCI6MzgsXCIuLi9zaGFwZXMvQ29udmV4XCI6MzksXCIuLi9zaGFwZXMvUmVjdGFuZ2xlXCI6NDQsXCIuLi9zaGFwZXMvU2hhcGVcIjo0NSxcIi4uL3V0aWxzL1R1cGxlRGljdGlvbmFyeVwiOjQ5LFwiLi4vdXRpbHMvVXRpbHNcIjo1MH1dLDEyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gUmF5O1xuXG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xudmFyIFJheWNhc3RSZXN1bHQgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpO1xudmFyIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyk7XG52YXIgQUFCQiA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9BQUJCJyk7XG5cbi8qKlxuICogQSBsaW5lIHdpdGggYSBzdGFydCBhbmQgZW5kIHBvaW50IHRoYXQgaXMgdXNlZCB0byBpbnRlcnNlY3Qgc2hhcGVzLlxuICogQGNsYXNzIFJheVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJheShvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IGZyb21cbiAgICAgKi9cbiAgICB0aGlzLmZyb20gPSBvcHRpb25zLmZyb20gPyB2ZWMyLmZyb21WYWx1ZXMob3B0aW9ucy5mcm9tWzBdLCBvcHRpb25zLmZyb21bMV0pIDogdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IHRvXG4gICAgICovXG4gICAgdGhpcy50byA9IG9wdGlvbnMudG8gPyB2ZWMyLmZyb21WYWx1ZXMob3B0aW9ucy50b1swXSwgb3B0aW9ucy50b1sxXSkgOiB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBfZGlyZWN0aW9uXG4gICAgICovXG4gICAgdGhpcy5fZGlyZWN0aW9uID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmVjaXNpb24gb2YgdGhlIHJheS4gVXNlZCB3aGVuIGNoZWNraW5nIHBhcmFsbGVsaXR5IGV0Yy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcHJlY2lzaW9uXG4gICAgICovXG4gICAgdGhpcy5wcmVjaXNpb24gPSAwLjAwMDE7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0aGUgUmF5IHRvIHRha2UgLmNvbGxpc2lvblJlc3BvbnNlIGZsYWdzIGludG8gYWNjb3VudCBvbiBib2RpZXMgYW5kIHNoYXBlcy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGNoZWNrQ29sbGlzaW9uUmVzcG9uc2VcbiAgICAgKi9cbiAgICB0aGlzLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSByYXkgc2tpcHMgYW55IGhpdHMgd2l0aCBub3JtYWwuZG90KHJheURpcmVjdGlvbikgPCAwLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2tpcEJhY2tmYWNlc1xuICAgICAqL1xuICAgIHRoaXMuc2tpcEJhY2tmYWNlcyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbGxpc2lvbk1hc2tcbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uTWFzayA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbGxpc2lvbkdyb3VwXG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpc2lvbkdyb3VwID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXJzZWN0aW9uIG1vZGUuIFNob3VsZCBiZSBSYXkuQU5ZLCBSYXkuQUxMIG9yIFJheS5DTE9TRVNULlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb2RlXG4gICAgICovXG4gICAgdGhpcy5tb2RlID0gUmF5LkFOWTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgcmVzdWx0IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxuICAgICAqL1xuICAgIHRoaXMucmVzdWx0ID0gbmV3IFJheWNhc3RSZXN1bHQoKTtcblxuICAgIC8qKlxuICAgICAqIFdpbGwgYmUgc2V0IHRvIHRydWUgZHVyaW5nIGludGVyc2VjdFdvcmxkKCkgaWYgdGhlIHJheSBoaXQgYW55dGhpbmcuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBoYXNIaXRcbiAgICAgKi9cbiAgICB0aGlzLmhhc0hpdCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCwgdXNlci1wcm92aWRlZCByZXN1bHQgY2FsbGJhY2suIFdpbGwgYmUgdXNlZCBpZiBtb2RlIGlzIFJheS5BTEwuXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICB0aGlzLmNhbGxiYWNrID0gZnVuY3Rpb24ocmVzdWx0KXt9O1xufVxuUmF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJheTtcblxuUmF5LkNMT1NFU1QgPSAxO1xuUmF5LkFOWSA9IDI7XG5SYXkuQUxMID0gNDtcblxudmFyIHRtcEFBQkIgPSBuZXcgQUFCQigpO1xudmFyIHRtcEFycmF5ID0gW107XG5cbi8qKlxuICogRG8gaXRlcnNlY3Rpb24gYWdhaW5zdCBhbGwgYm9kaWVzIGluIHRoZSBnaXZlbiBXb3JsZC5cbiAqIEBtZXRob2QgaW50ZXJzZWN0V29ybGRcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSByYXkgaGl0IGFueXRoaW5nLCBvdGhlcndpc2UgZmFsc2UuXG4gKi9cblJheS5wcm90b3R5cGUuaW50ZXJzZWN0V29ybGQgPSBmdW5jdGlvbiAod29ybGQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgUmF5LkFOWTtcbiAgICB0aGlzLnJlc3VsdCA9IG9wdGlvbnMucmVzdWx0IHx8IG5ldyBSYXljYXN0UmVzdWx0KCk7XG4gICAgdGhpcy5za2lwQmFja2ZhY2VzID0gISFvcHRpb25zLnNraXBCYWNrZmFjZXM7XG4gICAgdGhpcy5jb2xsaXNpb25NYXNrID0gdHlwZW9mKG9wdGlvbnMuY29sbGlzaW9uTWFzaykgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5jb2xsaXNpb25NYXNrIDogLTE7XG4gICAgdGhpcy5jb2xsaXNpb25Hcm91cCA9IHR5cGVvZihvcHRpb25zLmNvbGxpc2lvbkdyb3VwKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmNvbGxpc2lvbkdyb3VwIDogLTE7XG4gICAgaWYob3B0aW9ucy5mcm9tKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMuZnJvbSwgb3B0aW9ucy5mcm9tKTtcbiAgICB9XG4gICAgaWYob3B0aW9ucy50byl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLnRvLCBvcHRpb25zLnRvKTtcbiAgICB9XG4gICAgdGhpcy5jYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKXt9O1xuICAgIHRoaXMuaGFzSGl0ID0gZmFsc2U7XG5cbiAgICB0aGlzLnJlc3VsdC5yZXNldCgpO1xuICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigpO1xuXG4gICAgdGhpcy5nZXRBQUJCKHRtcEFBQkIpO1xuICAgIHRtcEFycmF5Lmxlbmd0aCA9IDA7XG4gICAgd29ybGQuYnJvYWRwaGFzZS5hYWJiUXVlcnkod29ybGQsIHRtcEFBQkIsIHRtcEFycmF5KTtcbiAgICB0aGlzLmludGVyc2VjdEJvZGllcyh0bXBBcnJheSk7XG5cbiAgICByZXR1cm4gdGhpcy5oYXNIaXQ7XG59O1xuXG52YXIgdjEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHYyID0gdmVjMi5jcmVhdGUoKTtcblxudmFyIGludGVyc2VjdEJvZHlfd29ybGRQb3NpdGlvbiA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogU2hvb3QgYSByYXkgYXQgYSBib2R5LCBnZXQgYmFjayBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaGl0LlxuICogQG1ldGhvZCBpbnRlcnNlY3RCb2R5XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKiBAcGFyYW0ge1JheWNhc3RSZXN1bHR9IFtyZXN1bHRdIERlcHJlY2F0ZWQgLSBzZXQgdGhlIHJlc3VsdCBwcm9wZXJ0eSBvZiB0aGUgUmF5IGluc3RlYWQuXG4gKi9cblJheS5wcm90b3R5cGUuaW50ZXJzZWN0Qm9keSA9IGZ1bmN0aW9uIChib2R5LCByZXN1bHQpIHtcblxuICAgIGlmKHJlc3VsdCl7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oKTtcbiAgICB9XG4gICAgdmFyIGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgPSB0aGlzLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U7XG5cbiAgICBpZihjaGVja0NvbGxpc2lvblJlc3BvbnNlICYmICFib2R5LmNvbGxpc2lvblJlc3BvbnNlKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmKCh0aGlzLmNvbGxpc2lvbkdyb3VwICYgYm9keS5jb2xsaXNpb25NYXNrKT09PTAgfHwgKGJvZHkuY29sbGlzaW9uR3JvdXAgJiB0aGlzLmNvbGxpc2lvbk1hc2spPT09MCl7XG4gICAgLy8gICAgIHJldHVybjtcbiAgICAvLyB9XG5cbiAgICB2YXIgd29ybGRQb3NpdGlvbiA9IGludGVyc2VjdEJvZHlfd29ybGRQb3NpdGlvbjtcblxuICAgIGZvciAodmFyIGkgPSAwLCBOID0gYm9keS5zaGFwZXMubGVuZ3RoOyBpIDwgTjsgaSsrKSB7XG4gICAgICAgIHZhciBzaGFwZSA9IGJvZHkuc2hhcGVzW2ldO1xuXG4gICAgICAgIGlmKGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgJiYgIXNoYXBlLmNvbGxpc2lvblJlc3BvbnNlKXtcbiAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwXG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgd29ybGQgYW5nbGUgYW5kIHBvc2l0aW9uIG9mIHRoZSBzaGFwZVxuICAgICAgICB2ZWMyLmNvcHkod29ybGRQb3NpdGlvbiwgYm9keS5zaGFwZU9mZnNldHNbaV0pO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvc2l0aW9uLCB3b3JsZFBvc2l0aW9uLCBib2R5LmFuZ2xlKTtcbiAgICAgICAgdmVjMi5hZGQod29ybGRQb3NpdGlvbiwgd29ybGRQb3NpdGlvbiwgYm9keS5wb3NpdGlvbik7XG4gICAgICAgIHZhciB3b3JsZEFuZ2xlID0gYm9keS5zaGFwZUFuZ2xlc1tpXSArIGJvZHkuYW5nbGU7XG5cbiAgICAgICAgdGhpcy5pbnRlcnNlY3RTaGFwZShcbiAgICAgICAgICAgIHNoYXBlLFxuICAgICAgICAgICAgd29ybGRBbmdsZSxcbiAgICAgICAgICAgIHdvcmxkUG9zaXRpb24sXG4gICAgICAgICAgICBib2R5XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYodGhpcy5yZXN1bHQuX3Nob3VsZFN0b3Ape1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEBtZXRob2QgaW50ZXJzZWN0Qm9kaWVzXG4gKiBAcGFyYW0ge0FycmF5fSBib2RpZXMgQW4gYXJyYXkgb2YgQm9keSBvYmplY3RzLlxuICogQHBhcmFtIHtSYXljYXN0UmVzdWx0fSBbcmVzdWx0XSBEZXByZWNhdGVkXG4gKi9cblJheS5wcm90b3R5cGUuaW50ZXJzZWN0Qm9kaWVzID0gZnVuY3Rpb24gKGJvZGllcywgcmVzdWx0KSB7XG4gICAgaWYocmVzdWx0KXtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigpO1xuICAgIH1cblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGJvZGllcy5sZW5ndGg7ICF0aGlzLnJlc3VsdC5fc2hvdWxkU3RvcCAmJiBpIDwgbDsgaSArKyApIHtcbiAgICAgICAgdGhpcy5pbnRlcnNlY3RCb2R5KGJvZGllc1tpXSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBfZGlyZWN0aW9uIHZlY3Rvci5cbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIF91cGRhdGVEaXJlY3Rpb25cbiAqL1xuUmF5LnByb3RvdHlwZS5fdXBkYXRlRGlyZWN0aW9uID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZCA9IHRoaXMuX2RpcmVjdGlvbjtcbiAgICB2ZWMyLnN1YihkLCB0aGlzLnRvLCB0aGlzLmZyb20pOyAvLyB0aGlzLnRvLnZzdWIodGhpcy5mcm9tLCB0aGlzLl9kaXJlY3Rpb24pO1xuICAgIHZlYzIubm9ybWFsaXplKGQsIGQpOyAvLyB0aGlzLl9kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgaW50ZXJzZWN0U2hhcGVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1NoYXBlfSBzaGFwZVxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gKiBAcGFyYW0ge2FycmF5fSBwb3NpdGlvblxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKi9cblJheS5wcm90b3R5cGUuaW50ZXJzZWN0U2hhcGUgPSBmdW5jdGlvbihzaGFwZSwgYW5nbGUsIHBvc2l0aW9uLCBib2R5KXtcbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcblxuXG4gICAgLy8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmVcbiAgICB2YXIgZGlzdGFuY2UgPSBkaXN0YW5jZUZyb21JbnRlcnNlY3Rpb24oZnJvbSwgdGhpcy5fZGlyZWN0aW9uLCBwb3NpdGlvbik7XG4gICAgaWYgKCBkaXN0YW5jZSA+IHNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzICkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1ldGhvZCA9IHRoaXNbc2hhcGUudHlwZV07XG4gICAgaWYobWV0aG9kKXtcbiAgICAgICAgbWV0aG9kLmNhbGwodGhpcywgc2hhcGUsIGFuZ2xlLCBwb3NpdGlvbiwgYm9keSk7XG4gICAgfVxufTtcblxudmFyIHZlY3RvciA9IHZlYzIuY3JlYXRlKCk7XG52YXIgbm9ybWFsID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RQb2ludCA9IHZlYzIuY3JlYXRlKCk7XG5cbnZhciBhID0gdmVjMi5jcmVhdGUoKTtcbnZhciBiID0gdmVjMi5jcmVhdGUoKTtcbnZhciBjID0gdmVjMi5jcmVhdGUoKTtcbnZhciBkID0gdmVjMi5jcmVhdGUoKTtcblxudmFyIHRtcFJheWNhc3RSZXN1bHQgPSBuZXcgUmF5Y2FzdFJlc3VsdCgpO1xudmFyIGludGVyc2VjdFJlY3RhbmdsZV9kaXJlY3Rpb24gPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFJlY3RhbmdsZV9yYXlTdGFydCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UmVjdGFuZ2xlX3dvcmxkTm9ybWFsTWluID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RSZWN0YW5nbGVfd29ybGROb3JtYWxNYXggPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFJlY3RhbmdsZV9oaXRQb2ludFdvcmxkID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RSZWN0YW5nbGVfYm94TWluID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RSZWN0YW5nbGVfYm94TWF4ID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdFJlY3RhbmdsZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxuICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZVxuICogQHBhcmFtICB7YXJyYXl9IHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5XG4gKi9cblJheS5wcm90b3R5cGUuaW50ZXJzZWN0UmVjdGFuZ2xlID0gZnVuY3Rpb24oc2hhcGUsIGFuZ2xlLCBwb3NpdGlvbiwgYm9keSl7XG4gICAgdmFyIHRtaW4gPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgdG1heCA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICB2YXIgZGlyZWN0aW9uID0gaW50ZXJzZWN0UmVjdGFuZ2xlX2RpcmVjdGlvbjtcbiAgICB2YXIgcmF5U3RhcnQgPSBpbnRlcnNlY3RSZWN0YW5nbGVfcmF5U3RhcnQ7XG4gICAgdmFyIHdvcmxkTm9ybWFsTWluID0gaW50ZXJzZWN0UmVjdGFuZ2xlX3dvcmxkTm9ybWFsTWluO1xuICAgIHZhciB3b3JsZE5vcm1hbE1heCA9IGludGVyc2VjdFJlY3RhbmdsZV93b3JsZE5vcm1hbE1heDtcbiAgICB2YXIgaGl0UG9pbnRXb3JsZCA9IGludGVyc2VjdFJlY3RhbmdsZV9oaXRQb2ludFdvcmxkO1xuICAgIHZhciBib3hNaW4gPSBpbnRlcnNlY3RSZWN0YW5nbGVfYm94TWluO1xuICAgIHZhciBib3hNYXggPSBpbnRlcnNlY3RSZWN0YW5nbGVfYm94TWF4O1xuXG4gICAgdmVjMi5zZXQoYm94TWluLCAtc2hhcGUud2lkdGggKiAwLjUsIC1zaGFwZS5oZWlnaHQgKiAwLjUpO1xuICAgIHZlYzIuc2V0KGJveE1heCwgc2hhcGUud2lkdGggKiAwLjUsIHNoYXBlLmhlaWdodCAqIDAuNSk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gdGhlIHJheSBkaXJlY3Rpb24gYW5kIHN0YXJ0IHRvIGxvY2FsIHNwYWNlXG4gICAgdmVjMi5yb3RhdGUoZGlyZWN0aW9uLCB0aGlzLl9kaXJlY3Rpb24sIC1hbmdsZSk7XG4gICAgYm9keS50b0xvY2FsRnJhbWUocmF5U3RhcnQsIHRoaXMuZnJvbSk7XG5cbiAgICBpZiAoZGlyZWN0aW9uWzBdICE9PSAwKSB7XG4gICAgICAgIHZhciB0eDEgPSAoYm94TWluWzBdIC0gcmF5U3RhcnRbMF0pIC8gZGlyZWN0aW9uWzBdO1xuICAgICAgICB2YXIgdHgyID0gKGJveE1heFswXSAtIHJheVN0YXJ0WzBdKSAvIGRpcmVjdGlvblswXTtcblxuICAgICAgICB2YXIgdG1pbk9sZCA9IHRtaW47XG4gICAgICAgIHRtaW4gPSBNYXRoLm1heCh0bWluLCBNYXRoLm1pbih0eDEsIHR4MikpO1xuICAgICAgICBpZih0bWluICE9PSB0bWluT2xkKXtcbiAgICAgICAgICAgIHZlYzIuc2V0KHdvcmxkTm9ybWFsTWluLCB0eDEgPiB0eDIgPyAxIDogLTEsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRtYXhPbGQgPSB0bWF4O1xuICAgICAgICB0bWF4ID0gTWF0aC5taW4odG1heCwgTWF0aC5tYXgodHgxLCB0eDIpKTtcbiAgICAgICAgaWYodG1heCAhPT0gdG1heE9sZCl7XG4gICAgICAgICAgICB2ZWMyLnNldCh3b3JsZE5vcm1hbE1heCwgdHgxIDwgdHgyID8gMSA6IC0xLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaXJlY3Rpb25bMV0gIT09IDApIHtcbiAgICAgICAgdmFyIHR5MSA9IChib3hNaW5bMV0gLSByYXlTdGFydFsxXSkgLyBkaXJlY3Rpb25bMV07XG4gICAgICAgIHZhciB0eTIgPSAoYm94TWF4WzFdIC0gcmF5U3RhcnRbMV0pIC8gZGlyZWN0aW9uWzFdO1xuXG4gICAgICAgIHZhciB0bWluT2xkID0gdG1pbjtcbiAgICAgICAgdG1pbiA9IE1hdGgubWF4KHRtaW4sIE1hdGgubWluKHR5MSwgdHkyKSk7XG4gICAgICAgIGlmKHRtaW4gIT09IHRtaW5PbGQpe1xuICAgICAgICAgICAgdmVjMi5zZXQod29ybGROb3JtYWxNaW4sIDAsIHR5MSA+IHR5MiA/IDEgOiAtMSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG1heE9sZCA9IHRtYXg7XG4gICAgICAgIHRtYXggPSBNYXRoLm1pbih0bWF4LCBNYXRoLm1heCh0eTEsIHR5MikpO1xuICAgICAgICBpZih0bWF4ICE9PSB0bWF4T2xkKXtcbiAgICAgICAgICAgIHZlYzIuc2V0KHdvcmxkTm9ybWFsTWF4LCAwLCB0eTEgPCB0eTIgPyAxIDogLTEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodG1heCA+PSB0bWluKXtcbiAgICAgICAgLy8gSGl0IHBvaW50XG4gICAgICAgIHZlYzIuc2V0KFxuICAgICAgICAgICAgaGl0UG9pbnRXb3JsZCxcbiAgICAgICAgICAgIHJheVN0YXJ0WzBdICsgZGlyZWN0aW9uWzBdICogdG1pbixcbiAgICAgICAgICAgIHJheVN0YXJ0WzFdICsgZGlyZWN0aW9uWzFdICogdG1pblxuICAgICAgICApO1xuXG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkTm9ybWFsTWluLCB3b3JsZE5vcm1hbE1pbiwgYW5nbGUpO1xuXG4gICAgICAgIGJvZHkudG9Xb3JsZEZyYW1lKGhpdFBvaW50V29ybGQsIGhpdFBvaW50V29ybGQpO1xuXG4gICAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKHdvcmxkTm9ybWFsTWluLCBoaXRQb2ludFdvcmxkLCBzaGFwZSwgYm9keSwgLTEpO1xuICAgICAgICBpZih0aGlzLl9zaG91bGRTdG9wKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkTm9ybWFsTWF4LCB3b3JsZE5vcm1hbE1heCwgYW5nbGUpO1xuXG4gICAgICAgIC8vIEhpdCBwb2ludFxuICAgICAgICB2ZWMyLnNldChcbiAgICAgICAgICAgIGhpdFBvaW50V29ybGQsXG4gICAgICAgICAgICByYXlTdGFydFswXSArIGRpcmVjdGlvblswXSAqIHRtYXgsXG4gICAgICAgICAgICByYXlTdGFydFsxXSArIGRpcmVjdGlvblsxXSAqIHRtYXhcbiAgICAgICAgKTtcbiAgICAgICAgYm9keS50b1dvcmxkRnJhbWUoaGl0UG9pbnRXb3JsZCwgaGl0UG9pbnRXb3JsZCk7XG5cbiAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24od29ybGROb3JtYWxNYXgsIGhpdFBvaW50V29ybGQsIHNoYXBlLCBib2R5LCAtMSk7XG4gICAgfVxufTtcblJheS5wcm90b3R5cGVbU2hhcGUuUkVDVEFOR0xFXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0UmVjdGFuZ2xlO1xuXG52YXIgaW50ZXJzZWN0UGxhbmVfcGxhbmVQb2ludFRvRnJvbSA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UGxhbmVfZGlyX3NjYWxlZF93aXRoX3QgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFBsYW5lX2hpdFBvaW50V29ybGQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFBsYW5lX3dvcmxkTm9ybWFsID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RQbGFuZV9sZW4gPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgaW50ZXJzZWN0UGxhbmVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSAge251bWJlcn0gYW5nbGVcbiAqIEBwYXJhbSAge2FycmF5fSBwb3NpdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keVxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdFBsYW5lID0gZnVuY3Rpb24oc2hhcGUsIGFuZ2xlLCBwb3NpdGlvbiwgYm9keSl7XG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XG4gICAgdmFyIHRvID0gdGhpcy50bztcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZGlyZWN0aW9uO1xuXG4gICAgdmFyIHBsYW5lUG9pbnRUb0Zyb20gPSBpbnRlcnNlY3RQbGFuZV9wbGFuZVBvaW50VG9Gcm9tO1xuICAgIHZhciBkaXJfc2NhbGVkX3dpdGhfdCA9IGludGVyc2VjdFBsYW5lX2Rpcl9zY2FsZWRfd2l0aF90O1xuICAgIHZhciBoaXRQb2ludFdvcmxkID0gaW50ZXJzZWN0UGxhbmVfaGl0UG9pbnRXb3JsZDtcbiAgICB2YXIgd29ybGROb3JtYWwgPSBpbnRlcnNlY3RQbGFuZV93b3JsZE5vcm1hbDtcbiAgICB2YXIgbGVuID0gaW50ZXJzZWN0UGxhbmVfbGVuO1xuXG4gICAgLy8gR2V0IHBsYW5lIG5vcm1hbFxuICAgIHZlYzIuc2V0KHdvcmxkTm9ybWFsLCAwLCAxKTtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbCwgd29ybGROb3JtYWwsIGFuZ2xlKTtcblxuICAgIHZlYzIuc3ViKGxlbiwgZnJvbSwgcG9zaXRpb24pOyAvL2Zyb20udnN1Yihwb3NpdGlvbiwgbGVuKTtcbiAgICB2YXIgcGxhbmVUb0Zyb20gPSB2ZWMyLmRvdChsZW4sIHdvcmxkTm9ybWFsKTsgLy8gbGVuLmRvdCh3b3JsZE5vcm1hbCk7XG4gICAgdmVjMi5zdWIobGVuLCB0bywgcG9zaXRpb24pOyAvLyB0by52c3ViKHBvc2l0aW9uLCBsZW4pO1xuICAgIHZhciBwbGFuZVRvVG8gPSB2ZWMyLmRvdChsZW4sIHdvcmxkTm9ybWFsKTsgLy8gbGVuLmRvdCh3b3JsZE5vcm1hbCk7XG5cbiAgICBpZihwbGFuZVRvRnJvbSAqIHBsYW5lVG9UbyA+IDApe1xuICAgICAgICAvLyBcImZyb21cIiBhbmQgXCJ0b1wiIGFyZSBvbiB0aGUgc2FtZSBzaWRlIG9mIHRoZSBwbGFuZS4uLiBiYWlsIG91dFxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYodmVjMi5kaXN0YW5jZShmcm9tLCB0bykgLyogZnJvbS5kaXN0YW5jZVRvKHRvKSAqLyA8IHBsYW5lVG9Gcm9tKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuX2RvdF9kaXIgPSB2ZWMyLmRvdCh3b3JsZE5vcm1hbCwgZGlyZWN0aW9uKTsgLy8gd29ybGROb3JtYWwuZG90KGRpcmVjdGlvbik7XG5cbiAgICAvLyBpZiAoTWF0aC5hYnMobl9kb3RfZGlyKSA8IHRoaXMucHJlY2lzaW9uKSB7XG4gICAgLy8gICAgIC8vIE5vIGludGVyc2VjdGlvblxuICAgIC8vICAgICByZXR1cm47XG4gICAgLy8gfVxuXG4gICAgdmVjMi5zdWIocGxhbmVQb2ludFRvRnJvbSwgZnJvbSwgcG9zaXRpb24pOyAvLyBmcm9tLnZzdWIocG9zaXRpb24sIHBsYW5lUG9pbnRUb0Zyb20pO1xuICAgIHZhciB0ID0gLXZlYzIuZG90KHdvcmxkTm9ybWFsLCBwbGFuZVBvaW50VG9Gcm9tKSAvIG5fZG90X2RpcjsgLy8gLSB3b3JsZE5vcm1hbC5kb3QocGxhbmVQb2ludFRvRnJvbSkgLyBuX2RvdF9kaXI7XG4gICAgdmVjMi5zY2FsZShkaXJfc2NhbGVkX3dpdGhfdCwgZGlyZWN0aW9uLCB0KTsgLy8gZGlyZWN0aW9uLnNjYWxlKHQsIGRpcl9zY2FsZWRfd2l0aF90KTtcbiAgICB2ZWMyLmFkZChoaXRQb2ludFdvcmxkLCBmcm9tLCBkaXJfc2NhbGVkX3dpdGhfdCk7IC8vIGZyb20udmFkZChkaXJfc2NhbGVkX3dpdGhfdCwgaGl0UG9pbnRXb3JsZCk7XG5cbiAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbih3b3JsZE5vcm1hbCwgaGl0UG9pbnRXb3JsZCwgc2hhcGUsIGJvZHksIC0xKTtcbn07XG5SYXkucHJvdG90eXBlW1NoYXBlLlBMQU5FXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0UGxhbmU7XG5cbnZhciBSYXlfaW50ZXJzZWN0U3BoZXJlX2ludGVyc2VjdGlvblBvaW50ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBSYXlfaW50ZXJzZWN0U3BoZXJlX25vcm1hbCA9IHZlYzIuY3JlYXRlKCk7XG5SYXkucHJvdG90eXBlLmludGVyc2VjdENpcmNsZSA9IGZ1bmN0aW9uKHNoYXBlLCBhbmdsZSwgcG9zaXRpb24sIGJvZHkpe1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tLFxuICAgICAgICB0byA9IHRoaXMudG8sXG4gICAgICAgIHIgPSBzaGFwZS5yYWRpdXM7XG5cbiAgICB2YXIgYSA9IE1hdGgucG93KHRvWzBdIC0gZnJvbVswXSwgMikgKyBNYXRoLnBvdyh0b1sxXSAtIGZyb21bMV0sIDIpO1xuICAgIHZhciBiID0gMiAqICgodG9bMF0gLSBmcm9tWzBdKSAqIChmcm9tWzBdIC0gcG9zaXRpb25bMF0pICsgKHRvWzFdIC0gZnJvbVsxXSkgKiAoZnJvbVsxXSAtIHBvc2l0aW9uWzFdKSk7XG4gICAgdmFyIGMgPSBNYXRoLnBvdyhmcm9tWzBdIC0gcG9zaXRpb25bMF0sIDIpICsgTWF0aC5wb3coZnJvbVsxXSAtIHBvc2l0aW9uWzFdLCAyKSAtIE1hdGgucG93KHIsIDIpO1xuXG4gICAgdmFyIGRlbHRhID0gTWF0aC5wb3coYiwgMikgLSA0ICogYSAqIGM7XG5cbiAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSBSYXlfaW50ZXJzZWN0U3BoZXJlX2ludGVyc2VjdGlvblBvaW50O1xuICAgIHZhciBub3JtYWwgPSBSYXlfaW50ZXJzZWN0U3BoZXJlX25vcm1hbDtcblxuICAgIGlmKGRlbHRhIDwgMCl7XG4gICAgICAgIC8vIE5vIGludGVyc2VjdGlvblxuICAgICAgICByZXR1cm47XG5cbiAgICB9IGVsc2UgaWYoZGVsdGEgPT09IDApe1xuICAgICAgICAvLyBzaW5nbGUgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgICAgIHZlYzIubGVycChpbnRlcnNlY3Rpb25Qb2ludCwgZnJvbSwgdG8sIGRlbHRhKTsgLy8gZnJvbS5sZXJwKHRvLCBkZWx0YSwgaW50ZXJzZWN0aW9uUG9pbnQpO1xuXG4gICAgICAgIHZlYzIuc3ViKG5vcm1hbCwgaW50ZXJzZWN0aW9uUG9pbnQsIHBvc2l0aW9uKTsgLy8gaW50ZXJzZWN0aW9uUG9pbnQudnN1Yihwb3NpdGlvbiwgbm9ybWFsKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLG5vcm1hbCk7IC8vbm9ybWFsLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKG5vcm1hbCwgaW50ZXJzZWN0aW9uUG9pbnQsIHNoYXBlLCBib2R5LCAtMSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZDEgPSAoLSBiIC0gTWF0aC5zcXJ0KGRlbHRhKSkgLyAoMiAqIGEpO1xuICAgICAgICB2YXIgZDIgPSAoLSBiICsgTWF0aC5zcXJ0KGRlbHRhKSkgLyAoMiAqIGEpO1xuXG4gICAgICAgIHZlYzIubGVycChpbnRlcnNlY3Rpb25Qb2ludCwgZnJvbSwgdG8sIGQxKTsgLy8gZnJvbS5sZXJwKHRvLCBkMSwgaW50ZXJzZWN0aW9uUG9pbnQpO1xuXG4gICAgICAgIHZlYzIuc3ViKG5vcm1hbCwgaW50ZXJzZWN0aW9uUG9pbnQsIHBvc2l0aW9uKTsgLy8gaW50ZXJzZWN0aW9uUG9pbnQudnN1Yihwb3NpdGlvbiwgbm9ybWFsKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLG5vcm1hbCk7IC8vbm9ybWFsLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKG5vcm1hbCwgaW50ZXJzZWN0aW9uUG9pbnQsIHNoYXBlLCBib2R5LCAtMSk7XG5cbiAgICAgICAgaWYodGhpcy5yZXN1bHQuX3Nob3VsZFN0b3Ape1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmVjMi5sZXJwKGludGVyc2VjdGlvblBvaW50LCBmcm9tLCB0bywgZDIpOyAvLyBmcm9tLmxlcnAodG8sIGQyLCBpbnRlcnNlY3Rpb25Qb2ludCk7XG5cbiAgICAgICAgdmVjMi5zdWIobm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcG9zaXRpb24pOyAvLyBpbnRlcnNlY3Rpb25Qb2ludC52c3ViKHBvc2l0aW9uLCBub3JtYWwpO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShub3JtYWwsbm9ybWFsKTsgLy9ub3JtYWwubm9ybWFsaXplKCk7XG5cbiAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgc2hhcGUsIGJvZHksIC0xKTtcbiAgICB9XG59O1xuUmF5LnByb3RvdHlwZVtTaGFwZS5DSVJDTEVdID0gUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RDaXJjbGU7XG5cbi8qKlxuICogR2V0IHRoZSBBQUJCIG9mIHRoZSByYXkuXG4gKiBAbWV0aG9kIGdldEFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqL1xuUmF5LnByb3RvdHlwZS5nZXRBQUJCID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuICAgIHJlc3VsdC5sb3dlckJvdW5kWzBdID0gTWF0aC5taW4odG9bMF0sIGZyb21bMF0pO1xuICAgIHJlc3VsdC5sb3dlckJvdW5kWzFdID0gTWF0aC5taW4odG9bMV0sIGZyb21bMV0pO1xuICAgIHJlc3VsdC51cHBlckJvdW5kWzBdID0gTWF0aC5tYXgodG9bMF0sIGZyb21bMF0pO1xuICAgIHJlc3VsdC51cHBlckJvdW5kWzFdID0gTWF0aC5tYXgodG9bMV0sIGZyb21bMV0pO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHJlcG9ydEludGVyc2VjdGlvblxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge2FycmF5fSBub3JtYWxcbiAqIEBwYXJhbSAge2FycmF5fSBoaXRQb2ludFdvcmxkXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGludGVyc2VjdGlvbnMgc2hvdWxkIGNvbnRpbnVlXG4gKi9cblJheS5wcm90b3R5cGUucmVwb3J0SW50ZXJzZWN0aW9uID0gZnVuY3Rpb24obm9ybWFsLCBoaXRQb2ludFdvcmxkLCBzaGFwZSwgYm9keSwgaGl0RmFjZUluZGV4KXtcbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xuICAgIHZhciBkaXN0YW5jZSA9IHZlYzIuZGlzdGFuY2UoZnJvbSwgaGl0UG9pbnRXb3JsZCk7IC8vIGZyb20uZGlzdGFuY2VUbyhoaXRQb2ludFdvcmxkKTtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7XG5cbiAgICAvLyBTa2lwIGJhY2sgZmFjZXM/XG4gICAgaWYodGhpcy5za2lwQmFja2ZhY2VzICYmIC8qIG5vcm1hbC5kb3QodGhpcy5fZGlyZWN0aW9uKSAqLyB2ZWMyLmRvdChub3JtYWwsIHRoaXMuX2RpcmVjdGlvbikgPiAwKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlc3VsdC5oaXRGYWNlSW5kZXggPSB0eXBlb2YoaGl0RmFjZUluZGV4KSAhPT0gJ3VuZGVmaW5lZCcgPyBoaXRGYWNlSW5kZXggOiAtMTtcblxuICAgIHN3aXRjaCh0aGlzLm1vZGUpe1xuICAgIGNhc2UgUmF5LkFMTDpcbiAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlO1xuICAgICAgICByZXN1bHQuc2V0KFxuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgbm9ybWFsLFxuICAgICAgICAgICAgaGl0UG9pbnRXb3JsZCxcbiAgICAgICAgICAgIHNoYXBlLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIGRpc3RhbmNlXG4gICAgICAgICk7XG4gICAgICAgIHJlc3VsdC5oYXNIaXQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBSYXkuQ0xPU0VTVDpcblxuICAgICAgICAvLyBTdG9yZSBpZiBjbG9zZXIgdGhhbiBjdXJyZW50IGNsb3Nlc3RcbiAgICAgICAgaWYoZGlzdGFuY2UgPCByZXN1bHQuZGlzdGFuY2UgfHwgIXJlc3VsdC5oYXNIaXQpe1xuICAgICAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlO1xuICAgICAgICAgICAgcmVzdWx0Lmhhc0hpdCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQuc2V0KFxuICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgbm9ybWFsLFxuICAgICAgICAgICAgICAgIGhpdFBvaW50V29ybGQsXG4gICAgICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICBkaXN0YW5jZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgUmF5LkFOWTpcblxuICAgICAgICAvLyBSZXBvcnQgYW5kIHN0b3AuXG4gICAgICAgIHRoaXMuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0Lmhhc0hpdCA9IHRydWU7XG4gICAgICAgIHJlc3VsdC5zZXQoXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICBoaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgZGlzdGFuY2VcbiAgICAgICAgKTtcbiAgICAgICAgcmVzdWx0Ll9zaG91bGRTdG9wID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxudmFyIHYwID0gdmVjMi5jcmVhdGUoKSxcbiAgICBpbnRlcnNlY3QgPSB2ZWMyLmNyZWF0ZSgpO1xuZnVuY3Rpb24gZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uKGZyb20sIGRpcmVjdGlvbiwgcG9zaXRpb24pIHtcblxuICAgIC8vIHYwIGlzIHZlY3RvciBmcm9tIGZyb20gdG8gcG9zaXRpb25cbiAgICB2ZWMyLnN1Yih2MCwgcG9zaXRpb24sIGZyb20pOyAvLyBwb3NpdGlvbi52c3ViKGZyb20sdjApO1xuICAgIHZhciBkb3QgPSB2ZWMyLmRvdCh2MCwgZGlyZWN0aW9uKTsgLy8gdjAuZG90KGRpcmVjdGlvbik7XG5cbiAgICAvLyBpbnRlcnNlY3QgPSBkaXJlY3Rpb24qZG90ICsgZnJvbVxuICAgIHZlYzIuc2NhbGUoaW50ZXJzZWN0LCBkaXJlY3Rpb24sIGRvdCk7IC8vZGlyZWN0aW9uLm11bHQoZG90LGludGVyc2VjdCk7XG4gICAgdmVjMi5hZGQoaW50ZXJzZWN0LCBpbnRlcnNlY3QsIGZyb20pOyAvLyBpbnRlcnNlY3QudmFkZChmcm9tLCBpbnRlcnNlY3QpO1xuXG4gICAgdmFyIGRpc3RhbmNlID0gdmVjMi5kaXN0YW5jZShwb3NpdGlvbiwgaW50ZXJzZWN0KTsgLy8gcG9zaXRpb24uZGlzdGFuY2VUbyhpbnRlcnNlY3QpO1xuXG4gICAgcmV0dXJuIGRpc3RhbmNlO1xufVxuXG5cbn0se1wiLi4vY29sbGlzaW9uL0FBQkJcIjo3LFwiLi4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHRcIjoxMyxcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vc2hhcGVzL1NoYXBlXCI6NDV9XSwxMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJheWNhc3RSZXN1bHQ7XG5cbi8qKlxuICogU3RvcmFnZSBmb3IgUmF5IGNhc3RpbmcgZGF0YS5cbiAqIEBjbGFzcyBSYXljYXN0UmVzdWx0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUmF5Y2FzdFJlc3VsdCgpe1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge2FycmF5fSByYXlGcm9tV29ybGRcblx0ICovXG5cdHRoaXMucmF5RnJvbVdvcmxkID0gdmVjMi5jcmVhdGUoKTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IHthcnJheX0gcmF5VG9Xb3JsZFxuXHQgKi9cblx0dGhpcy5yYXlUb1dvcmxkID0gdmVjMi5jcmVhdGUoKTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IHthcnJheX0gaGl0Tm9ybWFsV29ybGRcblx0ICovXG5cdHRoaXMuaGl0Tm9ybWFsV29ybGQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge2FycmF5fSBoaXRQb2ludFdvcmxkXG5cdCAqL1xuXHR0aGlzLmhpdFBvaW50V29ybGQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IGhhc0hpdFxuXHQgKi9cblx0dGhpcy5oYXNIaXQgPSBmYWxzZTtcblxuXHQvKipcblx0ICogVGhlIGhpdCBzaGFwZSwgb3IgbnVsbC5cblx0ICogQHByb3BlcnR5IHtTaGFwZX0gc2hhcGVcblx0ICovXG5cdHRoaXMuc2hhcGUgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBUaGUgaGl0IGJvZHksIG9yIG51bGwuXG5cdCAqIEBwcm9wZXJ0eSB7Qm9keX0gYm9keVxuXHQgKi9cblx0dGhpcy5ib2R5ID0gbnVsbDtcblxuXHQvKipcblx0ICogVGhlIGluZGV4IG9mIHRoZSBoaXQgdHJpYW5nbGUsIGlmIHRoZSBoaXQgc2hhcGUgd2FzIGEgdHJpbWVzaC5cblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IGhpdEZhY2VJbmRleFxuXHQgKiBAZGVmYXVsdCAtMVxuXHQgKi9cblx0dGhpcy5oaXRGYWNlSW5kZXggPSAtMTtcblxuXHQvKipcblx0ICogRGlzdGFuY2UgdG8gdGhlIGhpdC4gV2lsbCBiZSBzZXQgdG8gLTEgaWYgdGhlcmUgd2FzIG5vIGhpdC5cblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IGRpc3RhbmNlXG5cdCAqIEBkZWZhdWx0IC0xXG5cdCAqL1xuXHR0aGlzLmRpc3RhbmNlID0gLTE7XG5cblx0LyoqXG5cdCAqIElmIHRoZSByYXkgc2hvdWxkIHN0b3AgdHJhdmVyc2luZyB0aGUgYm9kaWVzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IF9zaG91bGRTdG9wXG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqL1xuXHR0aGlzLl9zaG91bGRTdG9wID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVzZXQgYWxsIHJlc3VsdCBkYXRhLlxuICogQG1ldGhvZCByZXNldFxuICovXG5SYXljYXN0UmVzdWx0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcblx0dmVjMi5zZXQodGhpcy5yYXlGcm9tV29ybGQsIDAsIDApO1xuXHR2ZWMyLnNldCh0aGlzLnJheVRvV29ybGQsIDAsIDApO1xuXHR2ZWMyLnNldCh0aGlzLmhpdE5vcm1hbFdvcmxkLCAwLCAwKTtcblx0dmVjMi5zZXQodGhpcy5oaXRQb2ludFdvcmxkLCAwLCAwKTtcblx0dGhpcy5oYXNIaXQgPSBmYWxzZTtcblx0dGhpcy5zaGFwZSA9IG51bGw7XG5cdHRoaXMuYm9keSA9IG51bGw7XG5cdHRoaXMuaGl0RmFjZUluZGV4ID0gLTE7XG5cdHRoaXMuZGlzdGFuY2UgPSAtMTtcblx0dGhpcy5fc2hvdWxkU3RvcCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGFib3J0XG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcblx0dGhpcy5fc2hvdWxkU3RvcCA9IHRydWU7XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge2FycmF5fSByYXlGcm9tV29ybGRcbiAqIEBwYXJhbSB7YXJyYXl9IHJheVRvV29ybGRcbiAqIEBwYXJhbSB7YXJyYXl9IGhpdE5vcm1hbFdvcmxkXG4gKiBAcGFyYW0ge2FycmF5fSBoaXRQb2ludFdvcmxkXG4gKiBAcGFyYW0ge1NoYXBlfSBzaGFwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2VcbiAqL1xuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oXG5cdHJheUZyb21Xb3JsZCxcblx0cmF5VG9Xb3JsZCxcblx0aGl0Tm9ybWFsV29ybGQsXG5cdGhpdFBvaW50V29ybGQsXG5cdHNoYXBlLFxuXHRib2R5LFxuXHRkaXN0YW5jZVxuKXtcblx0dmVjMi5jb3B5KHRoaXMucmF5RnJvbVdvcmxkLCByYXlGcm9tV29ybGQpO1xuXHR2ZWMyLmNvcHkodGhpcy5yYXlUb1dvcmxkLCByYXlUb1dvcmxkKTtcblx0dmVjMi5jb3B5KHRoaXMuaGl0Tm9ybWFsV29ybGQsIGhpdE5vcm1hbFdvcmxkKTtcblx0dmVjMi5jb3B5KHRoaXMuaGl0UG9pbnRXb3JsZCwgaGl0UG9pbnRXb3JsZCk7XG5cdHRoaXMuc2hhcGUgPSBzaGFwZTtcblx0dGhpcy5ib2R5ID0gYm9keTtcblx0dGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xufTtcbn0se1wiLi4vbWF0aC92ZWMyXCI6MzF9XSwxNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpXG4sICAgQnJvYWRwaGFzZSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9Ccm9hZHBoYXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU0FQQnJvYWRwaGFzZTtcblxuLyoqXG4gKiBTd2VlcCBhbmQgcHJ1bmUgYnJvYWRwaGFzZSBhbG9uZyBvbmUgYXhpcy5cbiAqXG4gKiBAY2xhc3MgU0FQQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXG4gKi9cbmZ1bmN0aW9uIFNBUEJyb2FkcGhhc2UoKXtcbiAgICBCcm9hZHBoYXNlLmNhbGwodGhpcyxCcm9hZHBoYXNlLlNBUCk7XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGJvZGllcyBjdXJyZW50bHkgaW4gdGhlIGJyb2FkcGhhc2UuXG4gICAgICogQHByb3BlcnR5IGF4aXNMaXN0XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYXhpc0xpc3QgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBheGlzIHRvIHNvcnQgYWxvbmcuIDAgbWVhbnMgeC1heGlzIGFuZCAxIHktYXhpcy4gSWYgeW91ciBib2RpZXMgYXJlIG1vcmUgc3ByZWFkIG91dCBvdmVyIHRoZSBYIGF4aXMsIHNldCBheGlzSW5kZXggdG8gMCwgYW5kIHlvdSB3aWxsIGdhaW4gc29tZSBwZXJmb3JtYW5jZS5cbiAgICAgKiBAcHJvcGVydHkgYXhpc0luZGV4XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmF4aXNJbmRleCA9IDA7XG5cbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhpcy5fYWRkQm9keUhhbmRsZXIgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgdGhhdC5heGlzTGlzdC5wdXNoKGUuYm9keSk7XG4gICAgfTtcblxuICAgIHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIGxpc3RcbiAgICAgICAgdmFyIGlkeCA9IHRoYXQuYXhpc0xpc3QuaW5kZXhPZihlLmJvZHkpO1xuICAgICAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgICAgIHRoYXQuYXhpc0xpc3Quc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZSA9IG5ldyBCcm9hZHBoYXNlKCk7XG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNBUEJyb2FkcGhhc2U7XG5cbi8qKlxuICogQ2hhbmdlIHRoZSB3b3JsZFxuICogQG1ldGhvZCBzZXRXb3JsZFxuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqL1xuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuc2V0V29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgLy8gQ2xlYXIgdGhlIG9sZCBheGlzIGFycmF5XG4gICAgdGhpcy5heGlzTGlzdC5sZW5ndGggPSAwO1xuXG4gICAgLy8gQWRkIGFsbCBib2RpZXMgZnJvbSB0aGUgbmV3IHdvcmxkXG4gICAgVXRpbHMuYXBwZW5kQXJyYXkodGhpcy5heGlzTGlzdCwgd29ybGQuYm9kaWVzKTtcblxuICAgIC8vIFJlbW92ZSBvbGQgaGFuZGxlcnMsIGlmIGFueVxuICAgIHdvcmxkXG4gICAgICAgIC5vZmYoXCJhZGRCb2R5XCIsdGhpcy5fYWRkQm9keUhhbmRsZXIpXG4gICAgICAgIC5vZmYoXCJyZW1vdmVCb2R5XCIsdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIpO1xuXG4gICAgLy8gQWRkIGhhbmRsZXJzIHRvIHVwZGF0ZSB0aGUgbGlzdCBvZiBib2RpZXMuXG4gICAgd29ybGQub24oXCJhZGRCb2R5XCIsdGhpcy5fYWRkQm9keUhhbmRsZXIpLm9uKFwicmVtb3ZlQm9keVwiLHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyKTtcblxuICAgIHRoaXMud29ybGQgPSB3b3JsZDtcbn07XG5cbi8qKlxuICogU29ydHMgYm9kaWVzIGFsb25nIGFuIGF4aXMuXG4gKiBAbWV0aG9kIHNvcnRBeGlzTGlzdFxuICogQHBhcmFtIHtBcnJheX0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGF4aXNJbmRleFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblNBUEJyb2FkcGhhc2Uuc29ydEF4aXNMaXN0ID0gZnVuY3Rpb24oYSwgYXhpc0luZGV4KXtcbiAgICBheGlzSW5kZXggPSBheGlzSW5kZXh8MDtcbiAgICBmb3IodmFyIGk9MSxsPWEubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICB2YXIgdiA9IGFbaV07XG4gICAgICAgIGZvcih2YXIgaj1pIC0gMTtqPj0wO2otLSkge1xuICAgICAgICAgICAgaWYoYVtqXS5hYWJiLmxvd2VyQm91bmRbYXhpc0luZGV4XSA8PSB2LmFhYmIubG93ZXJCb3VuZFtheGlzSW5kZXhdKXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFbaisxXSA9IGFbal07XG4gICAgICAgIH1cbiAgICAgICAgYVtqKzFdID0gdjtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59O1xuXG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5zb3J0TGlzdCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJvZGllcyA9IHRoaXMuYXhpc0xpc3QsXG4gICAgYXhpc0luZGV4ID0gdGhpcy5heGlzSW5kZXg7XG5cbiAgICAvLyBTb3J0IHRoZSBsaXN0c1xuICAgIFNBUEJyb2FkcGhhc2Uuc29ydEF4aXNMaXN0KGJvZGllcywgYXhpc0luZGV4KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjb2xsaWRpbmcgcGFpcnNcbiAqIEBtZXRob2QgZ2V0Q29sbGlzaW9uUGFpcnNcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLmdldENvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24od29ybGQpe1xuICAgIHZhciBib2RpZXMgPSB0aGlzLmF4aXNMaXN0LFxuICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdCxcbiAgICAgICAgYXhpc0luZGV4ID0gdGhpcy5heGlzSW5kZXg7XG5cbiAgICByZXN1bHQubGVuZ3RoID0gMDtcblxuICAgIC8vIFVwZGF0ZSBhbGwgQUFCQnMgaWYgbmVlZGVkXG4gICAgdmFyIGwgPSBib2RpZXMubGVuZ3RoO1xuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIHZhciBiID0gYm9kaWVzW2xdO1xuICAgICAgICBpZihiLmFhYmJOZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBiLnVwZGF0ZUFBQkIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNvcnQgdGhlIGxpc3RzXG4gICAgdGhpcy5zb3J0TGlzdCgpO1xuXG4gICAgLy8gTG9vayB0aHJvdWdoIHRoZSBYIGxpc3RcbiAgICBmb3IodmFyIGk9MCwgTj1ib2RpZXMubGVuZ3RofDA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgZm9yKHZhciBqPWkrMTsgajxOOyBqKyspe1xuICAgICAgICAgICAgdmFyIGJqID0gYm9kaWVzW2pdO1xuXG4gICAgICAgICAgICAvLyBCb3VuZHMgb3ZlcmxhcD9cbiAgICAgICAgICAgIHZhciBvdmVybGFwcyA9IChiai5hYWJiLmxvd2VyQm91bmRbYXhpc0luZGV4XSA8PSBiaS5hYWJiLnVwcGVyQm91bmRbYXhpc0luZGV4XSk7XG4gICAgICAgICAgICBpZighb3ZlcmxhcHMpe1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihCcm9hZHBoYXNlLmNhbkNvbGxpZGUoYmksYmopICYmIHRoaXMuYm91bmRpbmdWb2x1bWVDaGVjayhiaSxiaikpe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJpLGJqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIHRoZSBib2RpZXMgd2l0aGluIGFuIEFBQkIuXG4gKiBAbWV0aG9kIGFhYmJRdWVyeVxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcGFyYW0ge2FycmF5fSByZXN1bHQgQW4gYXJyYXkgdG8gc3RvcmUgcmVzdWx0aW5nIGJvZGllcyBpbi5cbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5hYWJiUXVlcnkgPSBmdW5jdGlvbih3b3JsZCwgYWFiYiwgcmVzdWx0KXtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XG5cbiAgICB0aGlzLnNvcnRMaXN0KCk7XG5cbiAgICB2YXIgYXhpc0luZGV4ID0gdGhpcy5heGlzSW5kZXg7XG4gICAgdmFyIGF4aXMgPSAneCc7XG4gICAgaWYoYXhpc0luZGV4ID09PSAxKXsgYXhpcyA9ICd5JzsgfVxuICAgIGlmKGF4aXNJbmRleCA9PT0gMil7IGF4aXMgPSAneic7IH1cblxuICAgIHZhciBheGlzTGlzdCA9IHRoaXMuYXhpc0xpc3Q7XG4gICAgdmFyIGxvd2VyID0gYWFiYi5sb3dlckJvdW5kW2F4aXNdO1xuICAgIHZhciB1cHBlciA9IGFhYmIudXBwZXJCb3VuZFtheGlzXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXhpc0xpc3QubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYiA9IGF4aXNMaXN0W2ldO1xuXG4gICAgICAgIGlmKGIuYWFiYk5lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgIGIudXBkYXRlQUFCQigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYi5hYWJiLm92ZXJsYXBzKGFhYmIpKXtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG59LHtcIi4uL2NvbGxpc2lvbi9Ccm9hZHBoYXNlXCI6OCxcIi4uL3V0aWxzL1V0aWxzXCI6NTB9XSwxNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IENvbnN0cmFpbnQ7XG5cbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG5cbi8qKlxuICogQmFzZSBjb25zdHJhaW50IGNsYXNzLlxuICpcbiAqIEBjbGFzcyBDb25zdHJhaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY29sbGlkZUNvbm5lY3RlZD10cnVlXVxuICovXG5mdW5jdGlvbiBDb25zdHJhaW50KGJvZHlBLCBib2R5QiwgdHlwZSwgb3B0aW9ucyl7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBjb25zdHJhaW50LiBNYXkgYmUgb25lIG9mIENvbnN0cmFpbnQuRElTVEFOQ0UsIENvbnN0cmFpbnQuR0VBUiwgQ29uc3RyYWludC5MT0NLLCBDb25zdHJhaW50LlBSSVNNQVRJQyBvciBDb25zdHJhaW50LlJFVk9MVVRFLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0eXBlXG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdHlwZTtcblxuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLHtcbiAgICAgICAgY29sbGlkZUNvbm5lY3RlZCA6IHRydWUsXG4gICAgICAgIHdha2VVcEJvZGllcyA6IHRydWUsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBFcXVhdGlvbnMgdG8gYmUgc29sdmVkIGluIHRoaXMgY29uc3RyYWludFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGVxdWF0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRmlyc3QgYm9keSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb25zdHJhaW50LlxuICAgICAqIEBwcm9wZXJ0eSBib2R5QVxuICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAqL1xuICAgIHRoaXMuYm9keUEgPSBib2R5QTtcblxuICAgIC8qKlxuICAgICAqIFNlY29uZCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNvbnN0cmFpbnQuXG4gICAgICogQHByb3BlcnR5IGJvZHlCXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdGhlIGNvbm5lY3RlZCBib2RpZXMgdG8gY29sbGlkZS5cbiAgICAgKiBAcHJvcGVydHkgY29sbGlkZUNvbm5lY3RlZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpZGVDb25uZWN0ZWQgPSBvcHRpb25zLmNvbGxpZGVDb25uZWN0ZWQ7XG5cbiAgICAvLyBXYWtlIHVwIGJvZGllcyB3aGVuIGNvbm5lY3RlZFxuICAgIGlmKG9wdGlvbnMud2FrZVVwQm9kaWVzKXtcbiAgICAgICAgaWYoYm9keUEpe1xuICAgICAgICAgICAgYm9keUEud2FrZVVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoYm9keUIpe1xuICAgICAgICAgICAgYm9keUIud2FrZVVwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgY29uc3RyYWludCBwYXJhbWV0ZXJzIGJlZm9yZSBzb2x2ZS5cbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cbkNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIHVwZGF0ZSgpIG5vdCBpbXBsbWVtZW50ZWQgaW4gdGhpcyBDb25zdHJhaW50IHN1YmNsYXNzIVwiKTtcbn07XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IERJU1RBTkNFXG4gKi9cbkNvbnN0cmFpbnQuRElTVEFOQ0UgPSAxO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBHRUFSXG4gKi9cbkNvbnN0cmFpbnQuR0VBUiA9IDI7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IExPQ0tcbiAqL1xuQ29uc3RyYWludC5MT0NLID0gMztcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gUFJJU01BVElDXG4gKi9cbkNvbnN0cmFpbnQuUFJJU01BVElDID0gNDtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gUkVWT0xVVEVcbiAqL1xuQ29uc3RyYWludC5SRVZPTFVURSA9IDU7XG5cbi8qKlxuICogU2V0IHN0aWZmbmVzcyBmb3IgdGhpcyBjb25zdHJhaW50LlxuICogQG1ldGhvZCBzZXRTdGlmZm5lc3NcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGlmZm5lc3NcbiAqL1xuQ29uc3RyYWludC5wcm90b3R5cGUuc2V0U3RpZmZuZXNzID0gZnVuY3Rpb24oc3RpZmZuZXNzKXtcbiAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnM7XG4gICAgZm9yKHZhciBpPTA7IGkgIT09IGVxcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBlcSA9IGVxc1tpXTtcbiAgICAgICAgZXEuc3RpZmZuZXNzID0gc3RpZmZuZXNzO1xuICAgICAgICBlcS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXQgcmVsYXhhdGlvbiBmb3IgdGhpcyBjb25zdHJhaW50LlxuICogQG1ldGhvZCBzZXRSZWxheGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcmVsYXhhdGlvblxuICovXG5Db25zdHJhaW50LnByb3RvdHlwZS5zZXRSZWxheGF0aW9uID0gZnVuY3Rpb24ocmVsYXhhdGlvbil7XG4gICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zO1xuICAgIGZvcih2YXIgaT0wOyBpICE9PSBlcXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZXEgPSBlcXNbaV07XG4gICAgICAgIGVxLnJlbGF4YXRpb24gPSByZWxheGF0aW9uO1xuICAgICAgICBlcS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxufTtcblxufSx7XCIuLi91dGlscy9VdGlsc1wiOjUwfV0sMTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIENvbnN0cmFpbnQgPSBfZGVyZXFfKCcuL0NvbnN0cmFpbnQnKVxuLCAgIEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0VxdWF0aW9uJylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzdGFuY2VDb25zdHJhaW50O1xuXG4vKipcbiAqIENvbnN0cmFpbnQgdGhhdCB0cmllcyB0byBrZWVwIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBib2RpZXMgY29uc3RhbnQuXG4gKlxuICogQGNsYXNzIERpc3RhbmNlQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGlzdGFuY2VdIFRoZSBkaXN0YW5jZSB0byBrZWVwIGJldHdlZW4gdGhlIGFuY2hvciBwb2ludHMuIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvZGllcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmxvY2FsQW5jaG9yQV0gVGhlIGFuY2hvciBwb2ludCBmb3IgYm9keUEsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5QSBmcmFtZS4gRGVmYXVsdHMgdG8gWzAsMF0uXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5sb2NhbEFuY2hvckJdIFRoZSBhbmNob3IgcG9pbnQgZm9yIGJvZHlCLCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUIgZnJhbWUuIERlZmF1bHRzIHRvIFswLDBdLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm1heEZvcmNlPU51bWJlci5NQVhfVkFMVUVdIE1heGltdW0gZm9yY2UgdG8gYXBwbHkuXG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAvLyBJZiBkaXN0YW5jZSBpcyBub3QgZ2l2ZW4gYXMgYW4gb3B0aW9uLCB0aGVuIHRoZSBjdXJyZW50IGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvZGllcyBpcyB1c2VkLlxuICogICAgIC8vIEluIHRoaXMgZXhhbXBsZSwgdGhlIGJvZGllcyB3aWxsIGJlIGNvbnN0cmFpbmVkIHRvIGhhdmUgYSBkaXN0YW5jZSBvZiAyIGJldHdlZW4gdGhlaXIgY2VudGVycy5cbiAqICAgICB2YXIgYm9keUEgPSBuZXcgQm9keSh7IG1hc3M6IDEsIHBvc2l0aW9uOiBbLTEsIDBdIH0pO1xuICogICAgIHZhciBib2R5QiA9IG5ldyBCb2R5KHsgbWFzczogMSwgcG9zaXRpb246IFsxLCAwXSB9KTtcbiAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBEaXN0YW5jZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IERpc3RhbmNlQ29uc3RyYWludChib2R5QSwgYm9keUIsIHtcbiAqICAgICAgICAgZGlzdGFuY2U6IDEsICAgICAgICAgIC8vIERpc3RhbmNlIHRvIGtlZXAgYmV0d2VlbiB0aGUgcG9pbnRzXG4gKiAgICAgICAgIGxvY2FsQW5jaG9yQTogWzEsIDBdLCAvLyBQb2ludCBvbiBib2R5QVxuICogICAgICAgICBsb2NhbEFuY2hvckI6IFstMSwgMF0gLy8gUG9pbnQgb24gYm9keUJcbiAqICAgICB9KTtcbiAqL1xuZnVuY3Rpb24gRGlzdGFuY2VDb25zdHJhaW50KGJvZHlBLGJvZHlCLG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLHtcbiAgICAgICAgbG9jYWxBbmNob3JBOlswLDBdLFxuICAgICAgICBsb2NhbEFuY2hvckI6WzAsMF1cbiAgICB9KTtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLGJvZHlBLGJvZHlCLENvbnN0cmFpbnQuRElTVEFOQ0Usb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBMb2NhbCBhbmNob3IgaW4gYm9keSBBLlxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEFuY2hvckFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckEgPSB2ZWMyLmZyb21WYWx1ZXMob3B0aW9ucy5sb2NhbEFuY2hvckFbMF0sIG9wdGlvbnMubG9jYWxBbmNob3JBWzFdKTtcblxuICAgIC8qKlxuICAgICAqIExvY2FsIGFuY2hvciBpbiBib2R5IEIuXG4gICAgICogQHByb3BlcnR5IGxvY2FsQW5jaG9yQlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQW5jaG9yQiA9IHZlYzIuZnJvbVZhbHVlcyhvcHRpb25zLmxvY2FsQW5jaG9yQlswXSwgb3B0aW9ucy5sb2NhbEFuY2hvckJbMV0pO1xuXG4gICAgdmFyIGxvY2FsQW5jaG9yQSA9IHRoaXMubG9jYWxBbmNob3JBO1xuICAgIHZhciBsb2NhbEFuY2hvckIgPSB0aGlzLmxvY2FsQW5jaG9yQjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkaXN0YW5jZSB0byBrZWVwLlxuICAgICAqIEBwcm9wZXJ0eSBkaXN0YW5jZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kaXN0YW5jZSA9IDA7XG5cbiAgICBpZih0eXBlb2Yob3B0aW9ucy5kaXN0YW5jZSkgPT09ICdudW1iZXInKXtcbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNlIHRoZSBjdXJyZW50IHdvcmxkIGRpc3RhbmNlIGJldHdlZW4gdGhlIHdvcmxkIGFuY2hvciBwb2ludHMuXG4gICAgICAgIHZhciB3b3JsZEFuY2hvckEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgICAgICAgICAgd29ybGRBbmNob3JCID0gdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgICAgIHIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgICAgIC8vIFRyYW5zZm9ybSBsb2NhbCBhbmNob3JzIHRvIHdvcmxkXG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkQW5jaG9yQSwgbG9jYWxBbmNob3JBLCBib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkQW5jaG9yQiwgbG9jYWxBbmNob3JCLCBib2R5Qi5hbmdsZSk7XG5cbiAgICAgICAgdmVjMi5hZGQociwgYm9keUIucG9zaXRpb24sIHdvcmxkQW5jaG9yQik7XG4gICAgICAgIHZlYzIuc3ViKHIsIHIsIHdvcmxkQW5jaG9yQSk7XG4gICAgICAgIHZlYzIuc3ViKHIsIHIsIGJvZHlBLnBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLmRpc3RhbmNlID0gdmVjMi5sZW5ndGgocik7XG4gICAgfVxuXG4gICAgdmFyIG1heEZvcmNlO1xuICAgIGlmKHR5cGVvZihvcHRpb25zLm1heEZvcmNlKT09PVwidW5kZWZpbmVkXCIgKXtcbiAgICAgICAgbWF4Rm9yY2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1heEZvcmNlID0gb3B0aW9ucy5tYXhGb3JjZTtcbiAgICB9XG5cbiAgICB2YXIgbm9ybWFsID0gbmV3IEVxdWF0aW9uKGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSk7IC8vIEp1c3QgaW4gdGhlIG5vcm1hbCBkaXJlY3Rpb25cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFsgbm9ybWFsIF07XG5cbiAgICAvKipcbiAgICAgKiBNYXggZm9yY2UgdG8gYXBwbHkuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heEZvcmNlXG4gICAgICovXG4gICAgdGhpcy5tYXhGb3JjZSA9IG1heEZvcmNlO1xuXG4gICAgLy8gZyA9ICh4aSAtIHhqKS5kb3QobilcbiAgICAvLyBkZy9kdCA9ICh2aSAtIHZqKS5kb3QobikgPSBHKlcgPSBbbiAwIC1uIDBdICogW3ZpIHdpIHZqIHdqXSdcblxuICAgIC8vIC4uLmFuZCBpZiB3ZSB3ZXJlIHRvIGluY2x1ZGUgb2Zmc2V0IHBvaW50cyAoVE9ETyBmb3Igbm93KTpcbiAgICAvLyBnID1cbiAgICAvLyAgICAgICh4aiArIHJqIC0geGkgLSByaSkuZG90KG4pIC0gZGlzdGFuY2VcbiAgICAvL1xuICAgIC8vIGRnL2R0ID1cbiAgICAvLyAgICAgICh2aiArIHdqIHggcmogLSB2aSAtIHdpIHggcmkpLmRvdChuKSA9XG4gICAgLy8gICAgICB7IHRlcm0gMiBpcyBuZWFyIHplcm8gfSA9XG4gICAgLy8gICAgICBbLW4gICAtcmkgeCBuICAgbiAgIHJqIHggbl0gKiBbdmkgd2kgdmogd2pdJyA9XG4gICAgLy8gICAgICBHICogV1xuICAgIC8vXG4gICAgLy8gPT4gRyA9IFstbiAtcml4biBuIHJqeG5dXG5cbiAgICB2YXIgciA9IHZlYzIuY3JlYXRlKCk7XG4gICAgdmFyIHJpID0gdmVjMi5jcmVhdGUoKTsgLy8gd29ybGRBbmNob3JBXG4gICAgdmFyIHJqID0gdmVjMi5jcmVhdGUoKTsgLy8gd29ybGRBbmNob3JCXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIG5vcm1hbC5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICAgICAgeGkgPSBib2R5QS5wb3NpdGlvbixcbiAgICAgICAgICAgIHhqID0gYm9keUIucG9zaXRpb247XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtIGxvY2FsIGFuY2hvcnMgdG8gd29ybGRcbiAgICAgICAgdmVjMi5yb3RhdGUocmksIGxvY2FsQW5jaG9yQSwgYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZShyaiwgbG9jYWxBbmNob3JCLCBib2R5Qi5hbmdsZSk7XG5cbiAgICAgICAgdmVjMi5hZGQociwgeGosIHJqKTtcbiAgICAgICAgdmVjMi5zdWIociwgciwgcmkpO1xuICAgICAgICB2ZWMyLnN1YihyLCByLCB4aSk7XG5cbiAgICAgICAgLy92ZWMyLnN1YihyLCBib2R5Qi5wb3NpdGlvbiwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gdmVjMi5sZW5ndGgocikgLSB0aGF0LmRpc3RhbmNlO1xuICAgIH07XG5cbiAgICAvLyBNYWtlIHRoZSBjb250YWN0IGNvbnN0cmFpbnQgYmlsYXRlcmFsXG4gICAgdGhpcy5zZXRNYXhGb3JjZShtYXhGb3JjZSk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdXBwZXIgbGltaXQgaXMgZW5hYmxlZCBvciBub3QuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSB1cHBlckxpbWl0RW5hYmxlZFxuICAgICAqL1xuICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1cHBlciBjb25zdHJhaW50IGxpbWl0LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1cHBlckxpbWl0XG4gICAgICovXG4gICAgdGhpcy51cHBlckxpbWl0ID0gMTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBsb3dlciBsaW1pdCBpcyBlbmFibGVkIG9yIG5vdC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGxvd2VyTGltaXRFbmFibGVkXG4gICAgICovXG4gICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvd2VyIGNvbnN0cmFpbnQgbGltaXQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGxvd2VyTGltaXRcbiAgICAgKi9cbiAgICB0aGlzLmxvd2VyTGltaXQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBjb25zdHJhaW50IHBvc2l0aW9uLiBUaGlzIGlzIGVxdWFsIHRvIHRoZSBjdXJyZW50IGRpc3RhbmNlIGJldHdlZW4gdGhlIHdvcmxkIGFuY2hvciBwb2ludHMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHBvc2l0aW9uXG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IDA7XG59XG5EaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlID0gbmV3IENvbnN0cmFpbnQoKTtcbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaXN0YW5jZUNvbnN0cmFpbnQ7XG5cbi8qKlxuICogVXBkYXRlIHRoZSBjb25zdHJhaW50IGVxdWF0aW9ucy4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBib2RpZXMgY2hhbmdlZCBwb3NpdGlvbiwgYmVmb3JlIHNvbHZpbmcuXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG52YXIgbiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgcmkgPSB2ZWMyLmNyZWF0ZSgpOyAvLyB3b3JsZEFuY2hvckFcbnZhciByaiA9IHZlYzIuY3JlYXRlKCk7IC8vIHdvcmxkQW5jaG9yQlxuRGlzdGFuY2VDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBub3JtYWwgPSB0aGlzLmVxdWF0aW9uc1swXSxcbiAgICAgICAgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgIGRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZSxcbiAgICAgICAgeGkgPSBib2R5QS5wb3NpdGlvbixcbiAgICAgICAgeGogPSBib2R5Qi5wb3NpdGlvbixcbiAgICAgICAgbm9ybWFsRXF1YXRpb24gPSB0aGlzLmVxdWF0aW9uc1swXSxcbiAgICAgICAgRyA9IG5vcm1hbC5HO1xuXG4gICAgLy8gVHJhbnNmb3JtIGxvY2FsIGFuY2hvcnMgdG8gd29ybGRcbiAgICB2ZWMyLnJvdGF0ZShyaSwgdGhpcy5sb2NhbEFuY2hvckEsIGJvZHlBLmFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZShyaiwgdGhpcy5sb2NhbEFuY2hvckIsIGJvZHlCLmFuZ2xlKTtcblxuICAgIC8vIEdldCB3b3JsZCBhbmNob3IgcG9pbnRzIGFuZCBub3JtYWxcbiAgICB2ZWMyLmFkZChuLCB4aiwgcmopO1xuICAgIHZlYzIuc3ViKG4sIG4sIHJpKTtcbiAgICB2ZWMyLnN1YihuLCBuLCB4aSk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHZlYzIubGVuZ3RoKG4pO1xuXG4gICAgdmFyIHZpb2xhdGluZyA9IGZhbHNlO1xuICAgIGlmKHRoaXMudXBwZXJMaW1pdEVuYWJsZWQpe1xuICAgICAgICBpZih0aGlzLnBvc2l0aW9uID4gdGhpcy51cHBlckxpbWl0KXtcbiAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1heEZvcmNlID0gMDtcbiAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1pbkZvcmNlID0gLXRoaXMubWF4Rm9yY2U7XG4gICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gdGhpcy51cHBlckxpbWl0O1xuICAgICAgICAgICAgdmlvbGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQpe1xuICAgICAgICBpZih0aGlzLnBvc2l0aW9uIDwgdGhpcy5sb3dlckxpbWl0KXtcbiAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1heEZvcmNlID0gdGhpcy5tYXhGb3JjZTtcbiAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1pbkZvcmNlID0gMDtcbiAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSB0aGlzLmxvd2VyTGltaXQ7XG4gICAgICAgICAgICB2aW9sYXRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgfHwgdGhpcy51cHBlckxpbWl0RW5hYmxlZCkgJiYgIXZpb2xhdGluZyl7XG4gICAgICAgIC8vIE5vIGNvbnN0cmFpbnQgbmVlZGVkLlxuICAgICAgICBub3JtYWxFcXVhdGlvbi5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBub3JtYWxFcXVhdGlvbi5lbmFibGVkID0gdHJ1ZTtcblxuICAgIHZlYzIubm9ybWFsaXplKG4sbik7XG5cbiAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcbiAgICB2YXIgcml4biA9IHZlYzIuY3Jvc3NMZW5ndGgocmksIG4pLFxuICAgICAgICByanhuID0gdmVjMi5jcm9zc0xlbmd0aChyaiwgbik7XG5cbiAgICAvLyBHID0gWy1uIC1yaXhuIG4gcmp4bl1cbiAgICBHWzBdID0gLW5bMF07XG4gICAgR1sxXSA9IC1uWzFdO1xuICAgIEdbMl0gPSAtcml4bjtcbiAgICBHWzNdID0gblswXTtcbiAgICBHWzRdID0gblsxXTtcbiAgICBHWzVdID0gcmp4bjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXggZm9yY2UgdG8gYmUgdXNlZFxuICogQG1ldGhvZCBzZXRNYXhGb3JjZVxuICogQHBhcmFtIHtOdW1iZXJ9IGZcbiAqL1xuRGlzdGFuY2VDb25zdHJhaW50LnByb3RvdHlwZS5zZXRNYXhGb3JjZSA9IGZ1bmN0aW9uKGYpe1xuICAgIHZhciBub3JtYWwgPSB0aGlzLmVxdWF0aW9uc1swXTtcbiAgICBub3JtYWwubWluRm9yY2UgPSAtZjtcbiAgICBub3JtYWwubWF4Rm9yY2UgPSAgZjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBtYXggZm9yY2VcbiAqIEBtZXRob2QgZ2V0TWF4Rm9yY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRGlzdGFuY2VDb25zdHJhaW50LnByb3RvdHlwZS5nZXRNYXhGb3JjZSA9IGZ1bmN0aW9uKGYpe1xuICAgIHZhciBub3JtYWwgPSB0aGlzLmVxdWF0aW9uc1swXTtcbiAgICByZXR1cm4gbm9ybWFsLm1heEZvcmNlO1xufTtcblxufSx7XCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIjoyMyxcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vdXRpbHMvVXRpbHNcIjo1MCxcIi4vQ29uc3RyYWludFwiOjE1fV0sMTc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIENvbnN0cmFpbnQgPSBfZGVyZXFfKCcuL0NvbnN0cmFpbnQnKVxuLCAgIEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0VxdWF0aW9uJylcbiwgICBBbmdsZUxvY2tFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9BbmdsZUxvY2tFcXVhdGlvbicpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlYXJDb25zdHJhaW50O1xuXG4vKipcbiAqIENvbm5lY3RzIHR3byBib2RpZXMgYXQgZ2l2ZW4gb2Zmc2V0IHBvaW50cywgbGV0dGluZyB0aGVtIHJvdGF0ZSByZWxhdGl2ZSB0byBlYWNoIG90aGVyIGFyb3VuZCB0aGlzIHBvaW50LlxuICogQGNsYXNzIEdlYXJDb25zdHJhaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gICAgICAgICAgICBib2R5QVxuICogQHBhcmFtIHtCb2R5fSAgICAgICAgICAgIGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgW29wdGlvbnMuYW5nbGU9MF0gUmVsYXRpdmUgYW5nbGUgYmV0d2VlbiB0aGUgYm9kaWVzLiBXaWxsIGJlIHNldCB0byB0aGUgY3VycmVudCBhbmdsZSBiZXR3ZWVuIHRoZSBib2RpZXMgKHRoZSBnZWFyIHJhdGlvIGlzIGFjY291bnRlZCBmb3IpLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgIFtvcHRpb25zLnJhdGlvPTFdIEdlYXIgcmF0aW8uXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgW29wdGlvbnMubWF4VG9ycXVlXSBNYXhpbXVtIHRvcnF1ZSB0byBhcHBseS5cbiAqIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqIEB0b2RvIEFiaWxpdHkgdG8gc3BlY2lmeSB3b3JsZCBwb2ludHNcbiAqL1xuZnVuY3Rpb24gR2VhckNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIENvbnN0cmFpbnQuR0VBUiwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ2VhciByYXRpby5cbiAgICAgKiBAcHJvcGVydHkgcmF0aW9cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmF0aW8gPSB0eXBlb2Yob3B0aW9ucy5yYXRpbykgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zLnJhdGlvIDogMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZWxhdGl2ZSBhbmdsZVxuICAgICAqIEBwcm9wZXJ0eSBhbmdsZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hbmdsZSA9IHR5cGVvZihvcHRpb25zLmFuZ2xlKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMuYW5nbGUgOiBib2R5Qi5hbmdsZSAtIHRoaXMucmF0aW8gKiBib2R5QS5hbmdsZTtcblxuICAgIC8vIFNlbmQgc2FtZSBwYXJhbWV0ZXJzIHRvIHRoZSBlcXVhdGlvblxuICAgIG9wdGlvbnMuYW5nbGUgPSB0aGlzLmFuZ2xlO1xuICAgIG9wdGlvbnMucmF0aW8gPSB0aGlzLnJhdGlvO1xuXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXG4gICAgICAgIG5ldyBBbmdsZUxvY2tFcXVhdGlvbihib2R5QSxib2R5QixvcHRpb25zKSxcbiAgICBdO1xuXG4gICAgLy8gU2V0IG1heCB0b3JxdWVcbiAgICBpZih0eXBlb2Yob3B0aW9ucy5tYXhUb3JxdWUpID09PSBcIm51bWJlclwiKXtcbiAgICAgICAgdGhpcy5zZXRNYXhUb3JxdWUob3B0aW9ucy5tYXhUb3JxdWUpO1xuICAgIH1cbn1cbkdlYXJDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBDb25zdHJhaW50KCk7XG5HZWFyQ29uc3RyYWludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZWFyQ29uc3RyYWludDtcblxuR2VhckNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVxID0gdGhpcy5lcXVhdGlvbnNbMF07XG4gICAgaWYoZXEucmF0aW8gIT09IHRoaXMucmF0aW8pe1xuICAgICAgICBlcS5zZXRSYXRpbyh0aGlzLnJhdGlvKTtcbiAgICB9XG4gICAgZXEuYW5nbGUgPSB0aGlzLmFuZ2xlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heCB0b3JxdWUgZm9yIHRoZSBjb25zdHJhaW50LlxuICogQG1ldGhvZCBzZXRNYXhUb3JxdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3JxdWVcbiAqL1xuR2VhckNvbnN0cmFpbnQucHJvdG90eXBlLnNldE1heFRvcnF1ZSA9IGZ1bmN0aW9uKHRvcnF1ZSl7XG4gICAgdGhpcy5lcXVhdGlvbnNbMF0uc2V0TWF4VG9ycXVlKHRvcnF1ZSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWF4IHRvcnF1ZSBmb3IgdGhlIGNvbnN0cmFpbnQuXG4gKiBAbWV0aG9kIGdldE1heFRvcnF1ZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5HZWFyQ29uc3RyYWludC5wcm90b3R5cGUuZ2V0TWF4VG9ycXVlID0gZnVuY3Rpb24odG9ycXVlKXtcbiAgICByZXR1cm4gdGhpcy5lcXVhdGlvbnNbMF0ubWF4Rm9yY2U7XG59O1xufSx7XCIuLi9lcXVhdGlvbnMvQW5nbGVMb2NrRXF1YXRpb25cIjoyMSxcIi4uL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIzLFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL0NvbnN0cmFpbnRcIjoxNX1dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50JylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvY2tDb25zdHJhaW50O1xuXG4vKipcbiAqIExvY2tzIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBiZXR3ZWVuIHR3byBib2RpZXMuXG4gKlxuICogQGNsYXNzIExvY2tDb25zdHJhaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5sb2NhbE9mZnNldEJdIFRoZSBvZmZzZXQgb2YgYm9keUIgaW4gYm9keUEncyBmcmFtZS4gSWYgbm90IGdpdmVuIHRoZSBvZmZzZXQgaXMgY29tcHV0ZWQgZnJvbSBjdXJyZW50IHBvc2l0aW9ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sb2NhbEFuZ2xlQl0gVGhlIGFuZ2xlIG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuIElmIG5vdCBnaXZlbiwgdGhlIGFuZ2xlIGlzIGNvbXB1dGVkIGZyb20gY3VycmVudCBhbmdsZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4Rm9yY2VdXG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKi9cbmZ1bmN0aW9uIExvY2tDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBDb25zdHJhaW50LmNhbGwodGhpcyxib2R5QSxib2R5QixDb25zdHJhaW50LkxPQ0ssb3B0aW9ucyk7XG5cbiAgICB2YXIgbWF4Rm9yY2UgPSAoIHR5cGVvZihvcHRpb25zLm1heEZvcmNlKT09PVwidW5kZWZpbmVkXCIgPyBOdW1iZXIuTUFYX1ZBTFVFIDogb3B0aW9ucy5tYXhGb3JjZSApO1xuXG4gICAgdmFyIGxvY2FsQW5nbGVCID0gb3B0aW9ucy5sb2NhbEFuZ2xlQiB8fCAwO1xuXG4gICAgLy8gVXNlIDMgZXF1YXRpb25zOlxuICAgIC8vIGd4ID0gICAoeGogLSB4aSAtIGwpICogeGhhdCA9IDBcbiAgICAvLyBneSA9ICAgKHhqIC0geGkgLSBsKSAqIHloYXQgPSAwXG4gICAgLy8gZ3IgPSAgICh4aSAtIHhqICsgcikgKiB0aGF0ID0gMFxuICAgIC8vXG4gICAgLy8gLi4ud2hlcmU6XG4gICAgLy8gICBsIGlzIHRoZSBsb2NhbE9mZnNldEIgdmVjdG9yIHJvdGF0ZWQgdG8gd29ybGQgaW4gYm9keUEgZnJhbWVcbiAgICAvLyAgIHIgaXMgdGhlIHNhbWUgdmVjdG9yIGJ1dCByZXZlcnNlZCBhbmQgcm90YXRlZCBmcm9tIGJvZHlCIGZyYW1lXG4gICAgLy8gICB4aGF0LCB5aGF0IGFyZSB3b3JsZCBheGlzIHZlY3RvcnNcbiAgICAvLyAgIHRoYXQgaXMgdGhlIHRhbmdlbnQgb2YgclxuICAgIC8vXG4gICAgLy8gRm9yIHRoZSBmaXJzdCB0d28gY29uc3RyYWludHMsIHdlIGdldFxuICAgIC8vIEcqVyA9ICh2aiAtIHZpIC0gbGRvdCAgKSAqIHhoYXRcbiAgICAvLyAgICAgPSAodmogLSB2aSAtIHdpIHggbCkgKiB4aGF0XG4gICAgLy9cbiAgICAvLyBTaW5jZSAod2kgeCBsKSAqIHhoYXQgPSAobCB4IHhoYXQpICogd2ksIHdlIGdldFxuICAgIC8vIEcqVyA9IFsgLTEgICAwICAgKC1sIHggeGhhdCkgIDEgICAwICAgMF0gKiBbdmkgd2kgdmogd2pdXG4gICAgLy9cbiAgICAvLyBUaGUgbGFzdCBjb25zdHJhaW50IGdpdmVzXG4gICAgLy8gR1cgPSAodmkgLSB2aiArIHdqIHggcikgKiB0aGF0XG4gICAgLy8gICAgPSBbICB0aGF0ICAgMCAgLXRoYXQgIChyIHggdCkgXVxuXG4gICAgdmFyIHggPSAgICAgbmV3IEVxdWF0aW9uKGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSksXG4gICAgICAgIHkgPSAgICAgbmV3IEVxdWF0aW9uKGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSksXG4gICAgICAgIHJvdCA9ICAgbmV3IEVxdWF0aW9uKGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSk7XG5cbiAgICB2YXIgbCA9IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIGcgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgICAgICB0aGF0ID0gdGhpcztcbiAgICB4LmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZlYzIucm90YXRlKGwsIHRoYXQubG9jYWxPZmZzZXRCLCBib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIuc3ViKGcsIGJvZHlCLnBvc2l0aW9uLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc3ViKGcsIGcsIGwpO1xuICAgICAgICByZXR1cm4gZ1swXTtcbiAgICB9O1xuICAgIHkuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmVjMi5yb3RhdGUobCwgdGhhdC5sb2NhbE9mZnNldEIsIGJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5zdWIoZywgYm9keUIucG9zaXRpb24sIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIoZywgZywgbCk7XG4gICAgICAgIHJldHVybiBnWzFdO1xuICAgIH07XG4gICAgdmFyIHIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgICAgICB0ID0gdmVjMi5jcmVhdGUoKTtcbiAgICByb3QuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmVjMi5yb3RhdGUociwgdGhhdC5sb2NhbE9mZnNldEIsIGJvZHlCLmFuZ2xlIC0gdGhhdC5sb2NhbEFuZ2xlQik7XG4gICAgICAgIHZlYzIuc2NhbGUocixyLC0xKTtcbiAgICAgICAgdmVjMi5zdWIoZyxib2R5QS5wb3NpdGlvbixib2R5Qi5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuYWRkKGcsZyxyKTtcbiAgICAgICAgdmVjMi5yb3RhdGUodCxyLC1NYXRoLlBJLzIpO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZSh0LHQpO1xuICAgICAgICByZXR1cm4gdmVjMi5kb3QoZyx0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9mZnNldCBvZiBib2R5QiBpbiBib2R5QSdzIGZyYW1lLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGxvY2FsT2Zmc2V0QlxuICAgICAqL1xuICAgIHRoaXMubG9jYWxPZmZzZXRCID0gdmVjMi5jcmVhdGUoKTtcbiAgICBpZihvcHRpb25zLmxvY2FsT2Zmc2V0Qil7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmxvY2FsT2Zmc2V0Qiwgb3B0aW9ucy5sb2NhbE9mZnNldEIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbnN0cnVjdCBmcm9tIGN1cnJlbnQgcG9zaXRpb25zXG4gICAgICAgIHZlYzIuc3ViKHRoaXMubG9jYWxPZmZzZXRCLCBib2R5Qi5wb3NpdGlvbiwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh0aGlzLmxvY2FsT2Zmc2V0QiwgdGhpcy5sb2NhbE9mZnNldEIsIC1ib2R5QS5hbmdsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9mZnNldCBhbmdsZSBvZiBib2R5QiBpbiBib2R5QSdzIGZyYW1lLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsb2NhbEFuZ2xlQlxuICAgICAqL1xuICAgIHRoaXMubG9jYWxBbmdsZUIgPSAwO1xuICAgIGlmKHR5cGVvZihvcHRpb25zLmxvY2FsQW5nbGVCKSA9PT0gJ251bWJlcicpe1xuICAgICAgICB0aGlzLmxvY2FsQW5nbGVCID0gb3B0aW9ucy5sb2NhbEFuZ2xlQjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb25zdHJ1Y3RcbiAgICAgICAgdGhpcy5sb2NhbEFuZ2xlQiA9IGJvZHlCLmFuZ2xlIC0gYm9keUEuYW5nbGU7XG4gICAgfVxuXG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaCh4LCB5LCByb3QpO1xuICAgIHRoaXMuc2V0TWF4Rm9yY2UobWF4Rm9yY2UpO1xufVxuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlID0gbmV3IENvbnN0cmFpbnQoKTtcbkxvY2tDb25zdHJhaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvY2tDb25zdHJhaW50O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4aW11bSBmb3JjZSB0byBiZSBhcHBsaWVkLlxuICogQG1ldGhvZCBzZXRNYXhGb3JjZVxuICogQHBhcmFtIHtOdW1iZXJ9IGZvcmNlXG4gKi9cbkxvY2tDb25zdHJhaW50LnByb3RvdHlwZS5zZXRNYXhGb3JjZSA9IGZ1bmN0aW9uKGZvcmNlKXtcbiAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnM7XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5lcXVhdGlvbnMubGVuZ3RoOyBpKyspe1xuICAgICAgICBlcXNbaV0ubWF4Rm9yY2UgPSAgZm9yY2U7XG4gICAgICAgIGVxc1tpXS5taW5Gb3JjZSA9IC1mb3JjZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWF4IGZvcmNlLlxuICogQG1ldGhvZCBnZXRNYXhGb3JjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Mb2NrQ29uc3RyYWludC5wcm90b3R5cGUuZ2V0TWF4Rm9yY2UgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmVxdWF0aW9uc1swXS5tYXhGb3JjZTtcbn07XG5cbnZhciBsID0gdmVjMi5jcmVhdGUoKTtcbnZhciByID0gdmVjMi5jcmVhdGUoKTtcbnZhciB0ID0gdmVjMi5jcmVhdGUoKTtcbnZhciB4QXhpcyA9IHZlYzIuZnJvbVZhbHVlcygxLDApO1xudmFyIHlBeGlzID0gdmVjMi5mcm9tVmFsdWVzKDAsMSk7XG5Mb2NrQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgeCA9ICAgdGhpcy5lcXVhdGlvbnNbMF0sXG4gICAgICAgIHkgPSAgIHRoaXMuZXF1YXRpb25zWzFdLFxuICAgICAgICByb3QgPSB0aGlzLmVxdWF0aW9uc1syXSxcbiAgICAgICAgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUI7XG5cbiAgICB2ZWMyLnJvdGF0ZShsLHRoaXMubG9jYWxPZmZzZXRCLGJvZHlBLmFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZShyLHRoaXMubG9jYWxPZmZzZXRCLGJvZHlCLmFuZ2xlIC0gdGhpcy5sb2NhbEFuZ2xlQik7XG4gICAgdmVjMi5zY2FsZShyLHIsLTEpO1xuXG4gICAgdmVjMi5yb3RhdGUodCxyLE1hdGguUEkvMik7XG4gICAgdmVjMi5ub3JtYWxpemUodCx0KTtcblxuICAgIHguR1swXSA9IC0xO1xuICAgIHguR1sxXSA9ICAwO1xuICAgIHguR1syXSA9IC12ZWMyLmNyb3NzTGVuZ3RoKGwseEF4aXMpO1xuICAgIHguR1szXSA9ICAxO1xuXG4gICAgeS5HWzBdID0gIDA7XG4gICAgeS5HWzFdID0gLTE7XG4gICAgeS5HWzJdID0gLXZlYzIuY3Jvc3NMZW5ndGgobCx5QXhpcyk7XG4gICAgeS5HWzRdID0gIDE7XG5cbiAgICByb3QuR1swXSA9ICAtdFswXTtcbiAgICByb3QuR1sxXSA9ICAtdFsxXTtcbiAgICByb3QuR1szXSA9ICB0WzBdO1xuICAgIHJvdC5HWzRdID0gIHRbMV07XG4gICAgcm90LkdbNV0gPSAgdmVjMi5jcm9zc0xlbmd0aChyLHQpO1xufTtcblxufSx7XCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIjoyMyxcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9Db25zdHJhaW50XCI6MTV9XSwxOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4vQ29uc3RyYWludCcpXG4sICAgQ29udGFjdEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpXG4sICAgRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvRXF1YXRpb24nKVxuLCAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIFJvdGF0aW9uYWxMb2NrRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbExvY2tFcXVhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByaXNtYXRpY0NvbnN0cmFpbnQ7XG5cbi8qKlxuICogQ29uc3RyYWludCB0aGF0IG9ubHkgYWxsb3dzIGJvZGllcyB0byBtb3ZlIGFsb25nIGEgbGluZSwgcmVsYXRpdmUgdG8gZWFjaCBvdGhlci4gU2VlIDxhIGhyZWY9XCJodHRwOi8vd3d3Lmlmb3JjZTJkLm5ldC9iMmR0dXQvam9pbnRzLXByaXNtYXRpY1wiPnRoaXMgdHV0b3JpYWw8L2E+LlxuICpcbiAqIEBjbGFzcyBQcmlzbWF0aWNDb25zdHJhaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gICAgYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gICAgYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSAgW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gIFtvcHRpb25zLm1heEZvcmNlXSAgICAgICAgICAgICAgICBNYXggZm9yY2UgdG8gYmUgYXBwbGllZCBieSB0aGUgY29uc3RyYWludFxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb2NhbEFuY2hvckFdICAgICAgICAgICAgQm9keSBBJ3MgYW5jaG9yIHBvaW50LCBkZWZpbmVkIGluIGl0cyBvd24gbG9jYWwgZnJhbWUuXG4gKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLmxvY2FsQW5jaG9yQl0gICAgICAgICAgICBCb2R5IEIncyBhbmNob3IgcG9pbnQsIGRlZmluZWQgaW4gaXRzIG93biBsb2NhbCBmcmFtZS5cbiAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMubG9jYWxBeGlzQV0gICAgICAgICAgICAgIEFuIGF4aXMsIGRlZmluZWQgaW4gYm9keSBBIGZyYW1lLCB0aGF0IGJvZHkgQidzIGFuY2hvciBwb2ludCBtYXkgc2xpZGUgYWxvbmcuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRpc2FibGVSb3RhdGlvbmFsTG9ja10gICBJZiBzZXQgdG8gdHJ1ZSwgYm9keUIgd2lsbCBiZSBmcmVlIHRvIHJvdGF0ZSBhcm91bmQgaXRzIGFuY2hvciBwb2ludC5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgW29wdGlvbnMudXBwZXJMaW1pdF1cbiAqIEBwYXJhbSB7TnVtYmVyfSAgW29wdGlvbnMubG93ZXJMaW1pdF1cbiAqIEB0b2RvIEFiaWxpdHkgdG8gY3JlYXRlIHVzaW5nIG9ubHkgYSBwb2ludCBhbmQgYSB3b3JsZEF4aXNcbiAqL1xuZnVuY3Rpb24gUHJpc21hdGljQ29uc3RyYWludChib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLGJvZHlBLGJvZHlCLENvbnN0cmFpbnQuUFJJU01BVElDLG9wdGlvbnMpO1xuXG4gICAgLy8gR2V0IGFuY2hvcnNcbiAgICB2YXIgbG9jYWxBbmNob3JBID0gdmVjMi5mcm9tVmFsdWVzKDAsMCksXG4gICAgICAgIGxvY2FsQXhpc0EgPSB2ZWMyLmZyb21WYWx1ZXMoMSwwKSxcbiAgICAgICAgbG9jYWxBbmNob3JCID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG4gICAgaWYob3B0aW9ucy5sb2NhbEFuY2hvckEpeyB2ZWMyLmNvcHkobG9jYWxBbmNob3JBLCBvcHRpb25zLmxvY2FsQW5jaG9yQSk7IH1cbiAgICBpZihvcHRpb25zLmxvY2FsQXhpc0EpeyB2ZWMyLmNvcHkobG9jYWxBeGlzQSwgICBvcHRpb25zLmxvY2FsQXhpc0EpOyB9XG4gICAgaWYob3B0aW9ucy5sb2NhbEFuY2hvckIpeyB2ZWMyLmNvcHkobG9jYWxBbmNob3JCLCBvcHRpb25zLmxvY2FsQW5jaG9yQik7IH1cblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEFuY2hvckFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckEgPSBsb2NhbEFuY2hvckE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JCXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxBbmNob3JCID0gbG9jYWxBbmNob3JCO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGxvY2FsQXhpc0FcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEF4aXNBID0gbG9jYWxBeGlzQTtcblxuICAgIC8qXG5cbiAgICBUaGUgY29uc3RyYWludCB2aW9sYXRpb24gZm9yIHRoZSBjb21tb24gYXhpcyBwb2ludCBpc1xuXG4gICAgICAgIGcgPSAoIHhqICsgcmogLSB4aSAtIHJpICkgKiB0ICAgOj0gIGdnKnRcblxuICAgIHdoZXJlIHIgYXJlIGJvZHktbG9jYWwgYW5jaG9yIHBvaW50cywgYW5kIHQgaXMgYSB0YW5nZW50IHRvIHRoZSBjb25zdHJhaW50IGF4aXMgZGVmaW5lZCBpbiBib2R5IGkgZnJhbWUuXG5cbiAgICAgICAgZ2RvdCA9ICAoIHZqICsgd2ogeCByaiAtIHZpIC0gd2kgeCByaSApICogdCArICggeGogKyByaiAtIHhpIC0gcmkgKSAqICggd2kgeCB0IClcblxuICAgIE5vdGUgdGhlIHVzZSBvZiB0aGUgY2hhaW4gcnVsZS4gTm93IHdlIGlkZW50aWZ5IHRoZSBqYWNvYmlhblxuXG4gICAgICAgIEcqVyA9IFsgLXQgICAgICAtcmkgeCB0ICsgdCB4IGdnICAgICB0ICAgIHJqIHggdCBdICogW3ZpIHdpIHZqIHdqXVxuXG4gICAgVGhlIHJvdGF0aW9uYWwgcGFydCBpcyBqdXN0IGEgcm90YXRpb24gbG9jay5cblxuICAgICAqL1xuXG4gICAgdmFyIG1heEZvcmNlID0gdGhpcy5tYXhGb3JjZSA9IHR5cGVvZihvcHRpb25zLm1heEZvcmNlKSE9PVwidW5kZWZpbmVkXCIgPyBvcHRpb25zLm1heEZvcmNlIDogTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIC8vIFRyYW5zbGF0aW9uYWwgcGFydFxuICAgIHZhciB0cmFucyA9IG5ldyBFcXVhdGlvbihib2R5QSxib2R5QiwtbWF4Rm9yY2UsbWF4Rm9yY2UpO1xuICAgIHZhciByaSA9IG5ldyB2ZWMyLmNyZWF0ZSgpLFxuICAgICAgICByaiA9IG5ldyB2ZWMyLmNyZWF0ZSgpLFxuICAgICAgICBnZyA9IG5ldyB2ZWMyLmNyZWF0ZSgpLFxuICAgICAgICB0ID0gIG5ldyB2ZWMyLmNyZWF0ZSgpO1xuICAgIHRyYW5zLmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIGcgPSAoIHhqICsgcmogLSB4aSAtIHJpICkgKiB0XG4gICAgICAgIHJldHVybiB2ZWMyLmRvdChnZyx0KTtcbiAgICB9O1xuICAgIHRyYW5zLnVwZGF0ZUphY29iaWFuID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIEcgPSB0aGlzLkcsXG4gICAgICAgICAgICB4aSA9IGJvZHlBLnBvc2l0aW9uLFxuICAgICAgICAgICAgeGogPSBib2R5Qi5wb3NpdGlvbjtcbiAgICAgICAgdmVjMi5yb3RhdGUocmksbG9jYWxBbmNob3JBLGJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUocmosbG9jYWxBbmNob3JCLGJvZHlCLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5hZGQoZ2cseGoscmopO1xuICAgICAgICB2ZWMyLnN1YihnZyxnZyx4aSk7XG4gICAgICAgIHZlYzIuc3ViKGdnLGdnLHJpKTtcbiAgICAgICAgdmVjMi5yb3RhdGUodCxsb2NhbEF4aXNBLGJvZHlBLmFuZ2xlK01hdGguUEkvMik7XG5cbiAgICAgICAgR1swXSA9IC10WzBdO1xuICAgICAgICBHWzFdID0gLXRbMV07XG4gICAgICAgIEdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aChyaSx0KSArIHZlYzIuY3Jvc3NMZW5ndGgodCxnZyk7XG4gICAgICAgIEdbM10gPSB0WzBdO1xuICAgICAgICBHWzRdID0gdFsxXTtcbiAgICAgICAgR1s1XSA9IHZlYzIuY3Jvc3NMZW5ndGgocmosdCk7XG4gICAgfTtcbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHRyYW5zKTtcblxuICAgIC8vIFJvdGF0aW9uYWwgcGFydFxuICAgIGlmKCFvcHRpb25zLmRpc2FibGVSb3RhdGlvbmFsTG9jayl7XG4gICAgICAgIHZhciByb3QgPSBuZXcgUm90YXRpb25hbExvY2tFcXVhdGlvbihib2R5QSxib2R5QiwtbWF4Rm9yY2UsbWF4Rm9yY2UpO1xuICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHJvdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHBvc2l0aW9uIG9mIGFuY2hvciBBIHJlbGF0aXZlIHRvIGFuY2hvciBCLCBhbG9uZyB0aGUgY29uc3RyYWludCBheGlzLlxuICAgICAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IDA7XG5cbiAgICAvLyBJcyB0aGlzIG9uZSB1c2VkIGF0IGFsbD9cbiAgICB0aGlzLnZlbG9jaXR5ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGVuYWJsZSBsb3dlciBsaW1pdC5cbiAgICAgKiBAcHJvcGVydHkgbG93ZXJMaW1pdEVuYWJsZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gdHlwZW9mKG9wdGlvbnMubG93ZXJMaW1pdCkhPT1cInVuZGVmaW5lZFwiID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIHVwcGVyIGxpbWl0LlxuICAgICAqIEBwcm9wZXJ0eSB1cHBlckxpbWl0RW5hYmxlZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSB0eXBlb2Yob3B0aW9ucy51cHBlckxpbWl0KSE9PVwidW5kZWZpbmVkXCIgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBMb3dlciBjb25zdHJhaW50IGxpbWl0LiBUaGUgY29uc3RyYWludCBwb3NpdGlvbiBpcyBmb3JjZWQgdG8gYmUgbGFyZ2VyIHRoYW4gdGhpcyB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkgbG93ZXJMaW1pdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sb3dlckxpbWl0ID0gdHlwZW9mKG9wdGlvbnMubG93ZXJMaW1pdCkhPT1cInVuZGVmaW5lZFwiID8gb3B0aW9ucy5sb3dlckxpbWl0IDogMDtcblxuICAgIC8qKlxuICAgICAqIFVwcGVyIGNvbnN0cmFpbnQgbGltaXQuIFRoZSBjb25zdHJhaW50IHBvc2l0aW9uIGlzIGZvcmNlZCB0byBiZSBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkgdXBwZXJMaW1pdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy51cHBlckxpbWl0ID0gdHlwZW9mKG9wdGlvbnMudXBwZXJMaW1pdCkhPT1cInVuZGVmaW5lZFwiID8gb3B0aW9ucy51cHBlckxpbWl0IDogMTtcblxuICAgIC8vIEVxdWF0aW9ucyB1c2VkIGZvciBsaW1pdHNcbiAgICB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbiA9IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsYm9keUIpO1xuICAgIHRoaXMubG93ZXJMaW1pdEVxdWF0aW9uID0gbmV3IENvbnRhY3RFcXVhdGlvbihib2R5QSxib2R5Qik7XG5cbiAgICAvLyBTZXQgbWF4L21pbiBmb3JjZXNcbiAgICB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbi5taW5Gb3JjZSA9IHRoaXMubG93ZXJMaW1pdEVxdWF0aW9uLm1pbkZvcmNlID0gMDtcbiAgICB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbi5tYXhGb3JjZSA9IHRoaXMubG93ZXJMaW1pdEVxdWF0aW9uLm1heEZvcmNlID0gbWF4Rm9yY2U7XG5cbiAgICAvKipcbiAgICAgKiBFcXVhdGlvbiB1c2VkIGZvciB0aGUgbW90b3IuXG4gICAgICogQHByb3BlcnR5IG1vdG9yRXF1YXRpb25cbiAgICAgKiBAdHlwZSB7RXF1YXRpb259XG4gICAgICovXG4gICAgdGhpcy5tb3RvckVxdWF0aW9uID0gbmV3IEVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IG1vdG9yIHN0YXRlLiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgbW90b3IgdXNpbmcgLmVuYWJsZU1vdG9yXG4gICAgICogQHByb3BlcnR5IG1vdG9yRW5hYmxlZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubW90b3JFbmFibGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHRhcmdldCBzcGVlZCBmb3IgdGhlIG1vdG9yLlxuICAgICAqIEBwcm9wZXJ0eSBtb3RvclNwZWVkXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1vdG9yU3BlZWQgPSAwO1xuXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBtb3RvckVxdWF0aW9uID0gdGhpcy5tb3RvckVxdWF0aW9uO1xuICAgIHZhciBvbGQgPSBtb3RvckVxdWF0aW9uLmNvbXB1dGVHVztcbiAgICBtb3RvckVxdWF0aW9uLmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7IHJldHVybiAwOyB9O1xuICAgIG1vdG9yRXF1YXRpb24uY29tcHV0ZUdXID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIEcgPSB0aGlzLkcsXG4gICAgICAgICAgICBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgICAgICB2aSA9IGJpLnZlbG9jaXR5LFxuICAgICAgICAgICAgdmogPSBiai52ZWxvY2l0eSxcbiAgICAgICAgICAgIHdpID0gYmkuYW5ndWxhclZlbG9jaXR5LFxuICAgICAgICAgICAgd2ogPSBiai5hbmd1bGFyVmVsb2NpdHk7XG4gICAgICAgIHJldHVybiB0aGlzLmdtdWx0KEcsdmksd2ksdmosd2opICsgdGhhdC5tb3RvclNwZWVkO1xuICAgIH07XG59XG5cblByaXNtYXRpY0NvbnN0cmFpbnQucHJvdG90eXBlID0gbmV3IENvbnN0cmFpbnQoKTtcblByaXNtYXRpY0NvbnN0cmFpbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHJpc21hdGljQ29uc3RyYWludDtcblxudmFyIHdvcmxkQXhpc0EgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHdvcmxkQW5jaG9yQSA9IHZlYzIuY3JlYXRlKCksXG4gICAgd29ybGRBbmNob3JCID0gdmVjMi5jcmVhdGUoKSxcbiAgICBvcmllbnRlZEFuY2hvckEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIG9yaWVudGVkQW5jaG9yQiA9IHZlYzIuY3JlYXRlKCksXG4gICAgdG1wID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGNvbnN0cmFpbnQgZXF1YXRpb25zLiBTaG91bGQgYmUgZG9uZSBpZiBhbnkgb2YgdGhlIGJvZGllcyBjaGFuZ2VkIHBvc2l0aW9uLCBiZWZvcmUgc29sdmluZy5cbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cblByaXNtYXRpY0NvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zLFxuICAgICAgICB0cmFucyA9IGVxc1swXSxcbiAgICAgICAgdXBwZXJMaW1pdCA9IHRoaXMudXBwZXJMaW1pdCxcbiAgICAgICAgbG93ZXJMaW1pdCA9IHRoaXMubG93ZXJMaW1pdCxcbiAgICAgICAgdXBwZXJMaW1pdEVxdWF0aW9uID0gdGhpcy51cHBlckxpbWl0RXF1YXRpb24sXG4gICAgICAgIGxvd2VyTGltaXRFcXVhdGlvbiA9IHRoaXMubG93ZXJMaW1pdEVxdWF0aW9uLFxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcbiAgICAgICAgbG9jYWxBeGlzQSA9IHRoaXMubG9jYWxBeGlzQSxcbiAgICAgICAgbG9jYWxBbmNob3JBID0gdGhpcy5sb2NhbEFuY2hvckEsXG4gICAgICAgIGxvY2FsQW5jaG9yQiA9IHRoaXMubG9jYWxBbmNob3JCO1xuXG4gICAgdHJhbnMudXBkYXRlSmFjb2JpYW4oKTtcblxuICAgIC8vIFRyYW5zZm9ybSBsb2NhbCB0aGluZ3MgdG8gd29ybGRcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZEF4aXNBLCAgICAgIGxvY2FsQXhpc0EsICAgICAgYm9keUEuYW5nbGUpO1xuICAgIHZlYzIucm90YXRlKG9yaWVudGVkQW5jaG9yQSwgbG9jYWxBbmNob3JBLCAgICBib2R5QS5hbmdsZSk7XG4gICAgdmVjMi5hZGQod29ybGRBbmNob3JBLCAgICAgICBvcmllbnRlZEFuY2hvckEsIGJvZHlBLnBvc2l0aW9uKTtcbiAgICB2ZWMyLnJvdGF0ZShvcmllbnRlZEFuY2hvckIsIGxvY2FsQW5jaG9yQiwgICAgYm9keUIuYW5nbGUpO1xuICAgIHZlYzIuYWRkKHdvcmxkQW5jaG9yQiwgICAgICAgb3JpZW50ZWRBbmNob3JCLCBib2R5Qi5wb3NpdGlvbik7XG5cbiAgICB2YXIgcmVsUG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uID0gdmVjMi5kb3Qod29ybGRBbmNob3JCLHdvcmxkQXhpc0EpIC0gdmVjMi5kb3Qod29ybGRBbmNob3JBLHdvcmxkQXhpc0EpO1xuXG4gICAgLy8gTW90b3JcbiAgICBpZih0aGlzLm1vdG9yRW5hYmxlZCl7XG4gICAgICAgIC8vIEcgPSBbIGEgICAgIGEgeCByaSAgIC1hICAgLWEgeCByaiBdXG4gICAgICAgIHZhciBHID0gdGhpcy5tb3RvckVxdWF0aW9uLkc7XG4gICAgICAgIEdbMF0gPSB3b3JsZEF4aXNBWzBdO1xuICAgICAgICBHWzFdID0gd29ybGRBeGlzQVsxXTtcbiAgICAgICAgR1syXSA9IHZlYzIuY3Jvc3NMZW5ndGgod29ybGRBeGlzQSxvcmllbnRlZEFuY2hvckIpO1xuICAgICAgICBHWzNdID0gLXdvcmxkQXhpc0FbMF07XG4gICAgICAgIEdbNF0gPSAtd29ybGRBeGlzQVsxXTtcbiAgICAgICAgR1s1XSA9IC12ZWMyLmNyb3NzTGVuZ3RoKHdvcmxkQXhpc0Esb3JpZW50ZWRBbmNob3JBKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAgICBMaW1pdHMgc3RyYXRlZ3k6XG4gICAgICAgIEFkZCBjb250YWN0IGVxdWF0aW9uLCB3aXRoIG5vcm1hbCBhbG9uZyB0aGUgY29uc3RyYWludCBheGlzLlxuICAgICAgICBtaW4vbWF4Rm9yY2UgaXMgc2V0IHNvIHRoZSBjb25zdHJhaW50IGlzIHJlcHVsc2l2ZSBpbiB0aGUgY29ycmVjdCBkaXJlY3Rpb24uXG4gICAgICAgIFNvbWUgb2Zmc2V0IGlzIGFkZGVkIHRvIGVpdGhlciBlcXVhdGlvbi5jb250YWN0UG9pbnRBIG9yIC5jb250YWN0UG9pbnRCIHRvIGdldCB0aGUgY29ycmVjdCB1cHBlci9sb3dlciBsaW1pdC5cblxuICAgICAgICAgICAgICAgICBeXG4gICAgICAgICAgICAgICAgIHxcbiAgICAgIHVwcGVyTGltaXQgeFxuICAgICAgICAgICAgICAgICB8ICAgIC0tLS0tLVxuICAgICAgICAgYW5jaG9yQiB4PC0tLXwgIEIgfFxuICAgICAgICAgICAgICAgICB8ICAgIHwgICAgfFxuICAgICAgICAtLS0tLS0gICB8ICAgIC0tLS0tLVxuICAgICAgICB8ICAgIHwgICB8XG4gICAgICAgIHwgIEEgfC0tPnggYW5jaG9yQVxuICAgICAgICAtLS0tLS0gICB8XG4gICAgICAgICAgICAgICAgIHggbG93ZXJMaW1pdFxuICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgYXhpc1xuICAgICAqL1xuXG5cbiAgICBpZih0aGlzLnVwcGVyTGltaXRFbmFibGVkICYmIHJlbFBvc2l0aW9uID4gdXBwZXJMaW1pdCl7XG4gICAgICAgIC8vIFVwZGF0ZSBjb250YWN0IGNvbnN0cmFpbnQgbm9ybWFsLCBldGNcbiAgICAgICAgdmVjMi5zY2FsZSh1cHBlckxpbWl0RXF1YXRpb24ubm9ybWFsQSwgd29ybGRBeGlzQSwgLTEpO1xuICAgICAgICB2ZWMyLnN1Yih1cHBlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50QSwgd29ybGRBbmNob3JBLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc3ViKHVwcGVyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRCLCB3b3JsZEFuY2hvckIsIGJvZHlCLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zY2FsZSh0bXAsd29ybGRBeGlzQSx1cHBlckxpbWl0KTtcbiAgICAgICAgdmVjMi5hZGQodXBwZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEEsdXBwZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEEsdG1wKTtcbiAgICAgICAgaWYoZXFzLmluZGV4T2YodXBwZXJMaW1pdEVxdWF0aW9uKSA9PT0gLTEpe1xuICAgICAgICAgICAgZXFzLnB1c2godXBwZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpZHggPSBlcXMuaW5kZXhPZih1cHBlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5sb3dlckxpbWl0RW5hYmxlZCAmJiByZWxQb3NpdGlvbiA8IGxvd2VyTGltaXQpe1xuICAgICAgICAvLyBVcGRhdGUgY29udGFjdCBjb25zdHJhaW50IG5vcm1hbCwgZXRjXG4gICAgICAgIHZlYzIuc2NhbGUobG93ZXJMaW1pdEVxdWF0aW9uLm5vcm1hbEEsIHdvcmxkQXhpc0EsIDEpO1xuICAgICAgICB2ZWMyLnN1Yihsb3dlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50QSwgd29ybGRBbmNob3JBLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc3ViKGxvd2VyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRCLCB3b3JsZEFuY2hvckIsIGJvZHlCLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zY2FsZSh0bXAsd29ybGRBeGlzQSxsb3dlckxpbWl0KTtcbiAgICAgICAgdmVjMi5zdWIobG93ZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEIsbG93ZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEIsdG1wKTtcbiAgICAgICAgaWYoZXFzLmluZGV4T2YobG93ZXJMaW1pdEVxdWF0aW9uKSA9PT0gLTEpe1xuICAgICAgICAgICAgZXFzLnB1c2gobG93ZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpZHggPSBlcXMuaW5kZXhPZihsb3dlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBFbmFibGUgdGhlIG1vdG9yXG4gKiBAbWV0aG9kIGVuYWJsZU1vdG9yXG4gKi9cblByaXNtYXRpY0NvbnN0cmFpbnQucHJvdG90eXBlLmVuYWJsZU1vdG9yID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLm1vdG9yRW5hYmxlZCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaCh0aGlzLm1vdG9yRXF1YXRpb24pO1xuICAgIHRoaXMubW90b3JFbmFibGVkID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogRGlzYWJsZSB0aGUgcm90YXRpb25hbCBtb3RvclxuICogQG1ldGhvZCBkaXNhYmxlTW90b3JcbiAqL1xuUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUuZGlzYWJsZU1vdG9yID0gZnVuY3Rpb24oKXtcbiAgICBpZighdGhpcy5tb3RvckVuYWJsZWQpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5lcXVhdGlvbnMuaW5kZXhPZih0aGlzLm1vdG9yRXF1YXRpb24pO1xuICAgIHRoaXMuZXF1YXRpb25zLnNwbGljZShpLDEpO1xuICAgIHRoaXMubW90b3JFbmFibGVkID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29uc3RyYWludCBsaW1pdHMuXG4gKiBAbWV0aG9kIHNldExpbWl0c1xuICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIExvd2VyIGxpbWl0LlxuICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFVwcGVyIGxpbWl0LlxuICovXG5QcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS5zZXRMaW1pdHMgPSBmdW5jdGlvbiAobG93ZXIsIHVwcGVyKSB7XG4gICAgaWYodHlwZW9mKGxvd2VyKSA9PT0gJ251bWJlcicpe1xuICAgICAgICB0aGlzLmxvd2VyTGltaXQgPSBsb3dlcjtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0ID0gbG93ZXI7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZih0eXBlb2YodXBwZXIpID09PSAnbnVtYmVyJyl7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdCA9IHVwcGVyO1xuICAgICAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVwcGVyTGltaXQgPSB1cHBlcjtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cblxufSx7XCIuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uXCI6MjIsXCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIjoyMyxcIi4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTG9ja0VxdWF0aW9uXCI6MjUsXCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4vQ29uc3RyYWludFwiOjE1fV0sMjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIENvbnN0cmFpbnQgPSBfZGVyZXFfKCcuL0NvbnN0cmFpbnQnKVxuLCAgIEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0VxdWF0aW9uJylcbiwgICBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbicpXG4sICAgUm90YXRpb25hbExvY2tFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTG9ja0VxdWF0aW9uJylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmV2b2x1dGVDb25zdHJhaW50O1xuXG52YXIgd29ybGRQaXZvdEEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHdvcmxkUGl2b3RCID0gdmVjMi5jcmVhdGUoKSxcbiAgICB4QXhpcyA9IHZlYzIuZnJvbVZhbHVlcygxLDApLFxuICAgIHlBeGlzID0gdmVjMi5mcm9tVmFsdWVzKDAsMSksXG4gICAgZyA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQ29ubmVjdHMgdHdvIGJvZGllcyBhdCBnaXZlbiBvZmZzZXQgcG9pbnRzLCBsZXR0aW5nIHRoZW0gcm90YXRlIHJlbGF0aXZlIHRvIGVhY2ggb3RoZXIgYXJvdW5kIHRoaXMgcG9pbnQuXG4gKiBAY2xhc3MgUmV2b2x1dGVDb25zdHJhaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gICAgYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gICAgYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSAgW29wdGlvbnNdXG4gKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLndvcmxkUGl2b3RdIEEgcGl2b3QgcG9pbnQgZ2l2ZW4gaW4gd29ybGQgY29vcmRpbmF0ZXMuIElmIHNwZWNpZmllZCwgbG9jYWxQaXZvdEEgYW5kIGxvY2FsUGl2b3RCIGFyZSBhdXRvbWF0aWNhbGx5IGNvbXB1dGVkIGZyb20gdGhpcyB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMubG9jYWxQaXZvdEFdIFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIG1hc3Mgb2YgYm9keUEgd2hpY2ggYm9keUEgaXMgY29uc3RyYWluZWQgdG8uXG4gKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLmxvY2FsUGl2b3RCXSBTZWUgbG9jYWxQaXZvdEEuXG4gKiBAcGFyYW0ge051bWJlcn0gIFtvcHRpb25zLm1heEZvcmNlXSBUaGUgbWF4aW11bSBmb3JjZSB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGNvbnN0cmFpbiB0aGUgYm9kaWVzLlxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gVGhpcyB3aWxsIGNyZWF0ZSBhIHJldm9sdXRlIGNvbnN0cmFpbnQgYmV0d2VlbiB0d28gYm9kaWVzIHdpdGggcGl2b3QgcG9pbnQgaW4gYmV0d2VlbiB0aGVtLlxuICogICAgIHZhciBib2R5QSA9IG5ldyBCb2R5KHsgbWFzczogMSwgcG9zaXRpb246IFstMSwgMF0gfSk7XG4gKiAgICAgdmFyIGJvZHlCID0gbmV3IEJvZHkoeyBtYXNzOiAxLCBwb3NpdGlvbjogWzEsIDBdIH0pO1xuICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IFJldm9sdXRlQ29uc3RyYWludChib2R5QSwgYm9keUIsIHtcbiAqICAgICAgICAgd29ybGRQaXZvdDogWzAsIDBdXG4gKiAgICAgfSk7XG4gKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAqXG4gKiAgICAgLy8gVXNpbmcgYm9keS1sb2NhbCBwaXZvdCBwb2ludHMsIHRoZSBjb25zdHJhaW50IGNvdWxkIGhhdmUgYmVlbiBjb25zdHJ1Y3RlZCBsaWtlIHRoaXM6XG4gKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgUmV2b2x1dGVDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwge1xuICogICAgICAgICBsb2NhbFBpdm90QTogWzEsIDBdLFxuICogICAgICAgICBsb2NhbFBpdm90QjogWy0xLCAwXVxuICogICAgIH0pO1xuICovXG5mdW5jdGlvbiBSZXZvbHV0ZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBDb25zdHJhaW50LmNhbGwodGhpcyxib2R5QSxib2R5QixDb25zdHJhaW50LlJFVk9MVVRFLG9wdGlvbnMpO1xuXG4gICAgdmFyIG1heEZvcmNlID0gdGhpcy5tYXhGb3JjZSA9IHR5cGVvZihvcHRpb25zLm1heEZvcmNlKSAhPT0gXCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMubWF4Rm9yY2UgOiBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gcGl2b3RBXG4gICAgICovXG4gICAgdGhpcy5waXZvdEEgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gcGl2b3RCXG4gICAgICovXG4gICAgdGhpcy5waXZvdEIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgaWYob3B0aW9ucy53b3JsZFBpdm90KXtcbiAgICAgICAgLy8gQ29tcHV0ZSBwaXZvdEEgYW5kIHBpdm90QlxuICAgICAgICB2ZWMyLnN1Yih0aGlzLnBpdm90QSwgb3B0aW9ucy53b3JsZFBpdm90LCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc3ViKHRoaXMucGl2b3RCLCBvcHRpb25zLndvcmxkUGl2b3QsIGJvZHlCLnBvc2l0aW9uKTtcbiAgICAgICAgLy8gUm90YXRlIHRvIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICAgIHZlYzIucm90YXRlKHRoaXMucGl2b3RBLCB0aGlzLnBpdm90QSwgLWJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUodGhpcy5waXZvdEIsIHRoaXMucGl2b3RCLCAtYm9keUIuYW5nbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEdldCBwaXZvdEEgYW5kIHBpdm90QlxuICAgICAgICB2ZWMyLmNvcHkodGhpcy5waXZvdEEsIG9wdGlvbnMubG9jYWxQaXZvdEEpO1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy5waXZvdEIsIG9wdGlvbnMubG9jYWxQaXZvdEIpO1xuICAgIH1cblxuICAgIC8vIEVxdWF0aW9ucyB0byBiZSBmZWQgdG8gdGhlIHNvbHZlclxuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucyA9IFtcbiAgICAgICAgbmV3IEVxdWF0aW9uKGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSksXG4gICAgICAgIG5ldyBFcXVhdGlvbihib2R5QSxib2R5QiwtbWF4Rm9yY2UsbWF4Rm9yY2UpLFxuICAgIF07XG5cbiAgICB2YXIgeCA9IGVxc1swXTtcbiAgICB2YXIgeSA9IGVxc1sxXTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICB4LmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkUGl2b3RBLCB0aGF0LnBpdm90QSwgYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBpdm90QiwgdGhhdC5waXZvdEIsIGJvZHlCLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5hZGQoZywgYm9keUIucG9zaXRpb24sIHdvcmxkUGl2b3RCKTtcbiAgICAgICAgdmVjMi5zdWIoZywgZywgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1YihnLCBnLCB3b3JsZFBpdm90QSk7XG4gICAgICAgIHJldHVybiB2ZWMyLmRvdChnLHhBeGlzKTtcbiAgICB9O1xuXG4gICAgeS5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBpdm90QSwgdGhhdC5waXZvdEEsIGJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQaXZvdEIsIHRoYXQucGl2b3RCLCBib2R5Qi5hbmdsZSk7XG4gICAgICAgIHZlYzIuYWRkKGcsIGJvZHlCLnBvc2l0aW9uLCB3b3JsZFBpdm90Qik7XG4gICAgICAgIHZlYzIuc3ViKGcsIGcsIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIoZywgZywgd29ybGRQaXZvdEEpO1xuICAgICAgICByZXR1cm4gdmVjMi5kb3QoZyx5QXhpcyk7XG4gICAgfTtcblxuICAgIHkubWluRm9yY2UgPSB4Lm1pbkZvcmNlID0gLW1heEZvcmNlO1xuICAgIHkubWF4Rm9yY2UgPSB4Lm1heEZvcmNlID0gIG1heEZvcmNlO1xuXG4gICAgdGhpcy5tb3RvckVxdWF0aW9uID0gbmV3IFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBtb3RvciBpcyBlbmFibGVkLiBVc2UgLmVuYWJsZU1vdG9yKCkgdG8gZW5hYmxlIHRoZSBjb25zdHJhaW50IG1vdG9yLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbW90b3JFbmFibGVkXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5tb3RvckVuYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJhaW50IHBvc2l0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSBhbmdsZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5hbmdsZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgbG93ZXIgbGltaXRcbiAgICAgKiBAcHJvcGVydHkgbG93ZXJMaW1pdEVuYWJsZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgdXBwZXIgbGltaXRcbiAgICAgKiBAcHJvcGVydHkgdXBwZXJMaW1pdEVuYWJsZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG93ZXIgbGltaXQgb24gdGhlIGNvbnN0cmFpbnQgYW5nbGUuXG4gICAgICogQHByb3BlcnR5IGxvd2VyTGltaXRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvd2VyTGltaXQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHVwcGVyIGxpbWl0IG9uIHRoZSBjb25zdHJhaW50IGFuZ2xlLlxuICAgICAqIEBwcm9wZXJ0eSB1cHBlckxpbWl0XG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51cHBlckxpbWl0ID0gMDtcblxuICAgIHRoaXMudXBwZXJMaW1pdEVxdWF0aW9uID0gbmV3IFJvdGF0aW9uYWxMb2NrRXF1YXRpb24oYm9keUEsYm9keUIpO1xuICAgIHRoaXMubG93ZXJMaW1pdEVxdWF0aW9uID0gbmV3IFJvdGF0aW9uYWxMb2NrRXF1YXRpb24oYm9keUEsYm9keUIpO1xuICAgIHRoaXMudXBwZXJMaW1pdEVxdWF0aW9uLm1pbkZvcmNlID0gMDtcbiAgICB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbi5tYXhGb3JjZSA9IDA7XG59XG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlID0gbmV3IENvbnN0cmFpbnQoKTtcblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXZvbHV0ZUNvbnN0cmFpbnQ7XG5cbi8qKlxuICogU2V0IHRoZSBjb25zdHJhaW50IGFuZ2xlIGxpbWl0cy5cbiAqIEBtZXRob2Qgc2V0TGltaXRzXG4gKiBAcGFyYW0ge251bWJlcn0gbG93ZXIgTG93ZXIgYW5nbGUgbGltaXQuXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVXBwZXIgYW5nbGUgbGltaXQuXG4gKi9cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TGltaXRzID0gZnVuY3Rpb24gKGxvd2VyLCB1cHBlcikge1xuICAgIGlmKHR5cGVvZihsb3dlcikgPT09ICdudW1iZXInKXtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0ID0gbG93ZXI7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdCA9IGxvd2VyO1xuICAgICAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYodHlwZW9mKHVwcGVyKSA9PT0gJ251bWJlcicpe1xuICAgICAgICB0aGlzLnVwcGVyTGltaXQgPSB1cHBlcjtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0ID0gdXBwZXI7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJvZHlBID0gIHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gIHRoaXMuYm9keUIsXG4gICAgICAgIHBpdm90QSA9IHRoaXMucGl2b3RBLFxuICAgICAgICBwaXZvdEIgPSB0aGlzLnBpdm90QixcbiAgICAgICAgZXFzID0gICAgdGhpcy5lcXVhdGlvbnMsXG4gICAgICAgIG5vcm1hbCA9IGVxc1swXSxcbiAgICAgICAgdGFuZ2VudD0gZXFzWzFdLFxuICAgICAgICB4ID0gZXFzWzBdLFxuICAgICAgICB5ID0gZXFzWzFdLFxuICAgICAgICB1cHBlckxpbWl0ID0gdGhpcy51cHBlckxpbWl0LFxuICAgICAgICBsb3dlckxpbWl0ID0gdGhpcy5sb3dlckxpbWl0LFxuICAgICAgICB1cHBlckxpbWl0RXF1YXRpb24gPSB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbixcbiAgICAgICAgbG93ZXJMaW1pdEVxdWF0aW9uID0gdGhpcy5sb3dlckxpbWl0RXF1YXRpb247XG5cbiAgICB2YXIgcmVsQW5nbGUgPSB0aGlzLmFuZ2xlID0gYm9keUIuYW5nbGUgLSBib2R5QS5hbmdsZTtcblxuICAgIGlmKHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgJiYgcmVsQW5nbGUgPiB1cHBlckxpbWl0KXtcbiAgICAgICAgdXBwZXJMaW1pdEVxdWF0aW9uLmFuZ2xlID0gdXBwZXJMaW1pdDtcbiAgICAgICAgaWYoZXFzLmluZGV4T2YodXBwZXJMaW1pdEVxdWF0aW9uKSA9PT0gLTEpe1xuICAgICAgICAgICAgZXFzLnB1c2godXBwZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpZHggPSBlcXMuaW5kZXhPZih1cHBlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5sb3dlckxpbWl0RW5hYmxlZCAmJiByZWxBbmdsZSA8IGxvd2VyTGltaXQpe1xuICAgICAgICBsb3dlckxpbWl0RXF1YXRpb24uYW5nbGUgPSBsb3dlckxpbWl0O1xuICAgICAgICBpZihlcXMuaW5kZXhPZihsb3dlckxpbWl0RXF1YXRpb24pID09PSAtMSl7XG4gICAgICAgICAgICBlcXMucHVzaChsb3dlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlkeCA9IGVxcy5pbmRleE9mKGxvd2VyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICAgICAgZXFzLnNwbGljZShpZHgsMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuXG4gICAgVGhlIGNvbnN0cmFpbnQgdmlvbGF0aW9uIGlzXG5cbiAgICAgICAgZyA9IHhqICsgcmogLSB4aSAtIHJpXG5cbiAgICAuLi53aGVyZSB4aSBhbmQgeGogYXJlIHRoZSBib2R5IHBvc2l0aW9ucyBhbmQgcmkgYW5kIHJqIHdvcmxkLW9yaWVudGVkIG9mZnNldCB2ZWN0b3JzLiBEaWZmZXJlbnRpYXRlOlxuXG4gICAgICAgIGdkb3QgPSB2aiArIHdqIHggcmogLSB2aSAtIHdpIHggcmlcblxuICAgIFdlIHNwbGl0IHRoaXMgaW50byB4IGFuZCB5IGRpcmVjdGlvbnMuIChsZXQgeCBhbmQgeSBiZSB1bml0IHZlY3RvcnMgYWxvbmcgdGhlIHJlc3BlY3RpdmUgYXhlcylcblxuICAgICAgICBnZG90ICogeCA9ICggdmogKyB3aiB4IHJqIC0gdmkgLSB3aSB4IHJpICkgKiB4XG4gICAgICAgICAgICAgICAgID0gKCB2aip4ICsgKHdqIHggcmopKnggLXZpKnggLSh3aSB4IHJpKSp4XG4gICAgICAgICAgICAgICAgID0gKCB2aip4ICsgKHJqIHggeCkqd2ogLXZpKnggLShyaSB4IHgpKndpXG4gICAgICAgICAgICAgICAgID0gWyAteCAgIC0ocmkgeCB4KSAgIHggICAocmogeCB4KV0gKiBbdmkgd2kgdmogd2pdXG4gICAgICAgICAgICAgICAgID0gRypXXG5cbiAgICAuLi5hbmQgc2ltaWxhciBmb3IgeS4gV2UgaGF2ZSB0aGVuIGlkZW50aWZpZWQgdGhlIGphY29iaWFuIGVudHJpZXMgZm9yIHggYW5kIHkgZGlyZWN0aW9uczpcblxuICAgICAgICBHeCA9IFsgeCAgIChyaiB4IHgpICAgLXggICAtKHJpIHggeCldXG4gICAgICAgIEd5ID0gWyB5ICAgKHJqIHggeSkgICAteSAgIC0ocmkgeCB5KV1cblxuICAgICAqL1xuXG4gICAgdmVjMi5yb3RhdGUod29ybGRQaXZvdEEsIHBpdm90QSwgYm9keUEuYW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHdvcmxkUGl2b3RCLCBwaXZvdEIsIGJvZHlCLmFuZ2xlKTtcblxuICAgIC8vIHRvZG86IHRoZXNlIGFyZSBhIGJpdCBzcGFyc2UuIFdlIGNvdWxkIHNhdmUgc29tZSBjb21wdXRhdGlvbnMgb24gbWFraW5nIGN1c3RvbSBlcS5jb21wdXRlR1cgZnVuY3Rpb25zLCBldGNcblxuICAgIHguR1swXSA9IC0xO1xuICAgIHguR1sxXSA9ICAwO1xuICAgIHguR1syXSA9IC12ZWMyLmNyb3NzTGVuZ3RoKHdvcmxkUGl2b3RBLHhBeGlzKTtcbiAgICB4LkdbM10gPSAgMTtcbiAgICB4LkdbNF0gPSAgMDtcbiAgICB4LkdbNV0gPSAgdmVjMi5jcm9zc0xlbmd0aCh3b3JsZFBpdm90Qix4QXhpcyk7XG5cbiAgICB5LkdbMF0gPSAgMDtcbiAgICB5LkdbMV0gPSAtMTtcbiAgICB5LkdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aCh3b3JsZFBpdm90QSx5QXhpcyk7XG4gICAgeS5HWzNdID0gIDA7XG4gICAgeS5HWzRdID0gIDE7XG4gICAgeS5HWzVdID0gIHZlYzIuY3Jvc3NMZW5ndGgod29ybGRQaXZvdEIseUF4aXMpO1xufTtcblxuLyoqXG4gKiBFbmFibGUgdGhlIHJvdGF0aW9uYWwgbW90b3JcbiAqIEBtZXRob2QgZW5hYmxlTW90b3JcbiAqL1xuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS5lbmFibGVNb3RvciA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5tb3RvckVuYWJsZWQpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZXF1YXRpb25zLnB1c2godGhpcy5tb3RvckVxdWF0aW9uKTtcbiAgICB0aGlzLm1vdG9yRW5hYmxlZCA9IHRydWU7XG59O1xuXG4vKipcbiAqIERpc2FibGUgdGhlIHJvdGF0aW9uYWwgbW90b3JcbiAqIEBtZXRob2QgZGlzYWJsZU1vdG9yXG4gKi9cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUuZGlzYWJsZU1vdG9yID0gZnVuY3Rpb24oKXtcbiAgICBpZighdGhpcy5tb3RvckVuYWJsZWQpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5lcXVhdGlvbnMuaW5kZXhPZih0aGlzLm1vdG9yRXF1YXRpb24pO1xuICAgIHRoaXMuZXF1YXRpb25zLnNwbGljZShpLDEpO1xuICAgIHRoaXMubW90b3JFbmFibGVkID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBtb3RvciBpcyBlbmFibGVkLlxuICogQG1ldGhvZCBtb3RvcklzRW5hYmxlZFxuICogQGRlcHJlY2F0ZWQgdXNlIHByb3BlcnR5IG1vdG9yRW5hYmxlZCBpbnN0ZWFkLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS5tb3RvcklzRW5hYmxlZCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICEhdGhpcy5tb3RvckVuYWJsZWQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc3BlZWQgb2YgdGhlIHJvdGF0aW9uYWwgY29uc3RyYWludCBtb3RvclxuICogQG1ldGhvZCBzZXRNb3RvclNwZWVkXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHNwZWVkXG4gKi9cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uKHNwZWVkKXtcbiAgICBpZighdGhpcy5tb3RvckVuYWJsZWQpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5lcXVhdGlvbnMuaW5kZXhPZih0aGlzLm1vdG9yRXF1YXRpb24pO1xuICAgIHRoaXMuZXF1YXRpb25zW2ldLnJlbGF0aXZlVmVsb2NpdHkgPSBzcGVlZDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzcGVlZCBvZiB0aGUgcm90YXRpb25hbCBjb25zdHJhaW50IG1vdG9yXG4gKiBAbWV0aG9kIGdldE1vdG9yU3BlZWRcbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGN1cnJlbnQgc3BlZWQsIG9yIGZhbHNlIGlmIHRoZSBtb3RvciBpcyBub3QgZW5hYmxlZC5cbiAqL1xuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS5nZXRNb3RvclNwZWVkID0gZnVuY3Rpb24oKXtcbiAgICBpZighdGhpcy5tb3RvckVuYWJsZWQpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1vdG9yRXF1YXRpb24ucmVsYXRpdmVWZWxvY2l0eTtcbn07XG5cbn0se1wiLi4vZXF1YXRpb25zL0VxdWF0aW9uXCI6MjMsXCIuLi9lcXVhdGlvbnMvUm90YXRpb25hbExvY2tFcXVhdGlvblwiOjI1LFwiLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uXCI6MjYsXCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4vQ29uc3RyYWludFwiOjE1fV0sMjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIEVxdWF0aW9uID0gX2RlcmVxXyhcIi4vRXF1YXRpb25cIiksXG4gICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFuZ2xlTG9ja0VxdWF0aW9uO1xuXG4vKipcbiAqIExvY2tzIHRoZSByZWxhdGl2ZSBhbmdsZSBiZXR3ZWVuIHR3byBib2RpZXMuIFRoZSBjb25zdHJhaW50IHRyaWVzIHRvIGtlZXAgdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gdHdvIHZlY3RvcnMsIGxvY2FsIGluIGVhY2ggYm9keSwgdG8gemVyby4gVGhlIGxvY2FsIGFuZ2xlIGluIGJvZHkgaSBpcyBhIHBhcmFtZXRlci5cbiAqXG4gKiBAY2xhc3MgQW5nbGVMb2NrRXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRXF1YXRpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbmdsZV0gQW5nbGUgdG8gYWRkIHRvIHRoZSBsb2NhbCB2ZWN0b3IgaW4gYm9keSBBLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJhdGlvXSBHZWFyIHJhdGlvXG4gKi9cbmZ1bmN0aW9uIEFuZ2xlTG9ja0VxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLGJvZHlBLGJvZHlCLC1OdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUpO1xuICAgIHRoaXMuYW5nbGUgPSBvcHRpb25zLmFuZ2xlIHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ2VhciByYXRpby5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcmF0aW9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUgc2V0UmF0aW9cbiAgICAgKi9cbiAgICB0aGlzLnJhdGlvID0gdHlwZW9mKG9wdGlvbnMucmF0aW8pPT09XCJudW1iZXJcIiA/IG9wdGlvbnMucmF0aW8gOiAxO1xuXG4gICAgdGhpcy5zZXRSYXRpbyh0aGlzLnJhdGlvKTtcbn1cbkFuZ2xlTG9ja0VxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuQW5nbGVMb2NrRXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQW5nbGVMb2NrRXF1YXRpb247XG5cbkFuZ2xlTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnJhdGlvICogdGhpcy5ib2R5QS5hbmdsZSAtIHRoaXMuYm9keUIuYW5nbGUgKyB0aGlzLmFuZ2xlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGdlYXIgcmF0aW8gZm9yIHRoaXMgZXF1YXRpb25cbiAqIEBtZXRob2Qgc2V0UmF0aW9cbiAqIEBwYXJhbSB7TnVtYmVyfSByYXRpb1xuICovXG5BbmdsZUxvY2tFcXVhdGlvbi5wcm90b3R5cGUuc2V0UmF0aW8gPSBmdW5jdGlvbihyYXRpbyl7XG4gICAgdmFyIEcgPSB0aGlzLkc7XG4gICAgR1syXSA9ICByYXRpbztcbiAgICBHWzVdID0gLTE7XG4gICAgdGhpcy5yYXRpbyA9IHJhdGlvO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heCBmb3JjZSBmb3IgdGhlIGVxdWF0aW9uLlxuICogQG1ldGhvZCBzZXRNYXhUb3JxdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3JxdWVcbiAqL1xuQW5nbGVMb2NrRXF1YXRpb24ucHJvdG90eXBlLnNldE1heFRvcnF1ZSA9IGZ1bmN0aW9uKHRvcnF1ZSl7XG4gICAgdGhpcy5tYXhGb3JjZSA9ICB0b3JxdWU7XG4gICAgdGhpcy5taW5Gb3JjZSA9IC10b3JxdWU7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9FcXVhdGlvblwiOjIzfV0sMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIEVxdWF0aW9uID0gX2RlcmVxXyhcIi4vRXF1YXRpb25cIiksXG4gICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhY3RFcXVhdGlvbjtcblxuLyoqXG4gKiBOb24tcGVuZXRyYXRpb24gY29uc3RyYWludCBlcXVhdGlvbi4gVHJpZXMgdG8gbWFrZSB0aGUgY29udGFjdFBvaW50QSBhbmQgY29udGFjdFBvaW50QiB2ZWN0b3JzIGNvaW5jaWRlLCB3aGlsZSBrZWVwaW5nIHRoZSBhcHBsaWVkIGZvcmNlIHJlcHVsc2l2ZS5cbiAqXG4gKiBAY2xhc3MgQ29udGFjdEVxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEVxdWF0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKi9cbmZ1bmN0aW9uIENvbnRhY3RFcXVhdGlvbihib2R5QSwgYm9keUIpe1xuICAgIEVxdWF0aW9uLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAwLCBOdW1iZXIuTUFYX1ZBTFVFKTtcblxuICAgIC8qKlxuICAgICAqIFZlY3RvciBmcm9tIGJvZHkgaSBjZW50ZXIgb2YgbWFzcyB0byB0aGUgY29udGFjdCBwb2ludC5cbiAgICAgKiBAcHJvcGVydHkgY29udGFjdFBvaW50QVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RQb2ludEEgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIHRoaXMucGVuZXRyYXRpb25WZWMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogV29ybGQtb3JpZW50ZWQgdmVjdG9yIGZyb20gYm9keSBBIGNlbnRlciBvZiBtYXNzIHRvIHRoZSBjb250YWN0IHBvaW50LlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0UG9pbnRCXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdFBvaW50QiA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbm9ybWFsIHZlY3RvciwgcG9pbnRpbmcgb3V0IG9mIGJvZHkgaVxuICAgICAqIEBwcm9wZXJ0eSBub3JtYWxBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubm9ybWFsQSA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdGl0dXRpb24gdG8gdXNlICgwPW5vIGJvdW5jaW5lc3MsIDE9bWF4IGJvdW5jaW5lc3MpLlxuICAgICAqIEBwcm9wZXJ0eSByZXN0aXR1dGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXN0aXR1dGlvbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHByb3BlcnR5IGlzIHNldCB0byB0cnVlIGlmIHRoaXMgaXMgdGhlIGZpcnN0IGltcGFjdCBiZXR3ZWVuIHRoZSBib2RpZXMgKG5vdCBwZXJzaXN0YW50IGNvbnRhY3QpLlxuICAgICAqIEBwcm9wZXJ0eSBmaXJzdEltcGFjdFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMuZmlyc3RJbXBhY3QgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFwZSBpbiBib2R5IGkgdGhhdCB0cmlnZ2VyZWQgdGhpcyBjb250YWN0LlxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZUFcbiAgICAgKiBAdHlwZSB7U2hhcGV9XG4gICAgICovXG4gICAgdGhpcy5zaGFwZUEgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNoYXBlIGluIGJvZHkgaiB0aGF0IHRyaWdnZXJlZCB0aGlzIGNvbnRhY3QuXG4gICAgICogQHByb3BlcnR5IHNoYXBlQlxuICAgICAqIEB0eXBlIHtTaGFwZX1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlQiA9IG51bGw7XG59XG5Db250YWN0RXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XG5Db250YWN0RXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udGFjdEVxdWF0aW9uO1xuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGEsYixoKXtcbiAgICB2YXIgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHJpID0gdGhpcy5jb250YWN0UG9pbnRBLFxuICAgICAgICByaiA9IHRoaXMuY29udGFjdFBvaW50QixcbiAgICAgICAgeGkgPSBiaS5wb3NpdGlvbixcbiAgICAgICAgeGogPSBiai5wb3NpdGlvbjtcblxuICAgIHZhciBwZW5ldHJhdGlvblZlYyA9IHRoaXMucGVuZXRyYXRpb25WZWMsXG4gICAgICAgIG4gPSB0aGlzLm5vcm1hbEEsXG4gICAgICAgIEcgPSB0aGlzLkc7XG5cbiAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcbiAgICB2YXIgcml4biA9IHZlYzIuY3Jvc3NMZW5ndGgocmksbiksXG4gICAgICAgIHJqeG4gPSB2ZWMyLmNyb3NzTGVuZ3RoKHJqLG4pO1xuXG4gICAgLy8gRyA9IFstbiAtcml4biBuIHJqeG5dXG4gICAgR1swXSA9IC1uWzBdO1xuICAgIEdbMV0gPSAtblsxXTtcbiAgICBHWzJdID0gLXJpeG47XG4gICAgR1szXSA9IG5bMF07XG4gICAgR1s0XSA9IG5bMV07XG4gICAgR1s1XSA9IHJqeG47XG5cbiAgICAvLyBDYWxjdWxhdGUgcSA9IHhqK3JqIC0oeGkrcmkpIGkuZS4gdGhlIHBlbmV0cmF0aW9uIHZlY3RvclxuICAgIHZlYzIuYWRkKHBlbmV0cmF0aW9uVmVjLHhqLHJqKTtcbiAgICB2ZWMyLnN1YihwZW5ldHJhdGlvblZlYyxwZW5ldHJhdGlvblZlYyx4aSk7XG4gICAgdmVjMi5zdWIocGVuZXRyYXRpb25WZWMscGVuZXRyYXRpb25WZWMscmkpO1xuXG4gICAgLy8gQ29tcHV0ZSBpdGVyYXRpb25cbiAgICB2YXIgR1csIEdxO1xuICAgIGlmKHRoaXMuZmlyc3RJbXBhY3QgJiYgdGhpcy5yZXN0aXR1dGlvbiAhPT0gMCl7XG4gICAgICAgIEdxID0gMDtcbiAgICAgICAgR1cgPSAoMS9iKSooMSt0aGlzLnJlc3RpdHV0aW9uKSAqIHRoaXMuY29tcHV0ZUdXKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgR3EgPSB2ZWMyLmRvdChuLHBlbmV0cmF0aW9uVmVjKSArIHRoaXMub2Zmc2V0O1xuICAgICAgICBHVyA9IHRoaXMuY29tcHV0ZUdXKCk7XG4gICAgfVxuXG4gICAgdmFyIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG4gICAgdmFyIEIgPSAtIEdxICogYSAtIEdXICogYiAtIGgqR2lNZjtcblxuICAgIHJldHVybiBCO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4vRXF1YXRpb25cIjoyM31dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gRXF1YXRpb247XG5cbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyksXG4gICAgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpLFxuICAgIEJvZHkgPSBfZGVyZXFfKCcuLi9vYmplY3RzL0JvZHknKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBjb25zdHJhaW50IGVxdWF0aW9ucy5cbiAqIEBjbGFzcyBFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBIEZpcnN0IGJvZHkgcGFydGljaXBhdGluZyBpbiB0aGUgZXF1YXRpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keUIgU2Vjb25kIGJvZHkgcGFydGljaXBhdGluZyBpbiB0aGUgZXF1YXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5Gb3JjZSBNaW5pbXVtIGZvcmNlIHRvIGFwcGx5LiBEZWZhdWx0OiAtTnVtYmVyLk1BWF9WQUxVRVxuICogQHBhcmFtIHtudW1iZXJ9IG1heEZvcmNlIE1heGltdW0gZm9yY2UgdG8gYXBwbHkuIERlZmF1bHQ6IE51bWJlci5NQVhfVkFMVUVcbiAqL1xuZnVuY3Rpb24gRXF1YXRpb24oYm9keUEsIGJvZHlCLCBtaW5Gb3JjZSwgbWF4Rm9yY2Upe1xuXG4gICAgLyoqXG4gICAgICogTWluaW11bSBmb3JjZSB0byBhcHBseSB3aGVuIHNvbHZpbmcuXG4gICAgICogQHByb3BlcnR5IG1pbkZvcmNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1pbkZvcmNlID0gdHlwZW9mKG1pbkZvcmNlKT09PVwidW5kZWZpbmVkXCIgPyAtTnVtYmVyLk1BWF9WQUxVRSA6IG1pbkZvcmNlO1xuXG4gICAgLyoqXG4gICAgICogTWF4IGZvcmNlIHRvIGFwcGx5IHdoZW4gc29sdmluZy5cbiAgICAgKiBAcHJvcGVydHkgbWF4Rm9yY2VcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4Rm9yY2UgPSB0eXBlb2YobWF4Rm9yY2UpPT09XCJ1bmRlZmluZWRcIiA/IE51bWJlci5NQVhfVkFMVUUgOiBtYXhGb3JjZTtcblxuICAgIC8qKlxuICAgICAqIEZpcnN0IGJvZHkgcGFydGljaXBhdGluZyBpbiB0aGUgY29uc3RyYWludFxuICAgICAqIEBwcm9wZXJ0eSBib2R5QVxuICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAqL1xuICAgIHRoaXMuYm9keUEgPSBib2R5QTtcblxuICAgIC8qKlxuICAgICAqIFNlY29uZCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNvbnN0cmFpbnRcbiAgICAgKiBAcHJvcGVydHkgYm9keUJcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlCID0gYm9keUI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RpZmZuZXNzIG9mIHRoaXMgZXF1YXRpb24uIFR5cGljYWxseSBjaG9zZW4gdG8gYSBsYXJnZSBudW1iZXIgKH4xZTcpLCBidXQgY2FuIGJlIGNob3NlbiBzb21ld2hhdCBmcmVlbHkgdG8gZ2V0IGEgc3RhYmxlIHNpbXVsYXRpb24uXG4gICAgICogQHByb3BlcnR5IHN0aWZmbmVzc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zdGlmZm5lc3MgPSBFcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTUztcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgdGltZSBzdGVwcyBuZWVkZWQgdG8gc3RhYmlsaXplIHRoZSBjb25zdHJhaW50IGVxdWF0aW9uLiBUeXBpY2FsbHkgYmV0d2VlbiAzIGFuZCA1IHRpbWUgc3RlcHMuXG4gICAgICogQHByb3BlcnR5IHJlbGF4YXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVsYXhhdGlvbiA9IEVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBKYWNvYmlhbiBlbnRyeSBvZiB0aGlzIGVxdWF0aW9uLiA2IG51bWJlcnMsIDMgcGVyIGJvZHkgKHgseSxhbmdsZSkuXG4gICAgICogQHByb3BlcnR5IEdcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5HID0gbmV3IFV0aWxzLkFSUkFZX1RZUEUoNik7XG4gICAgZm9yKHZhciBpPTA7IGk8NjsgaSsrKXtcbiAgICAgICAgdGhpcy5HW2ldPTA7XG4gICAgfVxuXG4gICAgdGhpcy5vZmZzZXQgPSAwO1xuXG4gICAgdGhpcy5hID0gMDtcbiAgICB0aGlzLmIgPSAwO1xuICAgIHRoaXMuZXBzaWxvbiA9IDA7XG4gICAgdGhpcy50aW1lU3RlcCA9IDEvNjA7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgc3RpZmZuZXNzIG9yIHJlbGF4YXRpb24gd2FzIGNoYW5nZWQuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBuZWVkc1VwZGF0ZVxuICAgICAqL1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdGluZyBjb25zdHJhaW50IG11bHRpcGxpZXIgZnJvbSB0aGUgbGFzdCBzb2x2ZS4gVGhpcyBpcyBtb3N0bHkgZXF1aXZhbGVudCB0byB0aGUgZm9yY2UgcHJvZHVjZWQgYnkgdGhlIGNvbnN0cmFpbnQuXG4gICAgICogQHByb3BlcnR5IG11bHRpcGxpZXJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubXVsdGlwbGllciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBSZWxhdGl2ZSB2ZWxvY2l0eS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcmVsYXRpdmVWZWxvY2l0eVxuICAgICAqL1xuICAgIHRoaXMucmVsYXRpdmVWZWxvY2l0eSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZXF1YXRpb24gaXMgZW5hYmxlZCBvciBub3QuIElmIHRydWUsIGl0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNvbHZlci5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xufVxuRXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXF1YXRpb247XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgc3RpZmZuZXNzIHdoZW4gY3JlYXRpbmcgYSBuZXcgRXF1YXRpb24uXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gREVGQVVMVF9TVElGRk5FU1NcbiAqIEBkZWZhdWx0IDFlNlxuICovXG5FcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTUyA9IDFlNjtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCByZWxheGF0aW9uIHdoZW4gY3JlYXRpbmcgYSBuZXcgRXF1YXRpb24uXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gREVGQVVMVF9SRUxBWEFUSU9OXG4gKiBAZGVmYXVsdCA0XG4gKi9cbkVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTiA9IDQ7XG5cbi8qKlxuICogQ29tcHV0ZSBTUE9PSyBwYXJhbWV0ZXJzIC5hLCAuYiBhbmQgLmVwc2lsb24gYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhcmFtZXRlcnMuIFNlZSBlcXVhdGlvbnMgOSwgMTAgYW5kIDExIGluIHRoZSA8YSBocmVmPVwiaHR0cDovL3d3dzguY3MudW11LnNlL2t1cnNlci81RFYwNTgvVlQwOS9sZWN0dXJlcy9zcG9va25vdGVzLnBkZlwiPlNQT09LIG5vdGVzPC9hPi5cbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBrID0gdGhpcy5zdGlmZm5lc3MsXG4gICAgICAgIGQgPSB0aGlzLnJlbGF4YXRpb24sXG4gICAgICAgIGggPSB0aGlzLnRpbWVTdGVwO1xuXG4gICAgdGhpcy5hID0gNC4wIC8gKGggKiAoMSArIDQgKiBkKSk7XG4gICAgdGhpcy5iID0gKDQuMCAqIGQpIC8gKDEgKyA0ICogZCk7XG4gICAgdGhpcy5lcHNpbG9uID0gNC4wIC8gKGggKiBoICogayAqICgxICsgNCAqIGQpKTtcblxuICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgYSBqYWNvYmlhbiBlbnRyeSB3aXRoIGNvcnJlc3BvbmRpbmcgcG9zaXRpb25zIG9yIHZlbG9jaXRpZXNcbiAqIEBtZXRob2QgZ211bHRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmdtdWx0ID0gZnVuY3Rpb24oRyx2aSx3aSx2aix3ail7XG4gICAgcmV0dXJuICBHWzBdICogdmlbMF0gK1xuICAgICAgICAgICAgR1sxXSAqIHZpWzFdICtcbiAgICAgICAgICAgIEdbMl0gKiB3aSArXG4gICAgICAgICAgICBHWzNdICogdmpbMF0gK1xuICAgICAgICAgICAgR1s0XSAqIHZqWzFdICtcbiAgICAgICAgICAgIEdbNV0gKiB3ajtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFJIUyBvZiB0aGUgU1BPT0sgZXF1YXRpb25cbiAqIEBtZXRob2QgY29tcHV0ZUJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24oYSxiLGgpe1xuICAgIHZhciBHVyA9IHRoaXMuY29tcHV0ZUdXKCk7XG4gICAgdmFyIEdxID0gdGhpcy5jb21wdXRlR3EoKTtcbiAgICB2YXIgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcbiAgICByZXR1cm4gLSBHcSAqIGEgLSBHVyAqIGIgLSBHaU1mKmg7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIEdcXCpxLCB3aGVyZSBxIGFyZSB0aGUgZ2VuZXJhbGl6ZWQgYm9keSBjb29yZGluYXRlc1xuICogQG1ldGhvZCBjb21wdXRlR3FcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmFyIHFpID0gdmVjMi5jcmVhdGUoKSxcbiAgICBxaiA9IHZlYzIuY3JlYXRlKCk7XG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgRyA9IHRoaXMuRyxcbiAgICAgICAgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHhpID0gYmkucG9zaXRpb24sXG4gICAgICAgIHhqID0gYmoucG9zaXRpb24sXG4gICAgICAgIGFpID0gYmkuYW5nbGUsXG4gICAgICAgIGFqID0gYmouYW5nbGU7XG5cbiAgICByZXR1cm4gdGhpcy5nbXVsdChHLCBxaSwgYWksIHFqLCBhaikgKyB0aGlzLm9mZnNldDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgR1xcKlcsIHdoZXJlIFcgYXJlIHRoZSBib2R5IHZlbG9jaXRpZXNcbiAqIEBtZXRob2QgY29tcHV0ZUdXXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR1cgPSBmdW5jdGlvbigpe1xuICAgIHZhciBHID0gdGhpcy5HLFxuICAgICAgICBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgdmkgPSBiaS52ZWxvY2l0eSxcbiAgICAgICAgdmogPSBiai52ZWxvY2l0eSxcbiAgICAgICAgd2kgPSBiaS5hbmd1bGFyVmVsb2NpdHksXG4gICAgICAgIHdqID0gYmouYW5ndWxhclZlbG9jaXR5O1xuICAgIHJldHVybiB0aGlzLmdtdWx0KEcsdmksd2ksdmosd2opICsgdGhpcy5yZWxhdGl2ZVZlbG9jaXR5O1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyBHXFwqV2xhbWJkYSwgd2hlcmUgVyBhcmUgdGhlIGJvZHkgdmVsb2NpdGllc1xuICogQG1ldGhvZCBjb21wdXRlR1dsYW1iZGFcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHV2xhbWJkYSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIEcgPSB0aGlzLkcsXG4gICAgICAgIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICB2aSA9IGJpLnZsYW1iZGEsXG4gICAgICAgIHZqID0gYmoudmxhbWJkYSxcbiAgICAgICAgd2kgPSBiaS53bGFtYmRhLFxuICAgICAgICB3aiA9IGJqLndsYW1iZGE7XG4gICAgcmV0dXJuIHRoaXMuZ211bHQoRyx2aSx3aSx2aix3aik7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIEdcXCppbnYoTSlcXCpmLCB3aGVyZSBNIGlzIHRoZSBtYXNzIG1hdHJpeCB3aXRoIGRpYWdvbmFsIGJsb2NrcyBmb3IgZWFjaCBib2R5LCBhbmQgZiBhcmUgdGhlIGZvcmNlcyBvbiB0aGUgYm9kaWVzLlxuICogQG1ldGhvZCBjb21wdXRlR2lNZlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG52YXIgaU1maSA9IHZlYzIuY3JlYXRlKCksXG4gICAgaU1maiA9IHZlYzIuY3JlYXRlKCk7XG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdpTWYgPSBmdW5jdGlvbigpe1xuICAgIHZhciBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgZmkgPSBiaS5mb3JjZSxcbiAgICAgICAgdGkgPSBiaS5hbmd1bGFyRm9yY2UsXG4gICAgICAgIGZqID0gYmouZm9yY2UsXG4gICAgICAgIHRqID0gYmouYW5ndWxhckZvcmNlLFxuICAgICAgICBpbnZNYXNzaSA9IGJpLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludklpID0gYmkuaW52SW5lcnRpYVNvbHZlLFxuICAgICAgICBpbnZJaiA9IGJqLmludkluZXJ0aWFTb2x2ZSxcbiAgICAgICAgRyA9IHRoaXMuRztcblxuICAgIHZlYzIuc2NhbGUoaU1maSwgZmksaW52TWFzc2kpO1xuICAgIHZlYzIuc2NhbGUoaU1maiwgZmosaW52TWFzc2opO1xuXG4gICAgcmV0dXJuIHRoaXMuZ211bHQoRyxpTWZpLHRpKmludklpLGlNZmosdGoqaW52SWopO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyBHXFwqaW52KE0pXFwqRydcbiAqIEBtZXRob2QgY29tcHV0ZUdpTUd0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR2lNR3QgPSBmdW5jdGlvbigpe1xuICAgIHZhciBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgaW52TWFzc2kgPSBiaS5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludk1hc3NqID0gYmouaW52TWFzc1NvbHZlLFxuICAgICAgICBpbnZJaSA9IGJpLmludkluZXJ0aWFTb2x2ZSxcbiAgICAgICAgaW52SWogPSBiai5pbnZJbmVydGlhU29sdmUsXG4gICAgICAgIEcgPSB0aGlzLkc7XG5cbiAgICByZXR1cm4gIEdbMF0gKiBHWzBdICogaW52TWFzc2kgK1xuICAgICAgICAgICAgR1sxXSAqIEdbMV0gKiBpbnZNYXNzaSArXG4gICAgICAgICAgICBHWzJdICogR1syXSAqICAgIGludklpICtcbiAgICAgICAgICAgIEdbM10gKiBHWzNdICogaW52TWFzc2ogK1xuICAgICAgICAgICAgR1s0XSAqIEdbNF0gKiBpbnZNYXNzaiArXG4gICAgICAgICAgICBHWzVdICogR1s1XSAqICAgIGludklqO1xufTtcblxudmFyIGFkZFRvV2xhbWJkYV90ZW1wID0gdmVjMi5jcmVhdGUoKSxcbiAgICBhZGRUb1dsYW1iZGFfR2kgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFkZFRvV2xhbWJkYV9HaiA9IHZlYzIuY3JlYXRlKCksXG4gICAgYWRkVG9XbGFtYmRhX3JpID0gdmVjMi5jcmVhdGUoKSxcbiAgICBhZGRUb1dsYW1iZGFfcmogPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFkZFRvV2xhbWJkYV9NZGlhZyA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQWRkIGNvbnN0cmFpbnQgdmVsb2NpdHkgdG8gdGhlIGJvZGllcy5cbiAqIEBtZXRob2QgYWRkVG9XbGFtYmRhXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsdGFsYW1iZGFcbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmFkZFRvV2xhbWJkYSA9IGZ1bmN0aW9uKGRlbHRhbGFtYmRhKXtcbiAgICB2YXIgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHRlbXAgPSBhZGRUb1dsYW1iZGFfdGVtcCxcbiAgICAgICAgR2kgPSBhZGRUb1dsYW1iZGFfR2ksXG4gICAgICAgIEdqID0gYWRkVG9XbGFtYmRhX0dqLFxuICAgICAgICByaSA9IGFkZFRvV2xhbWJkYV9yaSxcbiAgICAgICAgcmogPSBhZGRUb1dsYW1iZGFfcmosXG4gICAgICAgIGludk1hc3NpID0gYmkuaW52TWFzc1NvbHZlLFxuICAgICAgICBpbnZNYXNzaiA9IGJqLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52SWkgPSBiaS5pbnZJbmVydGlhU29sdmUsXG4gICAgICAgIGludklqID0gYmouaW52SW5lcnRpYVNvbHZlLFxuICAgICAgICBNZGlhZyA9IGFkZFRvV2xhbWJkYV9NZGlhZyxcbiAgICAgICAgRyA9IHRoaXMuRztcblxuICAgIEdpWzBdID0gR1swXTtcbiAgICBHaVsxXSA9IEdbMV07XG4gICAgR2pbMF0gPSBHWzNdO1xuICAgIEdqWzFdID0gR1s0XTtcblxuICAgIC8vIEFkZCB0byBsaW5lYXIgdmVsb2NpdHlcbiAgICAvLyB2X2xhbWJkYSArPSBpbnYoTSkgKiBkZWx0YV9sYW1iYSAqIEdcbiAgICB2ZWMyLnNjYWxlKHRlbXAsIEdpLCBpbnZNYXNzaSpkZWx0YWxhbWJkYSk7XG4gICAgdmVjMi5hZGQoIGJpLnZsYW1iZGEsIGJpLnZsYW1iZGEsIHRlbXApO1xuICAgIC8vIFRoaXMgaW1wdWxzZSBpcyBpbiB0aGUgb2Zmc2V0IGZyYW1lXG4gICAgLy8gQWxzbyBhZGQgY29udHJpYnV0aW9uIHRvIGFuZ3VsYXJcbiAgICAvL2JpLndsYW1iZGEgLT0gdmVjMi5jcm9zc0xlbmd0aCh0ZW1wLHJpKTtcbiAgICBiaS53bGFtYmRhICs9IGludklpICogR1syXSAqIGRlbHRhbGFtYmRhO1xuXG5cbiAgICB2ZWMyLnNjYWxlKHRlbXAsIEdqLCBpbnZNYXNzaipkZWx0YWxhbWJkYSk7XG4gICAgdmVjMi5hZGQoIGJqLnZsYW1iZGEsIGJqLnZsYW1iZGEsIHRlbXApO1xuICAgIC8vYmoud2xhbWJkYSAtPSB2ZWMyLmNyb3NzTGVuZ3RoKHRlbXAscmopO1xuICAgIGJqLndsYW1iZGEgKz0gaW52SWogKiBHWzVdICogZGVsdGFsYW1iZGE7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGRlbm9taW5hdG9yIHBhcnQgb2YgdGhlIFNQT09LIGVxdWF0aW9uOiBDID0gR1xcKmludihNKVxcKkcnICsgZXBzXG4gKiBAbWV0aG9kIGNvbXB1dGVJbnZDXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVwc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUludkMgPSBmdW5jdGlvbihlcHMpe1xuICAgIHJldHVybiAxLjAgLyAodGhpcy5jb21wdXRlR2lNR3QoKSArIGVwcyk7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vb2JqZWN0cy9Cb2R5XCI6MzIsXCIuLi91dGlscy9VdGlsc1wiOjUwfV0sMjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIEVxdWF0aW9uID0gX2RlcmVxXygnLi9FcXVhdGlvbicpXG4sICAgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZyaWN0aW9uRXF1YXRpb247XG5cbi8qKlxuICogQ29uc3RyYWlucyB0aGUgc2xpcHBpbmcgaW4gYSBjb250YWN0IGFsb25nIGEgdGFuZ2VudFxuICpcbiAqIEBjbGFzcyBGcmljdGlvbkVxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzbGlwRm9yY2VcbiAqIEBleHRlbmRzIEVxdWF0aW9uXG4gKi9cbmZ1bmN0aW9uIEZyaWN0aW9uRXF1YXRpb24oYm9keUEsIGJvZHlCLCBzbGlwRm9yY2Upe1xuICAgIEVxdWF0aW9uLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAtc2xpcEZvcmNlLCBzbGlwRm9yY2UpO1xuXG4gICAgLyoqXG4gICAgICogUmVsYXRpdmUgdmVjdG9yIGZyb20gY2VudGVyIG9mIGJvZHkgQSB0byB0aGUgY29udGFjdCBwb2ludCwgd29ybGQgb3JpZW50ZWQuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RQb2ludEFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0UG9pbnRBID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIFJlbGF0aXZlIHZlY3RvciBmcm9tIGNlbnRlciBvZiBib2R5IEIgdG8gdGhlIGNvbnRhY3QgcG9pbnQsIHdvcmxkIG9yaWVudGVkLlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0UG9pbnRCXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdFBvaW50QiA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUYW5nZW50IHZlY3RvciB0aGF0IHRoZSBmcmljdGlvbiBmb3JjZSB3aWxsIGFjdCBhbG9uZy4gV29ybGQgb3JpZW50ZWQuXG4gICAgICogQHByb3BlcnR5IHRcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy50ID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIEEgQ29udGFjdEVxdWF0aW9uIGNvbm5lY3RlZCB0byB0aGlzIGZyaWN0aW9uLiBUaGUgY29udGFjdCBlcXVhdGlvbnMgY2FuIGJlIHVzZWQgdG8gcmVzY2FsZSB0aGUgbWF4IGZvcmNlIGZvciB0aGUgZnJpY3Rpb24uIElmIG1vcmUgdGhhbiBvbmUgY29udGFjdCBlcXVhdGlvbiBpcyBnaXZlbiwgdGhlbiB0aGUgbWF4IGZvcmNlIGNhbiBiZSBzZXQgdG8gdGhlIGF2ZXJhZ2UuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RFcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7Q29udGFjdEVxdWF0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNoYXBlIGluIGJvZHkgaSB0aGF0IHRyaWdnZXJlZCB0aGlzIGZyaWN0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZUFcbiAgICAgKiBAdHlwZSB7U2hhcGV9XG4gICAgICogQHRvZG8gTmVlZGVkPyBUaGUgc2hhcGUgY2FuIGJlIGxvb2tlZCB1cCB2aWEgY29udGFjdEVxdWF0aW9uLnNoYXBlQS4uLlxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVBID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFwZSBpbiBib2R5IGogdGhhdCB0cmlnZ2VyZWQgdGhpcyBmcmljdGlvbi5cbiAgICAgKiBAcHJvcGVydHkgc2hhcGVCXG4gICAgICogQHR5cGUge1NoYXBlfVxuICAgICAqIEB0b2RvIE5lZWRlZD8gVGhlIHNoYXBlIGNhbiBiZSBsb29rZWQgdXAgdmlhIGNvbnRhY3RFcXVhdGlvbi5zaGFwZUIuLi5cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlQiA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJpY3Rpb24gY29lZmZpY2llbnQgdG8gdXNlLlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvbkNvZWZmaWNpZW50XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uQ29lZmZpY2llbnQgPSAwLjM7XG59XG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGcmljdGlvbkVxdWF0aW9uO1xuXG4vKipcbiAqIFNldCB0aGUgc2xpcHBpbmcgY29uZGl0aW9uIGZvciB0aGUgY29uc3RyYWludC4gVGhlIGZyaWN0aW9uIGZvcmNlIGNhbm5vdCBiZVxuICogbGFyZ2VyIHRoYW4gdGhpcyB2YWx1ZS5cbiAqIEBtZXRob2Qgc2V0U2xpcEZvcmNlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHNsaXBGb3JjZVxuICovXG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZS5zZXRTbGlwRm9yY2UgPSBmdW5jdGlvbihzbGlwRm9yY2Upe1xuICAgIHRoaXMubWF4Rm9yY2UgPSBzbGlwRm9yY2U7XG4gICAgdGhpcy5taW5Gb3JjZSA9IC1zbGlwRm9yY2U7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWF4IGZvcmNlIGZvciB0aGUgY29uc3RyYWludC5cbiAqIEBtZXRob2QgZ2V0U2xpcEZvcmNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlLmdldFNsaXBGb3JjZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMubWF4Rm9yY2U7XG59O1xuXG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGEsYixoKXtcbiAgICB2YXIgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHJpID0gdGhpcy5jb250YWN0UG9pbnRBLFxuICAgICAgICByaiA9IHRoaXMuY29udGFjdFBvaW50QixcbiAgICAgICAgdCA9IHRoaXMudCxcbiAgICAgICAgRyA9IHRoaXMuRztcblxuICAgIC8vIEcgPSBbLXQgLXJpeHQgdCByanh0XVxuICAgIC8vIEFuZCByZW1lbWJlciwgdGhpcyBpcyBhIHB1cmUgdmVsb2NpdHkgY29uc3RyYWludCwgZyBpcyBhbHdheXMgemVybyFcbiAgICBHWzBdID0gLXRbMF07XG4gICAgR1sxXSA9IC10WzFdO1xuICAgIEdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aChyaSx0KTtcbiAgICBHWzNdID0gdFswXTtcbiAgICBHWzRdID0gdFsxXTtcbiAgICBHWzVdID0gdmVjMi5jcm9zc0xlbmd0aChyaix0KTtcblxuICAgIHZhciBHVyA9IHRoaXMuY29tcHV0ZUdXKCksXG4gICAgICAgIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG5cbiAgICB2YXIgQiA9IC8qIC0gZyAqIGEgICovIC0gR1cgKiBiIC0gaCpHaU1mO1xuXG4gICAgcmV0dXJuIEI7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vdXRpbHMvVXRpbHNcIjo1MCxcIi4vRXF1YXRpb25cIjoyM31dLDI1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBFcXVhdGlvbiA9IF9kZXJlcV8oXCIuL0VxdWF0aW9uXCIpLFxuICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uO1xuXG4vKipcbiAqIExvY2tzIHRoZSByZWxhdGl2ZSBhbmdsZSBiZXR3ZWVuIHR3byBib2RpZXMuIFRoZSBjb25zdHJhaW50IHRyaWVzIHRvIGtlZXAgdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gdHdvIHZlY3RvcnMsIGxvY2FsIGluIGVhY2ggYm9keSwgdG8gemVyby4gVGhlIGxvY2FsIGFuZ2xlIGluIGJvZHkgaSBpcyBhIHBhcmFtZXRlci5cbiAqXG4gKiBAY2xhc3MgUm90YXRpb25hbExvY2tFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ2xlXSBBbmdsZSB0byBhZGQgdG8gdGhlIGxvY2FsIHZlY3RvciBpbiBib2R5QS5cbiAqL1xuZnVuY3Rpb24gUm90YXRpb25hbExvY2tFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIEVxdWF0aW9uLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAtTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYW5nbGVcbiAgICAgKi9cbiAgICB0aGlzLmFuZ2xlID0gb3B0aW9ucy5hbmdsZSB8fCAwO1xuXG4gICAgdmFyIEcgPSB0aGlzLkc7XG4gICAgR1syXSA9ICAxO1xuICAgIEdbNV0gPSAtMTtcbn1cblJvdGF0aW9uYWxMb2NrRXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XG5Sb3RhdGlvbmFsTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJvdGF0aW9uYWxMb2NrRXF1YXRpb247XG5cbnZhciB3b3JsZFZlY3RvckEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHdvcmxkVmVjdG9yQiA9IHZlYzIuY3JlYXRlKCksXG4gICAgeEF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMSwwKSxcbiAgICB5QXhpcyA9IHZlYzIuZnJvbVZhbHVlcygwLDEpO1xuUm90YXRpb25hbExvY2tFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlY3RvckEseEF4aXMsdGhpcy5ib2R5QS5hbmdsZSt0aGlzLmFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlY3RvckIseUF4aXMsdGhpcy5ib2R5Qi5hbmdsZSk7XG4gICAgcmV0dXJuIHZlYzIuZG90KHdvcmxkVmVjdG9yQSx3b3JsZFZlY3RvckIpO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4vRXF1YXRpb25cIjoyM31dLDI2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBFcXVhdGlvbiA9IF9kZXJlcV8oXCIuL0VxdWF0aW9uXCIpLFxuICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbjtcblxuLyoqXG4gKiBTeW5jcyByb3RhdGlvbmFsIHZlbG9jaXR5IG9mIHR3byBib2RpZXMsIG9yIHNldHMgYSByZWxhdGl2ZSB2ZWxvY2l0eSAobW90b3IpLlxuICpcbiAqIEBjbGFzcyBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICovXG5mdW5jdGlvbiBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbihib2R5QSwgYm9keUIpe1xuICAgIEVxdWF0aW9uLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAtTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgdGhpcy5yZWxhdGl2ZVZlbG9jaXR5ID0gMTtcbiAgICB0aGlzLnJhdGlvID0gMTtcbn1cblJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb247XG5Sb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihhLGIsaCl7XG4gICAgdmFyIEcgPSB0aGlzLkc7XG4gICAgR1syXSA9IC0xO1xuICAgIEdbNV0gPSB0aGlzLnJhdGlvO1xuXG4gICAgdmFyIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG4gICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKTtcbiAgICB2YXIgQiA9IC0gR1cgKiBiIC0gaCpHaU1mO1xuXG4gICAgcmV0dXJuIEI7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9FcXVhdGlvblwiOjIzfV0sMjc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBvYmplY3RzIHRoYXQgZGlzcGF0Y2hlcyBldmVudHMuXG4gKiBAY2xhc3MgRXZlbnRFbWl0dGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogRXZlbnRFbWl0dGVyLFxuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICogQG1ldGhvZCBvblxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4ge0V2ZW50RW1pdHRlcn0gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyLCBjb250ZXh0ICkge1xuICAgICAgICBsaXN0ZW5lci5jb250ZXh0ID0gY29udGV4dCB8fCB0aGlzO1xuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSA9PT0gLSAxICkge1xuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYW4gZXZlbnQgbGlzdGVuZXIgaXMgYWRkZWRcbiAgICAgKiBAbWV0aG9kIGhhc1xuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgaWYobGlzdGVuZXIpe1xuICAgICAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgIT09IC0gMSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICogQG1ldGhvZCBvZmZcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cbiAgICAgKi9cbiAgICBvZmY6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIHZhciBpbmRleCA9IGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICk7XG4gICAgICAgIGlmICggaW5kZXggIT09IC0gMSApIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1sgdHlwZSBdLnNwbGljZSggaW5kZXgsIDEgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW1pdCBhbiBldmVudC5cbiAgICAgKiBAbWV0aG9kIGVtaXRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGV2ZW50XG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBldmVudC50eXBlXG4gICAgICogQHJldHVybiB7RXZlbnRFbWl0dGVyfSBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24gKCBldmVudCApIHtcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgdmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcbiAgICAgICAgaWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbGlzdGVuZXJBcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXJyYXlbIGkgXTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsKCBsaXN0ZW5lci5jb250ZXh0LCBldmVudCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbn0se31dLDI4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBNYXRlcmlhbCA9IF9kZXJlcV8oJy4vTWF0ZXJpYWwnKTtcbnZhciBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhY3RNYXRlcmlhbDtcblxuLyoqXG4gKiBEZWZpbmVzIHdoYXQgaGFwcGVucyB3aGVuIHR3byBtYXRlcmlhbHMgbWVldCwgc3VjaCBhcyB3aGF0IGZyaWN0aW9uIGNvZWZmaWNpZW50IHRvIHVzZS4gWW91IGNhbiBhbHNvIHNldCBvdGhlciB0aGluZ3Mgc3VjaCBhcyByZXN0aXR1dGlvbiwgc3VyZmFjZSB2ZWxvY2l0eSBhbmQgY29uc3RyYWludCBwYXJhbWV0ZXJzLlxuICogQGNsYXNzIENvbnRhY3RNYXRlcmlhbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBtYXRlcmlhbEFcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1hdGVyaWFsQlxuICogQHBhcmFtIHtPYmplY3R9ICAgW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5mcmljdGlvbj0wLjNdICAgICAgIEZyaWN0aW9uIGNvZWZmaWNpZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMucmVzdGl0dXRpb249MF0gICAgICBSZXN0aXR1dGlvbiBjb2VmZmljaWVudCBha2EgXCJib3VuY2luZXNzXCIuXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5zdGlmZm5lc3NdICAgICAgICAgIENvbnRhY3RFcXVhdGlvbiBzdGlmZm5lc3MuXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5yZWxheGF0aW9uXSAgICAgICAgIENvbnRhY3RFcXVhdGlvbiByZWxheGF0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMuZnJpY3Rpb25TdGlmZm5lc3NdICBGcmljdGlvbkVxdWF0aW9uIHN0aWZmbmVzcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLmZyaWN0aW9uUmVsYXhhdGlvbl0gRnJpY3Rpb25FcXVhdGlvbiByZWxheGF0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMuc3VyZmFjZVZlbG9jaXR5PTBdICBTdXJmYWNlIHZlbG9jaXR5LlxuICogQGF1dGhvciBzY2h0ZXBwZVxuICovXG5mdW5jdGlvbiBDb250YWN0TWF0ZXJpYWwobWF0ZXJpYWxBLCBtYXRlcmlhbEIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYoIShtYXRlcmlhbEEgaW5zdGFuY2VvZiBNYXRlcmlhbCkgfHwgIShtYXRlcmlhbEIgaW5zdGFuY2VvZiBNYXRlcmlhbCkpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaXJzdCB0d28gYXJndW1lbnRzIG11c3QgYmUgTWF0ZXJpYWwgaW5zdGFuY2VzLlwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGFjdCBtYXRlcmlhbCBpZGVudGlmaWVyXG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gQ29udGFjdE1hdGVyaWFsLmlkQ291bnRlcisrO1xuXG4gICAgLyoqXG4gICAgICogRmlyc3QgbWF0ZXJpYWwgcGFydGljaXBhdGluZyBpbiB0aGUgY29udGFjdCBtYXRlcmlhbFxuICAgICAqIEBwcm9wZXJ0eSBtYXRlcmlhbEFcbiAgICAgKiBAdHlwZSB7TWF0ZXJpYWx9XG4gICAgICovXG4gICAgdGhpcy5tYXRlcmlhbEEgPSBtYXRlcmlhbEE7XG5cbiAgICAvKipcbiAgICAgKiBTZWNvbmQgbWF0ZXJpYWwgcGFydGljaXBhdGluZyBpbiB0aGUgY29udGFjdCBtYXRlcmlhbFxuICAgICAqIEBwcm9wZXJ0eSBtYXRlcmlhbEJcbiAgICAgKiBAdHlwZSB7TWF0ZXJpYWx9XG4gICAgICovXG4gICAgdGhpcy5tYXRlcmlhbEIgPSBtYXRlcmlhbEI7XG5cbiAgICAvKipcbiAgICAgKiBGcmljdGlvbiB0byB1c2UgaW4gdGhlIGNvbnRhY3Qgb2YgdGhlc2UgdHdvIG1hdGVyaWFsc1xuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbiAgICA9ICB0eXBlb2Yob3B0aW9ucy5mcmljdGlvbikgICAgIT09IFwidW5kZWZpbmVkXCIgPyAgIE51bWJlcihvcHRpb25zLmZyaWN0aW9uKSAgICA6IDAuMztcblxuICAgIC8qKlxuICAgICAqIFJlc3RpdHV0aW9uIHRvIHVzZSBpbiB0aGUgY29udGFjdCBvZiB0aGVzZSB0d28gbWF0ZXJpYWxzXG4gICAgICogQHByb3BlcnR5IHJlc3RpdHV0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RpdHV0aW9uID0gIHR5cGVvZihvcHRpb25zLnJlc3RpdHV0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIiA/ICAgTnVtYmVyKG9wdGlvbnMucmVzdGl0dXRpb24pIDogMC4wO1xuXG4gICAgLyoqXG4gICAgICogU3RpZmZuZXNzIG9mIHRoZSByZXN1bHRpbmcgQ29udGFjdEVxdWF0aW9uIHRoYXQgdGhpcyBDb250YWN0TWF0ZXJpYWwgZ2VuZXJhdGVcbiAgICAgKiBAcHJvcGVydHkgc3RpZmZuZXNzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnN0aWZmbmVzcyA9ICAgICAgICAgICAgdHlwZW9mKG9wdGlvbnMuc3RpZmZuZXNzKSAgICAgICAgICAgIT09IFwidW5kZWZpbmVkXCIgPyAgIE51bWJlcihvcHRpb25zLnN0aWZmbmVzcykgICA6IEVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTO1xuXG4gICAgLyoqXG4gICAgICogUmVsYXhhdGlvbiBvZiB0aGUgcmVzdWx0aW5nIENvbnRhY3RFcXVhdGlvbiB0aGF0IHRoaXMgQ29udGFjdE1hdGVyaWFsIGdlbmVyYXRlXG4gICAgICogQHByb3BlcnR5IHJlbGF4YXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVsYXhhdGlvbiA9ICAgICAgICAgICB0eXBlb2Yob3B0aW9ucy5yZWxheGF0aW9uKSAgICAgICAgICAhPT0gXCJ1bmRlZmluZWRcIiA/ICAgTnVtYmVyKG9wdGlvbnMucmVsYXhhdGlvbikgIDogRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OO1xuXG4gICAgLyoqXG4gICAgICogU3RpZmZuZXNzIG9mIHRoZSByZXN1bHRpbmcgRnJpY3Rpb25FcXVhdGlvbiB0aGF0IHRoaXMgQ29udGFjdE1hdGVyaWFsIGdlbmVyYXRlXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uU3RpZmZuZXNzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uU3RpZmZuZXNzID0gICAgdHlwZW9mKG9wdGlvbnMuZnJpY3Rpb25TdGlmZm5lc3MpICAgIT09IFwidW5kZWZpbmVkXCIgPyAgIE51bWJlcihvcHRpb25zLmZyaWN0aW9uU3RpZmZuZXNzKSAgIDogRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1M7XG5cbiAgICAvKipcbiAgICAgKiBSZWxheGF0aW9uIG9mIHRoZSByZXN1bHRpbmcgRnJpY3Rpb25FcXVhdGlvbiB0aGF0IHRoaXMgQ29udGFjdE1hdGVyaWFsIGdlbmVyYXRlXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uUmVsYXhhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvblJlbGF4YXRpb24gPSAgIHR5cGVvZihvcHRpb25zLmZyaWN0aW9uUmVsYXhhdGlvbikgICE9PSBcInVuZGVmaW5lZFwiID8gICBOdW1iZXIob3B0aW9ucy5mcmljdGlvblJlbGF4YXRpb24pICA6IEVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTjtcblxuICAgIC8qKlxuICAgICAqIFdpbGwgYWRkIHN1cmZhY2UgdmVsb2NpdHkgdG8gdGhpcyBtYXRlcmlhbC4gSWYgYm9keUEgcmVzdHMgb24gdG9wIGlmIGJvZHlCLCBhbmQgdGhlIHN1cmZhY2UgdmVsb2NpdHkgaXMgcG9zaXRpdmUsIGJvZHlBIHdpbGwgc2xpZGUgdG8gdGhlIHJpZ2h0LlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzdXJmYWNlVmVsb2NpdHlcbiAgICAgKi9cbiAgICB0aGlzLnN1cmZhY2VWZWxvY2l0eSA9IHR5cGVvZihvcHRpb25zLnN1cmZhY2VWZWxvY2l0eSkgICAgIT09IFwidW5kZWZpbmVkXCIgPyAgIE51bWJlcihvcHRpb25zLnN1cmZhY2VWZWxvY2l0eSkgICAgOiAwO1xuXG4gICAgLyoqXG4gICAgICogT2Zmc2V0IHRvIGJlIHNldCBvbiBDb250YWN0RXF1YXRpb25zLiBBIHBvc2l0aXZlIHZhbHVlIHdpbGwgbWFrZSB0aGUgYm9kaWVzIHBlbmV0cmF0ZSBtb3JlIGludG8gZWFjaCBvdGhlci4gQ2FuIGJlIHVzZWZ1bCBpbiBzY2VuZXMgd2hlcmUgY29udGFjdHMgbmVlZCB0byBiZSBtb3JlIHBlcnNpc3RlbnQsIGZvciBleGFtcGxlIHdoZW4gc3RhY2tpbmcuIEFrYSBcImN1cmUgZm9yIG5lcnZvdXMgY29udGFjdHNcIi5cbiAgICAgKiBAcHJvcGVydHkgY29udGFjdFNraW5TaXplXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RTa2luU2l6ZSA9IDAuMDA1O1xufVxuXG5Db250YWN0TWF0ZXJpYWwuaWRDb3VudGVyID0gMDtcblxufSx7XCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIjoyMyxcIi4vTWF0ZXJpYWxcIjoyOX1dLDI5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gTWF0ZXJpYWw7XG5cbi8qKlxuICogRGVmaW5lcyBhIHBoeXNpY3MgbWF0ZXJpYWwuXG4gKiBAY2xhc3MgTWF0ZXJpYWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGlkIE1hdGVyaWFsIGlkZW50aWZpZXJcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqL1xuZnVuY3Rpb24gTWF0ZXJpYWwoaWQpe1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXRlcmlhbCBpZGVudGlmaWVyXG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gaWQgfHwgTWF0ZXJpYWwuaWRDb3VudGVyKys7XG59XG5cbk1hdGVyaWFsLmlkQ291bnRlciA9IDA7XG5cbn0se31dLDMwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuICAgIC8qXG4gICAgICAgIFBvbHlLIGxpYnJhcnlcbiAgICAgICAgdXJsOiBodHRwOi8vcG9seWsuaXZhbmsubmV0XG4gICAgICAgIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbmNlLlxuXG4gICAgICAgIENvcHlyaWdodCAoYykgMjAxMiBJdmFuIEt1Y2tpclxuXG4gICAgICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gICAgICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gICAgICAgIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICAgICAgICByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAgICAgICAgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICAgICAgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gICAgICAgIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gICAgICAgIGNvbmRpdGlvbnM6XG5cbiAgICAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgICAgICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgICAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgICAgICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gICAgICAgIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gICAgICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gICAgICAgIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICAgICAgICBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAgICAgICAgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICAgICAgICBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gICAgKi9cblxuICAgIHZhciBQb2x5SyA9IHt9O1xuXG4gICAgLypcbiAgICAgICAgSXMgUG9seWdvbiBzZWxmLWludGVyc2VjdGluZz9cblxuICAgICAgICBPKG5eMilcbiAgICAqL1xuICAgIC8qXG4gICAgUG9seUsuSXNTaW1wbGUgPSBmdW5jdGlvbihwKVxuICAgIHtcbiAgICAgICAgdmFyIG4gPSBwLmxlbmd0aD4+MTtcbiAgICAgICAgaWYobjw0KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIGExID0gbmV3IFBvbHlLLl9QKCksIGEyID0gbmV3IFBvbHlLLl9QKCk7XG4gICAgICAgIHZhciBiMSA9IG5ldyBQb2x5Sy5fUCgpLCBiMiA9IG5ldyBQb2x5Sy5fUCgpO1xuICAgICAgICB2YXIgYyA9IG5ldyBQb2x5Sy5fUCgpO1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgYTEueCA9IHBbMippICBdO1xuICAgICAgICAgICAgYTEueSA9IHBbMippKzFdO1xuICAgICAgICAgICAgaWYoaT09bi0xKSAgeyBhMi54ID0gcFswICAgIF07ICBhMi55ID0gcFsxICAgIF07IH1cbiAgICAgICAgICAgIGVsc2UgICAgICAgIHsgYTIueCA9IHBbMippKzJdOyAgYTIueSA9IHBbMippKzNdOyB9XG5cbiAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPG47IGorKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZihNYXRoLmFicyhpLWopIDwgMikgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYoaj09bi0xICYmIGk9PTApIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmKGk9PW4tMSAmJiBqPT0wKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGIxLnggPSBwWzIqaiAgXTtcbiAgICAgICAgICAgICAgICBiMS55ID0gcFsyKmorMV07XG4gICAgICAgICAgICAgICAgaWYoaj09bi0xKSAgeyBiMi54ID0gcFswICAgIF07ICBiMi55ID0gcFsxICAgIF07IH1cbiAgICAgICAgICAgICAgICBlbHNlICAgICAgICB7IGIyLnggPSBwWzIqaisyXTsgIGIyLnkgPSBwWzIqaiszXTsgfVxuXG4gICAgICAgICAgICAgICAgaWYoUG9seUsuX0dldExpbmVJbnRlcnNlY3Rpb24oYTEsYTIsYjEsYjIsYykgIT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIFBvbHlLLklzQ29udmV4ID0gZnVuY3Rpb24ocClcbiAgICB7XG4gICAgICAgIGlmKHAubGVuZ3RoPDYpIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgbCA9IHAubGVuZ3RoIC0gNDtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bDsgaSs9MilcbiAgICAgICAgICAgIGlmKCFQb2x5Sy5fY29udmV4KHBbaV0sIHBbaSsxXSwgcFtpKzJdLCBwW2krM10sIHBbaSs0XSwgcFtpKzVdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZighUG9seUsuX2NvbnZleChwW2wgIF0sIHBbbCsxXSwgcFtsKzJdLCBwW2wrM10sIHBbMF0sIHBbMV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmKCFQb2x5Sy5fY29udmV4KHBbbCsyXSwgcFtsKzNdLCBwWzAgIF0sIHBbMSAgXSwgcFsyXSwgcFszXSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgICovXG4gICAgUG9seUsuR2V0QXJlYSA9IGZ1bmN0aW9uKHApXG4gICAge1xuICAgICAgICBpZihwLmxlbmd0aCA8NikgcmV0dXJuIDA7XG4gICAgICAgIHZhciBsID0gcC5sZW5ndGggLSAyO1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bDsgaSs9MilcbiAgICAgICAgICAgIHN1bSArPSAocFtpKzJdLXBbaV0pICogKHBbaSsxXStwW2krM10pO1xuICAgICAgICBzdW0gKz0gKHBbMF0tcFtsXSkgKiAocFtsKzFdK3BbMV0pO1xuICAgICAgICByZXR1cm4gLSBzdW0gKiAwLjU7XG4gICAgfVxuICAgIC8qXG4gICAgUG9seUsuR2V0QUFCQiA9IGZ1bmN0aW9uKHApXG4gICAge1xuICAgICAgICB2YXIgbWlueCA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbWlueSA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbWF4eCA9IC1taW54O1xuICAgICAgICB2YXIgbWF4eSA9IC1taW55O1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxwLmxlbmd0aDsgaSs9MilcbiAgICAgICAge1xuICAgICAgICAgICAgbWlueCA9IE1hdGgubWluKG1pbngsIHBbaSAgXSk7XG4gICAgICAgICAgICBtYXh4ID0gTWF0aC5tYXgobWF4eCwgcFtpICBdKTtcbiAgICAgICAgICAgIG1pbnkgPSBNYXRoLm1pbihtaW55LCBwW2krMV0pO1xuICAgICAgICAgICAgbWF4eSA9IE1hdGgubWF4KG1heHksIHBbaSsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt4Om1pbngsIHk6bWlueSwgd2lkdGg6bWF4eC1taW54LCBoZWlnaHQ6bWF4eS1taW55fTtcbiAgICB9XG4gICAgKi9cblxuICAgIFBvbHlLLlRyaWFuZ3VsYXRlID0gZnVuY3Rpb24ocClcbiAgICB7XG4gICAgICAgIHZhciBuID0gcC5sZW5ndGg+PjE7XG4gICAgICAgIGlmKG48MykgcmV0dXJuIFtdO1xuICAgICAgICB2YXIgdGdzID0gW107XG4gICAgICAgIHZhciBhdmwgPSBbXTtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bjsgaSsrKSBhdmwucHVzaChpKTtcblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBhbCA9IG47XG4gICAgICAgIHdoaWxlKGFsID4gMylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGkwID0gYXZsWyhpKzApJWFsXTtcbiAgICAgICAgICAgIHZhciBpMSA9IGF2bFsoaSsxKSVhbF07XG4gICAgICAgICAgICB2YXIgaTIgPSBhdmxbKGkrMiklYWxdO1xuXG4gICAgICAgICAgICB2YXIgYXggPSBwWzIqaTBdLCAgYXkgPSBwWzIqaTArMV07XG4gICAgICAgICAgICB2YXIgYnggPSBwWzIqaTFdLCAgYnkgPSBwWzIqaTErMV07XG4gICAgICAgICAgICB2YXIgY3ggPSBwWzIqaTJdLCAgY3kgPSBwWzIqaTIrMV07XG5cbiAgICAgICAgICAgIHZhciBlYXJGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYoUG9seUsuX2NvbnZleChheCwgYXksIGJ4LCBieSwgY3gsIGN5KSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBlYXJGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8YWw7IGorKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2aSA9IGF2bFtqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYodmk9PWkwIHx8IHZpPT1pMSB8fCB2aT09aTIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZihQb2x5Sy5fUG9pbnRJblRyaWFuZ2xlKHBbMip2aV0sIHBbMip2aSsxXSwgYXgsIGF5LCBieCwgYnksIGN4LCBjeSkpIHtlYXJGb3VuZCA9IGZhbHNlOyBicmVhazt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZWFyRm91bmQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGdzLnB1c2goaTAsIGkxLCBpMik7XG4gICAgICAgICAgICAgICAgYXZsLnNwbGljZSgoaSsxKSVhbCwgMSk7XG4gICAgICAgICAgICAgICAgYWwtLTtcbiAgICAgICAgICAgICAgICBpPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihpKysgPiAzKmFsKSBicmVhazsgICAgICAvLyBubyBjb252ZXggYW5nbGVzIDooXG4gICAgICAgIH1cbiAgICAgICAgdGdzLnB1c2goYXZsWzBdLCBhdmxbMV0sIGF2bFsyXSk7XG4gICAgICAgIHJldHVybiB0Z3M7XG4gICAgfVxuICAgIC8qXG4gICAgUG9seUsuQ29udGFpbnNQb2ludCA9IGZ1bmN0aW9uKHAsIHB4LCBweSlcbiAgICB7XG4gICAgICAgIHZhciBuID0gcC5sZW5ndGg+PjE7XG4gICAgICAgIHZhciBheCwgYXksIGJ4ID0gcFsyKm4tMl0tcHgsIGJ5ID0gcFsyKm4tMV0tcHk7XG4gICAgICAgIHZhciBkZXB0aCA9IDA7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgYXggPSBieDsgIGF5ID0gYnk7XG4gICAgICAgICAgICBieCA9IHBbMippICBdIC0gcHg7XG4gICAgICAgICAgICBieSA9IHBbMippKzFdIC0gcHk7XG4gICAgICAgICAgICBpZihheTwgMCAmJiBieTwgMCkgY29udGludWU7ICAgIC8vIGJvdGggXCJ1cFwiIG9yIGJvdGggXCJkb253XCJcbiAgICAgICAgICAgIGlmKGF5Pj0wICYmIGJ5Pj0wKSBjb250aW51ZTsgICAgLy8gYm90aCBcInVwXCIgb3IgYm90aCBcImRvbndcIlxuICAgICAgICAgICAgaWYoYXg8IDAgJiYgYng8IDApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB2YXIgbHggPSBheCArIChieC1heCkqKC1heSkvKGJ5LWF5KTtcbiAgICAgICAgICAgIGlmKGx4PjApIGRlcHRoKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChkZXB0aCAmIDEpID09IDE7XG4gICAgfVxuXG4gICAgUG9seUsuU2xpY2UgPSBmdW5jdGlvbihwLCBheCwgYXksIGJ4LCBieSlcbiAgICB7XG4gICAgICAgIGlmKFBvbHlLLkNvbnRhaW5zUG9pbnQocCwgYXgsIGF5KSB8fCBQb2x5Sy5Db250YWluc1BvaW50KHAsIGJ4LCBieSkpIHJldHVybiBbcC5zbGljZSgwKV07XG5cbiAgICAgICAgdmFyIGEgPSBuZXcgUG9seUsuX1AoYXgsIGF5KTtcbiAgICAgICAgdmFyIGIgPSBuZXcgUG9seUsuX1AoYngsIGJ5KTtcbiAgICAgICAgdmFyIGlzY3MgPSBbXTsgIC8vIGludGVyc2VjdGlvbnNcbiAgICAgICAgdmFyIHBzID0gW107ICAgIC8vIHBvaW50c1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxwLmxlbmd0aDsgaSs9MikgcHMucHVzaChuZXcgUG9seUsuX1AocFtpXSwgcFtpKzFdKSk7XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8cHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpc2MgPSBuZXcgUG9seUsuX1AoMCwwKTtcbiAgICAgICAgICAgIGlzYyA9IFBvbHlLLl9HZXRMaW5lSW50ZXJzZWN0aW9uKGEsIGIsIHBzW2ldLCBwc1soaSsxKSVwcy5sZW5ndGhdLCBpc2MpO1xuXG4gICAgICAgICAgICBpZihpc2MpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaXNjLmZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlzY3MucHVzaChpc2MpO1xuICAgICAgICAgICAgICAgIHBzLnNwbGljZShpKzEsMCxpc2MpO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZihpc2NzLmxlbmd0aCA9PSAwKSByZXR1cm4gW3Auc2xpY2UoMCldO1xuICAgICAgICB2YXIgY29tcCA9IGZ1bmN0aW9uKHUsdikge3JldHVybiBQb2x5Sy5fUC5kaXN0KGEsdSkgLSBQb2x5Sy5fUC5kaXN0KGEsdik7IH1cbiAgICAgICAgaXNjcy5zb3J0KGNvbXApO1xuXG4gICAgICAgIHZhciBwZ3MgPSBbXTtcbiAgICAgICAgdmFyIGRpciA9IDA7XG4gICAgICAgIHdoaWxlKGlzY3MubGVuZ3RoID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIG4gPSBwcy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaTAgPSBpc2NzWzBdO1xuICAgICAgICAgICAgdmFyIGkxID0gaXNjc1sxXTtcbiAgICAgICAgICAgIHZhciBpbmQwID0gcHMuaW5kZXhPZihpMCk7XG4gICAgICAgICAgICB2YXIgaW5kMSA9IHBzLmluZGV4T2YoaTEpO1xuICAgICAgICAgICAgdmFyIHNvbHZlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZihQb2x5Sy5fZmlyc3RXaXRoRmxhZyhwcywgaW5kMCkgPT0gaW5kMSkgc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpMCA9IGlzY3NbMV07XG4gICAgICAgICAgICAgICAgaTEgPSBpc2NzWzBdO1xuICAgICAgICAgICAgICAgIGluZDAgPSBwcy5pbmRleE9mKGkwKTtcbiAgICAgICAgICAgICAgICBpbmQxID0gcHMuaW5kZXhPZihpMSk7XG4gICAgICAgICAgICAgICAgaWYoUG9seUsuX2ZpcnN0V2l0aEZsYWcocHMsIGluZDApID09IGluZDEpIHNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzb2x2ZWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGlyLS07XG4gICAgICAgICAgICAgICAgdmFyIHBnbiA9IFBvbHlLLl9nZXRQb2ludHMocHMsIGluZDAsIGluZDEpO1xuICAgICAgICAgICAgICAgIHBncy5wdXNoKHBnbik7XG4gICAgICAgICAgICAgICAgcHMgPSBQb2x5Sy5fZ2V0UG9pbnRzKHBzLCBpbmQxLCBpbmQwKTtcbiAgICAgICAgICAgICAgICBpMC5mbGFnID0gaTEuZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlzY3Muc3BsaWNlKDAsMik7XG4gICAgICAgICAgICAgICAgaWYoaXNjcy5sZW5ndGggPT0gMCkgcGdzLnB1c2gocHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IGRpcisrOyBpc2NzLnJldmVyc2UoKTsgfVxuICAgICAgICAgICAgaWYoZGlyPjEpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8cGdzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGcgPSBwZ3NbaV07XG4gICAgICAgICAgICB2YXIgbnBnID0gW107XG4gICAgICAgICAgICBmb3IodmFyIGo9MDsgajxwZy5sZW5ndGg7IGorKykgbnBnLnB1c2gocGdbal0ueCwgcGdbal0ueSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChucGcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgUG9seUsuUmF5Y2FzdCA9IGZ1bmN0aW9uKHAsIHgsIHksIGR4LCBkeSwgaXNjKVxuICAgIHtcbiAgICAgICAgdmFyIGwgPSBwLmxlbmd0aCAtIDI7XG4gICAgICAgIHZhciB0cCA9IFBvbHlLLl90cDtcbiAgICAgICAgdmFyIGExID0gdHBbMF0sIGEyID0gdHBbMV0sXG4gICAgICAgIGIxID0gdHBbMl0sIGIyID0gdHBbM10sIGMgPSB0cFs0XTtcbiAgICAgICAgYTEueCA9IHg7IGExLnkgPSB5O1xuICAgICAgICBhMi54ID0geCtkeDsgYTIueSA9IHkrZHk7XG5cbiAgICAgICAgaWYoaXNjPT1udWxsKSBpc2MgPSB7ZGlzdDowLCBlZGdlOjAsIG5vcm06e3g6MCwgeTowfSwgcmVmbDp7eDowLCB5OjB9fTtcbiAgICAgICAgaXNjLmRpc3QgPSBJbmZpbml0eTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxsOyBpKz0yKVxuICAgICAgICB7XG4gICAgICAgICAgICBiMS54ID0gcFtpICBdOyAgYjEueSA9IHBbaSsxXTtcbiAgICAgICAgICAgIGIyLnggPSBwW2krMl07ICBiMi55ID0gcFtpKzNdO1xuICAgICAgICAgICAgdmFyIG5pc2MgPSBQb2x5Sy5fUmF5TGluZUludGVyc2VjdGlvbihhMSwgYTIsIGIxLCBiMiwgYyk7XG4gICAgICAgICAgICBpZihuaXNjKSBQb2x5Sy5fdXBkYXRlSVNDKGR4LCBkeSwgYTEsIGIxLCBiMiwgYywgaS8yLCBpc2MpO1xuICAgICAgICB9XG4gICAgICAgIGIxLnggPSBiMi54OyAgYjEueSA9IGIyLnk7XG4gICAgICAgIGIyLnggPSBwWzBdOyAgYjIueSA9IHBbMV07XG4gICAgICAgIHZhciBuaXNjID0gUG9seUsuX1JheUxpbmVJbnRlcnNlY3Rpb24oYTEsIGEyLCBiMSwgYjIsIGMpO1xuICAgICAgICBpZihuaXNjKSBQb2x5Sy5fdXBkYXRlSVNDKGR4LCBkeSwgYTEsIGIxLCBiMiwgYywgcC5sZW5ndGgvMiwgaXNjKTtcblxuICAgICAgICByZXR1cm4gKGlzYy5kaXN0ICE9IEluZmluaXR5KSA/IGlzYyA6IG51bGw7XG4gICAgfVxuXG4gICAgUG9seUsuQ2xvc2VzdEVkZ2UgPSBmdW5jdGlvbihwLCB4LCB5LCBpc2MpXG4gICAge1xuICAgICAgICB2YXIgbCA9IHAubGVuZ3RoIC0gMjtcbiAgICAgICAgdmFyIHRwID0gUG9seUsuX3RwO1xuICAgICAgICB2YXIgYTEgPSB0cFswXSxcbiAgICAgICAgYjEgPSB0cFsyXSwgYjIgPSB0cFszXSwgYyA9IHRwWzRdO1xuICAgICAgICBhMS54ID0geDsgYTEueSA9IHk7XG5cbiAgICAgICAgaWYoaXNjPT1udWxsKSBpc2MgPSB7ZGlzdDowLCBlZGdlOjAsIHBvaW50Ont4OjAsIHk6MH0sIG5vcm06e3g6MCwgeTowfX07XG4gICAgICAgIGlzYy5kaXN0ID0gSW5maW5pdHk7XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bDsgaSs9MilcbiAgICAgICAge1xuICAgICAgICAgICAgYjEueCA9IHBbaSAgXTsgIGIxLnkgPSBwW2krMV07XG4gICAgICAgICAgICBiMi54ID0gcFtpKzJdOyAgYjIueSA9IHBbaSszXTtcbiAgICAgICAgICAgIFBvbHlLLl9wb2ludExpbmVEaXN0KGExLCBiMSwgYjIsIGk+PjEsIGlzYyk7XG4gICAgICAgIH1cbiAgICAgICAgYjEueCA9IGIyLng7ICBiMS55ID0gYjIueTtcbiAgICAgICAgYjIueCA9IHBbMF07ICBiMi55ID0gcFsxXTtcbiAgICAgICAgUG9seUsuX3BvaW50TGluZURpc3QoYTEsIGIxLCBiMiwgbD4+MSwgaXNjKTtcblxuICAgICAgICB2YXIgaWRzdCA9IDEvaXNjLmRpc3Q7XG4gICAgICAgIGlzYy5ub3JtLnggPSAoeC1pc2MucG9pbnQueCkqaWRzdDtcbiAgICAgICAgaXNjLm5vcm0ueSA9ICh5LWlzYy5wb2ludC55KSppZHN0O1xuICAgICAgICByZXR1cm4gaXNjO1xuICAgIH1cblxuICAgIFBvbHlLLl9wb2ludExpbmVEaXN0ID0gZnVuY3Rpb24ocCwgYSwgYiwgZWRnZSwgaXNjKVxuICAgIHtcbiAgICAgICAgdmFyIHggPSBwLngsIHkgPSBwLnksIHgxID0gYS54LCB5MSA9IGEueSwgeDIgPSBiLngsIHkyID0gYi55O1xuXG4gICAgICAgIHZhciBBID0geCAtIHgxO1xuICAgICAgICB2YXIgQiA9IHkgLSB5MTtcbiAgICAgICAgdmFyIEMgPSB4MiAtIHgxO1xuICAgICAgICB2YXIgRCA9IHkyIC0geTE7XG5cbiAgICAgICAgdmFyIGRvdCA9IEEgKiBDICsgQiAqIEQ7XG4gICAgICAgIHZhciBsZW5fc3EgPSBDICogQyArIEQgKiBEO1xuICAgICAgICB2YXIgcGFyYW0gPSBkb3QgLyBsZW5fc3E7XG5cbiAgICAgICAgdmFyIHh4LCB5eTtcblxuICAgICAgICBpZiAocGFyYW0gPCAwIHx8ICh4MSA9PSB4MiAmJiB5MSA9PSB5MikpIHtcbiAgICAgICAgICAgIHh4ID0geDE7XG4gICAgICAgICAgICB5eSA9IHkxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmFtID4gMSkge1xuICAgICAgICAgICAgeHggPSB4MjtcbiAgICAgICAgICAgIHl5ID0geTI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4eCA9IHgxICsgcGFyYW0gKiBDO1xuICAgICAgICAgICAgeXkgPSB5MSArIHBhcmFtICogRDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkeCA9IHggLSB4eDtcbiAgICAgICAgdmFyIGR5ID0geSAtIHl5O1xuICAgICAgICB2YXIgZHN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgaWYoZHN0PGlzYy5kaXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBpc2MuZGlzdCA9IGRzdDtcbiAgICAgICAgICAgIGlzYy5lZGdlID0gZWRnZTtcbiAgICAgICAgICAgIGlzYy5wb2ludC54ID0geHg7XG4gICAgICAgICAgICBpc2MucG9pbnQueSA9IHl5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgUG9seUsuX3VwZGF0ZUlTQyA9IGZ1bmN0aW9uKGR4LCBkeSwgYTEsIGIxLCBiMiwgYywgZWRnZSwgaXNjKVxuICAgIHtcbiAgICAgICAgdmFyIG5ybCA9IFBvbHlLLl9QLmRpc3QoYTEsIGMpO1xuICAgICAgICBpZihucmw8aXNjLmRpc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpYmwgPSAxL1BvbHlLLl9QLmRpc3QoYjEsIGIyKTtcbiAgICAgICAgICAgIHZhciBueCA9IC0oYjIueS1iMS55KSppYmw7XG4gICAgICAgICAgICB2YXIgbnkgPSAgKGIyLngtYjEueCkqaWJsO1xuICAgICAgICAgICAgdmFyIGRkb3QgPSAyKihkeCpueCtkeSpueSk7XG4gICAgICAgICAgICBpc2MuZGlzdCA9IG5ybDtcbiAgICAgICAgICAgIGlzYy5ub3JtLnggPSBueDtcbiAgICAgICAgICAgIGlzYy5ub3JtLnkgPSBueTtcbiAgICAgICAgICAgIGlzYy5yZWZsLnggPSAtZGRvdCpueCtkeDtcbiAgICAgICAgICAgIGlzYy5yZWZsLnkgPSAtZGRvdCpueStkeTtcbiAgICAgICAgICAgIGlzYy5lZGdlID0gZWRnZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFBvbHlLLl9nZXRQb2ludHMgPSBmdW5jdGlvbihwcywgaW5kMCwgaW5kMSlcbiAgICB7XG4gICAgICAgIHZhciBuID0gcHMubGVuZ3RoO1xuICAgICAgICB2YXIgbnBzID0gW107XG4gICAgICAgIGlmKGluZDE8aW5kMCkgaW5kMSArPSBuO1xuICAgICAgICBmb3IodmFyIGk9aW5kMDsgaTw9IGluZDE7IGkrKykgbnBzLnB1c2gocHNbaSVuXSk7XG4gICAgICAgIHJldHVybiBucHM7XG4gICAgfVxuXG4gICAgUG9seUsuX2ZpcnN0V2l0aEZsYWcgPSBmdW5jdGlvbihwcywgaW5kKVxuICAgIHtcbiAgICAgICAgdmFyIG4gPSBwcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlKHRydWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGluZCA9IChpbmQrMSklbjtcbiAgICAgICAgICAgIGlmKHBzW2luZF0uZmxhZykgcmV0dXJuIGluZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqL1xuICAgIFBvbHlLLl9Qb2ludEluVHJpYW5nbGUgPSBmdW5jdGlvbihweCwgcHksIGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpXG4gICAge1xuICAgICAgICB2YXIgdjB4ID0gY3gtYXg7XG4gICAgICAgIHZhciB2MHkgPSBjeS1heTtcbiAgICAgICAgdmFyIHYxeCA9IGJ4LWF4O1xuICAgICAgICB2YXIgdjF5ID0gYnktYXk7XG4gICAgICAgIHZhciB2MnggPSBweC1heDtcbiAgICAgICAgdmFyIHYyeSA9IHB5LWF5O1xuXG4gICAgICAgIHZhciBkb3QwMCA9IHYweCp2MHgrdjB5KnYweTtcbiAgICAgICAgdmFyIGRvdDAxID0gdjB4KnYxeCt2MHkqdjF5O1xuICAgICAgICB2YXIgZG90MDIgPSB2MHgqdjJ4K3YweSp2Mnk7XG4gICAgICAgIHZhciBkb3QxMSA9IHYxeCp2MXgrdjF5KnYxeTtcbiAgICAgICAgdmFyIGRvdDEyID0gdjF4KnYyeCt2MXkqdjJ5O1xuXG4gICAgICAgIHZhciBpbnZEZW5vbSA9IDEgLyAoZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEpO1xuICAgICAgICB2YXIgdSA9IChkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMikgKiBpbnZEZW5vbTtcbiAgICAgICAgdmFyIHYgPSAoZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIpICogaW52RGVub207XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgcG9pbnQgaXMgaW4gdHJpYW5nbGVcbiAgICAgICAgcmV0dXJuICh1ID49IDApICYmICh2ID49IDApICYmICh1ICsgdiA8IDEpO1xuICAgIH1cbiAgICAvKlxuICAgIFBvbHlLLl9SYXlMaW5lSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYTEsIGEyLCBiMSwgYjIsIGMpXG4gICAge1xuICAgICAgICB2YXIgZGF4ID0gKGExLngtYTIueCksIGRieCA9IChiMS54LWIyLngpO1xuICAgICAgICB2YXIgZGF5ID0gKGExLnktYTIueSksIGRieSA9IChiMS55LWIyLnkpO1xuXG4gICAgICAgIHZhciBEZW4gPSBkYXgqZGJ5IC0gZGF5KmRieDtcbiAgICAgICAgaWYgKERlbiA9PSAwKSByZXR1cm4gbnVsbDsgIC8vIHBhcmFsbGVsXG5cbiAgICAgICAgdmFyIEEgPSAoYTEueCAqIGEyLnkgLSBhMS55ICogYTIueCk7XG4gICAgICAgIHZhciBCID0gKGIxLnggKiBiMi55IC0gYjEueSAqIGIyLngpO1xuXG4gICAgICAgIHZhciBJID0gYztcbiAgICAgICAgdmFyIGlEZW4gPSAxL0RlbjtcbiAgICAgICAgSS54ID0gKCBBKmRieCAtIGRheCpCICkgKiBpRGVuO1xuICAgICAgICBJLnkgPSAoIEEqZGJ5IC0gZGF5KkIgKSAqIGlEZW47XG5cbiAgICAgICAgaWYoIVBvbHlLLl9JblJlY3QoSSwgYjEsIGIyKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmKChkYXk+MCAmJiBJLnk+YTEueSkgfHwgKGRheTwwICYmIEkueTxhMS55KSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmKChkYXg+MCAmJiBJLng+YTEueCkgfHwgKGRheDwwICYmIEkueDxhMS54KSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBJO1xuICAgIH1cblxuICAgIFBvbHlLLl9HZXRMaW5lSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYTEsIGEyLCBiMSwgYjIsIGMpXG4gICAge1xuICAgICAgICB2YXIgZGF4ID0gKGExLngtYTIueCksIGRieCA9IChiMS54LWIyLngpO1xuICAgICAgICB2YXIgZGF5ID0gKGExLnktYTIueSksIGRieSA9IChiMS55LWIyLnkpO1xuXG4gICAgICAgIHZhciBEZW4gPSBkYXgqZGJ5IC0gZGF5KmRieDtcbiAgICAgICAgaWYgKERlbiA9PSAwKSByZXR1cm4gbnVsbDsgIC8vIHBhcmFsbGVsXG5cbiAgICAgICAgdmFyIEEgPSAoYTEueCAqIGEyLnkgLSBhMS55ICogYTIueCk7XG4gICAgICAgIHZhciBCID0gKGIxLnggKiBiMi55IC0gYjEueSAqIGIyLngpO1xuXG4gICAgICAgIHZhciBJID0gYztcbiAgICAgICAgSS54ID0gKCBBKmRieCAtIGRheCpCICkgLyBEZW47XG4gICAgICAgIEkueSA9ICggQSpkYnkgLSBkYXkqQiApIC8gRGVuO1xuXG4gICAgICAgIGlmKFBvbHlLLl9JblJlY3QoSSwgYTEsIGEyKSAmJiBQb2x5Sy5fSW5SZWN0KEksIGIxLCBiMikpIHJldHVybiBJO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBQb2x5Sy5fSW5SZWN0ID0gZnVuY3Rpb24oYSwgYiwgYylcbiAgICB7XG4gICAgICAgIGlmICAoYi54ID09IGMueCkgcmV0dXJuIChhLnk+PU1hdGgubWluKGIueSwgYy55KSAmJiBhLnk8PU1hdGgubWF4KGIueSwgYy55KSk7XG4gICAgICAgIGlmICAoYi55ID09IGMueSkgcmV0dXJuIChhLng+PU1hdGgubWluKGIueCwgYy54KSAmJiBhLng8PU1hdGgubWF4KGIueCwgYy54KSk7XG5cbiAgICAgICAgaWYoYS54ID49IE1hdGgubWluKGIueCwgYy54KSAmJiBhLnggPD0gTWF0aC5tYXgoYi54LCBjLngpXG4gICAgICAgICYmIGEueSA+PSBNYXRoLm1pbihiLnksIGMueSkgJiYgYS55IDw9IE1hdGgubWF4KGIueSwgYy55KSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgKi9cbiAgICBQb2x5Sy5fY29udmV4ID0gZnVuY3Rpb24oYXgsIGF5LCBieCwgYnksIGN4LCBjeSlcbiAgICB7XG4gICAgICAgIHJldHVybiAoYXktYnkpKihjeC1ieCkgKyAoYngtYXgpKihjeS1ieSkgPj0gMDtcbiAgICB9XG4gICAgLypcbiAgICBQb2x5Sy5fUCA9IGZ1bmN0aW9uKHgseSlcbiAgICB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMuZmxhZyA9IGZhbHNlO1xuICAgIH1cbiAgICBQb2x5Sy5fUC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpXG4gICAge1xuICAgICAgICByZXR1cm4gXCJQb2ludCBbXCIrdGhpcy54K1wiLCBcIit0aGlzLnkrXCJdXCI7XG4gICAgfVxuICAgIFBvbHlLLl9QLmRpc3QgPSBmdW5jdGlvbihhLGIpXG4gICAge1xuICAgICAgICB2YXIgZHggPSBiLngtYS54O1xuICAgICAgICB2YXIgZHkgPSBiLnktYS55O1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4KmR4ICsgZHkqZHkpO1xuICAgIH1cblxuICAgIFBvbHlLLl90cCA9IFtdO1xuICAgIGZvcih2YXIgaT0wOyBpPDEwOyBpKyspIFBvbHlLLl90cC5wdXNoKG5ldyBQb2x5Sy5fUCgwLDApKTtcbiAgICAgICAgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQb2x5SztcblxufSx7fV0sMzE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogVGhlIHZlYzIgb2JqZWN0IGZyb20gZ2xNYXRyaXgsIHdpdGggc29tZSBleHRlbnNpb25zIGFuZCBzb21lIHJlbW92ZWQgbWV0aG9kcy4gU2VlIGh0dHA6Ly9nbG1hdHJpeC5uZXQuXG4gKiBAY2xhc3MgdmVjMlxuICovXG5cbnZhciB2ZWMyID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxudmFyIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxuLyoqXG4gKiBNYWtlIGEgY3Jvc3MgcHJvZHVjdCBhbmQgb25seSByZXR1cm4gdGhlIHogY29tcG9uZW50XG4gKiBAbWV0aG9kIGNyb3NzTGVuZ3RoXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7QXJyYXl9IGJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmVjMi5jcm9zc0xlbmd0aCA9IGZ1bmN0aW9uKGEsYil7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG59O1xuXG4vKipcbiAqIENyb3NzIHByb2R1Y3QgYmV0d2VlbiBhIHZlY3RvciBhbmQgdGhlIFogY29tcG9uZW50IG9mIGEgdmVjdG9yXG4gKiBAbWV0aG9kIGNyb3NzVlpcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSB2ZWNcbiAqIEBwYXJhbSAge051bWJlcn0gemNvbXBcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmVjMi5jcm9zc1ZaID0gZnVuY3Rpb24ob3V0LCB2ZWMsIHpjb21wKXtcbiAgICB2ZWMyLnJvdGF0ZShvdXQsdmVjLC1NYXRoLlBJLzIpOy8vIFJvdGF0ZSBhY2NvcmRpbmcgdG8gdGhlIHJpZ2h0IGhhbmQgcnVsZVxuICAgIHZlYzIuc2NhbGUob3V0LG91dCx6Y29tcCk7ICAgICAgLy8gU2NhbGUgd2l0aCB6XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3Jvc3MgcHJvZHVjdCBiZXR3ZWVuIGEgdmVjdG9yIGFuZCB0aGUgWiBjb21wb25lbnQgb2YgYSB2ZWN0b3JcbiAqIEBtZXRob2QgY3Jvc3NaVlxuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7TnVtYmVyfSB6Y29tcFxuICogQHBhcmFtICB7QXJyYXl9IHZlY1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG52ZWMyLmNyb3NzWlYgPSBmdW5jdGlvbihvdXQsIHpjb21wLCB2ZWMpe1xuICAgIHZlYzIucm90YXRlKG91dCx2ZWMsTWF0aC5QSS8yKTsgLy8gUm90YXRlIGFjY29yZGluZyB0byB0aGUgcmlnaHQgaGFuZCBydWxlXG4gICAgdmVjMi5zY2FsZShvdXQsb3V0LHpjb21wKTsgICAgICAvLyBTY2FsZSB3aXRoIHpcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgYW4gYW5nbGVcbiAqIEBtZXRob2Qgcm90YXRlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG52ZWMyLnJvdGF0ZSA9IGZ1bmN0aW9uKG91dCxhLGFuZ2xlKXtcbiAgICBpZihhbmdsZSAhPT0gMCl7XG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgcyA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgIHggPSBhWzBdLFxuICAgICAgICAgICAgeSA9IGFbMV07XG4gICAgICAgIG91dFswXSA9IGMqeCAtcyp5O1xuICAgICAgICBvdXRbMV0gPSBzKnggK2MqeTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzFdO1xuICAgIH1cbn07XG5cbi8qKlxuICogUm90YXRlIGEgdmVjdG9yIDkwIGRlZ3JlZXMgY2xvY2t3aXNlXG4gKiBAbWV0aG9kIHJvdGF0ZTkwY3dcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbnZlYzIucm90YXRlOTBjdyA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXTtcbiAgICB2YXIgeSA9IGFbMV07XG4gICAgb3V0WzBdID0geTtcbiAgICBvdXRbMV0gPSAteDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcG9pbnQgcG9zaXRpb24gdG8gbG9jYWwgZnJhbWUuXG4gKiBAbWV0aG9kIHRvTG9jYWxGcmFtZVxuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7QXJyYXl9IHdvcmxkUG9pbnRcbiAqIEBwYXJhbSAge0FycmF5fSBmcmFtZVBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGZyYW1lQW5nbGVcbiAqL1xudmVjMi50b0xvY2FsRnJhbWUgPSBmdW5jdGlvbihvdXQsIHdvcmxkUG9pbnQsIGZyYW1lUG9zaXRpb24sIGZyYW1lQW5nbGUpe1xuICAgIHZlYzIuY29weShvdXQsIHdvcmxkUG9pbnQpO1xuICAgIHZlYzIuc3ViKG91dCwgb3V0LCBmcmFtZVBvc2l0aW9uKTtcbiAgICB2ZWMyLnJvdGF0ZShvdXQsIG91dCwgLWZyYW1lQW5nbGUpO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBwb2ludCBwb3NpdGlvbiB0byBnbG9iYWwgZnJhbWUuXG4gKiBAbWV0aG9kIHRvR2xvYmFsRnJhbWVcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSBsb2NhbFBvaW50XG4gKiBAcGFyYW0gIHtBcnJheX0gZnJhbWVQb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBmcmFtZUFuZ2xlXG4gKi9cbnZlYzIudG9HbG9iYWxGcmFtZSA9IGZ1bmN0aW9uKG91dCwgbG9jYWxQb2ludCwgZnJhbWVQb3NpdGlvbiwgZnJhbWVBbmdsZSl7XG4gICAgdmVjMi5jb3B5KG91dCwgbG9jYWxQb2ludCk7XG4gICAgdmVjMi5yb3RhdGUob3V0LCBvdXQsIGZyYW1lQW5nbGUpO1xuICAgIHZlYzIuYWRkKG91dCwgb3V0LCBmcmFtZVBvc2l0aW9uKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSBjZW50cm9pZCBvZiBhIHRyaWFuZ2xlIHNwYW5uZWQgYnkgdmVjdG9ycyBhLGIsYy4gU2VlIGh0dHA6Ly9lYXN5Y2FsY3VsYXRpb24uY29tL2FuYWx5dGljYWwvbGVhcm4tY2VudHJvaWQucGhwXG4gKiBAbWV0aG9kIGNlbnRyb2lkXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7QXJyYXl9IGJcbiAqIEBwYXJhbSAge0FycmF5fSBjXG4gKiBAcmV0dXJuICB7QXJyYXl9IFRoZSBvdXQgb2JqZWN0XG4gKi9cbnZlYzIuY2VudHJvaWQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICAgIHZlYzIuYWRkKG91dCwgYSwgYik7XG4gICAgdmVjMi5hZGQob3V0LCBvdXQsIGMpO1xuICAgIHZlYzIuc2NhbGUob3V0LCBvdXQsIDEvMyk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBjcmVhdGVcbiAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFV0aWxzLkFSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICogQHN0YXRpY1xuICogQG1ldGhvZCBjbG9uZVxuICogQHBhcmFtIHtBcnJheX0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFV0aWxzLkFSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZnJvbVZhbHVlc1xuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtBcnJheX0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbnZlYzIuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFV0aWxzLkFSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgY29weVxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSkge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7QXJyYXl9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHR3byB2ZWMyJ3NcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3VidHJhY3RcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLnN1YnRyYWN0XG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHN1YlxuICovXG52ZWMyLnN1YiA9IHZlYzIuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIG11bHRpcGx5XG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7QXJyYXl9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgdmVjMi5tdWx0aXBseVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBtdWxcbiAqL1xudmVjMi5tdWwgPSB2ZWMyLm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzInc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBkaXZpZGVcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgdmVjMi5kaXZpZGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZGl2XG4gKi9cbnZlYzIuZGl2ID0gdmVjMi5kaXZpZGU7XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc2NhbGVcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBkaXN0YW5jZVxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzIuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHZlYzIuZGlzdGFuY2VcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZGlzdFxuICovXG52ZWMyLmRpc3QgPSB2ZWMyLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBzcXVhcmVkRGlzdGFuY2VcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7QXJyYXl9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzIuc3F1YXJlZERpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4geCp4ICsgeSp5O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgdmVjMi5zcXVhcmVkRGlzdGFuY2VcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3FyRGlzdFxuICovXG52ZWMyLnNxckRpc3QgPSB2ZWMyLnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGxlbmd0aFxuICogQHBhcmFtIHtBcnJheX0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybiB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWMyLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLmxlbmd0aFxuICogQG1ldGhvZCBsZW5cbiAqIEBzdGF0aWNcbiAqL1xudmVjMi5sZW4gPSB2ZWMyLmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3F1YXJlZExlbmd0aFxuICogQHBhcmFtIHtBcnJheX0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjMi5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLnNxdWFyZWRMZW5ndGhcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3FyTGVuXG4gKi9cbnZlYzIuc3FyTGVuID0gdmVjMi5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIG5lZ2F0ZVxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMyXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZVxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5Knk7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGRvdFxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWMyLmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3RyXG4gKiBAcGFyYW0ge0FycmF5fSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWMyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnKSc7XG59O1xuXG52ZWMyLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG59LHtcIi4uL3V0aWxzL1V0aWxzXCI6NTB9XSwzMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgZGVjb21wID0gX2RlcmVxXygncG9seS1kZWNvbXAnKVxuLCAgIENvbnZleCA9IF9kZXJlcV8oJy4uL3NoYXBlcy9Db252ZXgnKVxuLCAgIEFBQkIgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQUFCQicpXG4sICAgRXZlbnRFbWl0dGVyID0gX2RlcmVxXygnLi4vZXZlbnRzL0V2ZW50RW1pdHRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJvZHk7XG5cbi8qKlxuICogQSByaWdpZCBib2R5LiBIYXMgZ290IGEgY2VudGVyIG9mIG1hc3MsIHBvc2l0aW9uLCB2ZWxvY2l0eSBhbmQgYSBudW1iZXIgb2ZcbiAqIHNoYXBlcyB0aGF0IGFyZSB1c2VkIGZvciBjb2xsaXNpb25zLlxuICpcbiAqIEBjbGFzcyBCb2R5XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgW29wdGlvbnMubWFzcz0wXSAgICBBIG51bWJlciA+PSAwLiBJZiB6ZXJvLCB0aGUgLnR5cGUgd2lsbCBiZSBzZXQgdG8gQm9keS5TVEFUSUMuXG4gKiBAcGFyYW0ge0FycmF5fSAgICAgICAgICAgICAgIFtvcHRpb25zLnBvc2l0aW9uXVxuICogQHBhcmFtIHtBcnJheX0gICAgICAgICAgICAgICBbb3B0aW9ucy52ZWxvY2l0eV1cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgW29wdGlvbnMuYW5nbGU9MF1cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgW29wdGlvbnMuYW5ndWxhclZlbG9jaXR5PTBdXG4gKiBAcGFyYW0ge0FycmF5fSAgICAgICAgICAgICAgIFtvcHRpb25zLmZvcmNlXVxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgICBbb3B0aW9ucy5hbmd1bGFyRm9yY2U9MF1cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgW29wdGlvbnMuZml4ZWRSb3RhdGlvbj1mYWxzZV1cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgW29wdGlvbnMuY2NkU3BlZWRUaHJlc2hvbGQ9LTFdXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgIFtvcHRpb25zLmNjZEl0ZXJhdGlvbnM9MTBdXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgLy8gQ3JlYXRlIGEgdHlwaWNhbCBkeW5hbWljIGJvZHlcbiAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHtcbiAqICAgICAgICAgbWFzczogMSxcbiAqICAgICAgICAgcG9zaXRpb246IFswLCAwXSxcbiAqICAgICAgICAgYW5nbGU6IDAsXG4gKiAgICAgICAgIHZlbG9jaXR5OiBbMCwgMF0sXG4gKiAgICAgICAgIGFuZ3VsYXJWZWxvY2l0eTogMFxuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBBZGQgYSBjaXJjdWxhciBzaGFwZSB0byB0aGUgYm9keVxuICogICAgIGJvZHkuYWRkU2hhcGUobmV3IENpcmNsZSgxKSk7XG4gKlxuICogICAgIC8vIEFkZCB0aGUgYm9keSB0byB0aGUgd29ybGRcbiAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHkpO1xuICovXG5mdW5jdGlvbiBCb2R5KG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYm9keSBpZGVudGlmeWVyXG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gKytCb2R5Ll9pZENvdW50ZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd29ybGQgdGhhdCB0aGlzIGJvZHkgaXMgYWRkZWQgdG8uIFRoaXMgcHJvcGVydHkgaXMgc2V0IHRvIE5VTEwgaWYgdGhlIGJvZHkgaXMgbm90IGFkZGVkIHRvIGFueSB3b3JsZC5cbiAgICAgKiBAcHJvcGVydHkgd29ybGRcbiAgICAgKiBAdHlwZSB7V29ybGR9XG4gICAgICovXG4gICAgdGhpcy53b3JsZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2hhcGVzIG9mIHRoZSBib2R5LiBUaGUgbG9jYWwgdHJhbnNmb3JtIG9mIHRoZSBzaGFwZSBpbiAuc2hhcGVzW2ldIGlzXG4gICAgICogZGVmaW5lZCBieSAuc2hhcGVPZmZzZXRzW2ldIGFuZCAuc2hhcGVBbmdsZXNbaV0uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc2hhcGVzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYWwgc2hhcGUgb2Zmc2V0cywgcmVsYXRpdmUgdG8gdGhlIGJvZHkgY2VudGVyIG9mIG1hc3MuIFRoaXMgaXMgYW5cbiAgICAgKiBhcnJheSBvZiBBcnJheS5cbiAgICAgKiBAcHJvcGVydHkgc2hhcGVPZmZzZXRzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVPZmZzZXRzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYm9keS1sb2NhbCBzaGFwZSBhbmdsZSB0cmFuc2Zvcm1zLiBUaGlzIGlzIGFuIGFycmF5IG9mIG51bWJlcnMgKGFuZ2xlcykuXG4gICAgICogQHByb3BlcnR5IHNoYXBlQW5nbGVzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVBbmdsZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXNzIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBtYXNzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1hc3MgPSBvcHRpb25zLm1hc3MgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG1hc3Mgb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGludk1hc3NcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW52TWFzcyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5lcnRpYSBvZiB0aGUgYm9keSBhcm91bmQgdGhlIFogYXhpcy5cbiAgICAgKiBAcHJvcGVydHkgaW5lcnRpYVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbmVydGlhID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIGluZXJ0aWEgb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGludkluZXJ0aWFcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW52SW5lcnRpYSA9IDA7XG5cbiAgICB0aGlzLmludk1hc3NTb2x2ZSA9IDA7XG4gICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gZml4IHRoZSByb3RhdGlvbiBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgZml4ZWRSb3RhdGlvblxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZml4ZWRSb3RhdGlvbiA9ICEhb3B0aW9ucy5maXhlZFJvdGF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5XG4gICAgICogQHByb3BlcnR5IHBvc2l0aW9uXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcbiAgICBpZihvcHRpb25zLnBvc2l0aW9uKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMucG9zaXRpb24sIG9wdGlvbnMucG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcnBvbGF0ZWQgcG9zaXRpb24gb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGludGVycG9sYXRlZFBvc2l0aW9uXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJwb2xhdGVkUG9zaXRpb24gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcnBvbGF0ZWQgYW5nbGUgb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGludGVycG9sYXRlZEFuZ2xlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmludGVycG9sYXRlZEFuZ2xlID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyBwb3NpdGlvbiBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgcHJldmlvdXNQb3NpdGlvblxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnByZXZpb3VzUG9zaXRpb24gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyBhbmdsZSBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgcHJldmlvdXNBbmdsZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wcmV2aW91c0FuZ2xlID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZWxvY2l0eSBvZiB0aGUgYm9keVxuICAgICAqIEBwcm9wZXJ0eSB2ZWxvY2l0eVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnZlbG9jaXR5ID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG4gICAgaWYob3B0aW9ucy52ZWxvY2l0eSl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLnZlbG9jaXR5LCBvcHRpb25zLnZlbG9jaXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJhaW50IHZlbG9jaXR5IHRoYXQgd2FzIGFkZGVkIHRvIHRoZSBib2R5IGR1cmluZyB0aGUgbGFzdCBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSB2bGFtYmRhXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudmxhbWJkYSA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4gICAgLyoqXG4gICAgICogQW5ndWxhciBjb25zdHJhaW50IHZlbG9jaXR5IHRoYXQgd2FzIGFkZGVkIHRvIHRoZSBib2R5IGR1cmluZyBsYXN0IHN0ZXAuXG4gICAgICogQHByb3BlcnR5IHdsYW1iZGFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy53bGFtYmRhID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbmdsZSBvZiB0aGUgYm9keSwgaW4gcmFkaWFucy5cbiAgICAgKiBAcHJvcGVydHkgYW5nbGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIFRoZSBhbmdsZSBwcm9wZXJ0eSBpcyBub3Qgbm9ybWFsaXplZCB0byB0aGUgaW50ZXJ2YWwgMCB0byAyKnBpLCBpdCBjYW4gYmUgYW55IHZhbHVlLlxuICAgICAqICAgICAvLyBJZiB5b3UgbmVlZCBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMipwaSwgdXNlIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gdG8gbm9ybWFsaXplIGl0LlxuICAgICAqICAgICBmdW5jdGlvbiBub3JtYWxpemVBbmdsZShhbmdsZSl7XG4gICAgICogICAgICAgICBhbmdsZSA9IGFuZ2xlICUgKDIqTWF0aC5QSSk7XG4gICAgICogICAgICAgICBpZihhbmdsZSA8IDApe1xuICAgICAqICAgICAgICAgICAgIGFuZ2xlICs9ICgyKk1hdGguUEkpO1xuICAgICAqICAgICAgICAgfVxuICAgICAqICAgICAgICAgcmV0dXJuIGFuZ2xlO1xuICAgICAqICAgICB9XG4gICAgICovXG4gICAgdGhpcy5hbmdsZSA9IG9wdGlvbnMuYW5nbGUgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbmd1bGFyIHZlbG9jaXR5IG9mIHRoZSBib2R5LCBpbiByYWRpYW5zIHBlciBzZWNvbmQuXG4gICAgICogQHByb3BlcnR5IGFuZ3VsYXJWZWxvY2l0eVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgPSBvcHRpb25zLmFuZ3VsYXJWZWxvY2l0eSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZvcmNlIGFjdGluZyBvbiB0aGUgYm9keS4gU2luY2UgdGhlIGJvZHkgZm9yY2UgKGFuZCB7eyNjcm9zc0xpbmsgXCJCb2R5L2FuZ3VsYXJGb3JjZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSkgd2lsbCBiZSB6ZXJvZWQgYWZ0ZXIgZWFjaCBzdGVwLCBzbyB5b3UgbmVlZCB0byBzZXQgdGhlIGZvcmNlIGJlZm9yZSBlYWNoIHN0ZXAuXG4gICAgICogQHByb3BlcnR5IGZvcmNlXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gVGhpcyBwcm9kdWNlcyBhIGZvcmNlZmllbGQgb2YgMSBOZXd0b24gaW4gdGhlIHBvc2l0aXZlIHggZGlyZWN0aW9uLlxuICAgICAqICAgICBmb3IodmFyIGk9MDsgaTxudW1TdGVwczsgaSsrKXtcbiAgICAgKiAgICAgICAgIGJvZHkuZm9yY2VbMF0gPSAxO1xuICAgICAqICAgICAgICAgd29ybGQuc3RlcCgxLzYwKTtcbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gVGhpcyB3aWxsIGFwcGx5IGEgcm90YXRpb25hbCBmb3JjZSBvbiB0aGUgYm9keVxuICAgICAqICAgICBmb3IodmFyIGk9MDsgaTxudW1TdGVwczsgaSsrKXtcbiAgICAgKiAgICAgICAgIGJvZHkuYW5ndWxhckZvcmNlID0gLTM7XG4gICAgICogICAgICAgICB3b3JsZC5zdGVwKDEvNjApO1xuICAgICAqICAgICB9XG4gICAgICovXG4gICAgdGhpcy5mb3JjZSA9IHZlYzIuY3JlYXRlKCk7XG4gICAgaWYob3B0aW9ucy5mb3JjZSl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmZvcmNlLCBvcHRpb25zLmZvcmNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW5ndWxhciBmb3JjZSBhY3Rpbmcgb24gdGhlIGJvZHkuIFNlZSB7eyNjcm9zc0xpbmsgXCJCb2R5L2ZvcmNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqIEBwcm9wZXJ0eSBhbmd1bGFyRm9yY2VcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYW5ndWxhckZvcmNlID0gb3B0aW9ucy5hbmd1bGFyRm9yY2UgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsaW5lYXIgZGFtcGluZyBhY3Rpbmcgb24gdGhlIGJvZHkgaW4gdGhlIHZlbG9jaXR5IGRpcmVjdGlvbi4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwcm9wZXJ0eSBkYW1waW5nXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwLjFcbiAgICAgKi9cbiAgICB0aGlzLmRhbXBpbmcgPSB0eXBlb2Yob3B0aW9ucy5kYW1waW5nKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMuZGFtcGluZyA6IDAuMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbmd1bGFyIGZvcmNlIGFjdGluZyBvbiB0aGUgYm9keS4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwcm9wZXJ0eSBhbmd1bGFyRGFtcGluZ1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4xXG4gICAgICovXG4gICAgdGhpcy5hbmd1bGFyRGFtcGluZyA9IHR5cGVvZihvcHRpb25zLmFuZ3VsYXJEYW1waW5nKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMuYW5ndWxhckRhbXBpbmcgOiAwLjE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBtb3Rpb24gdGhpcyBib2R5IGhhcy4gU2hvdWxkIGJlIG9uZSBvZjoge3sjY3Jvc3NMaW5rIFwiQm9keS9TVEFUSUM6cHJvcGVydHlcIn19Qm9keS5TVEFUSUN7ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiQm9keS9EWU5BTUlDOnByb3BlcnR5XCJ9fUJvZHkuRFlOQU1JQ3t7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJCb2R5L0tJTkVNQVRJQzpwcm9wZXJ0eVwifX1Cb2R5LktJTkVNQVRJQ3t7L2Nyb3NzTGlua319LlxuICAgICAqXG4gICAgICogKiBTdGF0aWMgYm9kaWVzIGRvIG5vdCBtb3ZlLCBhbmQgdGhleSBkbyBub3QgcmVzcG9uZCB0byBmb3JjZXMgb3IgY29sbGlzaW9uLlxuICAgICAqICogRHluYW1pYyBib2RpZXMgYm9keSBjYW4gbW92ZSBhbmQgcmVzcG9uZCB0byBjb2xsaXNpb25zIGFuZCBmb3JjZXMuXG4gICAgICogKiBLaW5lbWF0aWMgYm9kaWVzIG9ubHkgbW92ZXMgYWNjb3JkaW5nIHRvIGl0cyAudmVsb2NpdHksIGFuZCBkb2VzIG5vdCByZXNwb25kIHRvIGNvbGxpc2lvbnMgb3IgZm9yY2UuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdHlwZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBCb2RpZXMgYXJlIHN0YXRpYyBieSBkZWZhdWx0LiBTdGF0aWMgYm9kaWVzIHdpbGwgbmV2ZXIgbW92ZS5cbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSgpO1xuICAgICAqICAgICBjb25zb2xlLmxvZyhib2R5LnR5cGUgPT0gQm9keS5TVEFUSUMpOyAvLyB0cnVlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBCeSBzZXR0aW5nIHRoZSBtYXNzIG9mIGEgYm9keSB0byBhIG5vbnplcm8gbnVtYmVyLCB0aGUgYm9keVxuICAgICAqICAgICAvLyB3aWxsIGJlY29tZSBkeW5hbWljIGFuZCB3aWxsIG1vdmUgYW5kIGludGVyYWN0IHdpdGggb3RoZXIgYm9kaWVzLlxuICAgICAqICAgICB2YXIgZHluYW1pY0JvZHkgPSBuZXcgQm9keSh7XG4gICAgICogICAgICAgICBtYXNzIDogMVxuICAgICAqICAgICB9KTtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZHluYW1pY0JvZHkudHlwZSA9PSBCb2R5LkRZTkFNSUMpOyAvLyB0cnVlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBLaW5lbWF0aWMgYm9kaWVzIHdpbGwgb25seSBtb3ZlIGlmIHlvdSBjaGFuZ2UgdGhlaXIgdmVsb2NpdHkuXG4gICAgICogICAgIHZhciBraW5lbWF0aWNCb2R5ID0gbmV3IEJvZHkoe1xuICAgICAqICAgICAgICAgdHlwZTogQm9keS5LSU5FTUFUSUMgLy8gVHlwZSBjYW4gYmUgc2V0IHZpYSB0aGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogICAgIH0pO1xuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IEJvZHkuU1RBVElDO1xuXG4gICAgaWYodHlwZW9mKG9wdGlvbnMudHlwZSkgIT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuICAgIH0gZWxzZSBpZighb3B0aW9ucy5tYXNzKXtcbiAgICAgICAgdGhpcy50eXBlID0gQm9keS5TVEFUSUM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50eXBlID0gQm9keS5EWU5BTUlDO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJvdW5kaW5nIGNpcmNsZSByYWRpdXMuXG4gICAgICogQHByb3BlcnR5IGJvdW5kaW5nUmFkaXVzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gMDtcblxuICAgIC8qKlxuICAgICAqIEJvdW5kaW5nIGJveCBvZiB0aGlzIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGFhYmJcbiAgICAgKiBAdHlwZSB7QUFCQn1cbiAgICAgKi9cbiAgICB0aGlzLmFhYmIgPSBuZXcgQUFCQigpO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBBQUJCIG5lZWRzIHVwZGF0ZS4gVXBkYXRlIGl0IHdpdGgge3sjY3Jvc3NMaW5rIFwiQm9keS91cGRhdGVBQUJCOm1ldGhvZFwifX0udXBkYXRlQUFCQigpe3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IGFhYmJOZWVkc1VwZGF0ZVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBzZWUgdXBkYXRlQUFCQlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gRm9yY2UgdXBkYXRlIHRoZSBBQUJCXG4gICAgICogICAgIGJvZHkuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgKiAgICAgYm9keS51cGRhdGVBQUJCKCk7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGJvZHkuYWFiYk5lZWRzVXBkYXRlKTsgLy8gZmFsc2VcbiAgICAgKi9cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgYm9keSB3aWxsIGF1dG9tYXRpY2FsbHkgZmFsbCB0byBzbGVlcC4gTm90ZSB0aGF0IHlvdSBuZWVkIHRvIGVuYWJsZSBzbGVlcGluZyBpbiB0aGUge3sjY3Jvc3NMaW5rIFwiV29ybGRcIn19e3svY3Jvc3NMaW5rfX0gYmVmb3JlIGFueXRoaW5nIHdpbGwgaGFwcGVuLlxuICAgICAqIEBwcm9wZXJ0eSBhbGxvd1NsZWVwXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMuYWxsb3dTbGVlcCA9IHRydWU7XG5cbiAgICB0aGlzLndhbnRzVG9TbGVlcCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogT25lIG9mIHt7I2Nyb3NzTGluayBcIkJvZHkvQVdBS0U6cHJvcGVydHlcIn19Qm9keS5BV0FLRXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJCb2R5L1NMRUVQWTpwcm9wZXJ0eVwifX1Cb2R5LlNMRUVQWXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJCb2R5L1NMRUVQSU5HOnByb3BlcnR5XCJ9fUJvZHkuU0xFRVBJTkd7ey9jcm9zc0xpbmt9fS5cbiAgICAgKlxuICAgICAqIFRoZSBib2R5IGlzIGluaXRpYWxseSBCb2R5LkFXQUtFLiBJZiBpdHMgdmVsb2NpdHkgbm9ybSBpcyBiZWxvdyAuc2xlZXBTcGVlZExpbWl0LCB0aGUgc2xlZXBTdGF0ZSB3aWxsIGJlY29tZSBCb2R5LlNMRUVQWS4gSWYgdGhlIGJvZHkgY29udGludWVzIHRvIGJlIEJvZHkuU0xFRVBZIGZvciAuc2xlZXBUaW1lTGltaXQgc2Vjb25kcywgaXQgd2lsbCBmYWxsIGFzbGVlcCAoQm9keS5TTEVFUFkpLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHNsZWVwU3RhdGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IEJvZHkuQVdBS0VcbiAgICAgKi9cbiAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LkFXQUtFO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIHNwZWVkICh0aGUgbm9ybSBvZiB0aGUgdmVsb2NpdHkpIGlzIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLCB0aGUgYm9keSBpcyBjb25zaWRlcmVkIHNsZWVweS5cbiAgICAgKiBAcHJvcGVydHkgc2xlZXBTcGVlZExpbWl0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwLjJcbiAgICAgKi9cbiAgICB0aGlzLnNsZWVwU3BlZWRMaW1pdCA9IDAuMjtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBib2R5IGhhcyBiZWVuIHNsZWVweSBmb3IgdGhpcyBzbGVlcFRpbWVMaW1pdCBzZWNvbmRzLCBpdCBpcyBjb25zaWRlcmVkIHNsZWVwaW5nLlxuICAgICAqIEBwcm9wZXJ0eSBzbGVlcFRpbWVMaW1pdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHRoaXMuc2xlZXBUaW1lTGltaXQgPSAxO1xuXG4gICAgLyoqXG4gICAgICogR3Jhdml0eSBzY2FsaW5nIGZhY3Rvci4gSWYgeW91IHdhbnQgdGhlIGJvZHkgdG8gaWdub3JlIGdyYXZpdHksIHNldCB0aGlzIHRvIHplcm8uIElmIHlvdSB3YW50IHRvIHJldmVyc2UgZ3Jhdml0eSwgc2V0IGl0IHRvIC0xLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBncmF2aXR5U2NhbGVcbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5ncmF2aXR5U2NhbGUgPSAxO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBwcm9kdWNlIGNvbnRhY3QgZm9yY2VzIHdoZW4gaW4gY29udGFjdCB3aXRoIG90aGVyIGJvZGllcy4gTm90ZSB0aGF0IGNvbnRhY3RzIHdpbGwgYmUgZ2VuZXJhdGVkLCBidXQgdGhleSB3aWxsIGJlIGRpc2FibGVkLiBUaGF0IG1lYW5zIHRoYXQgdGhpcyBib2R5IHdpbGwgbW92ZSB0aHJvdWdoIG90aGVyIGJvZGllcywgYnV0IGl0IHdpbGwgc3RpbGwgdHJpZ2dlciBjb250YWN0IGV2ZW50cywgZXRjLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY29sbGlzaW9uUmVzcG9uc2VcbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpc2lvblJlc3BvbnNlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEhvdyBsb25nIHRoZSBib2R5IGhhcyBiZWVuIHNsZWVwaW5nLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBpZGxlVGltZVxuICAgICAqL1xuICAgIHRoaXMuaWRsZVRpbWUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhc3QgdGltZSB3aGVuIHRoZSBib2R5IHdlbnQgdG8gU0xFRVBZIHN0YXRlLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0aW1lTGFzdFNsZWVweVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50aW1lTGFzdFNsZWVweSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgYm9keSBzcGVlZCBleGNlZWRzIHRoaXMgdGhyZXNob2xkLCBDQ0QgKGNvbnRpbnVvdXMgY29sbGlzaW9uIGRldGVjdGlvbikgd2lsbCBiZSBlbmFibGVkLiBTZXQgaXQgdG8gYSBuZWdhdGl2ZSBudW1iZXIgdG8gZGlzYWJsZSBDQ0QgY29tcGxldGVseSBmb3IgdGhpcyBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjY2RTcGVlZFRocmVzaG9sZFxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICovXG4gICAgdGhpcy5jY2RTcGVlZFRocmVzaG9sZCA9IG9wdGlvbnMuY2NkU3BlZWRUaHJlc2hvbGQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2NkU3BlZWRUaHJlc2hvbGQgOiAtMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gc2VhcmNoaW5nIGZvciB0aGUgdGltZSBvZiBpbXBhY3QgZHVyaW5nIENDRC4gQSBsYXJnZXIgbnVtYmVyIHdpbGwgYXNzdXJlIHRoYXQgdGhlcmUncyBhIHNtYWxsIHBlbmV0cmF0aW9uIG9uIENDRCBjb2xsaXNpb24sIGJ1dCBhIHNtYWxsIG51bWJlciB3aWxsIGdpdmUgbW9yZSBwZXJmb3JtYW5jZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY2NkSXRlcmF0aW9uc1xuICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICovXG4gICAgdGhpcy5jY2RJdGVyYXRpb25zID0gb3B0aW9ucy5jY2RJdGVyYXRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNjZEl0ZXJhdGlvbnMgOiAxMDtcblxuICAgIHRoaXMuY29uY2F2ZVBhdGggPSBudWxsO1xuXG4gICAgdGhpcy5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IGZhbHNlO1xuXG4gICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xufVxuQm9keS5wcm90b3R5cGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5Cb2R5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJvZHk7XG5cbkJvZHkuX2lkQ291bnRlciA9IDA7XG5cbkJvZHkucHJvdG90eXBlLnVwZGF0ZVNvbHZlTWFzc1Byb3BlcnRpZXMgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyB8fCB0aGlzLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKXtcbiAgICAgICAgdGhpcy5pbnZNYXNzU29sdmUgPSAwO1xuICAgICAgICB0aGlzLmludkluZXJ0aWFTb2x2ZSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnZNYXNzU29sdmUgPSB0aGlzLmludk1hc3M7XG4gICAgICAgIHRoaXMuaW52SW5lcnRpYVNvbHZlID0gdGhpcy5pbnZJbmVydGlhO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2V0IHRoZSB0b3RhbCBkZW5zaXR5IG9mIHRoZSBib2R5XG4gKiBAbWV0aG9kIHNldERlbnNpdHlcbiAqL1xuQm9keS5wcm90b3R5cGUuc2V0RGVuc2l0eSA9IGZ1bmN0aW9uKGRlbnNpdHkpIHtcbiAgICB2YXIgdG90YWxBcmVhID0gdGhpcy5nZXRBcmVhKCk7XG4gICAgdGhpcy5tYXNzID0gdG90YWxBcmVhICogZGVuc2l0eTtcbiAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdG90YWwgYXJlYSBvZiBhbGwgc2hhcGVzIGluIHRoZSBib2R5XG4gKiBAbWV0aG9kIGdldEFyZWFcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQm9keS5wcm90b3R5cGUuZ2V0QXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0b3RhbEFyZWEgPSAwO1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuc2hhcGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdG90YWxBcmVhICs9IHRoaXMuc2hhcGVzW2ldLmFyZWE7XG4gICAgfVxuICAgIHJldHVybiB0b3RhbEFyZWE7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgQUFCQiBmcm9tIHRoZSBib2R5LiBUaGUgQUFCQiBpcyB1cGRhdGVkIGlmIG5lY2Vzc2FyeS5cbiAqIEBtZXRob2QgZ2V0QUFCQlxuICovXG5Cb2R5LnByb3RvdHlwZS5nZXRBQUJCID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLmFhYmJOZWVkc1VwZGF0ZSl7XG4gICAgICAgIHRoaXMudXBkYXRlQUFCQigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hYWJiO1xufTtcblxudmFyIHNoYXBlQUFCQiA9IG5ldyBBQUJCKCksXG4gICAgdG1wID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBBQUJCIG9mIHRoZSBCb2R5XG4gKiBAbWV0aG9kIHVwZGF0ZUFBQkJcbiAqL1xuQm9keS5wcm90b3R5cGUudXBkYXRlQUFCQiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcyxcbiAgICAgICAgc2hhcGVPZmZzZXRzID0gdGhpcy5zaGFwZU9mZnNldHMsXG4gICAgICAgIHNoYXBlQW5nbGVzID0gdGhpcy5zaGFwZUFuZ2xlcyxcbiAgICAgICAgTiA9IHNoYXBlcy5sZW5ndGgsXG4gICAgICAgIG9mZnNldCA9IHRtcCxcbiAgICAgICAgYm9keUFuZ2xlID0gdGhpcy5hbmdsZTtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIHNoYXBlID0gc2hhcGVzW2ldLFxuICAgICAgICAgICAgYW5nbGUgPSBzaGFwZUFuZ2xlc1tpXSArIGJvZHlBbmdsZTtcblxuICAgICAgICAvLyBHZXQgc2hhcGUgd29ybGQgb2Zmc2V0XG4gICAgICAgIHZlYzIucm90YXRlKG9mZnNldCwgc2hhcGVPZmZzZXRzW2ldLCBib2R5QW5nbGUpO1xuICAgICAgICB2ZWMyLmFkZChvZmZzZXQsIG9mZnNldCwgdGhpcy5wb3NpdGlvbik7XG5cbiAgICAgICAgLy8gR2V0IHNoYXBlIEFBQkJcbiAgICAgICAgc2hhcGUuY29tcHV0ZUFBQkIoc2hhcGVBQUJCLCBvZmZzZXQsIGFuZ2xlKTtcblxuICAgICAgICBpZihpPT09MCl7XG4gICAgICAgICAgICB0aGlzLmFhYmIuY29weShzaGFwZUFBQkIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hYWJiLmV4dGVuZChzaGFwZUFBQkIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdGhlIGJvZHkuIFNob3VsZCBiZSBkb25lIGlmIGFueSBvZiB0aGUgc2hhcGVzXG4gKiBhcmUgY2hhbmdlZC5cbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqL1xuQm9keS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcyxcbiAgICAgICAgc2hhcGVPZmZzZXRzID0gdGhpcy5zaGFwZU9mZnNldHMsXG4gICAgICAgIE4gPSBzaGFwZXMubGVuZ3RoLFxuICAgICAgICByYWRpdXMgPSAwO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV0sXG4gICAgICAgICAgICBvZmZzZXQgPSB2ZWMyLmxlbmd0aChzaGFwZU9mZnNldHNbaV0pLFxuICAgICAgICAgICAgciA9IHNoYXBlLmJvdW5kaW5nUmFkaXVzO1xuICAgICAgICBpZihvZmZzZXQgKyByID4gcmFkaXVzKXtcbiAgICAgICAgICAgIHJhZGl1cyA9IG9mZnNldCArIHI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gcmFkaXVzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBzaGFwZSB0byB0aGUgYm9keS4gWW91IGNhbiBwYXNzIGEgbG9jYWwgdHJhbnNmb3JtIHdoZW4gYWRkaW5nIGEgc2hhcGUsXG4gKiBzbyB0aGF0IHRoZSBzaGFwZSBnZXRzIGFuIG9mZnNldCBhbmQgYW5nbGUgcmVsYXRpdmUgdG8gdGhlIGJvZHkgY2VudGVyIG9mIG1hc3MuXG4gKiBXaWxsIGF1dG9tYXRpY2FsbHkgdXBkYXRlIHRoZSBtYXNzIHByb3BlcnRpZXMgYW5kIGJvdW5kaW5nIHJhZGl1cy5cbiAqXG4gKiBAbWV0aG9kIGFkZFNoYXBlXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICAgICAgICAgIHNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gW29mZnNldF0gTG9jYWwgYm9keSBvZmZzZXQgb2YgdGhlIHNoYXBlLlxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgICAgICBbYW5nbGVdICBMb2NhbCBib2R5IGFuZ2xlLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSgpLFxuICogICAgICAgICBzaGFwZSA9IG5ldyBDaXJjbGUoKTtcbiAqXG4gKiAgICAgLy8gQWRkIHRoZSBzaGFwZSB0byB0aGUgYm9keSwgcG9zaXRpb25lZCBpbiB0aGUgY2VudGVyXG4gKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSk7XG4gKlxuICogICAgIC8vIEFkZCBhbm90aGVyIHNoYXBlIHRvIHRoZSBib2R5LCBwb3NpdGlvbmVkIDEgdW5pdCBsZW5ndGggZnJvbSB0aGUgYm9keSBjZW50ZXIgb2YgbWFzcyBhbG9uZyB0aGUgbG9jYWwgeC1heGlzLlxuICogICAgIGJvZHkuYWRkU2hhcGUoc2hhcGUsWzEsMF0pO1xuICpcbiAqICAgICAvLyBBZGQgYW5vdGhlciBzaGFwZSB0byB0aGUgYm9keSwgcG9zaXRpb25lZCAxIHVuaXQgbGVuZ3RoIGZyb20gdGhlIGJvZHkgY2VudGVyIG9mIG1hc3MgYWxvbmcgdGhlIGxvY2FsIHktYXhpcywgYW5kIHJvdGF0ZWQgOTAgZGVncmVlcyBDQ1cuXG4gKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSxbMCwxXSxNYXRoLlBJLzIpO1xuICovXG5Cb2R5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlLG9mZnNldCxhbmdsZSl7XG4gICAgYW5nbGUgPSBhbmdsZSB8fCAwLjA7XG5cbiAgICAvLyBDb3B5IHRoZSBvZmZzZXQgdmVjdG9yXG4gICAgaWYob2Zmc2V0KXtcbiAgICAgICAgb2Zmc2V0ID0gdmVjMi5mcm9tVmFsdWVzKG9mZnNldFswXSxvZmZzZXRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuICAgIH1cblxuICAgIHRoaXMuc2hhcGVzICAgICAgLnB1c2goc2hhcGUpO1xuICAgIHRoaXMuc2hhcGVPZmZzZXRzLnB1c2gob2Zmc2V0KTtcbiAgICB0aGlzLnNoYXBlQW5nbGVzIC5wdXNoKGFuZ2xlKTtcbiAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1JhZGl1cygpO1xuXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBzaGFwZVxuICogQG1ldGhvZCByZW1vdmVTaGFwZVxuICogQHBhcmFtICB7U2hhcGV9ICBzaGFwZVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgVHJ1ZSBpZiB0aGUgc2hhcGUgd2FzIGZvdW5kIGFuZCByZW1vdmVkLCBlbHNlIGZhbHNlLlxuICovXG5Cb2R5LnByb3RvdHlwZS5yZW1vdmVTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlKXtcbiAgICB2YXIgaWR4ID0gdGhpcy5zaGFwZXMuaW5kZXhPZihzaGFwZSk7XG5cbiAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgdGhpcy5zaGFwZXMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgdGhpcy5zaGFwZU9mZnNldHMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgdGhpcy5zaGFwZUFuZ2xlcy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgLmluZXJ0aWEsIC5pbnZNYXNzLCAuaW52SW5lcnRpYSBmb3IgdGhpcyBCb2R5LiBTaG91bGQgYmUgY2FsbGVkIHdoZW5cbiAqIGNoYW5naW5nIHRoZSBzdHJ1Y3R1cmUgb3IgbWFzcyBvZiB0aGUgQm9keS5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZU1hc3NQcm9wZXJ0aWVzXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICBib2R5Lm1hc3MgKz0gMTtcbiAqICAgICBib2R5LnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG4gKi9cbkJvZHkucHJvdG90eXBlLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLnR5cGUgPT09IEJvZHkuU1RBVElDIHx8IHRoaXMudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpe1xuXG4gICAgICAgIHRoaXMubWFzcyA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIHRoaXMuaW52TWFzcyA9IDA7XG4gICAgICAgIHRoaXMuaW5lcnRpYSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIHRoaXMuaW52SW5lcnRpYSA9IDA7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcyxcbiAgICAgICAgICAgIE4gPSBzaGFwZXMubGVuZ3RoLFxuICAgICAgICAgICAgbSA9IHRoaXMubWFzcyAvIE4sXG4gICAgICAgICAgICBJID0gMDtcblxuICAgICAgICBpZighdGhpcy5maXhlZFJvdGF0aW9uKXtcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPE47IGkrKyl7XG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gc2hhcGVzW2ldLFxuICAgICAgICAgICAgICAgICAgICByMiA9IHZlYzIuc3F1YXJlZExlbmd0aCh0aGlzLnNoYXBlT2Zmc2V0c1tpXSksXG4gICAgICAgICAgICAgICAgICAgIEljbSA9IHNoYXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEobSk7XG4gICAgICAgICAgICAgICAgSSArPSBJY20gKyBtKnIyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbmVydGlhID0gSTtcbiAgICAgICAgICAgIHRoaXMuaW52SW5lcnRpYSA9IEk+MCA/IDEvSSA6IDA7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5lcnRpYSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICB0aGlzLmludkluZXJ0aWEgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW52ZXJzZSBtYXNzIHByb3BlcnRpZXMgYXJlIGVhc3lcbiAgICAgICAgdGhpcy5pbnZNYXNzID0gMS90aGlzLm1hc3M7Ly8gPiAwID8gMS90aGlzLm1hc3MgOiAwO1xuICAgIH1cbn07XG5cbnZhciBCb2R5X2FwcGx5Rm9yY2VfciA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQXBwbHkgZm9yY2UgdG8gYSB3b3JsZCBwb2ludC4gVGhpcyBjb3VsZCBmb3IgZXhhbXBsZSBiZSBhIHBvaW50IG9uIHRoZSBSaWdpZEJvZHkgc3VyZmFjZS4gQXBwbHlpbmcgZm9yY2UgdGhpcyB3YXkgd2lsbCBhZGQgdG8gQm9keS5mb3JjZSBhbmQgQm9keS5hbmd1bGFyRm9yY2UuXG4gKiBAbWV0aG9kIGFwcGx5Rm9yY2VcbiAqIEBwYXJhbSB7QXJyYXl9IGZvcmNlIFRoZSBmb3JjZSB0byBhZGQuXG4gKiBAcGFyYW0ge0FycmF5fSB3b3JsZFBvaW50IEEgd29ybGQgcG9pbnQgdG8gYXBwbHkgdGhlIGZvcmNlIG9uLlxuICovXG5Cb2R5LnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24oZm9yY2Usd29ybGRQb2ludCl7XG4gICAgLy8gQ29tcHV0ZSBwb2ludCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgYm9keSBjZW50ZXJcbiAgICB2YXIgciA9IEJvZHlfYXBwbHlGb3JjZV9yO1xuICAgIHZlYzIuc3ViKHIsd29ybGRQb2ludCx0aGlzLnBvc2l0aW9uKTtcblxuICAgIC8vIEFkZCBsaW5lYXIgZm9yY2VcbiAgICB2ZWMyLmFkZCh0aGlzLmZvcmNlLHRoaXMuZm9yY2UsZm9yY2UpO1xuXG4gICAgLy8gQ29tcHV0ZSBwcm9kdWNlZCByb3RhdGlvbmFsIGZvcmNlXG4gICAgdmFyIHJvdEZvcmNlID0gdmVjMi5jcm9zc0xlbmd0aChyLGZvcmNlKTtcblxuICAgIC8vIEFkZCByb3RhdGlvbmFsIGZvcmNlXG4gICAgdGhpcy5hbmd1bGFyRm9yY2UgKz0gcm90Rm9yY2U7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHdvcmxkIHBvaW50IHRvIGxvY2FsIGJvZHkgZnJhbWUuXG4gKiBAbWV0aG9kIHRvTG9jYWxGcmFtZVxuICogQHBhcmFtICB7QXJyYXl9IG91dCAgICAgICAgICBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW5cbiAqIEBwYXJhbSAge0FycmF5fSB3b3JsZFBvaW50ICAgVGhlIGlucHV0IHdvcmxkIHZlY3RvclxuICovXG5Cb2R5LnByb3RvdHlwZS50b0xvY2FsRnJhbWUgPSBmdW5jdGlvbihvdXQsIHdvcmxkUG9pbnQpe1xuICAgIHZlYzIudG9Mb2NhbEZyYW1lKG91dCwgd29ybGRQb2ludCwgdGhpcy5wb3NpdGlvbiwgdGhpcy5hbmdsZSk7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIGxvY2FsIHBvaW50IHRvIHdvcmxkIGZyYW1lLlxuICogQG1ldGhvZCB0b1dvcmxkRnJhbWVcbiAqIEBwYXJhbSAge0FycmF5fSBvdXQgICAgICAgICAgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluXG4gKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxQb2ludCAgIFRoZSBpbnB1dCBsb2NhbCB2ZWN0b3JcbiAqL1xuQm9keS5wcm90b3R5cGUudG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24ob3V0LCBsb2NhbFBvaW50KXtcbiAgICB2ZWMyLnRvR2xvYmFsRnJhbWUob3V0LCBsb2NhbFBvaW50LCB0aGlzLnBvc2l0aW9uLCB0aGlzLmFuZ2xlKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBwb2x5Z29uIHNoYXBlIHBhdGgsIGFuZCBhc3NlbWJsZXMgY29udmV4IHNoYXBlcyBmcm9tIHRoYXQgYW5kIHB1dHMgdGhlbSBhdCBwcm9wZXIgb2Zmc2V0IHBvaW50cy5cbiAqIEBtZXRob2QgZnJvbVBvbHlnb25cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggQW4gYXJyYXkgb2YgMmQgdmVjdG9ycywgZS5nLiBbWzAsMF0sWzAsMV0sLi4uXSB0aGF0IHJlc2VtYmxlcyBhIGNvbmNhdmUgb3IgY29udmV4IHBvbHlnb24uIFRoZSBzaGFwZSBtdXN0IGJlIHNpbXBsZSBhbmQgd2l0aG91dCBob2xlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3B0aW1hbERlY29tcD1mYWxzZV0gICBTZXQgdG8gdHJ1ZSBpZiB5b3UgbmVlZCBvcHRpbWFsIGRlY29tcG9zaXRpb24uIFdhcm5pbmc6IHZlcnkgc2xvdyBmb3IgcG9seWdvbnMgd2l0aCBtb3JlIHRoYW4gMTAgdmVydGljZXMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBTaW1wbGVDaGVjaz1mYWxzZV0gU2V0IHRvIHRydWUgaWYgeW91IGFscmVhZHkga25vdyB0aGF0IHRoZSBwYXRoIGlzIG5vdCBpbnRlcnNlY3RpbmcgaXRzZWxmLlxuICogQHBhcmFtIHtCb29sZWFufE51bWJlcn0gW29wdGlvbnMucmVtb3ZlQ29sbGluZWFyUG9pbnRzPWZhbHNlXSBTZXQgdG8gYSBudW1iZXIgKGFuZ2xlIHRocmVzaG9sZCB2YWx1ZSkgdG8gcmVtb3ZlIGNvbGxpbmVhciBwb2ludHMsIG9yIGZhbHNlIHRvIGtlZXAgYWxsIHBvaW50cy5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgb24gc3VjY2VzcywgZWxzZSBmYWxzZS5cbiAqL1xuQm9keS5wcm90b3R5cGUuZnJvbVBvbHlnb24gPSBmdW5jdGlvbihwYXRoLG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gUmVtb3ZlIGFsbCBzaGFwZXNcbiAgICBmb3IodmFyIGk9dGhpcy5zaGFwZXMubGVuZ3RoOyBpPj0wOyAtLWkpe1xuICAgICAgICB0aGlzLnJlbW92ZVNoYXBlKHRoaXMuc2hhcGVzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IG5ldyBkZWNvbXAuUG9seWdvbigpO1xuICAgIHAudmVydGljZXMgPSBwYXRoO1xuXG4gICAgLy8gTWFrZSBpdCBjb3VudGVyLWNsb2Nrd2lzZVxuICAgIHAubWFrZUNDVygpO1xuXG4gICAgaWYodHlwZW9mKG9wdGlvbnMucmVtb3ZlQ29sbGluZWFyUG9pbnRzKSA9PT0gXCJudW1iZXJcIil7XG4gICAgICAgIHAucmVtb3ZlQ29sbGluZWFyUG9pbnRzKG9wdGlvbnMucmVtb3ZlQ29sbGluZWFyUG9pbnRzKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhbnkgbGluZSBzZWdtZW50IGludGVyc2VjdHMgdGhlIHBhdGggaXRzZWxmXG4gICAgaWYodHlwZW9mKG9wdGlvbnMuc2tpcFNpbXBsZUNoZWNrKSA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgIGlmKCFwLmlzU2ltcGxlKCkpe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2F2ZSB0aGlzIHBhdGggZm9yIGxhdGVyXG4gICAgdGhpcy5jb25jYXZlUGF0aCA9IHAudmVydGljZXMuc2xpY2UoMCk7XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5jb25jYXZlUGF0aC5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB2ID0gWzAsMF07XG4gICAgICAgIHZlYzIuY29weSh2LHRoaXMuY29uY2F2ZVBhdGhbaV0pO1xuICAgICAgICB0aGlzLmNvbmNhdmVQYXRoW2ldID0gdjtcbiAgICB9XG5cbiAgICAvLyBTbG93IG9yIGZhc3QgZGVjb21wP1xuICAgIHZhciBjb252ZXhlcztcbiAgICBpZihvcHRpb25zLm9wdGltYWxEZWNvbXApe1xuICAgICAgICBjb252ZXhlcyA9IHAuZGVjb21wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29udmV4ZXMgPSBwLnF1aWNrRGVjb21wKCk7XG4gICAgfVxuXG4gICAgdmFyIGNtID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8vIEFkZCBjb252ZXhlc1xuICAgIGZvcih2YXIgaT0wOyBpIT09Y29udmV4ZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAvLyBDcmVhdGUgY29udmV4XG4gICAgICAgIHZhciBjID0gbmV3IENvbnZleChjb252ZXhlc1tpXS52ZXJ0aWNlcyk7XG5cbiAgICAgICAgLy8gTW92ZSBhbGwgdmVydGljZXMgc28gaXRzIGNlbnRlciBvZiBtYXNzIGlzIGluIHRoZSBsb2NhbCBjZW50ZXIgb2YgdGhlIGNvbnZleFxuICAgICAgICBmb3IodmFyIGo9MDsgaiE9PWMudmVydGljZXMubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgdmFyIHYgPSBjLnZlcnRpY2VzW2pdO1xuICAgICAgICAgICAgdmVjMi5zdWIodix2LGMuY2VudGVyT2ZNYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZlYzIuc2NhbGUoY20sYy5jZW50ZXJPZk1hc3MsMSk7XG4gICAgICAgIGMudXBkYXRlVHJpYW5nbGVzKCk7XG4gICAgICAgIGMudXBkYXRlQ2VudGVyT2ZNYXNzKCk7XG4gICAgICAgIGMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcblxuICAgICAgICAvLyBBZGQgdGhlIHNoYXBlXG4gICAgICAgIHRoaXMuYWRkU2hhcGUoYyxjbSk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGp1c3RDZW50ZXJPZk1hc3MoKTtcblxuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIHJldHVybiB0cnVlO1xufTtcblxudmFyIGFkanVzdENlbnRlck9mTWFzc190bXAxID0gdmVjMi5mcm9tVmFsdWVzKDAsMCksXG4gICAgYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMyA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgIGFkanVzdENlbnRlck9mTWFzc190bXA0ID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbi8qKlxuICogTW92ZXMgdGhlIHNoYXBlIG9mZnNldHMgc28gdGhlaXIgY2VudGVyIG9mIG1hc3MgYmVjb21lcyB0aGUgYm9keSBjZW50ZXIgb2YgbWFzcy5cbiAqIEBtZXRob2QgYWRqdXN0Q2VudGVyT2ZNYXNzXG4gKi9cbkJvZHkucHJvdG90eXBlLmFkanVzdENlbnRlck9mTWFzcyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIG9mZnNldF90aW1lc19hcmVhID0gYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDIsXG4gICAgICAgIHN1bSA9ICAgICAgICAgICAgICAgYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDMsXG4gICAgICAgIGNtID0gICAgICAgICAgICAgICAgYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDQsXG4gICAgICAgIHRvdGFsQXJlYSA9ICAgICAgICAgMDtcbiAgICB2ZWMyLnNldChzdW0sMCwwKTtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09dGhpcy5zaGFwZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgcyA9IHRoaXMuc2hhcGVzW2ldLFxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5zaGFwZU9mZnNldHNbaV07XG4gICAgICAgIHZlYzIuc2NhbGUob2Zmc2V0X3RpbWVzX2FyZWEsb2Zmc2V0LHMuYXJlYSk7XG4gICAgICAgIHZlYzIuYWRkKHN1bSxzdW0sb2Zmc2V0X3RpbWVzX2FyZWEpO1xuICAgICAgICB0b3RhbEFyZWEgKz0gcy5hcmVhO1xuICAgIH1cblxuICAgIHZlYzIuc2NhbGUoY20sc3VtLDEvdG90YWxBcmVhKTtcblxuICAgIC8vIE5vdyBtb3ZlIGFsbCBzaGFwZXNcbiAgICBmb3IodmFyIGk9MDsgaSE9PXRoaXMuc2hhcGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNoYXBlc1tpXSxcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuc2hhcGVPZmZzZXRzW2ldO1xuXG4gICAgICAgIC8vIE9mZnNldCBtYXkgYmUgdW5kZWZpbmVkLiBGaXggdGhhdC5cbiAgICAgICAgaWYoIW9mZnNldCl7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNoYXBlT2Zmc2V0c1tpXSA9IHZlYzIuY3JlYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2ZWMyLnN1YihvZmZzZXQsb2Zmc2V0LGNtKTtcbiAgICB9XG5cbiAgICAvLyBNb3ZlIHRoZSBib2R5IHBvc2l0aW9uIHRvb1xuICAgIHZlYzIuYWRkKHRoaXMucG9zaXRpb24sdGhpcy5wb3NpdGlvbixjbSk7XG5cbiAgICAvLyBBbmQgY29uY2F2ZSBwYXRoXG4gICAgZm9yKHZhciBpPTA7IHRoaXMuY29uY2F2ZVBhdGggJiYgaTx0aGlzLmNvbmNhdmVQYXRoLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmVjMi5zdWIodGhpcy5jb25jYXZlUGF0aFtpXSwgdGhpcy5jb25jYXZlUGF0aFtpXSwgY20pO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGZvcmNlIG9uIHRoZSBib2R5IHRvIHplcm8uXG4gKiBAbWV0aG9kIHNldFplcm9Gb3JjZVxuICovXG5Cb2R5LnByb3RvdHlwZS5zZXRaZXJvRm9yY2UgPSBmdW5jdGlvbigpe1xuICAgIHZlYzIuc2V0KHRoaXMuZm9yY2UsMC4wLDAuMCk7XG4gICAgdGhpcy5hbmd1bGFyRm9yY2UgPSAwLjA7XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5yZXNldENvbnN0cmFpbnRWZWxvY2l0eSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICB2bGFtYmRhID0gYi52bGFtYmRhO1xuICAgIHZlYzIuc2V0KHZsYW1iZGEsMCwwKTtcbiAgICBiLndsYW1iZGEgPSAwO1xufTtcblxuQm9keS5wcm90b3R5cGUuYWRkQ29uc3RyYWludFZlbG9jaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgIHYgPSBiLnZlbG9jaXR5O1xuICAgIHZlYzIuYWRkKCB2LCB2LCBiLnZsYW1iZGEpO1xuICAgIGIuYW5ndWxhclZlbG9jaXR5ICs9IGIud2xhbWJkYTtcbn07XG5cbi8qKlxuICogQXBwbHkgZGFtcGluZywgc2VlIDxhIGhyZWY9XCJodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYnVsbGV0L2lzc3Vlcy9kZXRhaWw/aWQ9NzRcIj50aGlzPC9hPiBmb3IgZGV0YWlscy5cbiAqIEBtZXRob2QgYXBwbHlEYW1waW5nXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGR0IEN1cnJlbnQgdGltZSBzdGVwXG4gKi9cbkJvZHkucHJvdG90eXBlLmFwcGx5RGFtcGluZyA9IGZ1bmN0aW9uKGR0KXtcbiAgICBpZih0aGlzLnR5cGUgPT09IEJvZHkuRFlOQU1JQyl7IC8vIE9ubHkgZm9yIGR5bmFtaWMgYm9kaWVzXG4gICAgICAgIHZhciB2ID0gdGhpcy52ZWxvY2l0eTtcbiAgICAgICAgdmVjMi5zY2FsZSh2LCB2LCBNYXRoLnBvdygxLjAgLSB0aGlzLmRhbXBpbmcsZHQpKTtcbiAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgKj0gTWF0aC5wb3coMS4wIC0gdGhpcy5hbmd1bGFyRGFtcGluZyxkdCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBXYWtlIHRoZSBib2R5IHVwLiBOb3JtYWxseSB5b3Ugc2hvdWxkIG5vdCBuZWVkIHRoaXMsIGFzIHRoZSBib2R5IGlzIGF1dG9tYXRpY2FsbHkgYXdva2VuIGF0IGV2ZW50cyBzdWNoIGFzIGNvbGxpc2lvbnMuXG4gKiBTZXRzIHRoZSBzbGVlcFN0YXRlIHRvIHt7I2Nyb3NzTGluayBcIkJvZHkvQVdBS0U6cHJvcGVydHlcIn19Qm9keS5BV0FLRXt7L2Nyb3NzTGlua319IGFuZCBlbWl0cyB0aGUgd2FrZVVwIGV2ZW50IGlmIHRoZSBib2R5IHdhc24ndCBhd2FrZSBiZWZvcmUuXG4gKiBAbWV0aG9kIHdha2VVcFxuICovXG5Cb2R5LnByb3RvdHlwZS53YWtlVXAgPSBmdW5jdGlvbigpe1xuICAgIHZhciBzID0gdGhpcy5zbGVlcFN0YXRlO1xuICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuQVdBS0U7XG4gICAgdGhpcy5pZGxlVGltZSA9IDA7XG4gICAgaWYocyAhPT0gQm9keS5BV0FLRSl7XG4gICAgICAgIHRoaXMuZW1pdChCb2R5Lndha2VVcEV2ZW50KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEZvcmNlIGJvZHkgc2xlZXBcbiAqIEBtZXRob2Qgc2xlZXBcbiAqL1xuQm9keS5wcm90b3R5cGUuc2xlZXAgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuU0xFRVBJTkc7XG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgPSAwO1xuICAgIHRoaXMuYW5ndWxhckZvcmNlID0gMDtcbiAgICB2ZWMyLnNldCh0aGlzLnZlbG9jaXR5LDAsMCk7XG4gICAgdmVjMi5zZXQodGhpcy5mb3JjZSwwLDApO1xuICAgIHRoaXMuZW1pdChCb2R5LnNsZWVwRXZlbnQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgZXZlcnkgdGltZXN0ZXAgdG8gdXBkYXRlIGludGVybmFsIHNsZWVwIHRpbWVyIGFuZCBjaGFuZ2Ugc2xlZXAgc3RhdGUgaWYgbmVlZGVkLlxuICogQG1ldGhvZCBzbGVlcFRpY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFRoZSB3b3JsZCB0aW1lIGluIHNlY29uZHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9udFNsZWVwXG4gKiBAcGFyYW0ge251bWJlcn0gZHRcbiAqL1xuQm9keS5wcm90b3R5cGUuc2xlZXBUaWNrID0gZnVuY3Rpb24odGltZSwgZG9udFNsZWVwLCBkdCl7XG4gICAgaWYoIXRoaXMuYWxsb3dTbGVlcCB8fCB0aGlzLnR5cGUgPT09IEJvZHkuU0xFRVBJTkcpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy53YW50c1RvU2xlZXAgPSBmYWxzZTtcblxuICAgIHZhciBzbGVlcFN0YXRlID0gdGhpcy5zbGVlcFN0YXRlLFxuICAgICAgICBzcGVlZFNxdWFyZWQgPSB2ZWMyLnNxdWFyZWRMZW5ndGgodGhpcy52ZWxvY2l0eSkgKyBNYXRoLnBvdyh0aGlzLmFuZ3VsYXJWZWxvY2l0eSwyKSxcbiAgICAgICAgc3BlZWRMaW1pdFNxdWFyZWQgPSBNYXRoLnBvdyh0aGlzLnNsZWVwU3BlZWRMaW1pdCwyKTtcblxuICAgIC8vIEFkZCB0byBpZGxlIHRpbWVcbiAgICBpZihzcGVlZFNxdWFyZWQgPj0gc3BlZWRMaW1pdFNxdWFyZWQpe1xuICAgICAgICB0aGlzLmlkbGVUaW1lID0gMDtcbiAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5BV0FLRTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlkbGVUaW1lICs9IGR0O1xuICAgICAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LlNMRUVQWTtcbiAgICB9XG4gICAgaWYodGhpcy5pZGxlVGltZSA+IHRoaXMuc2xlZXBUaW1lTGltaXQpe1xuICAgICAgICBpZighZG9udFNsZWVwKXtcbiAgICAgICAgICAgIHRoaXMuc2xlZXAoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud2FudHNUb1NsZWVwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgaWYoc2xlZXBTdGF0ZT09PUJvZHkuQVdBS0UgJiYgc3BlZWRTcXVhcmVkIDwgc3BlZWRMaW1pdFNxdWFyZWQpe1xuICAgICAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LlNMRUVQWTsgLy8gU2xlZXB5XG4gICAgICAgIHRoaXMudGltZUxhc3RTbGVlcHkgPSB0aW1lO1xuICAgICAgICB0aGlzLmVtaXQoQm9keS5zbGVlcHlFdmVudCk7XG4gICAgfSBlbHNlIGlmKHNsZWVwU3RhdGU9PT1Cb2R5LlNMRUVQWSAmJiBzcGVlZFNxdWFyZWQgPj0gc3BlZWRMaW1pdFNxdWFyZWQpe1xuICAgICAgICB0aGlzLndha2VVcCgpOyAvLyBXYWtlIHVwXG4gICAgfSBlbHNlIGlmKHNsZWVwU3RhdGU9PT1Cb2R5LlNMRUVQWSAmJiAodGltZSAtIHRoaXMudGltZUxhc3RTbGVlcHkgKSA+IHRoaXMuc2xlZXBUaW1lTGltaXQpe1xuICAgICAgICB0aGlzLndhbnRzVG9TbGVlcCA9IHRydWU7XG4gICAgICAgIGlmKCFkb250U2xlZXApe1xuICAgICAgICAgICAgdGhpcy5zbGVlcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgICovXG59O1xuXG5Cb2R5LnByb3RvdHlwZS5nZXRWZWxvY2l0eUZyb21Qb3NpdGlvbiA9IGZ1bmN0aW9uKHN0b3JlLCB0aW1lU3RlcCl7XG4gICAgc3RvcmUgPSBzdG9yZSB8fCB2ZWMyLmNyZWF0ZSgpO1xuICAgIHZlYzIuc3ViKHN0b3JlLCB0aGlzLnBvc2l0aW9uLCB0aGlzLnByZXZpb3VzUG9zaXRpb24pO1xuICAgIHZlYzIuc2NhbGUoc3RvcmUsIHN0b3JlLCAxL3RpbWVTdGVwKTtcbiAgICByZXR1cm4gc3RvcmU7XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5nZXRBbmd1bGFyVmVsb2NpdHlGcm9tUG9zaXRpb24gPSBmdW5jdGlvbih0aW1lU3RlcCl7XG4gICAgcmV0dXJuICh0aGlzLmFuZ2xlIC0gdGhpcy5wcmV2aW91c0FuZ2xlKSAvIHRpbWVTdGVwO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYm9keSBpcyBvdmVybGFwcGluZyBhbm90aGVyIGJvZHkuIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBvbmx5IHdvcmtzIGlmIHRoZSBib2R5IHdhcyBhZGRlZCB0byBhIFdvcmxkIGFuZCBpZiBhdCBsZWFzdCBvbmUgc3RlcCB3YXMgdGFrZW4uXG4gKiBAbWV0aG9kIG92ZXJsYXBzXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5Cb2R5LnByb3RvdHlwZS5vdmVybGFwcyA9IGZ1bmN0aW9uKGJvZHkpe1xuICAgIHJldHVybiB0aGlzLndvcmxkLm92ZXJsYXBLZWVwZXIuYm9kaWVzQXJlT3ZlcmxhcHBpbmcodGhpcywgYm9keSk7XG59O1xuXG52YXIgaW50ZWdyYXRlX2ZoTWludiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZWdyYXRlX3ZlbG9kdCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogTW92ZSB0aGUgYm9keSBmb3J3YXJkIGluIHRpbWUgZ2l2ZW4gaXRzIGN1cnJlbnQgdmVsb2NpdHkuXG4gKiBAbWV0aG9kIGludGVncmF0ZVxuICogQHBhcmFtICB7TnVtYmVyfSBkdFxuICovXG5Cb2R5LnByb3RvdHlwZS5pbnRlZ3JhdGUgPSBmdW5jdGlvbihkdCl7XG4gICAgdmFyIG1pbnYgPSB0aGlzLmludk1hc3MsXG4gICAgICAgIGYgPSB0aGlzLmZvcmNlLFxuICAgICAgICBwb3MgPSB0aGlzLnBvc2l0aW9uLFxuICAgICAgICB2ZWxvID0gdGhpcy52ZWxvY2l0eTtcblxuICAgIC8vIFNhdmUgb2xkIHBvc2l0aW9uXG4gICAgdmVjMi5jb3B5KHRoaXMucHJldmlvdXNQb3NpdGlvbiwgdGhpcy5wb3NpdGlvbik7XG4gICAgdGhpcy5wcmV2aW91c0FuZ2xlID0gdGhpcy5hbmdsZTtcblxuICAgIC8vIFZlbG9jaXR5IHVwZGF0ZVxuICAgIGlmKCF0aGlzLmZpeGVkUm90YXRpb24pe1xuICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSArPSB0aGlzLmFuZ3VsYXJGb3JjZSAqIHRoaXMuaW52SW5lcnRpYSAqIGR0O1xuICAgIH1cbiAgICB2ZWMyLnNjYWxlKGludGVncmF0ZV9maE1pbnYsIGYsIGR0ICogbWludik7XG4gICAgdmVjMi5hZGQodmVsbywgaW50ZWdyYXRlX2ZoTWludiwgdmVsbyk7XG5cbiAgICAvLyBDQ0RcbiAgICBpZighdGhpcy5pbnRlZ3JhdGVUb1RpbWVPZkltcGFjdChkdCkpe1xuXG4gICAgICAgIC8vIFJlZ3VsYXIgcG9zaXRpb24gdXBkYXRlXG4gICAgICAgIHZlYzIuc2NhbGUoaW50ZWdyYXRlX3ZlbG9kdCwgdmVsbywgZHQpO1xuICAgICAgICB2ZWMyLmFkZChwb3MsIHBvcywgaW50ZWdyYXRlX3ZlbG9kdCk7XG4gICAgICAgIGlmKCF0aGlzLmZpeGVkUm90YXRpb24pe1xuICAgICAgICAgICAgdGhpcy5hbmdsZSArPSB0aGlzLmFuZ3VsYXJWZWxvY2l0eSAqIGR0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xufTtcblxudmFyIGRpcmVjdGlvbiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgZW5kID0gdmVjMi5jcmVhdGUoKTtcbnZhciBzdGFydFRvRW5kID0gdmVjMi5jcmVhdGUoKTtcbnZhciByZW1lbWJlclBvc2l0aW9uID0gdmVjMi5jcmVhdGUoKTtcbkJvZHkucHJvdG90eXBlLmludGVncmF0ZVRvVGltZU9mSW1wYWN0ID0gZnVuY3Rpb24oZHQpe1xuXG4gICAgaWYodGhpcy5jY2RTcGVlZFRocmVzaG9sZCA8IDAgfHwgdmVjMi5zcXVhcmVkTGVuZ3RoKHRoaXMudmVsb2NpdHkpIDwgTWF0aC5wb3codGhpcy5jY2RTcGVlZFRocmVzaG9sZCwgMikpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmVjMi5ub3JtYWxpemUoZGlyZWN0aW9uLCB0aGlzLnZlbG9jaXR5KTtcblxuICAgIHZlYzIuc2NhbGUoZW5kLCB0aGlzLnZlbG9jaXR5LCBkdCk7XG4gICAgdmVjMi5hZGQoZW5kLCBlbmQsIHRoaXMucG9zaXRpb24pO1xuXG4gICAgdmVjMi5zdWIoc3RhcnRUb0VuZCwgZW5kLCB0aGlzLnBvc2l0aW9uKTtcbiAgICB2YXIgc3RhcnRUb0VuZEFuZ2xlID0gdGhpcy5hbmd1bGFyVmVsb2NpdHkgKiBkdDtcbiAgICB2YXIgbGVuID0gdmVjMi5sZW5ndGgoc3RhcnRUb0VuZCk7XG5cbiAgICB2YXIgdGltZU9mSW1wYWN0ID0gMTtcblxuICAgIHZhciBoaXQ7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoaXMud29ybGQucmF5Y2FzdEFsbCh0aGlzLnBvc2l0aW9uLCBlbmQsIHt9LCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmKHJlc3VsdC5ib2R5ID09PSB0aGF0KXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoaXQgPSByZXN1bHQuYm9keTtcbiAgICAgICAgdmVjMi5jb3B5KGVuZCwgcmVzdWx0LmhpdFBvaW50V29ybGQpO1xuICAgICAgICB2ZWMyLnN1YihzdGFydFRvRW5kLCByZXN1bHQuaGl0UG9pbnRXb3JsZCwgdGhhdC5wb3NpdGlvbik7XG4gICAgICAgIHRpbWVPZkltcGFjdCA9IHZlYzIubGVuZ3RoKHN0YXJ0VG9FbmQpIC8gbGVuO1xuICAgICAgICByZXN1bHQuYWJvcnQoKTtcbiAgICB9KTtcblxuICAgIGlmKCFoaXQpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHJlbWVtYmVyQW5nbGUgPSB0aGlzLmFuZ2xlO1xuICAgIHZlYzIuY29weShyZW1lbWJlclBvc2l0aW9uLCB0aGlzLnBvc2l0aW9uKTtcblxuICAgIC8vIEdvdCBhIHN0YXJ0IGFuZCBlbmQgcG9pbnQuIEFwcHJveGltYXRlIHRpbWUgb2YgaW1wYWN0IHVzaW5nIGJpbmFyeSBzZWFyY2hcbiAgICB2YXIgaXRlciA9IDA7XG4gICAgdmFyIHRtaW4gPSAwO1xuICAgIHZhciB0bWlkID0gMDtcbiAgICB2YXIgdG1heCA9IHRpbWVPZkltcGFjdDtcbiAgICB3aGlsZSAodG1heCA+PSB0bWluICYmIGl0ZXIgPCB0aGlzLmNjZEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgaXRlcisrO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgbWlkcG9pbnRcbiAgICAgICAgdG1pZCA9ICh0bWF4IC0gdG1pbikgLyAyO1xuXG4gICAgICAgIC8vIE1vdmUgdGhlIGJvZHkgdG8gdGhhdCBwb2ludFxuICAgICAgICB2ZWMyLnNjYWxlKGludGVncmF0ZV92ZWxvZHQsIHN0YXJ0VG9FbmQsIHRpbWVPZkltcGFjdCk7XG4gICAgICAgIHZlYzIuYWRkKHRoaXMucG9zaXRpb24sIHJlbWVtYmVyUG9zaXRpb24sIGludGVncmF0ZV92ZWxvZHQpO1xuICAgICAgICB0aGlzLmFuZ2xlID0gcmVtZW1iZXJBbmdsZSArIHN0YXJ0VG9FbmRBbmdsZSAqIHRpbWVPZkltcGFjdDtcbiAgICAgICAgdGhpcy51cGRhdGVBQUJCKCk7XG5cbiAgICAgICAgLy8gY2hlY2sgb3ZlcmxhcFxuICAgICAgICB2YXIgb3ZlcmxhcHMgPSB0aGlzLmFhYmIub3ZlcmxhcHMoaGl0LmFhYmIpICYmIHRoaXMud29ybGQubmFycm93cGhhc2UuYm9kaWVzT3ZlcmxhcCh0aGlzLCBoaXQpO1xuXG4gICAgICAgIGlmIChvdmVybGFwcykge1xuICAgICAgICAgICAgLy8gY2hhbmdlIG1pbiB0byBzZWFyY2ggdXBwZXIgaW50ZXJ2YWxcbiAgICAgICAgICAgIHRtaW4gPSB0bWlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2hhbmdlIG1heCB0byBzZWFyY2ggbG93ZXIgaW50ZXJ2YWxcbiAgICAgICAgICAgIHRtYXggPSB0bWlkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGltZU9mSW1wYWN0ID0gdG1pZDtcblxuICAgIHZlYzIuY29weSh0aGlzLnBvc2l0aW9uLCByZW1lbWJlclBvc2l0aW9uKTtcbiAgICB0aGlzLmFuZ2xlID0gcmVtZW1iZXJBbmdsZTtcblxuICAgIC8vIG1vdmUgdG8gVE9JXG4gICAgdmVjMi5zY2FsZShpbnRlZ3JhdGVfdmVsb2R0LCBzdGFydFRvRW5kLCB0aW1lT2ZJbXBhY3QpO1xuICAgIHZlYzIuYWRkKHRoaXMucG9zaXRpb24sIHRoaXMucG9zaXRpb24sIGludGVncmF0ZV92ZWxvZHQpO1xuICAgIGlmKCF0aGlzLmZpeGVkUm90YXRpb24pe1xuICAgICAgICB0aGlzLmFuZ2xlICs9IHN0YXJ0VG9FbmRBbmdsZSAqIHRpbWVPZkltcGFjdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQGV2ZW50IHNsZWVweVxuICovXG5Cb2R5LnNsZWVweUV2ZW50ID0ge1xuICAgIHR5cGU6IFwic2xlZXB5XCJcbn07XG5cbi8qKlxuICogQGV2ZW50IHNsZWVwXG4gKi9cbkJvZHkuc2xlZXBFdmVudCA9IHtcbiAgICB0eXBlOiBcInNsZWVwXCJcbn07XG5cbi8qKlxuICogQGV2ZW50IHdha2V1cFxuICovXG5Cb2R5Lndha2VVcEV2ZW50ID0ge1xuICAgIHR5cGU6IFwid2FrZXVwXCJcbn07XG5cbi8qKlxuICogRHluYW1pYyBib2R5LlxuICogQHByb3BlcnR5IERZTkFNSUNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAc3RhdGljXG4gKi9cbkJvZHkuRFlOQU1JQyA9IDE7XG5cbi8qKlxuICogU3RhdGljIGJvZHkuXG4gKiBAcHJvcGVydHkgU1RBVElDXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LlNUQVRJQyA9IDI7XG5cbi8qKlxuICogS2luZW1hdGljIGJvZHkuXG4gKiBAcHJvcGVydHkgS0lORU1BVElDXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LktJTkVNQVRJQyA9IDQ7XG5cbi8qKlxuICogQHByb3BlcnR5IEFXQUtFXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LkFXQUtFID0gMDtcblxuLyoqXG4gKiBAcHJvcGVydHkgU0xFRVBZXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LlNMRUVQWSA9IDE7XG5cbi8qKlxuICogQHByb3BlcnR5IFNMRUVQSU5HXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LlNMRUVQSU5HID0gMjtcblxuXG59LHtcIi4uL2NvbGxpc2lvbi9BQUJCXCI6NyxcIi4uL2V2ZW50cy9FdmVudEVtaXR0ZXJcIjoyNyxcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vc2hhcGVzL0NvbnZleFwiOjM5LFwicG9seS1kZWNvbXBcIjo1fV0sMzM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcbnZhciBTcHJpbmcgPSBfZGVyZXFfKCcuL1NwcmluZycpO1xudmFyIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lYXJTcHJpbmc7XG5cbi8qKlxuICogQSBzcHJpbmcsIGNvbm5lY3RpbmcgdHdvIGJvZGllcy5cbiAqXG4gKiBUaGUgU3ByaW5nIGV4cGxpY2l0bHkgYWRkcyBmb3JjZSBhbmQgYW5ndWxhckZvcmNlIHRvIHRoZSBib2RpZXMuXG4gKlxuICogQGNsYXNzIExpbmVhclNwcmluZ1xuICogQGV4dGVuZHMgU3ByaW5nXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXN0TGVuZ3RoXSAgIEEgbnVtYmVyID4gMC4gRGVmYXVsdCBpcyB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB3b3JsZCBhbmNob3IgcG9pbnRzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0aWZmbmVzcz0xMDBdICBTcHJpbmcgY29uc3RhbnQgKHNlZSBIb29rZXMgTGF3KS4gQSBudW1iZXIgPj0gMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kYW1waW5nPTFdICAgICAgQSBudW1iZXIgPj0gMC4gRGVmYXVsdDogMVxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLndvcmxkQW5jaG9yQV0gICBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiB3b3JsZCBjb29yZGluYXRlcy4gT3ZlcnJpZGVzIHRoZSBvcHRpb24gXCJsb2NhbEFuY2hvckFcIiBpZiBnaXZlbi5cbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy53b3JsZEFuY2hvckJdXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxBbmNob3JBXSAgIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIGxvY2FsIGJvZHkgY29vcmRpbmF0ZXMuIERlZmF1bHRzIHRvIHRoZSBib2R5IGNlbnRlci5cbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5sb2NhbEFuY2hvckJdXG4gKi9cbmZ1bmN0aW9uIExpbmVhclNwcmluZyhib2R5QSxib2R5QixvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIFNwcmluZy5jYWxsKHRoaXMsIGJvZHlBLCBib2R5Qiwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBBbmNob3IgZm9yIGJvZHlBIGluIGxvY2FsIGJvZHlBIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEFuY2hvckFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuICAgIC8qKlxuICAgICAqIEFuY2hvciBmb3IgYm9keUIgaW4gbG9jYWwgYm9keUIgY29vcmRpbmF0ZXMuXG4gICAgICogQHByb3BlcnR5IGxvY2FsQW5jaG9yQlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQW5jaG9yQiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4gICAgaWYob3B0aW9ucy5sb2NhbEFuY2hvckEpeyB2ZWMyLmNvcHkodGhpcy5sb2NhbEFuY2hvckEsIG9wdGlvbnMubG9jYWxBbmNob3JBKTsgfVxuICAgIGlmKG9wdGlvbnMubG9jYWxBbmNob3JCKXsgdmVjMi5jb3B5KHRoaXMubG9jYWxBbmNob3JCLCBvcHRpb25zLmxvY2FsQW5jaG9yQik7IH1cbiAgICBpZihvcHRpb25zLndvcmxkQW5jaG9yQSl7IHRoaXMuc2V0V29ybGRBbmNob3JBKG9wdGlvbnMud29ybGRBbmNob3JBKTsgfVxuICAgIGlmKG9wdGlvbnMud29ybGRBbmNob3JCKXsgdGhpcy5zZXRXb3JsZEFuY2hvckIob3B0aW9ucy53b3JsZEFuY2hvckIpOyB9XG5cbiAgICB2YXIgd29ybGRBbmNob3JBID0gdmVjMi5jcmVhdGUoKTtcbiAgICB2YXIgd29ybGRBbmNob3JCID0gdmVjMi5jcmVhdGUoKTtcbiAgICB0aGlzLmdldFdvcmxkQW5jaG9yQSh3b3JsZEFuY2hvckEpO1xuICAgIHRoaXMuZ2V0V29ybGRBbmNob3JCKHdvcmxkQW5jaG9yQik7XG4gICAgdmFyIHdvcmxkRGlzdGFuY2UgPSB2ZWMyLmRpc3RhbmNlKHdvcmxkQW5jaG9yQSwgd29ybGRBbmNob3JCKTtcblxuICAgIC8qKlxuICAgICAqIFJlc3QgbGVuZ3RoIG9mIHRoZSBzcHJpbmcuXG4gICAgICogQHByb3BlcnR5IHJlc3RMZW5ndGhcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzdExlbmd0aCA9IHR5cGVvZihvcHRpb25zLnJlc3RMZW5ndGgpID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5yZXN0TGVuZ3RoIDogd29ybGREaXN0YW5jZTtcbn1cbkxpbmVhclNwcmluZy5wcm90b3R5cGUgPSBuZXcgU3ByaW5nKCk7XG5MaW5lYXJTcHJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZWFyU3ByaW5nO1xuXG4vKipcbiAqIFNldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQSwgdXNpbmcgd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIHNldFdvcmxkQW5jaG9yQVxuICogQHBhcmFtIHtBcnJheX0gd29ybGRBbmNob3JBXG4gKi9cbkxpbmVhclNwcmluZy5wcm90b3R5cGUuc2V0V29ybGRBbmNob3JBID0gZnVuY3Rpb24od29ybGRBbmNob3JBKXtcbiAgICB0aGlzLmJvZHlBLnRvTG9jYWxGcmFtZSh0aGlzLmxvY2FsQW5jaG9yQSwgd29ybGRBbmNob3JBKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBCLCB1c2luZyB3b3JsZCBjb29yZGluYXRlcy5cbiAqIEBtZXRob2Qgc2V0V29ybGRBbmNob3JCXG4gKiBAcGFyYW0ge0FycmF5fSB3b3JsZEFuY2hvckJcbiAqL1xuTGluZWFyU3ByaW5nLnByb3RvdHlwZS5zZXRXb3JsZEFuY2hvckIgPSBmdW5jdGlvbih3b3JsZEFuY2hvckIpe1xuICAgIHRoaXMuYm9keUIudG9Mb2NhbEZyYW1lKHRoaXMubG9jYWxBbmNob3JCLCB3b3JsZEFuY2hvckIpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEEsIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICogQG1ldGhvZCBnZXRXb3JsZEFuY2hvckFcbiAqIEBwYXJhbSB7QXJyYXl9IHJlc3VsdCBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXG4gKi9cbkxpbmVhclNwcmluZy5wcm90b3R5cGUuZ2V0V29ybGRBbmNob3JBID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB0aGlzLmJvZHlBLnRvV29ybGRGcmFtZShyZXN1bHQsIHRoaXMubG9jYWxBbmNob3JBKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBCLCBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAqIEBtZXRob2QgZ2V0V29ybGRBbmNob3JCXG4gKiBAcGFyYW0ge0FycmF5fSByZXN1bHQgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxuICovXG5MaW5lYXJTcHJpbmcucHJvdG90eXBlLmdldFdvcmxkQW5jaG9yQiA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgdGhpcy5ib2R5Qi50b1dvcmxkRnJhbWUocmVzdWx0LCB0aGlzLmxvY2FsQW5jaG9yQik7XG59O1xuXG52YXIgYXBwbHlGb3JjZV9yID0gICAgICAgICAgICAgIHZlYzIuY3JlYXRlKCksXG4gICAgYXBwbHlGb3JjZV9yX3VuaXQgPSAgICAgICAgIHZlYzIuY3JlYXRlKCksXG4gICAgYXBwbHlGb3JjZV91ID0gICAgICAgICAgICAgIHZlYzIuY3JlYXRlKCksXG4gICAgYXBwbHlGb3JjZV9mID0gICAgICAgICAgICAgIHZlYzIuY3JlYXRlKCksXG4gICAgYXBwbHlGb3JjZV93b3JsZEFuY2hvckEgPSAgIHZlYzIuY3JlYXRlKCksXG4gICAgYXBwbHlGb3JjZV93b3JsZEFuY2hvckIgPSAgIHZlYzIuY3JlYXRlKCksXG4gICAgYXBwbHlGb3JjZV9yaSA9ICAgICAgICAgICAgIHZlYzIuY3JlYXRlKCksXG4gICAgYXBwbHlGb3JjZV9yaiA9ICAgICAgICAgICAgIHZlYzIuY3JlYXRlKCksXG4gICAgYXBwbHlGb3JjZV90bXAgPSAgICAgICAgICAgIHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQXBwbHkgdGhlIHNwcmluZyBmb3JjZSB0byB0aGUgY29ubmVjdGVkIGJvZGllcy5cbiAqIEBtZXRob2QgYXBwbHlGb3JjZVxuICovXG5MaW5lYXJTcHJpbmcucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbigpe1xuICAgIHZhciBrID0gdGhpcy5zdGlmZm5lc3MsXG4gICAgICAgIGQgPSB0aGlzLmRhbXBpbmcsXG4gICAgICAgIGwgPSB0aGlzLnJlc3RMZW5ndGgsXG4gICAgICAgIGJvZHlBID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICByID0gYXBwbHlGb3JjZV9yLFxuICAgICAgICByX3VuaXQgPSBhcHBseUZvcmNlX3JfdW5pdCxcbiAgICAgICAgdSA9IGFwcGx5Rm9yY2VfdSxcbiAgICAgICAgZiA9IGFwcGx5Rm9yY2VfZixcbiAgICAgICAgdG1wID0gYXBwbHlGb3JjZV90bXA7XG5cbiAgICB2YXIgd29ybGRBbmNob3JBID0gYXBwbHlGb3JjZV93b3JsZEFuY2hvckEsXG4gICAgICAgIHdvcmxkQW5jaG9yQiA9IGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JCLFxuICAgICAgICByaSA9IGFwcGx5Rm9yY2VfcmksXG4gICAgICAgIHJqID0gYXBwbHlGb3JjZV9yajtcblxuICAgIC8vIEdldCB3b3JsZCBhbmNob3JzXG4gICAgdGhpcy5nZXRXb3JsZEFuY2hvckEod29ybGRBbmNob3JBKTtcbiAgICB0aGlzLmdldFdvcmxkQW5jaG9yQih3b3JsZEFuY2hvckIpO1xuXG4gICAgLy8gR2V0IG9mZnNldCBwb2ludHNcbiAgICB2ZWMyLnN1YihyaSwgd29ybGRBbmNob3JBLCBib2R5QS5wb3NpdGlvbik7XG4gICAgdmVjMi5zdWIocmosIHdvcmxkQW5jaG9yQiwgYm9keUIucG9zaXRpb24pO1xuXG4gICAgLy8gQ29tcHV0ZSBkaXN0YW5jZSB2ZWN0b3IgYmV0d2VlbiB3b3JsZCBhbmNob3IgcG9pbnRzXG4gICAgdmVjMi5zdWIociwgd29ybGRBbmNob3JCLCB3b3JsZEFuY2hvckEpO1xuICAgIHZhciBybGVuID0gdmVjMi5sZW4ocik7XG4gICAgdmVjMi5ub3JtYWxpemUocl91bml0LHIpO1xuXG4gICAgLy9jb25zb2xlLmxvZyhybGVuKVxuICAgIC8vY29uc29sZS5sb2coXCJBXCIsdmVjMi5zdHIod29ybGRBbmNob3JBKSxcIkJcIix2ZWMyLnN0cih3b3JsZEFuY2hvckIpKVxuXG4gICAgLy8gQ29tcHV0ZSByZWxhdGl2ZSB2ZWxvY2l0eSBvZiB0aGUgYW5jaG9yIHBvaW50cywgdVxuICAgIHZlYzIuc3ViKHUsIGJvZHlCLnZlbG9jaXR5LCBib2R5QS52ZWxvY2l0eSk7XG4gICAgdmVjMi5jcm9zc1pWKHRtcCwgYm9keUIuYW5ndWxhclZlbG9jaXR5LCByaik7XG4gICAgdmVjMi5hZGQodSwgdSwgdG1wKTtcbiAgICB2ZWMyLmNyb3NzWlYodG1wLCBib2R5QS5hbmd1bGFyVmVsb2NpdHksIHJpKTtcbiAgICB2ZWMyLnN1Yih1LCB1LCB0bXApO1xuXG4gICAgLy8gRiA9IC0gayAqICggeCAtIEwgKSAtIEQgKiAoIHUgKVxuICAgIHZlYzIuc2NhbGUoZiwgcl91bml0LCAtayoocmxlbi1sKSAtIGQqdmVjMi5kb3QodSxyX3VuaXQpKTtcblxuICAgIC8vIEFkZCBmb3JjZXMgdG8gYm9kaWVzXG4gICAgdmVjMi5zdWIoIGJvZHlBLmZvcmNlLCBib2R5QS5mb3JjZSwgZik7XG4gICAgdmVjMi5hZGQoIGJvZHlCLmZvcmNlLCBib2R5Qi5mb3JjZSwgZik7XG5cbiAgICAvLyBBbmd1bGFyIGZvcmNlXG4gICAgdmFyIHJpX3hfZiA9IHZlYzIuY3Jvc3NMZW5ndGgocmksIGYpO1xuICAgIHZhciByal94X2YgPSB2ZWMyLmNyb3NzTGVuZ3RoKHJqLCBmKTtcbiAgICBib2R5QS5hbmd1bGFyRm9yY2UgLT0gcmlfeF9mO1xuICAgIGJvZHlCLmFuZ3VsYXJGb3JjZSArPSByal94X2Y7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vdXRpbHMvVXRpbHNcIjo1MCxcIi4vU3ByaW5nXCI6MzV9XSwzNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xudmFyIFNwcmluZyA9IF9kZXJlcV8oJy4vU3ByaW5nJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUm90YXRpb25hbFNwcmluZztcblxuLyoqXG4gKiBBIHJvdGF0aW9uYWwgc3ByaW5nLCBjb25uZWN0aW5nIHR3byBib2RpZXMgcm90YXRpb24uIFRoaXMgc3ByaW5nIGV4cGxpY2l0bHkgYWRkcyBhbmd1bGFyRm9yY2UgKHRvcnF1ZSkgdG8gdGhlIGJvZGllcy5cbiAqXG4gKiBUaGUgc3ByaW5nIGNhbiBiZSBjb21iaW5lZCB3aXRoIGEge3sjY3Jvc3NMaW5rIFwiUmV2b2x1dGVDb25zdHJhaW50XCJ9fXt7L2Nyb3NzTGlua319IHRvIG1ha2UsIGZvciBleGFtcGxlLCBhIG1vdXNlIHRyYXAuXG4gKlxuICogQGNsYXNzIFJvdGF0aW9uYWxTcHJpbmdcbiAqIEBleHRlbmRzIFNwcmluZ1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzdEFuZ2xlXSBUaGUgcmVsYXRpdmUgYW5nbGUgb2YgYm9kaWVzIGF0IHdoaWNoIHRoZSBzcHJpbmcgaXMgYXQgcmVzdC4gSWYgbm90IGdpdmVuLCBpdCdzIHNldCB0byB0aGUgY3VycmVudCByZWxhdGl2ZSBhbmdsZSBiZXR3ZWVuIHRoZSBib2RpZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RpZmZuZXNzPTEwMF0gU3ByaW5nIGNvbnN0YW50IChzZWUgSG9va2VzIExhdykuIEEgbnVtYmVyID49IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZz0xXSBBIG51bWJlciA+PSAwLlxuICovXG5mdW5jdGlvbiBSb3RhdGlvbmFsU3ByaW5nKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBTcHJpbmcuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogUmVzdCBhbmdsZSBvZiB0aGUgc3ByaW5nLlxuICAgICAqIEBwcm9wZXJ0eSByZXN0QW5nbGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzdEFuZ2xlID0gdHlwZW9mKG9wdGlvbnMucmVzdEFuZ2xlKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMucmVzdEFuZ2xlIDogYm9keUIuYW5nbGUgLSBib2R5QS5hbmdsZTtcbn1cblJvdGF0aW9uYWxTcHJpbmcucHJvdG90eXBlID0gbmV3IFNwcmluZygpO1xuUm90YXRpb25hbFNwcmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb3RhdGlvbmFsU3ByaW5nO1xuXG4vKipcbiAqIEFwcGx5IHRoZSBzcHJpbmcgZm9yY2UgdG8gdGhlIGNvbm5lY3RlZCBib2RpZXMuXG4gKiBAbWV0aG9kIGFwcGx5Rm9yY2VcbiAqL1xuUm90YXRpb25hbFNwcmluZy5wcm90b3R5cGUuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGsgPSB0aGlzLnN0aWZmbmVzcyxcbiAgICAgICAgZCA9IHRoaXMuZGFtcGluZyxcbiAgICAgICAgbCA9IHRoaXMucmVzdEFuZ2xlLFxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcbiAgICAgICAgeCA9IGJvZHlCLmFuZ2xlIC0gYm9keUEuYW5nbGUsXG4gICAgICAgIHUgPSBib2R5Qi5hbmd1bGFyVmVsb2NpdHkgLSBib2R5QS5hbmd1bGFyVmVsb2NpdHk7XG5cbiAgICB2YXIgdG9ycXVlID0gLSBrICogKHggLSBsKSAtIGQgKiB1ICogMDtcblxuICAgIGJvZHlBLmFuZ3VsYXJGb3JjZSAtPSB0b3JxdWU7XG4gICAgYm9keUIuYW5ndWxhckZvcmNlICs9IHRvcnF1ZTtcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL1NwcmluZ1wiOjM1fV0sMzU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ByaW5nO1xuXG4vKipcbiAqIEEgc3ByaW5nLCBjb25uZWN0aW5nIHR3byBib2RpZXMuIFRoZSBTcHJpbmcgZXhwbGljaXRseSBhZGRzIGZvcmNlIGFuZCBhbmd1bGFyRm9yY2UgdG8gdGhlIGJvZGllcyBhbmQgZG9lcyB0aGVyZWZvcmUgbm90IHB1dCBsb2FkIG9uIHRoZSBjb25zdHJhaW50IHNvbHZlci5cbiAqXG4gKiBAY2xhc3MgU3ByaW5nXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGlmZm5lc3M9MTAwXSAgU3ByaW5nIGNvbnN0YW50IChzZWUgSG9va2VzIExhdykuIEEgbnVtYmVyID49IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZz0xXSAgICAgIEEgbnVtYmVyID49IDAuIERlZmF1bHQ6IDFcbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5sb2NhbEFuY2hvckFdICAgV2hlcmUgdG8gaG9vayB0aGUgc3ByaW5nIHRvIGJvZHkgQSwgaW4gbG9jYWwgYm9keSBjb29yZGluYXRlcy4gRGVmYXVsdHMgdG8gdGhlIGJvZHkgY2VudGVyLlxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLmxvY2FsQW5jaG9yQl1cbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy53b3JsZEFuY2hvckFdICAgV2hlcmUgdG8gaG9vayB0aGUgc3ByaW5nIHRvIGJvZHkgQSwgaW4gd29ybGQgY29vcmRpbmF0ZXMuIE92ZXJyaWRlcyB0aGUgb3B0aW9uIFwibG9jYWxBbmNob3JBXCIgaWYgZ2l2ZW4uXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMud29ybGRBbmNob3JCXVxuICovXG5mdW5jdGlvbiBTcHJpbmcoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucyx7XG4gICAgICAgIHN0aWZmbmVzczogMTAwLFxuICAgICAgICBkYW1waW5nOiAxLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU3RpZmZuZXNzIG9mIHRoZSBzcHJpbmcuXG4gICAgICogQHByb3BlcnR5IHN0aWZmbmVzc1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zdGlmZm5lc3MgPSBvcHRpb25zLnN0aWZmbmVzcztcblxuICAgIC8qKlxuICAgICAqIERhbXBpbmcgb2YgdGhlIHNwcmluZy5cbiAgICAgKiBAcHJvcGVydHkgZGFtcGluZ1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kYW1waW5nID0gb3B0aW9ucy5kYW1waW5nO1xuXG4gICAgLyoqXG4gICAgICogRmlyc3QgY29ubmVjdGVkIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGJvZHlBXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xuXG4gICAgLyoqXG4gICAgICogU2Vjb25kIGNvbm5lY3RlZCBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBib2R5QlxuICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAqL1xuICAgIHRoaXMuYm9keUIgPSBib2R5Qjtcbn1cblxuLyoqXG4gKiBBcHBseSB0aGUgc3ByaW5nIGZvcmNlIHRvIHRoZSBjb25uZWN0ZWQgYm9kaWVzLlxuICogQG1ldGhvZCBhcHBseUZvcmNlXG4gKi9cblNwcmluZy5wcm90b3R5cGUuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gVG8gYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3Nlc1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4uL3V0aWxzL1V0aWxzXCI6NTB9XSwzNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBFeHBvcnQgcDIgY2xhc3Nlc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQUFCQiA6ICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9BQUJCJyksXG4gICAgQW5nbGVMb2NrRXF1YXRpb24gOiAgICAgICAgICAgICBfZGVyZXFfKCcuL2VxdWF0aW9ucy9BbmdsZUxvY2tFcXVhdGlvbicpLFxuICAgIEJvZHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9vYmplY3RzL0JvZHknKSxcbiAgICBCcm9hZHBoYXNlIDogICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29sbGlzaW9uL0Jyb2FkcGhhc2UnKSxcbiAgICBDYXBzdWxlIDogICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL0NhcHN1bGUnKSxcbiAgICBDaXJjbGUgOiAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL0NpcmNsZScpLFxuICAgIENvbnN0cmFpbnQgOiAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb25zdHJhaW50cy9Db25zdHJhaW50JyksXG4gICAgQ29udGFjdEVxdWF0aW9uIDogICAgICAgICAgICAgICBfZGVyZXFfKCcuL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKSxcbiAgICBDb250YWN0TWF0ZXJpYWwgOiAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsJyksXG4gICAgQ29udmV4IDogICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9Db252ZXgnKSxcbiAgICBEaXN0YW5jZUNvbnN0cmFpbnQgOiAgICAgICAgICAgIF9kZXJlcV8oJy4vY29uc3RyYWludHMvRGlzdGFuY2VDb25zdHJhaW50JyksXG4gICAgRXF1YXRpb24gOiAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2VxdWF0aW9ucy9FcXVhdGlvbicpLFxuICAgIEV2ZW50RW1pdHRlciA6ICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9ldmVudHMvRXZlbnRFbWl0dGVyJyksXG4gICAgRnJpY3Rpb25FcXVhdGlvbiA6ICAgICAgICAgICAgICBfZGVyZXFfKCcuL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uJyksXG4gICAgR2VhckNvbnN0cmFpbnQgOiAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0dlYXJDb25zdHJhaW50JyksXG4gICAgR3JpZEJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9HcmlkQnJvYWRwaGFzZScpLFxuICAgIEdTU29sdmVyIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zb2x2ZXIvR1NTb2x2ZXInKSxcbiAgICBIZWlnaHRmaWVsZCA6ICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL0hlaWdodGZpZWxkJyksXG4gICAgTGluZSA6ICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9MaW5lJyksXG4gICAgTG9ja0NvbnN0cmFpbnQgOiAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50JyksXG4gICAgTWF0ZXJpYWwgOiAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL21hdGVyaWFsL01hdGVyaWFsJyksXG4gICAgTmFycm93cGhhc2UgOiAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9OYXJyb3dwaGFzZScpLFxuICAgIE5haXZlQnJvYWRwaGFzZSA6ICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlJyksXG4gICAgUGFydGljbGUgOiAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9QYXJ0aWNsZScpLFxuICAgIFBsYW5lIDogICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvUGxhbmUnKSxcbiAgICBSZXZvbHV0ZUNvbnN0cmFpbnQgOiAgICAgICAgICAgIF9kZXJlcV8oJy4vY29uc3RyYWludHMvUmV2b2x1dGVDb25zdHJhaW50JyksXG4gICAgUHJpc21hdGljQ29uc3RyYWludCA6ICAgICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL1ByaXNtYXRpY0NvbnN0cmFpbnQnKSxcbiAgICBSYXkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29sbGlzaW9uL1JheScpLFxuICAgIFJheWNhc3RSZXN1bHQgOiAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpLFxuICAgIFJlY3RhbmdsZSA6ICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvUmVjdGFuZ2xlJyksXG4gICAgUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24gOiAgICBfZGVyZXFfKCcuL2VxdWF0aW9ucy9Sb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbicpLFxuICAgIFNBUEJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vU0FQQnJvYWRwaGFzZScpLFxuICAgIFNoYXBlIDogICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvU2hhcGUnKSxcbiAgICBTb2x2ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc29sdmVyL1NvbHZlcicpLFxuICAgIFNwcmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9vYmplY3RzL1NwcmluZycpLFxuICAgIExpbmVhclNwcmluZyA6ICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9vYmplY3RzL0xpbmVhclNwcmluZycpLFxuICAgIFJvdGF0aW9uYWxTcHJpbmcgOiAgICAgICAgICAgICAgX2RlcmVxXygnLi9vYmplY3RzL1JvdGF0aW9uYWxTcHJpbmcnKSxcbiAgICBVdGlscyA6ICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vdXRpbHMvVXRpbHMnKSxcbiAgICBXb3JsZCA6ICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vd29ybGQvV29ybGQnKSxcbiAgICB2ZWMyIDogICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vbWF0aC92ZWMyJyksXG4gICAgdmVyc2lvbiA6ICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uLFxufTtcblxufSx7XCIuLi9wYWNrYWdlLmpzb25cIjo2LFwiLi9jb2xsaXNpb24vQUFCQlwiOjcsXCIuL2NvbGxpc2lvbi9Ccm9hZHBoYXNlXCI6OCxcIi4vY29sbGlzaW9uL0dyaWRCcm9hZHBoYXNlXCI6OSxcIi4vY29sbGlzaW9uL05haXZlQnJvYWRwaGFzZVwiOjEwLFwiLi9jb2xsaXNpb24vTmFycm93cGhhc2VcIjoxMSxcIi4vY29sbGlzaW9uL1JheVwiOjEyLFwiLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjEzLFwiLi9jb2xsaXNpb24vU0FQQnJvYWRwaGFzZVwiOjE0LFwiLi9jb25zdHJhaW50cy9Db25zdHJhaW50XCI6MTUsXCIuL2NvbnN0cmFpbnRzL0Rpc3RhbmNlQ29uc3RyYWludFwiOjE2LFwiLi9jb25zdHJhaW50cy9HZWFyQ29uc3RyYWludFwiOjE3LFwiLi9jb25zdHJhaW50cy9Mb2NrQ29uc3RyYWludFwiOjE4LFwiLi9jb25zdHJhaW50cy9QcmlzbWF0aWNDb25zdHJhaW50XCI6MTksXCIuL2NvbnN0cmFpbnRzL1Jldm9sdXRlQ29uc3RyYWludFwiOjIwLFwiLi9lcXVhdGlvbnMvQW5nbGVMb2NrRXF1YXRpb25cIjoyMSxcIi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjIyLFwiLi9lcXVhdGlvbnMvRXF1YXRpb25cIjoyMyxcIi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb25cIjoyNCxcIi4vZXF1YXRpb25zL1JvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uXCI6MjYsXCIuL2V2ZW50cy9FdmVudEVtaXR0ZXJcIjoyNyxcIi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsXCI6MjgsXCIuL21hdGVyaWFsL01hdGVyaWFsXCI6MjksXCIuL21hdGgvdmVjMlwiOjMxLFwiLi9vYmplY3RzL0JvZHlcIjozMixcIi4vb2JqZWN0cy9MaW5lYXJTcHJpbmdcIjozMyxcIi4vb2JqZWN0cy9Sb3RhdGlvbmFsU3ByaW5nXCI6MzQsXCIuL29iamVjdHMvU3ByaW5nXCI6MzUsXCIuL3NoYXBlcy9DYXBzdWxlXCI6MzcsXCIuL3NoYXBlcy9DaXJjbGVcIjozOCxcIi4vc2hhcGVzL0NvbnZleFwiOjM5LFwiLi9zaGFwZXMvSGVpZ2h0ZmllbGRcIjo0MCxcIi4vc2hhcGVzL0xpbmVcIjo0MSxcIi4vc2hhcGVzL1BhcnRpY2xlXCI6NDIsXCIuL3NoYXBlcy9QbGFuZVwiOjQzLFwiLi9zaGFwZXMvUmVjdGFuZ2xlXCI6NDQsXCIuL3NoYXBlcy9TaGFwZVwiOjQ1LFwiLi9zb2x2ZXIvR1NTb2x2ZXJcIjo0NixcIi4vc29sdmVyL1NvbHZlclwiOjQ3LFwiLi91dGlscy9VdGlsc1wiOjUwLFwiLi93b3JsZC9Xb3JsZFwiOjU0fV0sMzc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhcHN1bGU7XG5cbi8qKlxuICogQ2Fwc3VsZSBzaGFwZSBjbGFzcy5cbiAqIEBjbGFzcyBDYXBzdWxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFNoYXBlXG4gKiBAcGFyYW0ge051bWJlcn0gW2xlbmd0aD0xXSBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgZW5kIHBvaW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IFtyYWRpdXM9MV0gUmFkaXVzIG9mIHRoZSBjYXBzdWxlXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciByYWRpdXMgPSAxO1xuICogICAgIHZhciBsZW5ndGggPSAyO1xuICogICAgIHZhciBjYXBzdWxlU2hhcGUgPSBuZXcgQ2Fwc3VsZShsZW5ndGgsIHJhZGl1cyk7XG4gKiAgICAgYm9keS5hZGRTaGFwZShjYXBzdWxlU2hhcGUpO1xuICovXG5mdW5jdGlvbiBDYXBzdWxlKGxlbmd0aCwgcmFkaXVzKXtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBlbmQgcG9pbnRzLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsZW5ndGhcbiAgICAgKi9cbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aCB8fCAxO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJhZGl1cyBvZiB0aGUgY2Fwc3VsZS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcmFkaXVzXG4gICAgICovXG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXMgfHwgMTtcblxuICAgIFNoYXBlLmNhbGwodGhpcyxTaGFwZS5DQVBTVUxFKTtcbn1cbkNhcHN1bGUucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5DYXBzdWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhcHN1bGU7XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbWFzcyBtb21lbnQgb2YgaW5lcnRpYSBvZiB0aGUgQ2Fwc3VsZS5cbiAqIEBtZXRob2QgY29ucHV0ZU1vbWVudE9mSW5lcnRpYVxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAdG9kb1xuICovXG5DYXBzdWxlLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgLy8gQXBwcm94aW1hdGUgd2l0aCByZWN0YW5nbGVcbiAgICB2YXIgciA9IHRoaXMucmFkaXVzLFxuICAgICAgICB3ID0gdGhpcy5sZW5ndGggKyByLCAvLyAyKnIgaXMgdG9vIG11Y2gsIDAgaXMgdG9vIGxpdHRsZVxuICAgICAgICBoID0gcioyO1xuICAgIHJldHVybiBtYXNzICogKGgqaCArIHcqdykgLyAxMjtcbn07XG5cbi8qKlxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICovXG5DYXBzdWxlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IHRoaXMucmFkaXVzICsgdGhpcy5sZW5ndGgvMjtcbn07XG5cbi8qKlxuICogQG1ldGhvZCB1cGRhdGVBcmVhXG4gKi9cbkNhcHN1bGUucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYXJlYSA9IE1hdGguUEkgKiB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICsgdGhpcy5yYWRpdXMgKiAyICogdGhpcy5sZW5ndGg7XG59O1xuXG52YXIgciA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXQgICAgICBUaGUgcmVzdWx0aW5nIEFBQkIuXG4gKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbkNhcHN1bGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciByYWRpdXMgPSB0aGlzLnJhZGl1cztcblxuICAgIC8vIENvbXB1dGUgY2VudGVyIHBvc2l0aW9uIG9mIG9uZSBvZiB0aGUgdGhlIGNpcmNsZXMsIHdvcmxkIG9yaWVudGVkLCBidXQgd2l0aCBsb2NhbCBvZmZzZXRcbiAgICB2ZWMyLnNldChyLHRoaXMubGVuZ3RoIC8gMiwwKTtcbiAgICBpZihhbmdsZSAhPT0gMCl7XG4gICAgICAgIHZlYzIucm90YXRlKHIscixhbmdsZSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IGJvdW5kc1xuICAgIHZlYzIuc2V0KG91dC51cHBlckJvdW5kLCAgTWF0aC5tYXgoclswXStyYWRpdXMsIC1yWzBdK3JhZGl1cyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChyWzFdK3JhZGl1cywgLXJbMV0rcmFkaXVzKSk7XG4gICAgdmVjMi5zZXQob3V0Lmxvd2VyQm91bmQsICBNYXRoLm1pbihyWzBdLXJhZGl1cywgLXJbMF0tcmFkaXVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKHJbMV0tcmFkaXVzLCAtclsxXS1yYWRpdXMpKTtcblxuICAgIC8vIEFkZCBvZmZzZXRcbiAgICB2ZWMyLmFkZChvdXQubG93ZXJCb3VuZCwgb3V0Lmxvd2VyQm91bmQsIHBvc2l0aW9uKTtcbiAgICB2ZWMyLmFkZChvdXQudXBwZXJCb3VuZCwgb3V0LnVwcGVyQm91bmQsIHBvc2l0aW9uKTtcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL1NoYXBlXCI6NDV9XSwzODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJylcbiwgICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZTtcblxuLyoqXG4gKiBDaXJjbGUgc2hhcGUgY2xhc3MuXG4gKiBAY2xhc3MgQ2lyY2xlXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gW3JhZGl1cz0xXSBUaGUgcmFkaXVzIG9mIHRoaXMgY2lyY2xlXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgcmFkaXVzID0gMTtcbiAqICAgICB2YXIgY2lyY2xlU2hhcGUgPSBuZXcgQ2lyY2xlKHJhZGl1cyk7XG4gKiAgICAgYm9keS5hZGRTaGFwZShjaXJjbGVTaGFwZSk7XG4gKi9cbmZ1bmN0aW9uIENpcmNsZShyYWRpdXMpe1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlLlxuICAgICAqIEBwcm9wZXJ0eSByYWRpdXNcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmFkaXVzID0gcmFkaXVzIHx8IDE7XG5cbiAgICBTaGFwZS5jYWxsKHRoaXMsU2hhcGUuQ0lSQ0xFKTtcbn1cbkNpcmNsZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbkNpcmNsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaXJjbGU7XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQ2lyY2xlLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgdmFyIHIgPSB0aGlzLnJhZGl1cztcbiAgICByZXR1cm4gbWFzcyAqIHIgKiByIC8gMjtcbn07XG5cbi8qKlxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5DaXJjbGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gdGhpcy5yYWRpdXM7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgdXBkYXRlQXJlYVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5DaXJjbGUucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYXJlYSA9IE1hdGguUEkgKiB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuQ2lyY2xlLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKG91dCwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICB2YXIgciA9IHRoaXMucmFkaXVzO1xuICAgIHZlYzIuc2V0KG91dC51cHBlckJvdW5kLCAgciwgIHIpO1xuICAgIHZlYzIuc2V0KG91dC5sb3dlckJvdW5kLCAtciwgLXIpO1xuICAgIGlmKHBvc2l0aW9uKXtcbiAgICAgICAgdmVjMi5hZGQob3V0Lmxvd2VyQm91bmQsIG91dC5sb3dlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgICAgIHZlYzIuYWRkKG91dC51cHBlckJvdW5kLCBvdXQudXBwZXJCb3VuZCwgcG9zaXRpb24pO1xuICAgIH1cbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL1NoYXBlXCI6NDV9XSwzOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBwb2x5ayA9IF9kZXJlcV8oJy4uL21hdGgvcG9seWsnKVxuLCAgIGRlY29tcCA9IF9kZXJlcV8oJ3BvbHktZGVjb21wJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udmV4O1xuXG4vKipcbiAqIENvbnZleCBzaGFwZSBjbGFzcy5cbiAqIEBjbGFzcyBDb252ZXhcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBwYXJhbSB7QXJyYXl9IHZlcnRpY2VzIEFuIGFycmF5IG9mIHZlcnRpY2VzIHRoYXQgc3BhbiB0aGlzIHNoYXBlLiBWZXJ0aWNlcyBhcmUgZ2l2ZW4gaW4gY291bnRlci1jbG9ja3dpc2UgKENDVykgZGlyZWN0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gW2F4ZXNdIEFuIGFycmF5IG9mIHVuaXQgbGVuZ3RoIHZlY3RvcnMsIHJlcHJlc2VudGluZyB0aGUgc3ltbWV0cnkgYXhlcyBpbiB0aGUgY29udmV4LlxuICogQGV4YW1wbGVcbiAqICAgICAvLyBDcmVhdGUgYSBib3hcbiAqICAgICB2YXIgdmVydGljZXMgPSBbWy0xLC0xXSwgWzEsLTFdLCBbMSwxXSwgWy0xLDFdXTtcbiAqICAgICB2YXIgY29udmV4U2hhcGUgPSBuZXcgQ29udmV4KHZlcnRpY2VzKTtcbiAqICAgICBib2R5LmFkZFNoYXBlKGNvbnZleFNoYXBlKTtcbiAqL1xuZnVuY3Rpb24gQ29udmV4KHZlcnRpY2VzLCBheGVzKXtcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2VzIGRlZmluZWQgaW4gdGhlIGxvY2FsIGZyYW1lLlxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0aWNlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRpY2VzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBBeGVzIGRlZmluZWQgaW4gdGhlIGxvY2FsIGZyYW1lLlxuICAgICAqIEBwcm9wZXJ0eSBheGVzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYXhlcyA9IFtdO1xuXG4gICAgLy8gQ29weSB0aGUgdmVydHNcbiAgICBmb3IodmFyIGk9MDsgaTx2ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB2ID0gdmVjMi5jcmVhdGUoKTtcbiAgICAgICAgdmVjMi5jb3B5KHYsdmVydGljZXNbaV0pO1xuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2godik7XG4gICAgfVxuXG4gICAgaWYoYXhlcyl7XG4gICAgICAgIC8vIENvcHkgdGhlIGF4ZXNcbiAgICAgICAgZm9yKHZhciBpPTA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBheGlzID0gdmVjMi5jcmVhdGUoKTtcbiAgICAgICAgICAgIHZlYzIuY29weShheGlzLCBheGVzW2ldKTtcbiAgICAgICAgICAgIHRoaXMuYXhlcy5wdXNoKGF4aXMpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29uc3RydWN0IGF4ZXMgZnJvbSB0aGUgdmVydGV4IGRhdGFcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgd29ybGQgZWRnZVxuICAgICAgICAgICAgdmFyIHdvcmxkUG9pbnQwID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICB2YXIgd29ybGRQb2ludDEgPSB2ZXJ0aWNlc1soaSsxKSAlIHZlcnRpY2VzLmxlbmd0aF07XG5cbiAgICAgICAgICAgIHZhciBub3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgdmVjMi5zdWIobm9ybWFsLCB3b3JsZFBvaW50MSwgd29ybGRQb2ludDApO1xuXG4gICAgICAgICAgICAvLyBHZXQgbm9ybWFsIC0ganVzdCByb3RhdGUgOTAgZGVncmVlcyBzaW5jZSB2ZXJ0aWNlcyBhcmUgZ2l2ZW4gaW4gQ0NXXG4gICAgICAgICAgICB2ZWMyLnJvdGF0ZTkwY3cobm9ybWFsLCBub3JtYWwpO1xuICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLCBub3JtYWwpO1xuXG4gICAgICAgICAgICB0aGlzLmF4ZXMucHVzaChub3JtYWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGNlbnRlciBvZiBtYXNzIG9mIHRoZSBDb252ZXhcbiAgICAgKiBAcHJvcGVydHkgY2VudGVyT2ZNYXNzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY2VudGVyT2ZNYXNzID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbiAgICAvKipcbiAgICAgKiBUcmlhbmd1bGF0ZWQgdmVyc2lvbiBvZiB0aGlzIGNvbnZleC4gVGhlIHN0cnVjdHVyZSBpcyBBcnJheSBvZiAzLUFycmF5cywgYW5kIGVhY2ggc3ViYXJyYXkgY29udGFpbnMgMyBpbnRlZ2VycywgcmVmZXJlbmNpbmcgdGhlIHZlcnRpY2VzLlxuICAgICAqIEBwcm9wZXJ0eSB0cmlhbmdsZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy50cmlhbmdsZXMgPSBbXTtcblxuICAgIGlmKHRoaXMudmVydGljZXMubGVuZ3RoKXtcbiAgICAgICAgdGhpcy51cGRhdGVUcmlhbmdsZXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVDZW50ZXJPZk1hc3MoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYm91bmRpbmcgcmFkaXVzIG9mIHRoZSBjb252ZXhcbiAgICAgKiBAcHJvcGVydHkgYm91bmRpbmdSYWRpdXNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSAwO1xuXG4gICAgU2hhcGUuY2FsbCh0aGlzLCBTaGFwZS5DT05WRVgpO1xuXG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1JhZGl1cygpO1xuICAgIHRoaXMudXBkYXRlQXJlYSgpO1xuICAgIGlmKHRoaXMuYXJlYSA8IDApe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb252ZXggdmVydGljZXMgbXVzdCBiZSBnaXZlbiBpbiBjb250ZXItY2xvY2t3aXNlIHdpbmRpbmcuXCIpO1xuICAgIH1cbn1cbkNvbnZleC5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbkNvbnZleC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb252ZXg7XG5cbnZhciB0bXBWZWMxID0gdmVjMi5jcmVhdGUoKTtcbnZhciB0bXBWZWMyID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBQcm9qZWN0IGEgQ29udmV4IG9udG8gYSB3b3JsZC1vcmllbnRlZCBheGlzXG4gKiBAbWV0aG9kIHByb2plY3RPbnRvQXhpc1xuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IG9mZnNldFxuICogQHBhcmFtICB7QXJyYXl9IGxvY2FsQXhpc1xuICogQHBhcmFtICB7QXJyYXl9IHJlc3VsdFxuICovXG5Db252ZXgucHJvdG90eXBlLnByb2plY3RPbnRvTG9jYWxBeGlzID0gZnVuY3Rpb24obG9jYWxBeGlzLCByZXN1bHQpe1xuICAgIHZhciBtYXg9bnVsbCxcbiAgICAgICAgbWluPW51bGwsXG4gICAgICAgIHYsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBsb2NhbEF4aXMgPSB0bXBWZWMxO1xuXG4gICAgLy8gR2V0IHByb2plY3RlZCBwb3NpdGlvbiBvZiBhbGwgdmVydGljZXNcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdiA9IHRoaXMudmVydGljZXNbaV07XG4gICAgICAgIHZhbHVlID0gdmVjMi5kb3QodiwgbG9jYWxBeGlzKTtcbiAgICAgICAgaWYobWF4ID09PSBudWxsIHx8IHZhbHVlID4gbWF4KXtcbiAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKG1pbiA9PT0gbnVsbCB8fCB2YWx1ZSA8IG1pbil7XG4gICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKG1pbiA+IG1heCl7XG4gICAgICAgIHZhciB0ID0gbWluO1xuICAgICAgICBtaW4gPSBtYXg7XG4gICAgICAgIG1heCA9IHQ7XG4gICAgfVxuXG4gICAgdmVjMi5zZXQocmVzdWx0LCBtaW4sIG1heCk7XG59O1xuXG5Db252ZXgucHJvdG90eXBlLnByb2plY3RPbnRvV29ybGRBeGlzID0gZnVuY3Rpb24obG9jYWxBeGlzLCBzaGFwZU9mZnNldCwgc2hhcGVBbmdsZSwgcmVzdWx0KXtcbiAgICB2YXIgd29ybGRBeGlzID0gdG1wVmVjMjtcblxuICAgIHRoaXMucHJvamVjdE9udG9Mb2NhbEF4aXMobG9jYWxBeGlzLCByZXN1bHQpO1xuXG4gICAgLy8gUHJvamVjdCB0aGUgcG9zaXRpb24gb2YgdGhlIGJvZHkgb250byB0aGUgYXhpcyAtIG5lZWQgdG8gYWRkIHRoaXMgdG8gdGhlIHJlc3VsdFxuICAgIGlmKHNoYXBlQW5nbGUgIT09IDApe1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZEF4aXMsIGxvY2FsQXhpcywgc2hhcGVBbmdsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd29ybGRBeGlzID0gbG9jYWxBeGlzO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gdmVjMi5kb3Qoc2hhcGVPZmZzZXQsIHdvcmxkQXhpcyk7XG5cbiAgICB2ZWMyLnNldChyZXN1bHQsIHJlc3VsdFswXSArIG9mZnNldCwgcmVzdWx0WzFdICsgb2Zmc2V0KTtcbn07XG5cblxuLyoqXG4gKiBVcGRhdGUgdGhlIC50cmlhbmdsZXMgcHJvcGVydHlcbiAqIEBtZXRob2QgdXBkYXRlVHJpYW5nbGVzXG4gKi9cbkNvbnZleC5wcm90b3R5cGUudXBkYXRlVHJpYW5nbGVzID0gZnVuY3Rpb24oKXtcblxuICAgIHRoaXMudHJpYW5nbGVzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBSZXdyaXRlIG9uIHBvbHlrIG5vdGF0aW9uLCBhcnJheSBvZiBudW1iZXJzXG4gICAgdmFyIHBvbHlrVmVydHMgPSBbXTtcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZlcnRpY2VzW2ldO1xuICAgICAgICBwb2x5a1ZlcnRzLnB1c2godlswXSx2WzFdKTtcbiAgICB9XG5cbiAgICAvLyBUcmlhbmd1bGF0ZVxuICAgIHZhciB0cmlhbmdsZXMgPSBwb2x5ay5Ucmlhbmd1bGF0ZShwb2x5a1ZlcnRzKTtcblxuICAgIC8vIExvb3Agb3ZlciBhbGwgdHJpYW5nbGVzLCBhZGQgdGhlaXIgaW5lcnRpYSBjb250cmlidXRpb25zIHRvIElcbiAgICBmb3IodmFyIGk9MDsgaTx0cmlhbmdsZXMubGVuZ3RoOyBpKz0zKXtcbiAgICAgICAgdmFyIGlkMSA9IHRyaWFuZ2xlc1tpXSxcbiAgICAgICAgICAgIGlkMiA9IHRyaWFuZ2xlc1tpKzFdLFxuICAgICAgICAgICAgaWQzID0gdHJpYW5nbGVzW2krMl07XG5cbiAgICAgICAgLy8gQWRkIHRvIHRyaWFuZ2xlc1xuICAgICAgICB0aGlzLnRyaWFuZ2xlcy5wdXNoKFtpZDEsaWQyLGlkM10pO1xuICAgIH1cbn07XG5cbnZhciB1cGRhdGVDZW50ZXJPZk1hc3NfY2VudHJvaWQgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19jZW50cm9pZF90aW1lc19tYXNzID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfYSA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX2IgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19jID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfYWMgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19jYSA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX2NiID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfbiA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogVXBkYXRlIHRoZSAuY2VudGVyT2ZNYXNzIHByb3BlcnR5LlxuICogQG1ldGhvZCB1cGRhdGVDZW50ZXJPZk1hc3NcbiAqL1xuQ29udmV4LnByb3RvdHlwZS51cGRhdGVDZW50ZXJPZk1hc3MgPSBmdW5jdGlvbigpe1xuICAgIHZhciB0cmlhbmdsZXMgPSB0aGlzLnRyaWFuZ2xlcyxcbiAgICAgICAgdmVydHMgPSB0aGlzLnZlcnRpY2VzLFxuICAgICAgICBjbSA9IHRoaXMuY2VudGVyT2ZNYXNzLFxuICAgICAgICBjZW50cm9pZCA9IHVwZGF0ZUNlbnRlck9mTWFzc19jZW50cm9pZCxcbiAgICAgICAgbiA9IHVwZGF0ZUNlbnRlck9mTWFzc19uLFxuICAgICAgICBhID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2EsXG4gICAgICAgIGIgPSB1cGRhdGVDZW50ZXJPZk1hc3NfYixcbiAgICAgICAgYyA9IHVwZGF0ZUNlbnRlck9mTWFzc19jLFxuICAgICAgICBhYyA9IHVwZGF0ZUNlbnRlck9mTWFzc19hYyxcbiAgICAgICAgY2EgPSB1cGRhdGVDZW50ZXJPZk1hc3NfY2EsXG4gICAgICAgIGNiID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2NiLFxuICAgICAgICBjZW50cm9pZF90aW1lc19tYXNzID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2NlbnRyb2lkX3RpbWVzX21hc3M7XG5cbiAgICB2ZWMyLnNldChjbSwwLDApO1xuICAgIHZhciB0b3RhbEFyZWEgPSAwO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT10cmlhbmdsZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdCA9IHRyaWFuZ2xlc1tpXSxcbiAgICAgICAgICAgIGEgPSB2ZXJ0c1t0WzBdXSxcbiAgICAgICAgICAgIGIgPSB2ZXJ0c1t0WzFdXSxcbiAgICAgICAgICAgIGMgPSB2ZXJ0c1t0WzJdXTtcblxuICAgICAgICB2ZWMyLmNlbnRyb2lkKGNlbnRyb2lkLGEsYixjKTtcblxuICAgICAgICAvLyBHZXQgbWFzcyBmb3IgdGhlIHRyaWFuZ2xlIChkZW5zaXR5PTEgaW4gdGhpcyBjYXNlKVxuICAgICAgICAvLyBodHRwOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvODAxOTgvYXJlYS1vZi10cmlhbmdsZS12aWEtdmVjdG9yc1xuICAgICAgICB2YXIgbSA9IENvbnZleC50cmlhbmdsZUFyZWEoYSxiLGMpO1xuICAgICAgICB0b3RhbEFyZWEgKz0gbTtcblxuICAgICAgICAvLyBBZGQgdG8gY2VudGVyIG9mIG1hc3NcbiAgICAgICAgdmVjMi5zY2FsZShjZW50cm9pZF90aW1lc19tYXNzLCBjZW50cm9pZCwgbSk7XG4gICAgICAgIHZlYzIuYWRkKGNtLCBjbSwgY2VudHJvaWRfdGltZXNfbWFzcyk7XG4gICAgfVxuXG4gICAgdmVjMi5zY2FsZShjbSxjbSwxL3RvdGFsQXJlYSk7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIG1hc3MgbW9tZW50IG9mIGluZXJ0aWEgb2YgdGhlIENvbnZleC5cbiAqIEBtZXRob2QgY29tcHV0ZU1vbWVudE9mSW5lcnRpYVxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAc2VlIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvdG9waWMvMzQyODIyLW1vbWVudC1vZi1pbmVydGlhLW9mLWEtcG9seWdvbi0yZC9cbiAqL1xuQ29udmV4LnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgdmFyIGRlbm9tID0gMC4wLFxuICAgICAgICBudW1lciA9IDAuMCxcbiAgICAgICAgTiA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuICAgIGZvcih2YXIgaiA9IE4tMSwgaSA9IDA7IGkgPCBOOyBqID0gaSwgaSArKyl7XG4gICAgICAgIHZhciBwMCA9IHRoaXMudmVydGljZXNbal07XG4gICAgICAgIHZhciBwMSA9IHRoaXMudmVydGljZXNbaV07XG4gICAgICAgIHZhciBhID0gTWF0aC5hYnModmVjMi5jcm9zc0xlbmd0aChwMCxwMSkpO1xuICAgICAgICB2YXIgYiA9IHZlYzIuZG90KHAxLHAxKSArIHZlYzIuZG90KHAxLHAwKSArIHZlYzIuZG90KHAwLHAwKTtcbiAgICAgICAgZGVub20gKz0gYSAqIGI7XG4gICAgICAgIG51bWVyICs9IGE7XG4gICAgfVxuICAgIHJldHVybiAobWFzcyAvIDYuMCkgKiAoZGVub20gLyBudW1lcik7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIC5ib3VuZGluZ1JhZGl1cyBwcm9wZXJ0eVxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICovXG5Db252ZXgucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzLFxuICAgICAgICByMiA9IDA7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PXZlcnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGwyID0gdmVjMi5zcXVhcmVkTGVuZ3RoKHZlcnRzW2ldKTtcbiAgICAgICAgaWYobDIgPiByMil7XG4gICAgICAgICAgICByMiA9IGwyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IE1hdGguc3FydChyMik7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYXJlYSBvZiB0aGUgdHJpYW5nbGUgc3Bhbm5lZCBieSB0aGUgdGhyZWUgcG9pbnRzIGEsIGIsIGMuIFRoZSBhcmVhIGlzIHBvc2l0aXZlIGlmIHRoZSBwb2ludHMgYXJlIGdpdmVuIGluIGNvdW50ZXItY2xvY2t3aXNlIG9yZGVyLCBvdGhlcndpc2UgbmVnYXRpdmUuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHRyaWFuZ2xlQXJlYVxuICogQHBhcmFtIHtBcnJheX0gYVxuICogQHBhcmFtIHtBcnJheX0gYlxuICogQHBhcmFtIHtBcnJheX0gY1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Db252ZXgudHJpYW5nbGVBcmVhID0gZnVuY3Rpb24oYSxiLGMpe1xuICAgIHJldHVybiAoKChiWzBdIC0gYVswXSkqKGNbMV0gLSBhWzFdKSktKChjWzBdIC0gYVswXSkqKGJbMV0gLSBhWzFdKSkpICogMC41O1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIC5hcmVhXG4gKiBAbWV0aG9kIHVwZGF0ZUFyZWFcbiAqL1xuQ29udmV4LnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLnVwZGF0ZVRyaWFuZ2xlcygpO1xuICAgIHRoaXMuYXJlYSA9IDA7XG5cbiAgICB2YXIgdHJpYW5nbGVzID0gdGhpcy50cmlhbmdsZXMsXG4gICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcbiAgICBmb3IodmFyIGk9MDsgaSE9PXRyaWFuZ2xlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB0ID0gdHJpYW5nbGVzW2ldLFxuICAgICAgICAgICAgYSA9IHZlcnRzW3RbMF1dLFxuICAgICAgICAgICAgYiA9IHZlcnRzW3RbMV1dLFxuICAgICAgICAgICAgYyA9IHZlcnRzW3RbMl1dO1xuXG4gICAgICAgIC8vIEdldCBtYXNzIGZvciB0aGUgdHJpYW5nbGUgKGRlbnNpdHk9MSBpbiB0aGlzIGNhc2UpXG4gICAgICAgIHZhciBtID0gQ29udmV4LnRyaWFuZ2xlQXJlYShhLGIsYyk7XG4gICAgICAgIHRoaXMuYXJlYSArPSBtO1xuICAgIH1cbn07XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuQ29udmV4LnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKG91dCwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICBvdXQuc2V0RnJvbVBvaW50cyh0aGlzLnZlcnRpY2VzLCBwb3NpdGlvbiwgYW5nbGUsIDApO1xufTtcblxufSx7XCIuLi9tYXRoL3BvbHlrXCI6MzAsXCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4vU2hhcGVcIjo0NSxcInBvbHktZGVjb21wXCI6NX1dLDQwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKVxuLCAgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICAgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlaWdodGZpZWxkO1xuXG4vKipcbiAqIEhlaWdodGZpZWxkIHNoYXBlIGNsYXNzLiBIZWlnaHQgZGF0YSBpcyBnaXZlbiBhcyBhbiBhcnJheS4gVGhlc2UgZGF0YSBwb2ludHMgYXJlIHNwcmVhZCBvdXQgZXZlbmx5IHdpdGggYSBkaXN0YW5jZSBcImVsZW1lbnRXaWR0aFwiLlxuICogQGNsYXNzIEhlaWdodGZpZWxkXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIEFuIGFycmF5IG9mIFkgdmFsdWVzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgdGVycmFpbi5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluVmFsdWVdIE1pbmltdW0gdmFsdWUgb2YgdGhlIGRhdGEgcG9pbnRzIGluIHRoZSBkYXRhIGFycmF5LiBXaWxsIGJlIGNvbXB1dGVkIGF1dG9tYXRpY2FsbHkgaWYgbm90IGdpdmVuLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFZhbHVlXSBNYXhpbXVtIHZhbHVlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmVsZW1lbnRXaWR0aD0wLjFdIFdvcmxkIHNwYWNpbmcgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBkaXJlY3Rpb24uXG4gKiBAdG9kbyBTaG91bGQgYmUgcG9zc2libGUgdG8gdXNlIGFsb25nIGFsbCBheGVzLCBub3QganVzdCB5XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAvLyBHZW5lcmF0ZSBzb21lIGhlaWdodCBkYXRhICh5LXZhbHVlcykuXG4gKiAgICAgdmFyIGRhdGEgPSBbXTtcbiAqICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTAwMDsgaSsrKXtcbiAqICAgICAgICAgdmFyIHkgPSAwLjUgKiBNYXRoLmNvcygwLjIgKiBpKTtcbiAqICAgICAgICAgZGF0YS5wdXNoKHkpO1xuICogICAgIH1cbiAqXG4gKiAgICAgLy8gQ3JlYXRlIHRoZSBoZWlnaHRmaWVsZCBzaGFwZVxuICogICAgIHZhciBoZWlnaHRmaWVsZFNoYXBlID0gbmV3IEhlaWdodGZpZWxkKGRhdGEsIHtcbiAqICAgICAgICAgZWxlbWVudFdpZHRoOiAxIC8vIERpc3RhbmNlIGJldHdlZW4gdGhlIGRhdGEgcG9pbnRzIGluIFggZGlyZWN0aW9uXG4gKiAgICAgfSk7XG4gKiAgICAgdmFyIGhlaWdodGZpZWxkQm9keSA9IG5ldyBCb2R5KCk7XG4gKiAgICAgaGVpZ2h0ZmllbGRCb2R5LmFkZFNoYXBlKGhlaWdodGZpZWxkU2hhcGUpO1xuICogICAgIHdvcmxkLmFkZEJvZHkoaGVpZ2h0ZmllbGRCb2R5KTtcbiAqL1xuZnVuY3Rpb24gSGVpZ2h0ZmllbGQoZGF0YSwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgbWF4VmFsdWUgOiBudWxsLFxuICAgICAgICBtaW5WYWx1ZSA6IG51bGwsXG4gICAgICAgIGVsZW1lbnRXaWR0aCA6IDAuMVxuICAgIH0pO1xuXG4gICAgaWYob3B0aW9ucy5taW5WYWx1ZSA9PT0gbnVsbCB8fCBvcHRpb25zLm1heFZhbHVlID09PSBudWxsKXtcbiAgICAgICAgb3B0aW9ucy5tYXhWYWx1ZSA9IGRhdGFbMF07XG4gICAgICAgIG9wdGlvbnMubWluVmFsdWUgPSBkYXRhWzBdO1xuICAgICAgICBmb3IodmFyIGk9MDsgaSAhPT0gZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgdiA9IGRhdGFbaV07XG4gICAgICAgICAgICBpZih2ID4gb3B0aW9ucy5tYXhWYWx1ZSl7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tYXhWYWx1ZSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih2IDwgb3B0aW9ucy5taW5WYWx1ZSl7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5taW5WYWx1ZSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBudW1iZXJzLCBvciBoZWlnaHQgdmFsdWVzLCB0aGF0IGFyZSBzcHJlYWQgb3V0IGFsb25nIHRoZSB4IGF4aXMuXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gZGF0YVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICAvKipcbiAgICAgKiBNYXggdmFsdWUgb2YgdGhlIGRhdGFcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4VmFsdWVcbiAgICAgKi9cbiAgICB0aGlzLm1heFZhbHVlID0gb3B0aW9ucy5tYXhWYWx1ZTtcblxuICAgIC8qKlxuICAgICAqIE1heCB2YWx1ZSBvZiB0aGUgZGF0YVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5WYWx1ZVxuICAgICAqL1xuICAgIHRoaXMubWluVmFsdWUgPSBvcHRpb25zLm1pblZhbHVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIGVhY2ggZWxlbWVudFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbGVtZW50V2lkdGhcbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnRXaWR0aCA9IG9wdGlvbnMuZWxlbWVudFdpZHRoO1xuXG4gICAgU2hhcGUuY2FsbCh0aGlzLFNoYXBlLkhFSUdIVEZJRUxEKTtcbn1cbkhlaWdodGZpZWxkLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGVpZ2h0ZmllbGQ7XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbkhlaWdodGZpZWxkLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICAgIGFyZWEgPSAwO1xuICAgIGZvcih2YXIgaT0wOyBpPGRhdGEubGVuZ3RoLTE7IGkrKyl7XG4gICAgICAgIGFyZWEgKz0gKGRhdGFbaV0rZGF0YVtpKzFdKSAvIDIgKiB0aGlzLmVsZW1lbnRXaWR0aDtcbiAgICB9XG4gICAgdGhpcy5hcmVhID0gYXJlYTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXQgICAgICBUaGUgcmVzdWx0aW5nIEFBQkIuXG4gKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKG91dCwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICAvLyBVc2UgdGhlIG1heCBkYXRhIHJlY3RhbmdsZVxuICAgIG91dC51cHBlckJvdW5kWzBdID0gdGhpcy5lbGVtZW50V2lkdGggKiB0aGlzLmRhdGEubGVuZ3RoICsgcG9zaXRpb25bMF07XG4gICAgb3V0LnVwcGVyQm91bmRbMV0gPSB0aGlzLm1heFZhbHVlICsgcG9zaXRpb25bMV07XG4gICAgb3V0Lmxvd2VyQm91bmRbMF0gPSBwb3NpdGlvblswXTtcbiAgICBvdXQubG93ZXJCb3VuZFsxXSA9IC1OdW1iZXIuTUFYX1ZBTFVFOyAvLyBJbmZpbml0eVxufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4uL3V0aWxzL1V0aWxzXCI6NTAsXCIuL1NoYXBlXCI6NDV9XSw0MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZTtcblxuLyoqXG4gKiBMaW5lIHNoYXBlIGNsYXNzLiBUaGUgbGluZSBzaGFwZSBpcyBhbG9uZyB0aGUgeCBkaXJlY3Rpb24sIGFuZCBzdHJldGNoZXMgZnJvbSBbLWxlbmd0aC8yLCAwXSB0byBbbGVuZ3RoLzIsMF0uXG4gKiBAY2xhc3MgTGluZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtsZW5ndGg9MV0gVGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgbGluZVxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBMaW5lKGxlbmd0aCl7XG5cbiAgICAvKipcbiAgICAgKiBMZW5ndGggb2YgdGhpcyBsaW5lXG4gICAgICogQHByb3BlcnR5IGxlbmd0aFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGggfHwgMTtcblxuICAgIFNoYXBlLmNhbGwodGhpcyxTaGFwZS5MSU5FKTtcbn1cbkxpbmUucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5MaW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmU7XG5cbkxpbmUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICByZXR1cm4gbWFzcyAqIE1hdGgucG93KHRoaXMubGVuZ3RoLDIpIC8gMTI7XG59O1xuXG5MaW5lLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IHRoaXMubGVuZ3RoLzI7XG59O1xuXG52YXIgcG9pbnRzID0gW3ZlYzIuY3JlYXRlKCksdmVjMi5jcmVhdGUoKV07XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXQgICAgICBUaGUgcmVzdWx0aW5nIEFBQkIuXG4gKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbkxpbmUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciBsMiA9IHRoaXMubGVuZ3RoIC8gMjtcbiAgICB2ZWMyLnNldChwb2ludHNbMF0sIC1sMiwgIDApO1xuICAgIHZlYzIuc2V0KHBvaW50c1sxXSwgIGwyLCAgMCk7XG4gICAgb3V0LnNldEZyb21Qb2ludHMocG9pbnRzLHBvc2l0aW9uLGFuZ2xlLDApO1xufTtcblxuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9TaGFwZVwiOjQ1fV0sNDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnRpY2xlO1xuXG4vKipcbiAqIFBhcnRpY2xlIHNoYXBlIGNsYXNzLlxuICogQGNsYXNzIFBhcnRpY2xlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFNoYXBlXG4gKi9cbmZ1bmN0aW9uIFBhcnRpY2xlKCl7XG4gICAgU2hhcGUuY2FsbCh0aGlzLFNoYXBlLlBBUlRJQ0xFKTtcbn1cblBhcnRpY2xlLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuUGFydGljbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFydGljbGU7XG5cblBhcnRpY2xlLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgcmV0dXJuIDA7IC8vIENhbid0IHJvdGF0ZSBhIHBhcnRpY2xlXG59O1xuXG5QYXJ0aWNsZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSAwO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dFxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgdmVjMi5jb3B5KG91dC5sb3dlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgdmVjMi5jb3B5KG91dC51cHBlckJvdW5kLCBwb3NpdGlvbik7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9TaGFwZVwiOjQ1fV0sNDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNoYXBlID0gIF9kZXJlcV8oJy4vU2hhcGUnKVxuLCAgICB2ZWMyID0gIF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbGFuZTtcblxuLyoqXG4gKiBQbGFuZSBzaGFwZSBjbGFzcy4gVGhlIHBsYW5lIGlzIGZhY2luZyBpbiB0aGUgWSBkaXJlY3Rpb24uXG4gKiBAY2xhc3MgUGxhbmVcbiAqIEBleHRlbmRzIFNoYXBlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUGxhbmUoKXtcbiAgICBTaGFwZS5jYWxsKHRoaXMsU2hhcGUuUExBTkUpO1xufVxuUGxhbmUucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5QbGFuZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbGFuZTtcblxuLyoqXG4gKiBDb21wdXRlIG1vbWVudCBvZiBpbmVydGlhXG4gKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcbiAqL1xuUGxhbmUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICByZXR1cm4gMDsgLy8gUGxhbmUgaXMgaW5maW5pdGUuIFRoZSBpbmVydGlhIHNob3VsZCB0aGVyZWZvcmUgYmUgaW5maW50eSBidXQgYnkgY29udmVudGlvbiB3ZSBzZXQgMCBoZXJlXG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgYm91bmRpbmcgcmFkaXVzXG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXG4gKi9cblBsYW5lLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cblBsYW5lLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKG91dCwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICB2YXIgYSA9IDAsXG4gICAgICAgIHNldCA9IHZlYzIuc2V0O1xuICAgIGlmKHR5cGVvZihhbmdsZSkgPT09IFwibnVtYmVyXCIpe1xuICAgICAgICBhID0gYW5nbGUgJSAoMipNYXRoLlBJKTtcbiAgICB9XG5cbiAgICBpZihhID09PSAwKXtcbiAgICAgICAgLy8geSBnb2VzIGZyb20gLWluZiB0byAwXG4gICAgICAgIHNldChvdXQubG93ZXJCb3VuZCwgLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgICAgc2V0KG91dC51cHBlckJvdW5kLCAgTnVtYmVyLk1BWF9WQUxVRSwgIDApO1xuICAgIH0gZWxzZSBpZihhID09PSBNYXRoLlBJIC8gMil7XG4gICAgICAgIC8vIHggZ29lcyBmcm9tIDAgdG8gaW5mXG4gICAgICAgIHNldChvdXQubG93ZXJCb3VuZCwgMCwgLU51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICBzZXQob3V0LnVwcGVyQm91bmQsICAgICAgTnVtYmVyLk1BWF9WQUxVRSwgIE51bWJlci5NQVhfVkFMVUUpO1xuICAgIH0gZWxzZSBpZihhID09PSBNYXRoLlBJKXtcbiAgICAgICAgLy8geSBnb2VzIGZyb20gMCB0byBpbmZcbiAgICAgICAgc2V0KG91dC5sb3dlckJvdW5kLCAtTnVtYmVyLk1BWF9WQUxVRSwgMCk7XG4gICAgICAgIHNldChvdXQudXBwZXJCb3VuZCwgIE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUpO1xuICAgIH0gZWxzZSBpZihhID09PSAzKk1hdGguUEkvMil7XG4gICAgICAgIC8vIHggZ29lcyBmcm9tIC1pbmYgdG8gMFxuICAgICAgICBzZXQob3V0Lmxvd2VyQm91bmQsIC1OdW1iZXIuTUFYX1ZBTFVFLCAgICAgLU51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICBzZXQob3V0LnVwcGVyQm91bmQsICAwLCAgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2V0IG1heCBib3VuZHNcbiAgICAgICAgc2V0KG91dC5sb3dlckJvdW5kLCAtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICBzZXQob3V0LnVwcGVyQm91bmQsICBOdW1iZXIuTUFYX1ZBTFVFLCAgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgfVxuXG4gICAgdmVjMi5hZGQob3V0Lmxvd2VyQm91bmQsIG91dC5sb3dlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgdmVjMi5hZGQob3V0LnVwcGVyQm91bmQsIG91dC51cHBlckJvdW5kLCBwb3NpdGlvbik7XG59O1xuXG5QbGFuZS5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5hcmVhID0gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4uL3V0aWxzL1V0aWxzXCI6NTAsXCIuL1NoYXBlXCI6NDV9XSw0NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJylcbiwgICBDb252ZXggPSBfZGVyZXFfKCcuL0NvbnZleCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY3RhbmdsZTtcblxuLyoqXG4gKiBSZWN0YW5nbGUgc2hhcGUgY2xhc3MuXG4gKiBAY2xhc3MgUmVjdGFuZ2xlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGg9MV0gV2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0PTFdIEhlaWdodFxuICogQGV4dGVuZHMgQ29udmV4XG4gKi9cbmZ1bmN0aW9uIFJlY3RhbmdsZSh3aWR0aCwgaGVpZ2h0KXtcblxuICAgIC8qKlxuICAgICAqIFRvdGFsIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcHJvcGVydHkgd2lkdGhcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAxO1xuXG4gICAgLyoqXG4gICAgICogVG90YWwgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcHJvcGVydHkgaGVpZ2h0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAxO1xuXG4gICAgdmFyIHZlcnRzID0gWyAgIHZlYzIuZnJvbVZhbHVlcygtd2lkdGgvMiwgLWhlaWdodC8yKSxcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5mcm9tVmFsdWVzKCB3aWR0aC8yLCAtaGVpZ2h0LzIpLFxuICAgICAgICAgICAgICAgICAgICB2ZWMyLmZyb21WYWx1ZXMoIHdpZHRoLzIsICBoZWlnaHQvMiksXG4gICAgICAgICAgICAgICAgICAgIHZlYzIuZnJvbVZhbHVlcygtd2lkdGgvMiwgIGhlaWdodC8yKV07XG4gICAgdmFyIGF4ZXMgPSBbdmVjMi5mcm9tVmFsdWVzKDEsIDApLCB2ZWMyLmZyb21WYWx1ZXMoMCwgMSldO1xuXG4gICAgQ29udmV4LmNhbGwodGhpcywgdmVydHMsIGF4ZXMpO1xuXG4gICAgdGhpcy50eXBlID0gU2hhcGUuUkVDVEFOR0xFO1xufVxuUmVjdGFuZ2xlLnByb3RvdHlwZSA9IG5ldyBDb252ZXgoW10pO1xuUmVjdGFuZ2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlY3RhbmdsZTtcblxuLyoqXG4gKiBDb21wdXRlIG1vbWVudCBvZiBpbmVydGlhXG4gKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5SZWN0YW5nbGUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICB2YXIgdyA9IHRoaXMud2lkdGgsXG4gICAgICAgIGggPSB0aGlzLmhlaWdodDtcbiAgICByZXR1cm4gbWFzcyAqIChoKmggKyB3KncpIC8gMTI7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgYm91bmRpbmcgcmFkaXVzXG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXG4gKi9cblJlY3RhbmdsZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciB3ID0gdGhpcy53aWR0aCxcbiAgICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSBNYXRoLnNxcnQodyp3ICsgaCpoKSAvIDI7XG59O1xuXG52YXIgY29ybmVyMSA9IHZlYzIuY3JlYXRlKCksXG4gICAgY29ybmVyMiA9IHZlYzIuY3JlYXRlKCksXG4gICAgY29ybmVyMyA9IHZlYzIuY3JlYXRlKCksXG4gICAgY29ybmVyNCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXQgICAgICBUaGUgcmVzdWx0aW5nIEFBQkIuXG4gKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cblJlY3RhbmdsZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgb3V0LnNldEZyb21Qb2ludHModGhpcy52ZXJ0aWNlcyxwb3NpdGlvbixhbmdsZSwwKTtcbn07XG5cblJlY3RhbmdsZS5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5hcmVhID0gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xufTtcblxuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9Db252ZXhcIjozOSxcIi4vU2hhcGVcIjo0NX1dLDQ1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gU2hhcGU7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3Igc2hhcGVzLlxuICogQGNsYXNzIFNoYXBlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIFNoYXBlKHR5cGUpe1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIHNoYXBlLiBPbmUgb2Y6XG4gICAgICpcbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL0NJUkNMRTpwcm9wZXJ0eVwifX1TaGFwZS5DSVJDTEV7ey9jcm9zc0xpbmt9fVxuICAgICAqICoge3sjY3Jvc3NMaW5rIFwiU2hhcGUvUEFSVElDTEU6cHJvcGVydHlcIn19U2hhcGUuUEFSVElDTEV7ey9jcm9zc0xpbmt9fVxuICAgICAqICoge3sjY3Jvc3NMaW5rIFwiU2hhcGUvUExBTkU6cHJvcGVydHlcIn19U2hhcGUuUExBTkV7ey9jcm9zc0xpbmt9fVxuICAgICAqICoge3sjY3Jvc3NMaW5rIFwiU2hhcGUvQ09OVkVYOnByb3BlcnR5XCJ9fVNoYXBlLkNPTlZFWHt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9MSU5FOnByb3BlcnR5XCJ9fVNoYXBlLkxJTkV7ey9jcm9zc0xpbmt9fVxuICAgICAqICoge3sjY3Jvc3NMaW5rIFwiU2hhcGUvUkVDVEFOR0xFOnByb3BlcnR5XCJ9fVNoYXBlLlJFQ1RBTkdMRXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9DQVBTVUxFOnByb3BlcnR5XCJ9fVNoYXBlLkNBUFNVTEV7ey9jcm9zc0xpbmt9fVxuICAgICAqICoge3sjY3Jvc3NMaW5rIFwiU2hhcGUvSEVJR0hURklFTEQ6cHJvcGVydHlcIn19U2hhcGUuSEVJR0hURklFTER7ey9jcm9zc0xpbmt9fVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHR5cGVcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgLyoqXG4gICAgICogU2hhcGUgb2JqZWN0IGlkZW50aWZpZXIuXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcHJvcGVydHkgaWRcbiAgICAgKi9cbiAgICB0aGlzLmlkID0gU2hhcGUuaWRDb3VudGVyKys7XG5cbiAgICAvKipcbiAgICAgKiBCb3VuZGluZyBjaXJjbGUgcmFkaXVzIG9mIHRoaXMgc2hhcGVcbiAgICAgKiBAcHJvcGVydHkgYm91bmRpbmdSYWRpdXNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQ29sbGlzaW9uIGdyb3VwIHRoYXQgdGhpcyBzaGFwZSBiZWxvbmdzIHRvIChiaXQgbWFzaykuIFNlZSA8YSBocmVmPVwiaHR0cDovL3d3dy5hdXJlbGllbnJpYm9uLmNvbS9ibG9nLzIwMTEvMDcvYm94MmQtdHV0b3JpYWwtY29sbGlzaW9uLWZpbHRlcmluZy9cIj50aGlzIHR1dG9yaWFsPC9hPi5cbiAgICAgKiBAcHJvcGVydHkgY29sbGlzaW9uR3JvdXBcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIFNldHVwIGJpdHMgZm9yIGVhY2ggYXZhaWxhYmxlIGdyb3VwXG4gICAgICogICAgIHZhciBQTEFZRVIgPSBNYXRoLnBvdygyLDApLFxuICAgICAqICAgICAgICAgRU5FTVkgPSAgTWF0aC5wb3coMiwxKSxcbiAgICAgKiAgICAgICAgIEdST1VORCA9IE1hdGgucG93KDIsMilcbiAgICAgKlxuICAgICAqICAgICAvLyBQdXQgc2hhcGVzIGludG8gdGhlaXIgZ3JvdXBzXG4gICAgICogICAgIHBsYXllcjFTaGFwZS5jb2xsaXNpb25Hcm91cCA9IFBMQVlFUjtcbiAgICAgKiAgICAgcGxheWVyMlNoYXBlLmNvbGxpc2lvbkdyb3VwID0gUExBWUVSO1xuICAgICAqICAgICBlbmVteVNoYXBlICAuY29sbGlzaW9uR3JvdXAgPSBFTkVNWTtcbiAgICAgKiAgICAgZ3JvdW5kU2hhcGUgLmNvbGxpc2lvbkdyb3VwID0gR1JPVU5EO1xuICAgICAqXG4gICAgICogICAgIC8vIEFzc2lnbiBncm91cHMgdGhhdCBlYWNoIHNoYXBlIGNvbGxpZGUgd2l0aC5cbiAgICAgKiAgICAgLy8gTm90ZSB0aGF0IHRoZSBwbGF5ZXJzIGNhbiBjb2xsaWRlIHdpdGggZ3JvdW5kIGFuZCBlbmVtaWVzLCBidXQgbm90IHdpdGggb3RoZXIgcGxheWVycy5cbiAgICAgKiAgICAgcGxheWVyMVNoYXBlLmNvbGxpc2lvbk1hc2sgPSBFTkVNWSB8IEdST1VORDtcbiAgICAgKiAgICAgcGxheWVyMlNoYXBlLmNvbGxpc2lvbk1hc2sgPSBFTkVNWSB8IEdST1VORDtcbiAgICAgKiAgICAgZW5lbXlTaGFwZSAgLmNvbGxpc2lvbk1hc2sgPSBQTEFZRVIgfCBHUk9VTkQ7XG4gICAgICogICAgIGdyb3VuZFNoYXBlIC5jb2xsaXNpb25NYXNrID0gUExBWUVSIHwgRU5FTVk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBIb3cgY29sbGlzaW9uIGNoZWNrIGlzIGRvbmVcbiAgICAgKiAgICAgaWYoc2hhcGVBLmNvbGxpc2lvbkdyb3VwICYgc2hhcGVCLmNvbGxpc2lvbk1hc2spIT0wICYmIChzaGFwZUIuY29sbGlzaW9uR3JvdXAgJiBzaGFwZUEuY29sbGlzaW9uTWFzaykhPTApe1xuICAgICAqICAgICAgICAgLy8gVGhlIHNoYXBlcyB3aWxsIGNvbGxpZGVcbiAgICAgKiAgICAgfVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uR3JvdXAgPSAxO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBwcm9kdWNlIGNvbnRhY3QgZm9yY2VzIHdoZW4gaW4gY29udGFjdCB3aXRoIG90aGVyIGJvZGllcy4gTm90ZSB0aGF0IGNvbnRhY3RzIHdpbGwgYmUgZ2VuZXJhdGVkLCBidXQgdGhleSB3aWxsIGJlIGRpc2FibGVkLiBUaGF0IG1lYW5zIHRoYXQgdGhpcyBzaGFwZSB3aWxsIG1vdmUgdGhyb3VnaCBvdGhlciBib2R5IHNoYXBlcywgYnV0IGl0IHdpbGwgc3RpbGwgdHJpZ2dlciBjb250YWN0IGV2ZW50cywgZXRjLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY29sbGlzaW9uUmVzcG9uc2VcbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpc2lvblJlc3BvbnNlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIENvbGxpc2lvbiBtYXNrIG9mIHRoaXMgc2hhcGUuIFNlZSAuY29sbGlzaW9uR3JvdXAuXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbk1hc2tcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uTWFzayA9ICAxO1xuICAgIGlmKHR5cGUpe1xuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWF0ZXJpYWwgdG8gdXNlIGluIGNvbGxpc2lvbnMgZm9yIHRoaXMgU2hhcGUuIElmIHRoaXMgaXMgc2V0IHRvIG51bGwsIHRoZSB3b3JsZCB3aWxsIHVzZSBkZWZhdWx0IG1hdGVyaWFsIHByb3BlcnRpZXMgaW5zdGVhZC5cbiAgICAgKiBAcHJvcGVydHkgbWF0ZXJpYWxcbiAgICAgKiBAdHlwZSB7TWF0ZXJpYWx9XG4gICAgICovXG4gICAgdGhpcy5tYXRlcmlhbCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBcmVhIG9mIHRoaXMgc2hhcGUuXG4gICAgICogQHByb3BlcnR5IGFyZWFcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYXJlYSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0aGlzIHNoYXBlIHRvIGJlIGEgc2Vuc29yLiBBIHNlbnNvciBkb2VzIG5vdCBnZW5lcmF0ZSBjb250YWN0cywgYnV0IGl0IHN0aWxsIHJlcG9ydHMgY29udGFjdCBldmVudHMuIFRoaXMgaXMgZ29vZCBpZiB5b3Ugd2FudCB0byBrbm93IGlmIGEgc2hhcGUgaXMgb3ZlcmxhcHBpbmcgYW5vdGhlciBzaGFwZSwgd2l0aG91dCB0aGVtIGdlbmVyYXRpbmcgY29udGFjdHMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzZW5zb3JcbiAgICAgKi9cbiAgICB0aGlzLnNlbnNvciA9IGZhbHNlO1xuXG4gICAgdGhpcy51cGRhdGVBcmVhKCk7XG59XG5cblNoYXBlLmlkQ291bnRlciA9IDA7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IENJUkNMRVxuICovXG5TaGFwZS5DSVJDTEUgPSAgICAgIDE7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IFBBUlRJQ0xFXG4gKi9cblNoYXBlLlBBUlRJQ0xFID0gICAgMjtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gUExBTkVcbiAqL1xuU2hhcGUuUExBTkUgPSAgICAgICA0O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBDT05WRVhcbiAqL1xuU2hhcGUuQ09OVkVYID0gICAgICA4O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBMSU5FXG4gKi9cblNoYXBlLkxJTkUgPSAgICAgICAgMTY7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IFJFQ1RBTkdMRVxuICovXG5TaGFwZS5SRUNUQU5HTEUgPSAgIDMyO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBDQVBTVUxFXG4gKi9cblNoYXBlLkNBUFNVTEUgPSAgICAgNjQ7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IEhFSUdIVEZJRUxEXG4gKi9cblNoYXBlLkhFSUdIVEZJRUxEID0gMTI4O1xuXG4vKipcbiAqIFNob3VsZCByZXR1cm4gdGhlIG1vbWVudCBvZiBpbmVydGlhIGFyb3VuZCB0aGUgWiBheGlzIG9mIHRoZSBib2R5IGdpdmVuIHRoZSB0b3RhbCBtYXNzLiBTZWUgPGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9tb21lbnRzX29mX2luZXJ0aWFcIj5XaWtpcGVkaWEncyBsaXN0IG9mIG1vbWVudHMgb2YgaW5lcnRpYTwvYT4uXG4gKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHJldHVybiB7TnVtYmVyfSBJZiB0aGUgaW5lcnRpYSBpcyBpbmZpbml0eSBvciBpZiB0aGUgb2JqZWN0IHNpbXBseSBpc24ndCBwb3NzaWJsZSB0byByb3RhdGUsIHJldHVybiAwLlxuICovXG5TaGFwZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNoYXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgU2hhcGUuLi5cIik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGNpcmNsZSByYWRpdXMgb2YgdGhpcyBzaGFwZS5cbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuU2hhcGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaGFwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBTaGFwZS4uLlwiKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSAuYXJlYSBwcm9wZXJ0eSBvZiB0aGUgc2hhcGUuXG4gKiBAbWV0aG9kIHVwZGF0ZUFyZWFcbiAqL1xuU2hhcGUucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIC8vIFRvIGJlIGltcGxlbWVudGVkIGluIGFsbCBzdWJjbGFzc2VzXG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIHdvcmxkIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggKEFBQkIpIG9mIHRoaXMgc2hhcGUuXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuU2hhcGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIC8vIFRvIGJlIGltcGxlbWVudGVkIGluIGVhY2ggc3ViY2xhc3Ncbn07XG5cbn0se31dLDQ2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBTb2x2ZXIgPSBfZGVyZXFfKCcuL1NvbHZlcicpXG4sICAgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpXG4sICAgRnJpY3Rpb25FcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gR1NTb2x2ZXI7XG5cbi8qKlxuICogSXRlcmF0aXZlIEdhdXNzLVNlaWRlbCBjb25zdHJhaW50IGVxdWF0aW9uIHNvbHZlci5cbiAqXG4gKiBAY2xhc3MgR1NTb2x2ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU29sdmVyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaXRlcmF0aW9ucz0xMF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50b2xlcmFuY2U9MF1cbiAqL1xuZnVuY3Rpb24gR1NTb2x2ZXIob3B0aW9ucyl7XG4gICAgU29sdmVyLmNhbGwodGhpcyxvcHRpb25zLFNvbHZlci5HUyk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gZG8gd2hlbiBzb2x2aW5nLiBNb3JlIGdpdmVzIGJldHRlciByZXN1bHRzLCBidXQgaXMgbW9yZSBleHBlbnNpdmUuXG4gICAgICogQHByb3BlcnR5IGl0ZXJhdGlvbnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaXRlcmF0aW9ucyA9IG9wdGlvbnMuaXRlcmF0aW9ucyB8fCAxMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlcnJvciB0b2xlcmFuY2UsIHBlciBjb25zdHJhaW50LiBJZiB0aGUgdG90YWwgZXJyb3IgaXMgYmVsb3cgdGhpcyBsaW1pdCwgdGhlIHNvbHZlciB3aWxsIHN0b3AgaXRlcmF0aW5nLiBTZXQgdG8gemVybyBmb3IgYXMgZ29vZCBzb2x1dGlvbiBhcyBwb3NzaWJsZSwgYnV0IHRvIHNvbWV0aGluZyBsYXJnZXIgdGhhbiB6ZXJvIHRvIG1ha2UgY29tcHV0YXRpb25zIGZhc3Rlci5cbiAgICAgKiBAcHJvcGVydHkgdG9sZXJhbmNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRvbGVyYW5jZSA9IG9wdGlvbnMudG9sZXJhbmNlIHx8IDFlLTEwO1xuXG4gICAgdGhpcy5hcnJheVN0ZXAgPSAzMDtcbiAgICB0aGlzLmxhbWJkYSA9IG5ldyBVdGlscy5BUlJBWV9UWVBFKHRoaXMuYXJyYXlTdGVwKTtcbiAgICB0aGlzLkJzID0gICAgIG5ldyBVdGlscy5BUlJBWV9UWVBFKHRoaXMuYXJyYXlTdGVwKTtcbiAgICB0aGlzLmludkNzID0gIG5ldyBVdGlscy5BUlJBWV9UWVBFKHRoaXMuYXJyYXlTdGVwKTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIHNldCBhbGwgcmlnaHQgaGFuZCBzaWRlIHRlcm1zIHRvIHplcm8gd2hlbiBzb2x2aW5nLiBDYW4gYmUgaGFuZHkgZm9yIGEgZmV3IGFwcGxpY2F0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkgdXNlWmVyb1JIU1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudXNlWmVyb1JIUyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHNvbHZlciBpdGVyYXRpb25zIHRoYXQgYXJlIGRvbmUgdG8gYXBwcm94aW1hdGUgbm9ybWFsIGZvcmNlcy4gV2hlbiB0aGVzZSBpdGVyYXRpb25zIGFyZSBkb25lLCBmcmljdGlvbiBmb3JjZSB3aWxsIGJlIGNvbXB1dGVkIGZyb20gdGhlIGNvbnRhY3Qgbm9ybWFsIGZvcmNlcy4gVGhlc2UgZnJpY3Rpb24gZm9yY2VzIHdpbGwgb3ZlcnJpZGUgYW55IG90aGVyIGZyaWN0aW9uIGZvcmNlcyBzZXQgZnJvbSB0aGUgV29ybGQgZm9yIGV4YW1wbGUuXG4gICAgICogVGhlIHNvbHZlciB3aWxsIHVzZSBsZXNzIGl0ZXJhdGlvbnMgaWYgdGhlIHNvbHV0aW9uIGlzIGJlbG93IHRoZSAudG9sZXJhbmNlLlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvbkl0ZXJhdGlvbnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25JdGVyYXRpb25zID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0aGF0IHdlcmUgbWFkZSBkdXJpbmcgdGhlIGxhc3Qgc29sdmUuIElmIC50b2xlcmFuY2UgaXMgemVybywgdGhpcyB2YWx1ZSB3aWxsIGFsd2F5cyBiZSBlcXVhbCB0byAuaXRlcmF0aW9ucywgYnV0IGlmIC50b2xlcmFuY2UgaXMgbGFyZ2VyIHRoYW4gemVybywgYW5kIHRoZSBzb2x2ZXIgY2FuIHF1aXQgZWFybHksIHRoZW4gdGhpcyBudW1iZXIgd2lsbCBiZSBzb21ld2hlcmUgYmV0d2VlbiAxIGFuZCAuaXRlcmF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gdXNlZEl0ZXJhdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLnVzZWRJdGVyYXRpb25zID0gMDtcbn1cbkdTU29sdmVyLnByb3RvdHlwZSA9IG5ldyBTb2x2ZXIoKTtcbkdTU29sdmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdTU29sdmVyO1xuXG5mdW5jdGlvbiBzZXRBcnJheVplcm8oYXJyYXkpe1xuICAgIHZhciBsID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIGFycmF5W2xdID0gKzAuMDtcbiAgICB9XG59XG5cbi8qKlxuICogU29sdmUgdGhlIHN5c3RlbSBvZiBlcXVhdGlvbnNcbiAqIEBtZXRob2Qgc29sdmVcbiAqIEBwYXJhbSAge051bWJlcn0gIGggICAgICAgVGltZSBzdGVwXG4gKiBAcGFyYW0gIHtXb3JsZH0gICB3b3JsZCAgICBXb3JsZCB0byBzb2x2ZVxuICovXG5HU1NvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbihoLCB3b3JsZCl7XG5cbiAgICB0aGlzLnNvcnRFcXVhdGlvbnMoKTtcblxuICAgIHZhciBpdGVyID0gMCxcbiAgICAgICAgbWF4SXRlciA9IHRoaXMuaXRlcmF0aW9ucyxcbiAgICAgICAgbWF4RnJpY3Rpb25JdGVyID0gdGhpcy5mcmljdGlvbkl0ZXJhdGlvbnMsXG4gICAgICAgIGVxdWF0aW9ucyA9IHRoaXMuZXF1YXRpb25zLFxuICAgICAgICBOZXEgPSBlcXVhdGlvbnMubGVuZ3RoLFxuICAgICAgICB0b2xTcXVhcmVkID0gTWF0aC5wb3codGhpcy50b2xlcmFuY2UqTmVxLCAyKSxcbiAgICAgICAgYm9kaWVzID0gd29ybGQuYm9kaWVzLFxuICAgICAgICBOYm9kaWVzID0gd29ybGQuYm9kaWVzLmxlbmd0aCxcbiAgICAgICAgYWRkID0gdmVjMi5hZGQsXG4gICAgICAgIHNldCA9IHZlYzIuc2V0LFxuICAgICAgICB1c2VaZXJvUkhTID0gdGhpcy51c2VaZXJvUkhTLFxuICAgICAgICBsYW1iZGEgPSB0aGlzLmxhbWJkYTtcblxuICAgIHRoaXMudXNlZEl0ZXJhdGlvbnMgPSAwO1xuXG4gICAgaWYoTmVxKXtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgdmFyIGIgPSBib2RpZXNbaV07XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBzb2x2ZSBtYXNzXG4gICAgICAgICAgICBiLnVwZGF0ZVNvbHZlTWFzc1Byb3BlcnRpZXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaW5ncyB0aGF0IGRvZXMgbm90IGNoYW5nZSBkdXJpbmcgaXRlcmF0aW9uIGNhbiBiZSBjb21wdXRlZCBvbmNlXG4gICAgaWYobGFtYmRhLmxlbmd0aCA8IE5lcSl7XG4gICAgICAgIGxhbWJkYSA9IHRoaXMubGFtYmRhID0gIG5ldyBVdGlscy5BUlJBWV9UWVBFKE5lcSArIHRoaXMuYXJyYXlTdGVwKTtcbiAgICAgICAgdGhpcy5CcyA9ICAgICAgICAgICAgICAgbmV3IFV0aWxzLkFSUkFZX1RZUEUoTmVxICsgdGhpcy5hcnJheVN0ZXApO1xuICAgICAgICB0aGlzLmludkNzID0gICAgICAgICAgICBuZXcgVXRpbHMuQVJSQVlfVFlQRShOZXEgKyB0aGlzLmFycmF5U3RlcCk7XG4gICAgfVxuICAgIHNldEFycmF5WmVybyhsYW1iZGEpO1xuICAgIHZhciBpbnZDcyA9IHRoaXMuaW52Q3MsXG4gICAgICAgIEJzID0gdGhpcy5CcyxcbiAgICAgICAgbGFtYmRhID0gdGhpcy5sYW1iZGE7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PWVxdWF0aW9ucy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBjID0gZXF1YXRpb25zW2ldO1xuICAgICAgICBpZihjLnRpbWVTdGVwICE9PSBoIHx8IGMubmVlZHNVcGRhdGUpe1xuICAgICAgICAgICAgYy50aW1lU3RlcCA9IGg7XG4gICAgICAgICAgICBjLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIEJzW2ldID0gICAgIGMuY29tcHV0ZUIoYy5hLGMuYixoKTtcbiAgICAgICAgaW52Q3NbaV0gPSAgYy5jb21wdXRlSW52QyhjLmVwc2lsb24pO1xuICAgIH1cblxuICAgIHZhciBxLCBCLCBjLCBkZWx0YWxhbWJkYVRvdCxpLGo7XG5cbiAgICBpZihOZXEgIT09IDApe1xuXG4gICAgICAgIGZvcihpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgdmFyIGIgPSBib2RpZXNbaV07XG5cbiAgICAgICAgICAgIC8vIFJlc2V0IHZsYW1iZGFcbiAgICAgICAgICAgIGIucmVzZXRDb25zdHJhaW50VmVsb2NpdHkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG1heEZyaWN0aW9uSXRlcil7XG4gICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgY29udGFjdCBlcXVhdGlvbnMgdG8gZ2V0IG5vcm1hbCBmb3JjZXNcbiAgICAgICAgICAgIGZvcihpdGVyPTA7IGl0ZXIhPT1tYXhGcmljdGlvbkl0ZXI7IGl0ZXIrKyl7XG5cbiAgICAgICAgICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSB0b3RhbCBlcnJvciBmb3IgZWFjaCBpdGVyYXRpb24uXG4gICAgICAgICAgICAgICAgZGVsdGFsYW1iZGFUb3QgPSAwLjA7XG5cbiAgICAgICAgICAgICAgICBmb3Ioaj0wOyBqIT09TmVxOyBqKyspe1xuICAgICAgICAgICAgICAgICAgICBjID0gZXF1YXRpb25zW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YWxhbWJkYSA9IEdTU29sdmVyLml0ZXJhdGVFcXVhdGlvbihqLGMsYy5lcHNpbG9uLEJzLGludkNzLGxhbWJkYSx1c2VaZXJvUkhTLGgsaXRlcik7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ICs9IE1hdGguYWJzKGRlbHRhbGFtYmRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnVzZWRJdGVyYXRpb25zKys7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdG90YWwgZXJyb3IgaXMgc21hbGwgZW5vdWdoIC0gc3RvcCBpdGVyYXRlXG4gICAgICAgICAgICAgICAgaWYoZGVsdGFsYW1iZGFUb3QqZGVsdGFsYW1iZGFUb3QgPD0gdG9sU3F1YXJlZCl7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgR1NTb2x2ZXIudXBkYXRlTXVsdGlwbGllcnMoZXF1YXRpb25zLCBsYW1iZGEsIDEvaCk7XG5cbiAgICAgICAgICAgIC8vIFNldCBjb21wdXRlZCBmcmljdGlvbiBmb3JjZVxuICAgICAgICAgICAgZm9yKGo9MDsgaiE9PU5lcTsgaisrKXtcbiAgICAgICAgICAgICAgICB2YXIgZXEgPSBlcXVhdGlvbnNbal07XG4gICAgICAgICAgICAgICAgaWYoZXEgaW5zdGFuY2VvZiBGcmljdGlvbkVxdWF0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaz0wOyBrIT09ZXEuY29udGFjdEVxdWF0aW9ucy5sZW5ndGg7IGsrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBmICs9IGVxLmNvbnRhY3RFcXVhdGlvbnNba10ubXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmICo9IGVxLmZyaWN0aW9uQ29lZmZpY2llbnQgLyBlcS5jb250YWN0RXF1YXRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZXEubWF4Rm9yY2UgPSAgZjtcbiAgICAgICAgICAgICAgICAgICAgZXEubWluRm9yY2UgPSAtZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIGVxdWF0aW9uc1xuICAgICAgICBmb3IoaXRlcj0wOyBpdGVyIT09bWF4SXRlcjsgaXRlcisrKXtcblxuICAgICAgICAgICAgLy8gQWNjdW11bGF0ZSB0aGUgdG90YWwgZXJyb3IgZm9yIGVhY2ggaXRlcmF0aW9uLlxuICAgICAgICAgICAgZGVsdGFsYW1iZGFUb3QgPSAwLjA7XG5cbiAgICAgICAgICAgIGZvcihqPTA7IGohPT1OZXE7IGorKyl7XG4gICAgICAgICAgICAgICAgYyA9IGVxdWF0aW9uc1tqXTtcblxuICAgICAgICAgICAgICAgIHZhciBkZWx0YWxhbWJkYSA9IEdTU29sdmVyLml0ZXJhdGVFcXVhdGlvbihqLGMsYy5lcHNpbG9uLEJzLGludkNzLGxhbWJkYSx1c2VaZXJvUkhTLGgsaXRlcik7XG4gICAgICAgICAgICAgICAgZGVsdGFsYW1iZGFUb3QgKz0gTWF0aC5hYnMoZGVsdGFsYW1iZGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVzZWRJdGVyYXRpb25zKys7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB0b3RhbCBlcnJvciBpcyBzbWFsbCBlbm91Z2ggLSBzdG9wIGl0ZXJhdGVcbiAgICAgICAgICAgIGlmKGRlbHRhbGFtYmRhVG90KmRlbHRhbGFtYmRhVG90IDw9IHRvbFNxdWFyZWQpe1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHJlc3VsdCB0byB2ZWxvY2l0eVxuICAgICAgICBmb3IoaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIGJvZGllc1tpXS5hZGRDb25zdHJhaW50VmVsb2NpdHkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEdTU29sdmVyLnVwZGF0ZU11bHRpcGxpZXJzKGVxdWF0aW9ucywgbGFtYmRhLCAxL2gpO1xuICAgIH1cbn07XG5cbi8vIFNldHMgdGhlIC5tdWx0aXBsaWVyIHByb3BlcnR5IG9mIGVhY2ggZXF1YXRpb25cbkdTU29sdmVyLnVwZGF0ZU11bHRpcGxpZXJzID0gZnVuY3Rpb24oZXF1YXRpb25zLCBsYW1iZGEsIGludkR0KXtcbiAgICAvLyBTZXQgdGhlIC5tdWx0aXBsaWVyIHByb3BlcnR5IG9mIGVhY2ggZXF1YXRpb25cbiAgICB2YXIgbCA9IGVxdWF0aW9ucy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgZXF1YXRpb25zW2xdLm11bHRpcGxpZXIgPSBsYW1iZGFbbF0gKiBpbnZEdDtcbiAgICB9XG59O1xuXG5HU1NvbHZlci5pdGVyYXRlRXF1YXRpb24gPSBmdW5jdGlvbihqLGVxLGVwcyxCcyxpbnZDcyxsYW1iZGEsdXNlWmVyb1JIUyxkdCxpdGVyKXtcbiAgICAvLyBDb21wdXRlIGl0ZXJhdGlvblxuICAgIHZhciBCID0gQnNbal0sXG4gICAgICAgIGludkMgPSBpbnZDc1tqXSxcbiAgICAgICAgbGFtYmRhaiA9IGxhbWJkYVtqXSxcbiAgICAgICAgR1dsYW1iZGEgPSBlcS5jb21wdXRlR1dsYW1iZGEoKTtcblxuICAgIHZhciBtYXhGb3JjZSA9IGVxLm1heEZvcmNlLFxuICAgICAgICBtaW5Gb3JjZSA9IGVxLm1pbkZvcmNlO1xuXG4gICAgaWYodXNlWmVyb1JIUyl7XG4gICAgICAgIEIgPSAwO1xuICAgIH1cblxuICAgIHZhciBkZWx0YWxhbWJkYSA9IGludkMgKiAoIEIgLSBHV2xhbWJkYSAtIGVwcyAqIGxhbWJkYWogKTtcblxuICAgIC8vIENsYW1wIGlmIHdlIGFyZSBub3Qgd2l0aGluIHRoZSBtaW4vbWF4IGludGVydmFsXG4gICAgdmFyIGxhbWJkYWpfcGx1c19kZWx0YWxhbWJkYSA9IGxhbWJkYWogKyBkZWx0YWxhbWJkYTtcbiAgICBpZihsYW1iZGFqX3BsdXNfZGVsdGFsYW1iZGEgPCBtaW5Gb3JjZSpkdCl7XG4gICAgICAgIGRlbHRhbGFtYmRhID0gbWluRm9yY2UqZHQgLSBsYW1iZGFqO1xuICAgIH0gZWxzZSBpZihsYW1iZGFqX3BsdXNfZGVsdGFsYW1iZGEgPiBtYXhGb3JjZSpkdCl7XG4gICAgICAgIGRlbHRhbGFtYmRhID0gbWF4Rm9yY2UqZHQgLSBsYW1iZGFqO1xuICAgIH1cbiAgICBsYW1iZGFbal0gKz0gZGVsdGFsYW1iZGE7XG4gICAgZXEuYWRkVG9XbGFtYmRhKGRlbHRhbGFtYmRhKTtcblxuICAgIHJldHVybiBkZWx0YWxhbWJkYTtcbn07XG5cbn0se1wiLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb25cIjoyNCxcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vdXRpbHMvVXRpbHNcIjo1MCxcIi4vU29sdmVyXCI6NDd9XSw0NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpXG4sICAgRXZlbnRFbWl0dGVyID0gX2RlcmVxXygnLi4vZXZlbnRzL0V2ZW50RW1pdHRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbHZlcjtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBjb25zdHJhaW50IHNvbHZlcnMuXG4gKiBAY2xhc3MgU29sdmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5mdW5jdGlvbiBTb2x2ZXIob3B0aW9ucyx0eXBlKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgZXF1YXRpb25zIGluIHRoZSBzb2x2ZXIuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZXF1YXRpb25zXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuZXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gc29ydCBhbGwgZXF1YXRpb25zIGJlZm9yZSBlYWNoIHNvbHZlLlxuICAgICAqIEBwcm9wZXJ0eSBlcXVhdGlvblNvcnRGdW5jdGlvblxuICAgICAqIEB0eXBlIHtmdW5jdGlvbnxib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZXF1YXRpb25Tb3J0RnVuY3Rpb24gPSBvcHRpb25zLmVxdWF0aW9uU29ydEZ1bmN0aW9uIHx8IGZhbHNlO1xufVxuU29sdmVyLnByb3RvdHlwZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblNvbHZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb2x2ZXI7XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGltcGxlbWVudGVkIGluIGVhY2ggc3ViY2xhc3NcbiAqIEBtZXRob2Qgc29sdmVcbiAqIEBwYXJhbSAge051bWJlcn0gZHRcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICovXG5Tb2x2ZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oZHQsd29ybGQpe1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNvbHZlci5zb2x2ZSBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcyFcIik7XG59O1xuXG52YXIgbW9ja1dvcmxkID0ge2JvZGllczpbXX07XG5cbi8qKlxuICogU29sdmVzIGFsbCBjb25zdHJhaW50cyBpbiBhbiBpc2xhbmQuXG4gKiBAbWV0aG9kIHNvbHZlSXNsYW5kXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGR0XG4gKiBAcGFyYW0gIHtJc2xhbmR9IGlzbGFuZFxuICovXG5Tb2x2ZXIucHJvdG90eXBlLnNvbHZlSXNsYW5kID0gZnVuY3Rpb24oZHQsaXNsYW5kKXtcblxuICAgIHRoaXMucmVtb3ZlQWxsRXF1YXRpb25zKCk7XG5cbiAgICBpZihpc2xhbmQuZXF1YXRpb25zLmxlbmd0aCl7XG4gICAgICAgIC8vIEFkZCBlcXVhdGlvbnMgdG8gc29sdmVyXG4gICAgICAgIHRoaXMuYWRkRXF1YXRpb25zKGlzbGFuZC5lcXVhdGlvbnMpO1xuICAgICAgICBtb2NrV29ybGQuYm9kaWVzLmxlbmd0aCA9IDA7XG4gICAgICAgIGlzbGFuZC5nZXRCb2RpZXMobW9ja1dvcmxkLmJvZGllcyk7XG5cbiAgICAgICAgLy8gU29sdmVcbiAgICAgICAgaWYobW9ja1dvcmxkLmJvZGllcy5sZW5ndGgpe1xuICAgICAgICAgICAgdGhpcy5zb2x2ZShkdCxtb2NrV29ybGQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBTb3J0IGFsbCBlcXVhdGlvbnMgdXNpbmcgdGhlIC5lcXVhdGlvblNvcnRGdW5jdGlvbi4gU2hvdWxkIGJlIGNhbGxlZCBieSBzdWJjbGFzc2VzIGJlZm9yZSBzb2x2aW5nLlxuICogQG1ldGhvZCBzb3J0RXF1YXRpb25zXG4gKi9cblNvbHZlci5wcm90b3R5cGUuc29ydEVxdWF0aW9ucyA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5lcXVhdGlvblNvcnRGdW5jdGlvbil7XG4gICAgICAgIHRoaXMuZXF1YXRpb25zLnNvcnQodGhpcy5lcXVhdGlvblNvcnRGdW5jdGlvbik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBZGQgYW4gZXF1YXRpb24gdG8gYmUgc29sdmVkLlxuICpcbiAqIEBtZXRob2QgYWRkRXF1YXRpb25cbiAqIEBwYXJhbSB7RXF1YXRpb259IGVxXG4gKi9cblNvbHZlci5wcm90b3R5cGUuYWRkRXF1YXRpb24gPSBmdW5jdGlvbihlcSl7XG4gICAgaWYoZXEuZW5hYmxlZCl7XG4gICAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goZXEpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQWRkIGVxdWF0aW9ucy4gU2FtZSBhcyAuYWRkRXF1YXRpb24sIGJ1dCB0aGlzIHRpbWUgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5IG9mIEVxdWF0aW9uc1xuICpcbiAqIEBtZXRob2QgYWRkRXF1YXRpb25zXG4gKiBAcGFyYW0ge0FycmF5fSBlcXNcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5hZGRFcXVhdGlvbnMgPSBmdW5jdGlvbihlcXMpe1xuICAgIC8vVXRpbHMuYXBwZW5kQXJyYXkodGhpcy5lcXVhdGlvbnMsZXFzKTtcbiAgICBmb3IodmFyIGk9MCwgTj1lcXMubGVuZ3RoOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGVxID0gZXFzW2ldO1xuICAgICAgICBpZihlcS5lbmFibGVkKXtcbiAgICAgICAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goZXEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gZXF1YXRpb24uXG4gKlxuICogQG1ldGhvZCByZW1vdmVFcXVhdGlvblxuICogQHBhcmFtIHtFcXVhdGlvbn0gZXFcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5yZW1vdmVFcXVhdGlvbiA9IGZ1bmN0aW9uKGVxKXtcbiAgICB2YXIgaSA9IHRoaXMuZXF1YXRpb25zLmluZGV4T2YoZXEpO1xuICAgIGlmKGkgIT09IC0xKXtcbiAgICAgICAgdGhpcy5lcXVhdGlvbnMuc3BsaWNlKGksMSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGN1cnJlbnRseSBhZGRlZCBlcXVhdGlvbnMuXG4gKlxuICogQG1ldGhvZCByZW1vdmVBbGxFcXVhdGlvbnNcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5yZW1vdmVBbGxFcXVhdGlvbnMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZXF1YXRpb25zLmxlbmd0aD0wO1xufTtcblxuU29sdmVyLkdTID0gMTtcblNvbHZlci5JU0xBTkQgPSAyO1xuXG59LHtcIi4uL2V2ZW50cy9FdmVudEVtaXR0ZXJcIjoyNyxcIi4uL3V0aWxzL1V0aWxzXCI6NTB9XSw0ODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgVHVwbGVEaWN0aW9uYXJ5ID0gX2RlcmVxXygnLi9UdXBsZURpY3Rpb25hcnknKTtcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4vVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPdmVybGFwS2VlcGVyO1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIG92ZXJsYXBzIGluIHRoZSBjdXJyZW50IHN0YXRlIGFuZCB0aGUgbGFzdCBzdGVwIHN0YXRlLlxuICogQGNsYXNzIE92ZXJsYXBLZWVwZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBPdmVybGFwS2VlcGVyKCkge1xuICAgIHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGUgPSBuZXcgVHVwbGVEaWN0aW9uYXJ5KCk7XG4gICAgdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZSA9IG5ldyBUdXBsZURpY3Rpb25hcnkoKTtcbiAgICB0aGlzLnJlY29yZFBvb2wgPSBbXTtcbiAgICB0aGlzLnRtcERpY3QgPSBuZXcgVHVwbGVEaWN0aW9uYXJ5KCk7XG4gICAgdGhpcy50bXBBcnJheTEgPSBbXTtcbn1cblxuLyoqXG4gKiBUaWNrcyBvbmUgc3RlcCBmb3J3YXJkIGluIHRpbWUuIFRoaXMgd2lsbCBtb3ZlIHRoZSBjdXJyZW50IG92ZXJsYXAgc3RhdGUgdG8gdGhlIFwib2xkXCIgb3ZlcmxhcCBzdGF0ZSwgYW5kIGNyZWF0ZSBhIG5ldyBvbmUgYXMgY3VycmVudC5cbiAqIEBtZXRob2QgdGlja1xuICovXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxhc3QgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlO1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZTtcblxuICAgIC8vIFNhdmUgb2xkIG9iamVjdHMgaW50byBwb29sXG4gICAgdmFyIGwgPSBsYXN0LmtleXMubGVuZ3RoO1xuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIHZhciBrZXkgPSBsYXN0LmtleXNbbF07XG4gICAgICAgIHZhciBsYXN0T2JqZWN0ID0gbGFzdC5nZXRCeUtleShrZXkpO1xuICAgICAgICB2YXIgY3VycmVudE9iamVjdCA9IGN1cnJlbnQuZ2V0QnlLZXkoa2V5KTtcbiAgICAgICAgaWYobGFzdE9iamVjdCAmJiAhY3VycmVudE9iamVjdCl7XG4gICAgICAgICAgICAvLyBUaGUgcmVjb3JkIGlzIG9ubHkgdXNlZCBpbiB0aGUgXCJsYXN0XCIgZGljdCwgYW5kIHdpbGwgYmUgcmVtb3ZlZC4gV2UgbWlnaHQgYXMgd2VsbCBwb29sIGl0LlxuICAgICAgICAgICAgdGhpcy5yZWNvcmRQb29sLnB1c2gobGFzdE9iamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDbGVhciBsYXN0IG9iamVjdFxuICAgIGxhc3QucmVzZXQoKTtcblxuICAgIC8vIFRyYW5zZmVyIGZyb20gbmV3IG9iamVjdCB0byBvbGRcbiAgICBsYXN0LmNvcHkoY3VycmVudCk7XG5cbiAgICAvLyBDbGVhciBjdXJyZW50IG9iamVjdFxuICAgIGN1cnJlbnQucmVzZXQoKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBzZXRPdmVybGFwcGluZ1xuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBzaGFwZUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7Qm9keX0gc2hhcGVCXG4gKi9cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLnNldE92ZXJsYXBwaW5nID0gZnVuY3Rpb24oYm9keUEsIHNoYXBlQSwgYm9keUIsIHNoYXBlQikge1xuICAgIHZhciBsYXN0ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZTtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGU7XG5cbiAgICAvLyBTdG9yZSBjdXJyZW50IGNvbnRhY3Qgc3RhdGVcbiAgICBpZighY3VycmVudC5nZXQoc2hhcGVBLmlkLCBzaGFwZUIuaWQpKXtcblxuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYodGhpcy5yZWNvcmRQb29sLmxlbmd0aCl7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5yZWNvcmRQb29sLnBvcCgpO1xuICAgICAgICAgICAgZGF0YS5zZXQoYm9keUEsIHNoYXBlQSwgYm9keUIsIHNoYXBlQik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gbmV3IE92ZXJsYXBLZWVwZXJSZWNvcmQoYm9keUEsIHNoYXBlQSwgYm9keUIsIHNoYXBlQik7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50LnNldChzaGFwZUEuaWQsIHNoYXBlQi5pZCwgZGF0YSk7XG4gICAgfVxufTtcblxuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0TmV3T3ZlcmxhcHMgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHJldHVybiB0aGlzLmdldERpZmYodGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZSwgdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZSwgcmVzdWx0KTtcbn07XG5cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldEVuZE92ZXJsYXBzID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICByZXR1cm4gdGhpcy5nZXREaWZmKHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGUsIHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGUsIHJlc3VsdCk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0d28gYm9kaWVzIGFyZSBjdXJyZW50bHkgb3ZlcmxhcHBpbmcuXG4gKiBAbWV0aG9kIGJvZGllc0FyZU92ZXJsYXBwaW5nXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmJvZGllc0FyZU92ZXJsYXBwaW5nID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKXtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGU7XG4gICAgdmFyIGwgPSBjdXJyZW50LmtleXMubGVuZ3RoO1xuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIHZhciBrZXkgPSBjdXJyZW50LmtleXNbbF07XG4gICAgICAgIHZhciBkYXRhID0gY3VycmVudC5kYXRhW2tleV07XG4gICAgICAgIGlmKChkYXRhLmJvZHlBID09PSBib2R5QSAmJiBkYXRhLmJvZHlCID09PSBib2R5QikgfHwgZGF0YS5ib2R5QSA9PT0gYm9keUIgJiYgZGF0YS5ib2R5QiA9PT0gYm9keUEpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0RGlmZiA9IGZ1bmN0aW9uKGRpY3RBLCBkaWN0QiwgcmVzdWx0KXtcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuICAgIHZhciBsYXN0ID0gZGljdEE7XG4gICAgdmFyIGN1cnJlbnQgPSBkaWN0QjtcblxuICAgIHJlc3VsdC5sZW5ndGggPSAwO1xuXG4gICAgdmFyIGwgPSBjdXJyZW50LmtleXMubGVuZ3RoO1xuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIHZhciBrZXkgPSBjdXJyZW50LmtleXNbbF07XG4gICAgICAgIHZhciBkYXRhID0gY3VycmVudC5kYXRhW2tleV07XG5cbiAgICAgICAgaWYoIWRhdGEpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgJytrZXkrJyBoYWQgbm8gZGF0YSEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0RGF0YSA9IGxhc3QuZGF0YVtrZXldO1xuICAgICAgICBpZighbGFzdERhdGEpe1xuICAgICAgICAgICAgLy8gTm90IG92ZXJsYXBwaW5nIGluIGxhc3Qgc3RhdGUsIGJ1dCBpbiBjdXJyZW50LlxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuaXNOZXdPdmVybGFwID0gZnVuY3Rpb24oc2hhcGVBLCBzaGFwZUIpe1xuICAgIHZhciBpZEEgPSBzaGFwZUEuaWR8MCxcbiAgICAgICAgaWRCID0gc2hhcGVCLmlkfDA7XG4gICAgdmFyIGxhc3QgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlO1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZTtcbiAgICAvLyBOb3QgaW4gbGFzdCBidXQgaW4gbmV3XG4gICAgcmV0dXJuICEhIWxhc3QuZ2V0KGlkQSwgaWRCKSAmJiAhIWN1cnJlbnQuZ2V0KGlkQSwgaWRCKTtcbn07XG5cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldE5ld0JvZHlPdmVybGFwcyA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgdGhpcy50bXBBcnJheTEubGVuZ3RoID0gMDtcbiAgICB2YXIgb3ZlcmxhcHMgPSB0aGlzLmdldE5ld092ZXJsYXBzKHRoaXMudG1wQXJyYXkxKTtcbiAgICByZXR1cm4gdGhpcy5nZXRCb2R5RGlmZihvdmVybGFwcywgcmVzdWx0KTtcbn07XG5cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldEVuZEJvZHlPdmVybGFwcyA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgdGhpcy50bXBBcnJheTEubGVuZ3RoID0gMDtcbiAgICB2YXIgb3ZlcmxhcHMgPSB0aGlzLmdldEVuZE92ZXJsYXBzKHRoaXMudG1wQXJyYXkxKTtcbiAgICByZXR1cm4gdGhpcy5nZXRCb2R5RGlmZihvdmVybGFwcywgcmVzdWx0KTtcbn07XG5cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldEJvZHlEaWZmID0gZnVuY3Rpb24ob3ZlcmxhcHMsIHJlc3VsdCl7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuICAgIHZhciBhY2N1bXVsYXRvciA9IHRoaXMudG1wRGljdDtcblxuICAgIHZhciBsID0gb3ZlcmxhcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGRhdGEgPSBvdmVybGFwc1tsXTtcblxuICAgICAgICAvLyBTaW5jZSB3ZSB1c2UgYm9keSBpZCdzIGZvciB0aGUgYWNjdW11bGF0b3IsIHRoZXNlIHdpbGwgYmUgYSBzdWJzZXQgb2YgdGhlIG9yaWdpbmFsIG9uZVxuICAgICAgICBhY2N1bXVsYXRvci5zZXQoZGF0YS5ib2R5QS5pZHwwLCBkYXRhLmJvZHlCLmlkfDAsIGRhdGEpO1xuICAgIH1cblxuICAgIGwgPSBhY2N1bXVsYXRvci5rZXlzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIgZGF0YSA9IGFjY3VtdWxhdG9yLmdldEJ5S2V5KGFjY3VtdWxhdG9yLmtleXNbbF0pO1xuICAgICAgICBpZihkYXRhKXtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhdGEuYm9keUEsIGRhdGEuYm9keUIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWNjdW11bGF0b3IucmVzZXQoKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIE92ZXJsYXAgZGF0YSBjb250YWluZXIgZm9yIHRoZSBPdmVybGFwS2VlcGVyXG4gKiBAY2xhc3MgT3ZlcmxhcEtlZXBlclJlY29yZFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQlxuICovXG5mdW5jdGlvbiBPdmVybGFwS2VlcGVyUmVjb3JkKGJvZHlBLCBzaGFwZUEsIGJvZHlCLCBzaGFwZUIpe1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7U2hhcGV9IHNoYXBlQVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVBID0gc2hhcGVBO1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7U2hhcGV9IHNoYXBlQlxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVCID0gc2hhcGVCO1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9keX0gYm9keUFcbiAgICAgKi9cbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtCb2R5fSBib2R5QlxuICAgICAqL1xuICAgIHRoaXMuYm9keUIgPSBib2R5Qjtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGRhdGEgZm9yIHRoZSByZWNvcmRcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQlxuICovXG5PdmVybGFwS2VlcGVyUmVjb3JkLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKXtcbiAgICBPdmVybGFwS2VlcGVyUmVjb3JkLmNhbGwodGhpcywgYm9keUEsIHNoYXBlQSwgYm9keUIsIHNoYXBlQik7XG59O1xuXG59LHtcIi4vVHVwbGVEaWN0aW9uYXJ5XCI6NDksXCIuL1V0aWxzXCI6NTB9XSw0OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHVwbGVEaWN0aW9uYXJ5O1xuXG4vKipcbiAqIEBjbGFzcyBUdXBsZURpY3Rpb25hcnlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBUdXBsZURpY3Rpb25hcnkoKSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YSBzdG9yYWdlXG4gICAgICogQHByb3BlcnR5IGRhdGFcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogS2V5cyB0aGF0IGFyZSBjdXJyZW50bHkgdXNlZC5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBrZXlzXG4gICAgICovXG4gICAgdGhpcy5rZXlzID0gW107XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgZ2l2ZW4gdHdvIGludGVnZXJzXG4gKiBAbWV0aG9kIGdldEtleVxuICogQHBhcmFtICB7bnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbihpZDEsIGlkMikge1xuICAgIGlkMSA9IGlkMXwwO1xuICAgIGlkMiA9IGlkMnwwO1xuXG4gICAgaWYgKCAoaWQxfDApID09PSAoaWQyfDApICl7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyB2YWxpZCBmb3IgdmFsdWVzIDwgMl4xNlxuICAgIHJldHVybiAoKGlkMXwwKSA+IChpZDJ8MCkgP1xuICAgICAgICAoaWQxIDw8IDE2KSB8IChpZDIgJiAweEZGRkYpIDpcbiAgICAgICAgKGlkMiA8PCAxNikgfCAoaWQxICYgMHhGRkZGKSl8MFxuICAgICAgICA7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZ2V0QnlLZXlcbiAqIEBwYXJhbSAge051bWJlcn0ga2V5XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0QnlLZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICBrZXkgPSBrZXl8MDtcbiAgICByZXR1cm4gdGhpcy5kYXRhW2tleV07XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZ2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge051bWJlcn0galxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGksIGopIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhW3RoaXMuZ2V0S2V5KGksIGopXTtcbn07XG5cbi8qKlxuICogU2V0IGEgdmFsdWUuXG4gKiBAbWV0aG9kIHNldFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGksIGosIHZhbHVlKSB7XG4gICAgaWYoIXZhbHVlKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZGF0YSFcIik7XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGksIGopO1xuXG4gICAgLy8gQ2hlY2sgaWYga2V5IGFscmVhZHkgZXhpc3RzXG4gICAgaWYoIXRoaXMuZGF0YVtrZXldKXtcbiAgICAgICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGFba2V5XSA9IHZhbHVlO1xuXG4gICAgcmV0dXJuIGtleTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBkYXRhLlxuICogQG1ldGhvZCByZXNldFxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICAgIGtleXMgPSB0aGlzLmtleXM7XG5cbiAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlKGwtLSkge1xuICAgICAgICBkZWxldGUgZGF0YVtrZXlzW2xdXTtcbiAgICB9XG5cbiAgICBrZXlzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIENvcHkgYW5vdGhlciBUdXBsZURpY3Rpb25hcnkuIE5vdGUgdGhhdCBhbGwgZGF0YSBpbiB0aGlzIGRpY3Rpb25hcnkgd2lsbCBiZSByZW1vdmVkLlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0ge1R1cGxlRGljdGlvbmFyeX0gZGljdCBUaGUgVHVwbGVEaWN0aW9uYXJ5IHRvIGNvcHkgaW50byB0aGlzIG9uZS5cbiAqL1xuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oZGljdCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICBVdGlscy5hcHBlbmRBcnJheSh0aGlzLmtleXMsIGRpY3Qua2V5cyk7XG4gICAgdmFyIGwgPSBkaWN0LmtleXMubGVuZ3RoO1xuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIHZhciBrZXkgPSBkaWN0LmtleXNbbF07XG4gICAgICAgIHRoaXMuZGF0YVtrZXldID0gZGljdC5kYXRhW2tleV07XG4gICAgfVxufTtcblxufSx7XCIuL1V0aWxzXCI6NTB9XSw1MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKiBnbG9iYWwgUDJfQVJSQVlfVFlQRSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFV0aWxzO1xuXG4vKipcbiAqIE1pc2MgdXRpbGl0eSBmdW5jdGlvbnNcbiAqIEBjbGFzcyBVdGlsc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFV0aWxzKCl7fVxuXG4vKipcbiAqIEFwcGVuZCB0aGUgdmFsdWVzIGluIGFycmF5IGIgdG8gdGhlIGFycmF5IGEuIFNlZSA8YSBocmVmPVwiaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzc0MTI2L2hvdy10by1hcHBlbmQtYW4tYXJyYXktdG8tYW4tZXhpc3RpbmctamF2YXNjcmlwdC1hcnJheS8xMzc0MTMxIzEzNzQxMzFcIj50aGlzPC9hPiBmb3IgYW4gZXhwbGFuYXRpb24uXG4gKiBAbWV0aG9kIGFwcGVuZEFycmF5XG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7QXJyYXl9IGJcbiAqL1xuVXRpbHMuYXBwZW5kQXJyYXkgPSBmdW5jdGlvbihhLGIpe1xuICAgIGlmIChiLmxlbmd0aCA8IDE1MDAwMCkge1xuICAgICAgICBhLnB1c2guYXBwbHkoYSwgYik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGIubGVuZ3RoOyBpICE9PSBsZW47ICsraSkge1xuICAgICAgICAgICAgYS5wdXNoKGJbaV0pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBHYXJiYWdlIGZyZWUgQXJyYXkuc3BsaWNlKCkuIERvZXMgbm90IGFsbG9jYXRlIGEgbmV3IGFycmF5LlxuICogQG1ldGhvZCBzcGxpY2VcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBhcnJheVxuICogQHBhcmFtICB7TnVtYmVyfSBpbmRleFxuICogQHBhcmFtICB7TnVtYmVyfSBob3dtYW55XG4gKi9cblV0aWxzLnNwbGljZSA9IGZ1bmN0aW9uKGFycmF5LGluZGV4LGhvd21hbnkpe1xuICAgIGhvd21hbnkgPSBob3dtYW55IHx8IDE7XG4gICAgZm9yICh2YXIgaT1pbmRleCwgbGVuPWFycmF5Lmxlbmd0aC1ob3dtYW55OyBpIDwgbGVuOyBpKyspe1xuICAgICAgICBhcnJheVtpXSA9IGFycmF5W2kgKyBob3dtYW55XTtcbiAgICB9XG4gICAgYXJyYXkubGVuZ3RoID0gbGVuO1xufTtcblxuLyoqXG4gKiBUaGUgYXJyYXkgdHlwZSB0byB1c2UgZm9yIGludGVybmFsIG51bWVyaWMgY29tcHV0YXRpb25zIHRocm91Z2hvdXQgdGhlIGxpYnJhcnkuIEZsb2F0MzJBcnJheSBpcyB1c2VkIGlmIGl0IGlzIGF2YWlsYWJsZSwgYnV0IGZhbGxzIGJhY2sgb24gQXJyYXkuIElmIHlvdSB3YW50IHRvIHNldCBhcnJheSB0eXBlIG1hbnVhbGx5LCBpbmplY3QgaXQgdmlhIHRoZSBnbG9iYWwgdmFyaWFibGUgUDJfQVJSQVlfVFlQRS4gU2VlIGV4YW1wbGUgYmVsb3cuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBBUlJBWV9UWVBFXG4gKiBAZXhhbXBsZVxuICogICAgIDxzY3JpcHQ+XG4gKiAgICAgICAgIDwhLS0gSW5qZWN0IHlvdXIgcHJlZmVycmVkIGFycmF5IHR5cGUgYmVmb3JlIGxvYWRpbmcgcDIuanMgLS0+XG4gKiAgICAgICAgIFAyX0FSUkFZX1RZUEUgPSBBcnJheTtcbiAqICAgICA8L3NjcmlwdD5cbiAqICAgICA8c2NyaXB0IHNyYz1cInAyLmpzXCI+PC9zY3JpcHQ+XG4gKi9cbmlmKHR5cGVvZiBQMl9BUlJBWV9UWVBFICE9PSAndW5kZWZpbmVkJykge1xuICAgIFV0aWxzLkFSUkFZX1RZUEUgPSBQMl9BUlJBWV9UWVBFO1xufSBlbHNlIGlmICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyl7XG4gICAgVXRpbHMuQVJSQVlfVFlQRSA9IEZsb2F0MzJBcnJheTtcbn0gZWxzZSB7XG4gICAgVXRpbHMuQVJSQVlfVFlQRSA9IEFycmF5O1xufVxuXG4vKipcbiAqIEV4dGVuZCBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBvZiBhbm90aGVyXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtICB7b2JqZWN0fSBhXG4gKiBAcGFyYW0gIHtvYmplY3R9IGJcbiAqL1xuVXRpbHMuZXh0ZW5kID0gZnVuY3Rpb24oYSxiKXtcbiAgICBmb3IodmFyIGtleSBpbiBiKXtcbiAgICAgICAgYVtrZXldID0gYltrZXldO1xuICAgIH1cbn07XG5cbi8qKlxuICogRXh0ZW5kIGFuIG9wdGlvbnMgb2JqZWN0IHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGRlZmF1bHRzXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgb2JqZWN0LiBNYXkgYmUgZmFsc3k6IGluIHRoaXMgY2FzZSwgYSBuZXcgb2JqZWN0IGlzIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxuICogQHBhcmFtICB7b2JqZWN0fSBkZWZhdWx0cyBBbiBvYmplY3QgY29udGFpbmluZyBkZWZhdWx0IHZhbHVlcy5cbiAqIEByZXR1cm4ge29iamVjdH0gVGhlIG1vZGlmaWVkIG9wdGlvbnMgb2JqZWN0LlxuICovXG5VdGlscy5kZWZhdWx0cyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmF1bHRzKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBmb3IodmFyIGtleSBpbiBkZWZhdWx0cyl7XG4gICAgICAgIGlmKCEoa2V5IGluIG9wdGlvbnMpKXtcbiAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IGRlZmF1bHRzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG59LHt9XSw1MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElzbGFuZDtcblxuLyoqXG4gKiBBbiBpc2xhbmQgb2YgYm9kaWVzIGNvbm5lY3RlZCB3aXRoIGVxdWF0aW9ucy5cbiAqIEBjbGFzcyBJc2xhbmRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBJc2xhbmQoKXtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgZXF1YXRpb25zIGluIHRoaXMgaXNsYW5kLlxuICAgICAqIEBwcm9wZXJ0eSBlcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgYm9kaWVzIGluIHRoaXMgaXNsYW5kLlxuICAgICAqIEBwcm9wZXJ0eSBib2RpZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5ib2RpZXMgPSBbXTtcbn1cblxuLyoqXG4gKiBDbGVhbiB0aGlzIGlzbGFuZCBmcm9tIGJvZGllcyBhbmQgZXF1YXRpb25zLlxuICogQG1ldGhvZCByZXNldFxuICovXG5Jc2xhbmQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmVxdWF0aW9ucy5sZW5ndGggPSB0aGlzLmJvZGllcy5sZW5ndGggPSAwO1xufTtcblxudmFyIGJvZHlJZHMgPSBbXTtcblxuLyoqXG4gKiBHZXQgYWxsIHVuaXF1ZSBib2RpZXMgaW4gdGhpcyBpc2xhbmQuXG4gKiBAbWV0aG9kIGdldEJvZGllc1xuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIEJvZHlcbiAqL1xuSXNsYW5kLnByb3RvdHlwZS5nZXRCb2RpZXMgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHZhciBib2RpZXMgPSByZXN1bHQgfHwgW10sXG4gICAgICAgIGVxcyA9IHRoaXMuZXF1YXRpb25zO1xuICAgIGJvZHlJZHMubGVuZ3RoID0gMDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PWVxcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBlcSA9IGVxc1tpXTtcbiAgICAgICAgaWYoYm9keUlkcy5pbmRleE9mKGVxLmJvZHlBLmlkKT09PS0xKXtcbiAgICAgICAgICAgIGJvZGllcy5wdXNoKGVxLmJvZHlBKTtcbiAgICAgICAgICAgIGJvZHlJZHMucHVzaChlcS5ib2R5QS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoYm9keUlkcy5pbmRleE9mKGVxLmJvZHlCLmlkKT09PS0xKXtcbiAgICAgICAgICAgIGJvZGllcy5wdXNoKGVxLmJvZHlCKTtcbiAgICAgICAgICAgIGJvZHlJZHMucHVzaChlcS5ib2R5Qi5pZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJvZGllcztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGVudGlyZSBpc2xhbmQgd2FudHMgdG8gc2xlZXAuXG4gKiBAbWV0aG9kIHdhbnRzVG9TbGVlcFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuSXNsYW5kLnByb3RvdHlwZS53YW50c1RvU2xlZXAgPSBmdW5jdGlvbigpe1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuYm9kaWVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmJvZGllc1tpXTtcbiAgICAgICAgaWYoYi50eXBlID09PSBCb2R5LkRZTkFNSUMgJiYgIWIud2FudHNUb1NsZWVwKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogTWFrZSBhbGwgYm9kaWVzIGluIHRoZSBpc2xhbmQgc2xlZXAuXG4gKiBAbWV0aG9kIHNsZWVwXG4gKi9cbklzbGFuZC5wcm90b3R5cGUuc2xlZXAgPSBmdW5jdGlvbigpe1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuYm9kaWVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmJvZGllc1tpXTtcbiAgICAgICAgYi5zbGVlcCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbn0se1wiLi4vb2JqZWN0cy9Cb2R5XCI6MzJ9XSw1MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgSXNsYW5kID0gX2RlcmVxXygnLi9Jc2xhbmQnKVxuLCAgIElzbGFuZE5vZGUgPSBfZGVyZXFfKCcuL0lzbGFuZE5vZGUnKVxuLCAgIEJvZHkgPSBfZGVyZXFfKCcuLi9vYmplY3RzL0JvZHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJc2xhbmRNYW5hZ2VyO1xuXG4vKipcbiAqIFNwbGl0cyB0aGUgc3lzdGVtIG9mIGJvZGllcyBhbmQgZXF1YXRpb25zIGludG8gaW5kZXBlbmRlbnQgaXNsYW5kc1xuICpcbiAqIEBjbGFzcyBJc2xhbmRNYW5hZ2VyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBleHRlbmRzIFNvbHZlclxuICovXG5mdW5jdGlvbiBJc2xhbmRNYW5hZ2VyKG9wdGlvbnMpe1xuXG4gICAgLy8gUG9vbGluZyBvZiBub2RlIG9iamVjdHMgc2F2ZXMgc29tZSBHQyBsb2FkXG4gICAgdGhpcy5fbm9kZVBvb2wgPSBbXTtcbiAgICB0aGlzLl9pc2xhbmRQb29sID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXF1YXRpb25zIHRvIHNwbGl0LiBNYW51YWxseSBmaWxsIHRoaXMgYXJyYXkgYmVmb3JlIHJ1bm5pbmcgLnNwbGl0KCkuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gZXF1YXRpb25zXG4gICAgICovXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHRpbmcge3sjY3Jvc3NMaW5rIFwiSXNsYW5kXCJ9fXt7L2Nyb3NzTGlua319cy5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBpc2xhbmRzXG4gICAgICovXG4gICAgdGhpcy5pc2xhbmRzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdWx0aW5nIGdyYXBoIG5vZGVzLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IG5vZGVzXG4gICAgICovXG4gICAgdGhpcy5ub2RlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5vZGUgcXVldWUsIHVzZWQgd2hlbiB0cmF2ZXJzaW5nIHRoZSBncmFwaCBvZiBub2Rlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHF1ZXVlXG4gICAgICovXG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xufVxuXG4vKipcbiAqIEdldCBhbiB1bnZpc2l0ZWQgbm9kZSBmcm9tIGEgbGlzdCBvZiBub2Rlcy5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZ2V0VW52aXNpdGVkTm9kZVxuICogQHBhcmFtICB7QXJyYXl9IG5vZGVzXG4gKiBAcmV0dXJuIHtJc2xhbmROb2RlfGJvb2xlYW59IFRoZSBub2RlIGlmIGZvdW5kLCBlbHNlIGZhbHNlLlxuICovXG5Jc2xhbmRNYW5hZ2VyLmdldFVudmlzaXRlZE5vZGUgPSBmdW5jdGlvbihub2Rlcyl7XG4gICAgdmFyIE5ub2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5ub2RlczsgaSsrKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYoIW5vZGUudmlzaXRlZCAmJiBub2RlLmJvZHkudHlwZSA9PT0gQm9keS5EWU5BTUlDKXtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogVmlzaXQgYSBub2RlLlxuICogQG1ldGhvZCB2aXNpdFxuICogQHBhcmFtICB7SXNsYW5kTm9kZX0gbm9kZVxuICogQHBhcmFtICB7QXJyYXl9IGJkc1xuICogQHBhcmFtICB7QXJyYXl9IGVxc1xuICovXG5Jc2xhbmRNYW5hZ2VyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uIChub2RlLGJkcyxlcXMpe1xuICAgIGJkcy5wdXNoKG5vZGUuYm9keSk7XG4gICAgdmFyIE5lcXMgPSBub2RlLmVxdWF0aW9ucy5sZW5ndGg7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1OZXFzOyBpKyspe1xuICAgICAgICB2YXIgZXEgPSBub2RlLmVxdWF0aW9uc1tpXTtcbiAgICAgICAgaWYoZXFzLmluZGV4T2YoZXEpID09PSAtMSl7IC8vIEFscmVhZHkgYWRkZWQ/XG4gICAgICAgICAgICBlcXMucHVzaChlcSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJ1bnMgdGhlIHNlYXJjaCBhbGdvcml0aG0sIHN0YXJ0aW5nIGF0IGEgcm9vdCBub2RlLiBUaGUgcmVzdWx0aW5nIGJvZGllcyBhbmQgZXF1YXRpb25zIHdpbGwgYmUgc3RvcmVkIGluIHRoZSBwcm92aWRlZCBhcnJheXMuXG4gKiBAbWV0aG9kIGJmc1xuICogQHBhcmFtICB7SXNsYW5kTm9kZX0gcm9vdCBUaGUgbm9kZSB0byBzdGFydCBmcm9tXG4gKiBAcGFyYW0gIHtBcnJheX0gYmRzICBBbiBhcnJheSB0byBhcHBlbmQgcmVzdWx0aW5nIEJvZGllcyB0by5cbiAqIEBwYXJhbSAge0FycmF5fSBlcXMgIEFuIGFycmF5IHRvIGFwcGVuZCByZXN1bHRpbmcgRXF1YXRpb25zIHRvLlxuICovXG5Jc2xhbmRNYW5hZ2VyLnByb3RvdHlwZS5iZnMgPSBmdW5jdGlvbihyb290LGJkcyxlcXMpe1xuXG4gICAgLy8gUmVzZXQgdGhlIHZpc2l0IHF1ZXVlXG4gICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZTtcbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xuXG4gICAgLy8gQWRkIHJvb3Qgbm9kZSB0byBxdWV1ZVxuICAgIHF1ZXVlLnB1c2gocm9vdCk7XG4gICAgcm9vdC52aXNpdGVkID0gdHJ1ZTtcbiAgICB0aGlzLnZpc2l0KHJvb3QsYmRzLGVxcyk7XG5cbiAgICAvLyBQcm9jZXNzIGFsbCBxdWV1ZWQgbm9kZXNcbiAgICB3aGlsZShxdWV1ZS5sZW5ndGgpIHtcblxuICAgICAgICAvLyBHZXQgbmV4dCBub2RlIGluIHRoZSBxdWV1ZVxuICAgICAgICB2YXIgbm9kZSA9IHF1ZXVlLnBvcCgpO1xuXG4gICAgICAgIC8vIFZpc2l0IHVudmlzaXRlZCBuZWlnaGJvcmluZyBub2Rlc1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIHdoaWxlKChjaGlsZCA9IElzbGFuZE1hbmFnZXIuZ2V0VW52aXNpdGVkTm9kZShub2RlLm5laWdoYm9ycykpKSB7XG4gICAgICAgICAgICBjaGlsZC52aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmlzaXQoY2hpbGQsYmRzLGVxcyk7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSBpZiBpdCdzIGR5bmFtaWNcbiAgICAgICAgICAgIGlmKGNoaWxkLmJvZHkudHlwZSA9PT0gQm9keS5EWU5BTUlDKXtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogU3BsaXQgdGhlIHdvcmxkIGludG8gaW5kZXBlbmRlbnQgaXNsYW5kcy4gVGhlIHJlc3VsdCBpcyBzdG9yZWQgaW4gLmlzbGFuZHMuXG4gKiBAbWV0aG9kIHNwbGl0XG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgZ2VuZXJhdGVkIGlzbGFuZHNcbiAqL1xuSXNsYW5kTWFuYWdlci5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIGJvZGllcyA9IHdvcmxkLmJvZGllcyxcbiAgICAgICAgbm9kZXMgPSB0aGlzLm5vZGVzLFxuICAgICAgICBlcXVhdGlvbnMgPSB0aGlzLmVxdWF0aW9ucztcblxuICAgIC8vIE1vdmUgb2xkIG5vZGVzIHRvIHRoZSBub2RlIHBvb2xcbiAgICB3aGlsZShub2Rlcy5sZW5ndGgpe1xuICAgICAgICB0aGlzLl9ub2RlUG9vbC5wdXNoKG5vZGVzLnBvcCgpKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbmVlZGVkIG5vZGVzLCByZXVzZSBpZiBwb3NzaWJsZVxuICAgIGZvcih2YXIgaT0wOyBpIT09Ym9kaWVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYodGhpcy5fbm9kZVBvb2wubGVuZ3RoKXtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZVBvb2wucG9wKCk7XG4gICAgICAgICAgICBub2RlLnJlc2V0KCk7XG4gICAgICAgICAgICBub2RlLmJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgSXNsYW5kTm9kZShib2RpZXNbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBjb25uZWN0aXZpdHkgZGF0YS4gRWFjaCBlcXVhdGlvbiBjb25uZWN0cyAyIGJvZGllcy5cbiAgICBmb3IodmFyIGs9MDsgayE9PWVxdWF0aW9ucy5sZW5ndGg7IGsrKyl7XG4gICAgICAgIHZhciBlcT1lcXVhdGlvbnNba10sXG4gICAgICAgICAgICBpPWJvZGllcy5pbmRleE9mKGVxLmJvZHlBKSxcbiAgICAgICAgICAgIGo9Ym9kaWVzLmluZGV4T2YoZXEuYm9keUIpLFxuICAgICAgICAgICAgbmk9bm9kZXNbaV0sXG4gICAgICAgICAgICBuaj1ub2Rlc1tqXTtcbiAgICAgICAgbmkubmVpZ2hib3JzLnB1c2gobmopO1xuICAgICAgICBuai5uZWlnaGJvcnMucHVzaChuaSk7XG4gICAgICAgIG5pLmVxdWF0aW9ucy5wdXNoKGVxKTtcbiAgICAgICAgbmouZXF1YXRpb25zLnB1c2goZXEpO1xuICAgIH1cblxuICAgIC8vIE1vdmUgb2xkIGlzbGFuZHMgdG8gdGhlIGlzbGFuZCBwb29sXG4gICAgdmFyIGlzbGFuZHMgPSB0aGlzLmlzbGFuZHM7XG4gICAgd2hpbGUoaXNsYW5kcy5sZW5ndGgpe1xuICAgICAgICB2YXIgaXNsYW5kID0gaXNsYW5kcy5wb3AoKTtcbiAgICAgICAgaXNsYW5kLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuX2lzbGFuZFBvb2wucHVzaChpc2xhbmQpO1xuICAgIH1cblxuICAgIC8vIEdldCBpc2xhbmRzXG4gICAgdmFyIGNoaWxkO1xuICAgIHdoaWxlKChjaGlsZCA9IElzbGFuZE1hbmFnZXIuZ2V0VW52aXNpdGVkTm9kZShub2RlcykpKXtcblxuICAgICAgICAvLyBDcmVhdGUgbmV3IGlzbGFuZFxuICAgICAgICB2YXIgaXNsYW5kID0gdGhpcy5faXNsYW5kUG9vbC5sZW5ndGggPyB0aGlzLl9pc2xhbmRQb29sLnBvcCgpIDogbmV3IElzbGFuZCgpO1xuXG4gICAgICAgIC8vIEdldCBhbGwgZXF1YXRpb25zIGFuZCBib2RpZXMgaW4gdGhpcyBpc2xhbmRcbiAgICAgICAgdGhpcy5iZnMoY2hpbGQsIGlzbGFuZC5ib2RpZXMsIGlzbGFuZC5lcXVhdGlvbnMpO1xuXG4gICAgICAgIGlzbGFuZHMucHVzaChpc2xhbmQpO1xuICAgIH1cblxuICAgIHJldHVybiBpc2xhbmRzO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4uL29iamVjdHMvQm9keVwiOjMyLFwiLi9Jc2xhbmRcIjo1MSxcIi4vSXNsYW5kTm9kZVwiOjUzfV0sNTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBJc2xhbmROb2RlO1xuXG4vKipcbiAqIEhvbGRzIGEgYm9keSBhbmQga2VlcHMgdHJhY2sgb2Ygc29tZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgbmVlZGVkIGZvciBncmFwaCB0cmF2ZXJzYWwuXG4gKiBAY2xhc3MgSXNsYW5kTm9kZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqL1xuZnVuY3Rpb24gSXNsYW5kTm9kZShib2R5KXtcblxuXHQvKipcblx0ICogVGhlIGJvZHkgdGhhdCBpcyBjb250YWluZWQgaW4gdGhpcyBub2RlLlxuXHQgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlcblx0ICovXG4gICAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAgIC8qKlxuICAgICAqIE5laWdoYm9yaW5nIElzbGFuZE5vZGVzXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gbmVpZ2hib3JzXG4gICAgICovXG4gICAgdGhpcy5uZWlnaGJvcnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEVxdWF0aW9ucyBjb25uZWN0ZWQgdG8gdGhpcyBub2RlLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGVxdWF0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuZXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIG5vZGUgd2FzIHZpc2l0aW5nIGR1cmluZyB0aGUgZ3JhcGggdHJhdmVyc2FsLlxuICAgICAqIEBwcm9wZXJ0eSB2aXNpdGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy52aXNpdGVkID0gZmFsc2U7XG59XG5cbi8qKlxuICogQ2xlYW4gdGhpcyBub2RlIGZyb20gYm9kaWVzIGFuZCBlcXVhdGlvbnMuXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cbklzbGFuZE5vZGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmVxdWF0aW9ucy5sZW5ndGggPSAwO1xuICAgIHRoaXMubmVpZ2hib3JzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy52aXNpdGVkID0gZmFsc2U7XG4gICAgdGhpcy5ib2R5ID0gbnVsbDtcbn07XG5cbn0se31dLDU0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qIGdsb2JhbCBwZXJmb3JtYW5jZSAqL1xuLypqc2hpbnQgLVcwMjAgKi9cblxudmFyICBHU1NvbHZlciA9IF9kZXJlcV8oJy4uL3NvbHZlci9HU1NvbHZlcicpXG4sICAgIFNvbHZlciA9IF9kZXJlcV8oJy4uL3NvbHZlci9Tb2x2ZXInKVxuLCAgICBOYWl2ZUJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlJylcbiwgICAgUmF5ID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1JheScpXG4sICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgICBDaXJjbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvQ2lyY2xlJylcbiwgICAgUmVjdGFuZ2xlID0gX2RlcmVxXygnLi4vc2hhcGVzL1JlY3RhbmdsZScpXG4sICAgIENvbnZleCA9IF9kZXJlcV8oJy4uL3NoYXBlcy9Db252ZXgnKVxuLCAgICBMaW5lID0gX2RlcmVxXygnLi4vc2hhcGVzL0xpbmUnKVxuLCAgICBQbGFuZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9QbGFuZScpXG4sICAgIENhcHN1bGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvQ2Fwc3VsZScpXG4sICAgIFBhcnRpY2xlID0gX2RlcmVxXygnLi4vc2hhcGVzL1BhcnRpY2xlJylcbiwgICAgRXZlbnRFbWl0dGVyID0gX2RlcmVxXygnLi4vZXZlbnRzL0V2ZW50RW1pdHRlcicpXG4sICAgIEJvZHkgPSBfZGVyZXFfKCcuLi9vYmplY3RzL0JvZHknKVxuLCAgICBTaGFwZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9TaGFwZScpXG4sICAgIExpbmVhclNwcmluZyA9IF9kZXJlcV8oJy4uL29iamVjdHMvTGluZWFyU3ByaW5nJylcbiwgICAgTWF0ZXJpYWwgPSBfZGVyZXFfKCcuLi9tYXRlcmlhbC9NYXRlcmlhbCcpXG4sICAgIENvbnRhY3RNYXRlcmlhbCA9IF9kZXJlcV8oJy4uL21hdGVyaWFsL0NvbnRhY3RNYXRlcmlhbCcpXG4sICAgIERpc3RhbmNlQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL0Rpc3RhbmNlQ29uc3RyYWludCcpXG4sICAgIENvbnN0cmFpbnQgPSBfZGVyZXFfKCcuLi9jb25zdHJhaW50cy9Db25zdHJhaW50JylcbiwgICAgTG9ja0NvbnN0cmFpbnQgPSBfZGVyZXFfKCcuLi9jb25zdHJhaW50cy9Mb2NrQ29uc3RyYWludCcpXG4sICAgIFJldm9sdXRlQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL1Jldm9sdXRlQ29uc3RyYWludCcpXG4sICAgIFByaXNtYXRpY0NvbnN0cmFpbnQgPSBfZGVyZXFfKCcuLi9jb25zdHJhaW50cy9QcmlzbWF0aWNDb25zdHJhaW50JylcbiwgICAgR2VhckNvbnN0cmFpbnQgPSBfZGVyZXFfKCcuLi9jb25zdHJhaW50cy9HZWFyQ29uc3RyYWludCcpXG4sICAgIHBrZyA9IF9kZXJlcV8oJy4uLy4uL3BhY2thZ2UuanNvbicpXG4sICAgIEJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpXG4sICAgIFNBUEJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vU0FQQnJvYWRwaGFzZScpXG4sICAgIE5hcnJvd3BoYXNlID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL05hcnJvd3BoYXNlJylcbiwgICAgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpXG4sICAgIE92ZXJsYXBLZWVwZXIgPSBfZGVyZXFfKCcuLi91dGlscy9PdmVybGFwS2VlcGVyJylcbiwgICAgSXNsYW5kTWFuYWdlciA9IF9kZXJlcV8oJy4vSXNsYW5kTWFuYWdlcicpXG4sICAgIFJvdGF0aW9uYWxTcHJpbmcgPSBfZGVyZXFfKCcuLi9vYmplY3RzL1JvdGF0aW9uYWxTcHJpbmcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXb3JsZDtcblxuaWYodHlwZW9mIHBlcmZvcm1hbmNlID09PSAndW5kZWZpbmVkJyl7XG4gICAgcGVyZm9ybWFuY2UgPSB7fTtcbn1cbmlmKCFwZXJmb3JtYW5jZS5ub3cpe1xuICAgIHZhciBub3dPZmZzZXQgPSBEYXRlLm5vdygpO1xuICAgIGlmIChwZXJmb3JtYW5jZS50aW1pbmcgJiYgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCl7XG4gICAgICAgIG5vd09mZnNldCA9IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQ7XG4gICAgfVxuICAgIHBlcmZvcm1hbmNlLm5vdyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbm93T2Zmc2V0O1xuICAgIH07XG59XG5cbi8qKlxuICogVGhlIGR5bmFtaWNzIHdvcmxkLCB3aGVyZSBhbGwgYm9kaWVzIGFuZCBjb25zdHJhaW50cyBsaXZlcy5cbiAqXG4gKiBAY2xhc3MgV29ybGRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgIFtvcHRpb25zXVxuICogQHBhcmFtIHtTb2x2ZXJ9ICAgICAgICAgIFtvcHRpb25zLnNvbHZlcl0gICAgICAgICAgICBEZWZhdWx0cyB0byBHU1NvbHZlci5cbiAqIEBwYXJhbSB7QXJyYXl9ICAgICAgICAgICBbb3B0aW9ucy5ncmF2aXR5XSAgICAgICAgICAgRGVmYXVsdHMgdG8gWzAsLTkuNzhdXG4gKiBAcGFyYW0ge0Jyb2FkcGhhc2V9ICAgICAgW29wdGlvbnMuYnJvYWRwaGFzZV0gICAgICAgIERlZmF1bHRzIHRvIE5haXZlQnJvYWRwaGFzZVxuICogQHBhcmFtIHtCb29sZWFufSAgICAgICAgIFtvcHRpb25zLmlzbGFuZFNwbGl0PWZhbHNlXVxuICogQHBhcmFtIHtCb29sZWFufSAgICAgICAgIFtvcHRpb25zLmRvUHJvZmlsaW5nPWZhbHNlXVxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgd29ybGQgPSBuZXcgV29ybGQoe1xuICogICAgICAgICBncmF2aXR5OiBbMCwgLTkuODFdLFxuICogICAgICAgICBicm9hZHBoYXNlOiBuZXcgU0FQQnJvYWRwaGFzZSgpXG4gKiAgICAgfSk7XG4gKi9cbmZ1bmN0aW9uIFdvcmxkKG9wdGlvbnMpe1xuICAgIEV2ZW50RW1pdHRlci5hcHBseSh0aGlzKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQWxsIHNwcmluZ3MgaW4gdGhlIHdvcmxkLiBUbyBhZGQgYSBzcHJpbmcgdG8gdGhlIHdvcmxkLCB1c2Uge3sjY3Jvc3NMaW5rIFwiV29ybGQvYWRkU3ByaW5nOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBzcHJpbmdzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuc3ByaW5ncyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQWxsIGJvZGllcyBpbiB0aGUgd29ybGQuIFRvIGFkZCBhIGJvZHkgdG8gdGhlIHdvcmxkLCB1c2Uge3sjY3Jvc3NMaW5rIFwiV29ybGQvYWRkQm9keTptZXRob2RcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gYm9kaWVzXG4gICAgICovXG4gICAgdGhpcy5ib2RpZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIERpc2FibGVkIGJvZHkgY29sbGlzaW9uIHBhaXJzLiBTZWUge3sjY3Jvc3NMaW5rIFwiV29ybGQvZGlzYWJsZUJvZHlDb2xsaXNpb246bWV0aG9kXCJ9fS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzXG4gICAgICovXG4gICAgdGhpcy5kaXNhYmxlZEJvZHlDb2xsaXNpb25QYWlycyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNvbHZlciB1c2VkIHRvIHNhdGlzZnkgY29uc3RyYWludHMgYW5kIGNvbnRhY3RzLiBEZWZhdWx0IGlzIHt7I2Nyb3NzTGluayBcIkdTU29sdmVyXCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqIEBwcm9wZXJ0eSB7U29sdmVyfSBzb2x2ZXJcbiAgICAgKi9cbiAgICB0aGlzLnNvbHZlciA9IG9wdGlvbnMuc29sdmVyIHx8IG5ldyBHU1NvbHZlcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hcnJvd3BoYXNlIHRvIHVzZSB0byBnZW5lcmF0ZSBjb250YWN0cy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBuYXJyb3dwaGFzZVxuICAgICAqIEB0eXBlIHtOYXJyb3dwaGFzZX1cbiAgICAgKi9cbiAgICB0aGlzLm5hcnJvd3BoYXNlID0gbmV3IE5hcnJvd3BoYXNlKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGlzbGFuZCBtYW5hZ2VyIG9mIHRoaXMgd29ybGQuXG4gICAgICogQHByb3BlcnR5IHtJc2xhbmRNYW5hZ2VyfSBpc2xhbmRNYW5hZ2VyXG4gICAgICovXG4gICAgdGhpcy5pc2xhbmRNYW5hZ2VyID0gbmV3IElzbGFuZE1hbmFnZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEdyYXZpdHkgaW4gdGhlIHdvcmxkLiBUaGlzIGlzIGFwcGxpZWQgb24gYWxsIGJvZGllcyBpbiB0aGUgYmVnaW5uaW5nIG9mIGVhY2ggc3RlcCgpLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGdyYXZpdHlcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5ncmF2aXR5ID0gdmVjMi5mcm9tVmFsdWVzKDAsIC05Ljc4KTtcbiAgICBpZihvcHRpb25zLmdyYXZpdHkpe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy5ncmF2aXR5LCBvcHRpb25zLmdyYXZpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdyYXZpdHkgdG8gdXNlIHdoZW4gYXBwcm94aW1hdGluZyB0aGUgZnJpY3Rpb24gbWF4IGZvcmNlIChtdSptYXNzKmdyYXZpdHkpLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBmcmljdGlvbkdyYXZpdHlcbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uR3Jhdml0eSA9IHZlYzIubGVuZ3RoKHRoaXMuZ3Jhdml0eSkgfHwgMTA7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCAuZnJpY3Rpb25HcmF2aXR5IHRvIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIHRoZSBsZW5ndGggb2YgLmdyYXZpdHkuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSB1c2VXb3JsZEdyYXZpdHlBc0ZyaWN0aW9uR3Jhdml0eVxuICAgICAqL1xuICAgIHRoaXMudXNlV29ybGRHcmF2aXR5QXNGcmljdGlvbkdyYXZpdHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGxlbmd0aCBvZiAuZ3Jhdml0eSBpcyB6ZXJvLCBhbmQgLnVzZVdvcmxkR3Jhdml0eUFzRnJpY3Rpb25HcmF2aXR5PXRydWUsIHRoZW4gc3dpdGNoIHRvIHVzaW5nIC5mcmljdGlvbkdyYXZpdHkgZm9yIGZyaWN0aW9uIGluc3RlYWQuIFRoaXMgZmFsbGJhY2sgaXMgdXNlZnVsIGZvciBncmF2aXR5bGVzcyBnYW1lcy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHVzZUZyaWN0aW9uR3Jhdml0eU9uWmVyb0dyYXZpdHlcbiAgICAgKi9cbiAgICB0aGlzLnVzZUZyaWN0aW9uR3Jhdml0eU9uWmVyb0dyYXZpdHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBkbyB0aW1pbmcgbWVhc3VyZW1lbnRzIGR1cmluZyB0aGUgc3RlcCgpIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBkb1BvZmlsaW5nXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5kb1Byb2ZpbGluZyA9IG9wdGlvbnMuZG9Qcm9maWxpbmcgfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBIb3cgbWFueSBtaWxsaXNlY2NvbmRzIHRoZSBsYXN0IHN0ZXAoKSB0b29rLiBUaGlzIGlzIHVwZGF0ZWQgZWFjaCBzdGVwIGlmIC5kb1Byb2ZpbGluZyBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBsYXN0U3RlcFRpbWVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGFzdFN0ZXBUaW1lID0gMC4wO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJyb2FkcGhhc2UgYWxnb3JpdGhtIHRvIHVzZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBicm9hZHBoYXNlXG4gICAgICogQHR5cGUge0Jyb2FkcGhhc2V9XG4gICAgICovXG4gICAgdGhpcy5icm9hZHBoYXNlID0gb3B0aW9ucy5icm9hZHBoYXNlIHx8IG5ldyBTQVBCcm9hZHBoYXNlKCk7XG4gICAgdGhpcy5icm9hZHBoYXNlLnNldFdvcmxkKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogVXNlci1hZGRlZCBjb25zdHJhaW50cy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjb25zdHJhaW50c1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnN0cmFpbnRzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBEdW1teSBkZWZhdWx0IG1hdGVyaWFsIGluIHRoZSB3b3JsZCwgdXNlZCBpbiAuZGVmYXVsdENvbnRhY3RNYXRlcmlhbFxuICAgICAqIEBwcm9wZXJ0eSB7TWF0ZXJpYWx9IGRlZmF1bHRNYXRlcmlhbFxuICAgICAqL1xuICAgIHRoaXMuZGVmYXVsdE1hdGVyaWFsID0gbmV3IE1hdGVyaWFsKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBjb250YWN0IG1hdGVyaWFsIHRvIHVzZSwgaWYgbm8gY29udGFjdCBtYXRlcmlhbCB3YXMgc2V0IGZvciB0aGUgY29sbGlkaW5nIG1hdGVyaWFscy5cbiAgICAgKiBAcHJvcGVydHkge0NvbnRhY3RNYXRlcmlhbH0gZGVmYXVsdENvbnRhY3RNYXRlcmlhbFxuICAgICAqL1xuICAgIHRoaXMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbCA9IG5ldyBDb250YWN0TWF0ZXJpYWwodGhpcy5kZWZhdWx0TWF0ZXJpYWwsdGhpcy5kZWZhdWx0TWF0ZXJpYWwpO1xuXG4gICAgLyoqXG4gICAgICogRm9yIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCB0aW1lIHN0ZXAgc2l6ZSB3ZSB1c2VkIGxhc3Qgc3RlcFxuICAgICAqIEBwcm9wZXJ0eSBsYXN0VGltZVN0ZXBcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGFzdFRpbWVTdGVwID0gMS82MDtcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSB0byBhdXRvbWF0aWNhbGx5IGFwcGx5IHNwcmluZyBmb3JjZXMgZWFjaCBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSBhcHBseVNwcmluZ0ZvcmNlc1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYXBwbHlTcHJpbmdGb3JjZXMgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHkgYm9keSBkYW1waW5nIGVhY2ggc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgYXBwbHlEYW1waW5nXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hcHBseURhbXBpbmcgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHkgZ3Jhdml0eSBlYWNoIHN0ZXAuXG4gICAgICogQHByb3BlcnR5IGFwcGx5R3Jhdml0eVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYXBwbHlHcmF2aXR5ID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZS9kaXNhYmxlIGNvbnN0cmFpbnQgc29sdmluZyBpbiBlYWNoIHN0ZXAuXG4gICAgICogQHByb3BlcnR5IHNvbHZlQ29uc3RyYWludHNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNvbHZlQ29uc3RyYWludHMgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIENvbnRhY3RNYXRlcmlhbHMgYWRkZWQgdG8gdGhlIFdvcmxkLlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0TWF0ZXJpYWxzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdE1hdGVyaWFscyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogV29ybGQgdGltZS5cbiAgICAgKiBAcHJvcGVydHkgdGltZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aW1lID0gMC4wO1xuXG4gICAgLyoqXG4gICAgICogSXMgdHJ1ZSBkdXJpbmcgdGhlIHN0ZXAoKS5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHN0ZXBwaW5nXG4gICAgICovXG4gICAgdGhpcy5zdGVwcGluZyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQm9kaWVzIHRoYXQgYXJlIHNjaGVkdWxlZCB0byBiZSByZW1vdmVkIGF0IHRoZSBlbmQgb2YgdGhlIHN0ZXAuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gYm9kaWVzVG9CZVJlbW92ZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYm9kaWVzVG9CZVJlbW92ZWQgPSBbXTtcblxuICAgIHRoaXMuZml4ZWRTdGVwVGltZSA9IDAuMDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gZW5hYmxlIGlzbGFuZCBzcGxpdHRpbmcuIElzbGFuZCBzcGxpdHRpbmcgY2FuIGJlIGFuIGFkdmFudGFnZSBmb3IgbWFueSB0aGluZ3MsIGluY2x1ZGluZyBzb2x2ZXIgcGVyZm9ybWFuY2UuIFNlZSB7eyNjcm9zc0xpbmsgXCJJc2xhbmRNYW5hZ2VyXCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNsYW5kU3BsaXRcbiAgICAgKi9cbiAgICB0aGlzLmlzbGFuZFNwbGl0ID0gdHlwZW9mKG9wdGlvbnMuaXNsYW5kU3BsaXQpIT09XCJ1bmRlZmluZWRcIiA/ICEhb3B0aW9ucy5pc2xhbmRTcGxpdCA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gdGhlIHdvcmxkIHRvIGVtaXQgdGhlIFwiaW1wYWN0XCIgZXZlbnQuIFR1cm5pbmcgdGhpcyBvZmYgY291bGQgaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAgICAgKiBAcHJvcGVydHkgZW1pdEltcGFjdEV2ZW50XG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5lbWl0SW1wYWN0RXZlbnQgPSB0cnVlO1xuXG4gICAgLy8gSWQgY291bnRlcnNcbiAgICB0aGlzLl9jb25zdHJhaW50SWRDb3VudGVyID0gMDtcbiAgICB0aGlzLl9ib2R5SWRDb3VudGVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGFmdGVyIHRoZSBzdGVwKCkuXG4gICAgICogQGV2ZW50IHBvc3RTdGVwXG4gICAgICovXG4gICAgdGhpcy5wb3N0U3RlcEV2ZW50ID0ge1xuICAgICAgICB0eXBlIDogXCJwb3N0U3RlcFwiLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgYm9keSBpcyBhZGRlZCB0byB0aGUgd29ybGQuXG4gICAgICogQGV2ZW50IGFkZEJvZHlcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAgICAgKi9cbiAgICB0aGlzLmFkZEJvZHlFdmVudCA9IHtcbiAgICAgICAgdHlwZSA6IFwiYWRkQm9keVwiLFxuICAgICAgICBib2R5IDogbnVsbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgYm9keSBpcyByZW1vdmVkIGZyb20gdGhlIHdvcmxkLlxuICAgICAqIEBldmVudCByZW1vdmVCb2R5XG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5XG4gICAgICovXG4gICAgdGhpcy5yZW1vdmVCb2R5RXZlbnQgPSB7XG4gICAgICAgIHR5cGUgOiBcInJlbW92ZUJvZHlcIixcbiAgICAgICAgYm9keSA6IG51bGxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBhIHNwcmluZyBpcyBhZGRlZCB0byB0aGUgd29ybGQuXG4gICAgICogQGV2ZW50IGFkZFNwcmluZ1xuICAgICAqIEBwYXJhbSB7U3ByaW5nfSBzcHJpbmdcbiAgICAgKi9cbiAgICB0aGlzLmFkZFNwcmluZ0V2ZW50ID0ge1xuICAgICAgICB0eXBlIDogXCJhZGRTcHJpbmdcIixcbiAgICAgICAgc3ByaW5nIDogbnVsbCxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBhIGZpcnN0IGNvbnRhY3QgaXMgY3JlYXRlZCBiZXR3ZWVuIHR3byBib2RpZXMuIFRoaXMgZXZlbnQgaXMgZmlyZWQgYWZ0ZXIgdGhlIHN0ZXAgaGFzIGJlZW4gZG9uZS5cbiAgICAgKiBAZXZlbnQgaW1wYWN0XG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAgICAgKi9cbiAgICB0aGlzLmltcGFjdEV2ZW50ID0ge1xuICAgICAgICB0eXBlOiBcImltcGFjdFwiLFxuICAgICAgICBib2R5QSA6IG51bGwsXG4gICAgICAgIGJvZHlCIDogbnVsbCxcbiAgICAgICAgc2hhcGVBIDogbnVsbCxcbiAgICAgICAgc2hhcGVCIDogbnVsbCxcbiAgICAgICAgY29udGFjdEVxdWF0aW9uIDogbnVsbCxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgYWZ0ZXIgdGhlIEJyb2FkcGhhc2UgaGFzIGNvbGxlY3RlZCBjb2xsaXNpb24gcGFpcnMgaW4gdGhlIHdvcmxkLlxuICAgICAqIEluc2lkZSB0aGUgZXZlbnQgaGFuZGxlciwgeW91IGNhbiBtb2RpZnkgdGhlIHBhaXJzIGFycmF5IGFzIHlvdSBsaWtlLCB0b1xuICAgICAqIHByZXZlbnQgY29sbGlzaW9ucyBiZXR3ZWVuIG9iamVjdHMgdGhhdCB5b3UgZG9uJ3Qgd2FudC5cbiAgICAgKiBAZXZlbnQgcG9zdEJyb2FkcGhhc2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBBbiBhcnJheSBvZiBjb2xsaXNpb24gcGFpcnMuIElmIHRoaXMgYXJyYXkgaXMgW2JvZHkxLGJvZHkyLGJvZHkzLGJvZHk0XSwgdGhlbiB0aGUgYm9keSBwYWlycyAxLDIgYW5kIDMsNCB3b3VsZCBhZHZhbmNlIHRvIG5hcnJvd3BoYXNlLlxuICAgICAqL1xuICAgIHRoaXMucG9zdEJyb2FkcGhhc2VFdmVudCA9IHtcbiAgICAgICAgdHlwZTpcInBvc3RCcm9hZHBoYXNlXCIsXG4gICAgICAgIHBhaXJzOm51bGwsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhvdyB0byBkZWFjdGl2YXRlIGJvZGllcyBkdXJpbmcgc2ltdWxhdGlvbi4gUG9zc2libGUgbW9kZXMgYXJlOiB7eyNjcm9zc0xpbmsgXCJXb3JsZC9OT19TTEVFUElORzpwcm9wZXJ0eVwifX1Xb3JsZC5OT19TTEVFUElOR3t7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJXb3JsZC9CT0RZX1NMRUVQSU5HOnByb3BlcnR5XCJ9fVdvcmxkLkJPRFlfU0xFRVBJTkd7ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiV29ybGQvSVNMQU5EX1NMRUVQSU5HOnByb3BlcnR5XCJ9fVdvcmxkLklTTEFORF9TTEVFUElOR3t7L2Nyb3NzTGlua319LlxuICAgICAqIElmIHNsZWVwaW5nIGlzIGVuYWJsZWQsIHlvdSBtaWdodCBuZWVkIHRvIHt7I2Nyb3NzTGluayBcIkJvZHkvd2FrZVVwOm1ldGhvZFwifX13YWtlIHVwe3svY3Jvc3NMaW5rfX0gdGhlIGJvZGllcyBpZiB0aGV5IGZhbGwgYXNsZWVwIHdoZW4gdGhleSBzaG91bGRuJ3QuIElmIHlvdSB3YW50IHRvIGVuYWJsZSBzbGVlcGluZyBpbiB0aGUgd29ybGQsIGJ1dCB3YW50IHRvIGRpc2FibGUgaXQgZm9yIGEgcGFydGljdWxhciBib2R5LCBzZWUge3sjY3Jvc3NMaW5rIFwiQm9keS9hbGxvd1NsZWVwOnByb3BlcnR5XCJ9fUJvZHkuYWxsb3dTbGVlcHt7L2Nyb3NzTGlua319LlxuICAgICAqIEBwcm9wZXJ0eSBzbGVlcE1vZGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IFdvcmxkLk5PX1NMRUVQSU5HXG4gICAgICovXG4gICAgdGhpcy5zbGVlcE1vZGUgPSBXb3JsZC5OT19TTEVFUElORztcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdHdvIHNoYXBlcyBzdGFydHMgc3RhcnQgdG8gb3ZlcmxhcC4gRmlyZWQgaW4gdGhlIG5hcnJvd3BoYXNlLCBkdXJpbmcgc3RlcC5cbiAgICAgKiBAZXZlbnQgYmVnaW5Db250YWN0XG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVBXG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXG4gICAgICogQHBhcmFtIHtCb2R5fSAgYm9keUFcbiAgICAgKiBAcGFyYW0ge0JvZHl9ICBib2R5QlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbnRhY3RFcXVhdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmJlZ2luQ29udGFjdEV2ZW50ID0ge1xuICAgICAgICB0eXBlOlwiYmVnaW5Db250YWN0XCIsXG4gICAgICAgIHNoYXBlQSA6IG51bGwsXG4gICAgICAgIHNoYXBlQiA6IG51bGwsXG4gICAgICAgIGJvZHlBIDogbnVsbCxcbiAgICAgICAgYm9keUIgOiBudWxsLFxuICAgICAgICBjb250YWN0RXF1YXRpb25zIDogW10sXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdHdvIHNoYXBlcyBzdG9wIG92ZXJsYXBwaW5nLCBhZnRlciB0aGUgbmFycm93cGhhc2UgKGR1cmluZyBzdGVwKS5cbiAgICAgKiBAZXZlbnQgZW5kQ29udGFjdFxuICAgICAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxuICAgICAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQlxuICAgICAqIEBwYXJhbSB7Qm9keX0gIGJvZHlBXG4gICAgICogQHBhcmFtIHtCb2R5fSAgYm9keUJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb250YWN0RXF1YXRpb25zXG4gICAgICovXG4gICAgdGhpcy5lbmRDb250YWN0RXZlbnQgPSB7XG4gICAgICAgIHR5cGU6XCJlbmRDb250YWN0XCIsXG4gICAgICAgIHNoYXBlQSA6IG51bGwsXG4gICAgICAgIHNoYXBlQiA6IG51bGwsXG4gICAgICAgIGJvZHlBIDogbnVsbCxcbiAgICAgICAgYm9keUIgOiBudWxsLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBqdXN0IGJlZm9yZSBlcXVhdGlvbnMgYXJlIGFkZGVkIHRvIHRoZSBzb2x2ZXIgdG8gYmUgc29sdmVkLiBDYW4gYmUgdXNlZCB0byBjb250cm9sIHdoYXQgZXF1YXRpb25zIGdvZXMgaW50byB0aGUgc29sdmVyLlxuICAgICAqIEBldmVudCBwcmVTb2x2ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbnRhY3RFcXVhdGlvbnMgIEFuIGFycmF5IG9mIGNvbnRhY3RzIHRvIGJlIHNvbHZlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmcmljdGlvbkVxdWF0aW9ucyBBbiBhcnJheSBvZiBmcmljdGlvbiBlcXVhdGlvbnMgdG8gYmUgc29sdmVkLlxuICAgICAqL1xuICAgIHRoaXMucHJlU29sdmVFdmVudCA9IHtcbiAgICAgICAgdHlwZTpcInByZVNvbHZlXCIsXG4gICAgICAgIGNvbnRhY3RFcXVhdGlvbnM6bnVsbCxcbiAgICAgICAgZnJpY3Rpb25FcXVhdGlvbnM6bnVsbCxcbiAgICB9O1xuXG4gICAgLy8gRm9yIGtlZXBpbmcgdHJhY2sgb2Ygb3ZlcmxhcHBpbmcgc2hhcGVzXG4gICAgdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZSA9IHsga2V5czpbXSB9O1xuICAgIHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGUgPSB7IGtleXM6W10gfTtcblxuICAgIHRoaXMub3ZlcmxhcEtlZXBlciA9IG5ldyBPdmVybGFwS2VlcGVyKCk7XG59XG5Xb3JsZC5wcm90b3R5cGUgPSBuZXcgT2JqZWN0KEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuV29ybGQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV29ybGQ7XG5cbi8qKlxuICogTmV2ZXIgZGVhY3RpdmF0ZSBib2RpZXMuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gTk9fU0xFRVBJTkdcbiAqL1xuV29ybGQuTk9fU0xFRVBJTkcgPSAxO1xuXG4vKipcbiAqIERlYWN0aXZhdGUgaW5kaXZpZHVhbCBib2RpZXMgaWYgdGhleSBhcmUgc2xlZXB5LlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IEJPRFlfU0xFRVBJTkdcbiAqL1xuV29ybGQuQk9EWV9TTEVFUElORyA9IDI7XG5cbi8qKlxuICogRGVhY3RpdmF0ZXMgYm9kaWVzIHRoYXQgYXJlIGluIGNvbnRhY3QsIGlmIGFsbCBvZiB0aGVtIGFyZSBzbGVlcHkuIE5vdGUgdGhhdCB5b3UgbXVzdCBlbmFibGUge3sjY3Jvc3NMaW5rIFwiV29ybGQvaXNsYW5kU3BsaXQ6cHJvcGVydHlcIn19LmlzbGFuZFNwbGl0e3svY3Jvc3NMaW5rfX0gZm9yIHRoaXMgdG8gd29yay5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJU0xBTkRfU0xFRVBJTkdcbiAqL1xuV29ybGQuSVNMQU5EX1NMRUVQSU5HID0gNDtcblxuLyoqXG4gKiBBZGQgYSBjb25zdHJhaW50IHRvIHRoZSBzaW11bGF0aW9uLlxuICpcbiAqIEBtZXRob2QgYWRkQ29uc3RyYWludFxuICogQHBhcmFtIHtDb25zdHJhaW50fSBjXG4gKi9cbldvcmxkLnByb3RvdHlwZS5hZGRDb25zdHJhaW50ID0gZnVuY3Rpb24oYyl7XG4gICAgdGhpcy5jb25zdHJhaW50cy5wdXNoKGMpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBDb250YWN0TWF0ZXJpYWwgdG8gdGhlIHNpbXVsYXRpb24uXG4gKiBAbWV0aG9kIGFkZENvbnRhY3RNYXRlcmlhbFxuICogQHBhcmFtIHtDb250YWN0TWF0ZXJpYWx9IGNvbnRhY3RNYXRlcmlhbFxuICovXG5Xb3JsZC5wcm90b3R5cGUuYWRkQ29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24oY29udGFjdE1hdGVyaWFsKXtcbiAgICB0aGlzLmNvbnRhY3RNYXRlcmlhbHMucHVzaChjb250YWN0TWF0ZXJpYWwpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgY29udGFjdCBtYXRlcmlhbFxuICpcbiAqIEBtZXRob2QgcmVtb3ZlQ29udGFjdE1hdGVyaWFsXG4gKiBAcGFyYW0ge0NvbnRhY3RNYXRlcmlhbH0gY21cbiAqL1xuV29ybGQucHJvdG90eXBlLnJlbW92ZUNvbnRhY3RNYXRlcmlhbCA9IGZ1bmN0aW9uKGNtKXtcbiAgICB2YXIgaWR4ID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzLmluZGV4T2YoY20pO1xuICAgIGlmKGlkeCE9PS0xKXtcbiAgICAgICAgVXRpbHMuc3BsaWNlKHRoaXMuY29udGFjdE1hdGVyaWFscyxpZHgsMSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgYSBjb250YWN0IG1hdGVyaWFsIGdpdmVuIHR3byBtYXRlcmlhbHNcbiAqIEBtZXRob2QgZ2V0Q29udGFjdE1hdGVyaWFsXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBtYXRlcmlhbEFcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1hdGVyaWFsQlxuICogQHJldHVybiB7Q29udGFjdE1hdGVyaWFsfSBUaGUgbWF0Y2hpbmcgQ29udGFjdE1hdGVyaWFsLCBvciBmYWxzZSBvbiBmYWlsLlxuICogQHRvZG8gVXNlIGZhc3RlciBoYXNoIG1hcCB0byBsb29rdXAgZnJvbSBtYXRlcmlhbCBpZCdzXG4gKi9cbldvcmxkLnByb3RvdHlwZS5nZXRDb250YWN0TWF0ZXJpYWwgPSBmdW5jdGlvbihtYXRlcmlhbEEsbWF0ZXJpYWxCKXtcbiAgICB2YXIgY21hdHMgPSB0aGlzLmNvbnRhY3RNYXRlcmlhbHM7XG4gICAgZm9yKHZhciBpPTAsIE49Y21hdHMubGVuZ3RoOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGNtID0gY21hdHNbaV07XG4gICAgICAgIGlmKCAoY20ubWF0ZXJpYWxBLmlkID09PSBtYXRlcmlhbEEuaWQpICYmIChjbS5tYXRlcmlhbEIuaWQgPT09IG1hdGVyaWFsQi5pZCkgfHxcbiAgICAgICAgICAgIChjbS5tYXRlcmlhbEEuaWQgPT09IG1hdGVyaWFsQi5pZCkgJiYgKGNtLm1hdGVyaWFsQi5pZCA9PT0gbWF0ZXJpYWxBLmlkKSApe1xuICAgICAgICAgICAgcmV0dXJuIGNtO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGNvbnN0cmFpbnRcbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUNvbnN0cmFpbnRcbiAqIEBwYXJhbSB7Q29uc3RyYWludH0gY1xuICovXG5Xb3JsZC5wcm90b3R5cGUucmVtb3ZlQ29uc3RyYWludCA9IGZ1bmN0aW9uKGMpe1xuICAgIHZhciBpZHggPSB0aGlzLmNvbnN0cmFpbnRzLmluZGV4T2YoYyk7XG4gICAgaWYoaWR4IT09LTEpe1xuICAgICAgICBVdGlscy5zcGxpY2UodGhpcy5jb25zdHJhaW50cyxpZHgsMSk7XG4gICAgfVxufTtcblxudmFyIHN0ZXBfciA9IHZlYzIuY3JlYXRlKCksXG4gICAgc3RlcF9ydW5pdCA9IHZlYzIuY3JlYXRlKCksXG4gICAgc3RlcF91ID0gdmVjMi5jcmVhdGUoKSxcbiAgICBzdGVwX2YgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHN0ZXBfZmhNaW52ID0gdmVjMi5jcmVhdGUoKSxcbiAgICBzdGVwX3ZlbG9kdCA9IHZlYzIuY3JlYXRlKCksXG4gICAgc3RlcF9tZyA9IHZlYzIuY3JlYXRlKCksXG4gICAgeGl3ID0gdmVjMi5mcm9tVmFsdWVzKDAsMCksXG4gICAgeGp3ID0gdmVjMi5mcm9tVmFsdWVzKDAsMCksXG4gICAgemVybyA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgIGludGVycHZlbG8gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuLyoqXG4gKiBTdGVwIHRoZSBwaHlzaWNzIHdvcmxkIGZvcndhcmQgaW4gdGltZS5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIG1vZGVzLiBUaGUgc2ltcGxlIG1vZGUgaXMgZml4ZWQgdGltZXN0ZXBwaW5nIHdpdGhvdXQgaW50ZXJwb2xhdGlvbi4gSW4gdGhpcyBjYXNlIHlvdSBvbmx5IHVzZSB0aGUgZmlyc3QgYXJndW1lbnQuIFRoZSBzZWNvbmQgY2FzZSB1c2VzIGludGVycG9sYXRpb24uIEluIHRoYXQgeW91IGFsc28gcHJvdmlkZSB0aGUgdGltZSBzaW5jZSB0aGUgZnVuY3Rpb24gd2FzIGxhc3QgdXNlZCwgYXMgd2VsbCBhcyB0aGUgbWF4aW11bSBmaXhlZCB0aW1lc3RlcHMgdG8gdGFrZS5cbiAqXG4gKiBAbWV0aG9kIHN0ZXBcbiAqIEBwYXJhbSB7TnVtYmVyfSBkdCAgICAgICAgICAgICAgICAgICAgICAgVGhlIGZpeGVkIHRpbWUgc3RlcCBzaXplIHRvIHVzZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZVNpbmNlTGFzdENhbGxlZD0wXSAgVGhlIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgZnVuY3Rpb24gd2FzIGxhc3QgY2FsbGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IFttYXhTdWJTdGVwcz0xMF0gICAgICAgICBNYXhpbXVtIG51bWJlciBvZiBmaXhlZCBzdGVwcyB0byB0YWtlIHBlciBmdW5jdGlvbiBjYWxsLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gZml4ZWQgdGltZXN0ZXBwaW5nIHdpdGhvdXQgaW50ZXJwb2xhdGlvblxuICogICAgIHZhciB3b3JsZCA9IG5ldyBXb3JsZCgpO1xuICogICAgIHdvcmxkLnN0ZXAoMC4wMSk7XG4gKlxuICogQHNlZSBodHRwOi8vYnVsbGV0cGh5c2ljcy5vcmcvbWVkaWF3aWtpLTEuNS44L2luZGV4LnBocC9TdGVwcGluZ19UaGVfV29ybGRcbiAqL1xuV29ybGQucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbihkdCx0aW1lU2luY2VMYXN0Q2FsbGVkLG1heFN1YlN0ZXBzKXtcbiAgICBtYXhTdWJTdGVwcyA9IG1heFN1YlN0ZXBzIHx8IDEwO1xuICAgIHRpbWVTaW5jZUxhc3RDYWxsZWQgPSB0aW1lU2luY2VMYXN0Q2FsbGVkIHx8IDA7XG5cbiAgICBpZih0aW1lU2luY2VMYXN0Q2FsbGVkID09PSAwKXsgLy8gRml4ZWQsIHNpbXBsZSBzdGVwcGluZ1xuXG4gICAgICAgIHRoaXMuaW50ZXJuYWxTdGVwKGR0KTtcblxuICAgICAgICAvLyBJbmNyZW1lbnQgdGltZVxuICAgICAgICB0aGlzLnRpbWUgKz0gZHQ7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIG51bWJlciBvZiBmaXhlZCBzdGVwcyB3ZSBzaG91bGQgaGF2ZSB0YWtlbiBzaW5jZSB0aGUgbGFzdCBzdGVwXG4gICAgICAgIHZhciBpbnRlcm5hbFN0ZXBzID0gTWF0aC5mbG9vciggKHRoaXMudGltZSt0aW1lU2luY2VMYXN0Q2FsbGVkKSAvIGR0KSAtIE1hdGguZmxvb3IodGhpcy50aW1lIC8gZHQpO1xuICAgICAgICBpbnRlcm5hbFN0ZXBzID0gTWF0aC5taW4oaW50ZXJuYWxTdGVwcyxtYXhTdWJTdGVwcyk7XG5cbiAgICAgICAgLy8gRG8gc29tZSBmaXhlZCBzdGVwcyB0byBjYXRjaCB1cFxuICAgICAgICB2YXIgdDAgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1pbnRlcm5hbFN0ZXBzOyBpKyspe1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFN0ZXAoZHQpO1xuICAgICAgICAgICAgaWYocGVyZm9ybWFuY2Uubm93KCkgLSB0MCA+IGR0KjEwMDApe1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBzbG93ZXIgdGhhbiByZWFsLXRpbWUuIEJldHRlciBiYWlsIG91dC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluY3JlbWVudCBpbnRlcm5hbCBjbG9ja1xuICAgICAgICB0aGlzLnRpbWUgKz0gdGltZVNpbmNlTGFzdENhbGxlZDtcblxuICAgICAgICAvLyBDb21wdXRlIFwiTGVmdCBvdmVyXCIgdGltZSBzdGVwXG4gICAgICAgIHZhciBoID0gdGhpcy50aW1lICUgZHQ7XG4gICAgICAgIHZhciBoX2Rpdl9kdCA9IGgvZHQ7XG5cbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT10aGlzLmJvZGllcy5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuYm9kaWVzW2pdO1xuICAgICAgICAgICAgaWYoYi50eXBlICE9PSBCb2R5LlNUQVRJQyAmJiBiLnNsZWVwU3RhdGUgIT09IEJvZHkuU0xFRVBJTkcpe1xuICAgICAgICAgICAgICAgIC8vIEludGVycG9sYXRlXG4gICAgICAgICAgICAgICAgdmVjMi5zdWIoaW50ZXJwdmVsbywgYi5wb3NpdGlvbiwgYi5wcmV2aW91c1Bvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB2ZWMyLnNjYWxlKGludGVycHZlbG8sIGludGVycHZlbG8sIGhfZGl2X2R0KTtcbiAgICAgICAgICAgICAgICB2ZWMyLmFkZChiLmludGVycG9sYXRlZFBvc2l0aW9uLCBiLnBvc2l0aW9uLCBpbnRlcnB2ZWxvKTtcblxuICAgICAgICAgICAgICAgIGIuaW50ZXJwb2xhdGVkQW5nbGUgPSBiLmFuZ2xlICsgKGIuYW5nbGUgLSBiLnByZXZpb3VzQW5nbGUpICogaF9kaXZfZHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZvciBzdGF0aWMgYm9kaWVzLCBqdXN0IGNvcHkuIFdobyBlbHNlIHdpbGwgZG8gaXQ/XG4gICAgICAgICAgICAgICAgdmVjMi5jb3B5KGIuaW50ZXJwb2xhdGVkUG9zaXRpb24sIGIucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGIuaW50ZXJwb2xhdGVkQW5nbGUgPSBiLmFuZ2xlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGVuZE92ZXJsYXBzID0gW107XG5cbi8qKlxuICogTWFrZSBhIGZpeGVkIHN0ZXAuXG4gKiBAbWV0aG9kIGludGVybmFsU3RlcFxuICogQHBhcmFtICB7bnVtYmVyfSBkdFxuICogQHByaXZhdGVcbiAqL1xuV29ybGQucHJvdG90eXBlLmludGVybmFsU3RlcCA9IGZ1bmN0aW9uKGR0KXtcbiAgICB0aGlzLnN0ZXBwaW5nID0gdHJ1ZTtcblxuICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgZG9Qcm9maWxpbmcgPSB0aGlzLmRvUHJvZmlsaW5nLFxuICAgICAgICBOc3ByaW5ncyA9IHRoaXMuc3ByaW5ncy5sZW5ndGgsXG4gICAgICAgIHNwcmluZ3MgPSB0aGlzLnNwcmluZ3MsXG4gICAgICAgIGJvZGllcyA9IHRoaXMuYm9kaWVzLFxuICAgICAgICBnID0gdGhpcy5ncmF2aXR5LFxuICAgICAgICBzb2x2ZXIgPSB0aGlzLnNvbHZlcixcbiAgICAgICAgTmJvZGllcyA9IHRoaXMuYm9kaWVzLmxlbmd0aCxcbiAgICAgICAgYnJvYWRwaGFzZSA9IHRoaXMuYnJvYWRwaGFzZSxcbiAgICAgICAgbnAgPSB0aGlzLm5hcnJvd3BoYXNlLFxuICAgICAgICBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHMsXG4gICAgICAgIHQwLCB0MSxcbiAgICAgICAgZmhNaW52ID0gc3RlcF9maE1pbnYsXG4gICAgICAgIHZlbG9kdCA9IHN0ZXBfdmVsb2R0LFxuICAgICAgICBtZyA9IHN0ZXBfbWcsXG4gICAgICAgIHNjYWxlID0gdmVjMi5zY2FsZSxcbiAgICAgICAgYWRkID0gdmVjMi5hZGQsXG4gICAgICAgIHJvdGF0ZSA9IHZlYzIucm90YXRlLFxuICAgICAgICBpc2xhbmRNYW5hZ2VyID0gdGhpcy5pc2xhbmRNYW5hZ2VyO1xuXG4gICAgdGhpcy5vdmVybGFwS2VlcGVyLnRpY2soKTtcblxuICAgIHRoaXMubGFzdFRpbWVTdGVwID0gZHQ7XG5cbiAgICBpZihkb1Byb2ZpbGluZyl7XG4gICAgICAgIHQwID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGFwcHJveGltYXRlIGZyaWN0aW9uIGdyYXZpdHkuXG4gICAgaWYodGhpcy51c2VXb3JsZEdyYXZpdHlBc0ZyaWN0aW9uR3Jhdml0eSl7XG4gICAgICAgIHZhciBncmF2aXR5TGVuID0gdmVjMi5sZW5ndGgodGhpcy5ncmF2aXR5KTtcbiAgICAgICAgaWYoIShncmF2aXR5TGVuID09PSAwICYmIHRoaXMudXNlRnJpY3Rpb25HcmF2aXR5T25aZXJvR3Jhdml0eSkpe1xuICAgICAgICAgICAgLy8gTm9uemVybyBncmF2aXR5LiBVc2UgaXQuXG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uR3Jhdml0eSA9IGdyYXZpdHlMZW47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgZ3Jhdml0eSB0byBib2RpZXNcbiAgICBpZih0aGlzLmFwcGx5R3Jhdml0eSl7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldLFxuICAgICAgICAgICAgICAgIGZpID0gYi5mb3JjZTtcbiAgICAgICAgICAgIGlmKGIudHlwZSAhPT0gQm9keS5EWU5BTUlDIHx8IGIuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyl7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ZWMyLnNjYWxlKG1nLGcsYi5tYXNzKmIuZ3Jhdml0eVNjYWxlKTsgLy8gRj1tKmdcbiAgICAgICAgICAgIGFkZChmaSxmaSxtZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgc3ByaW5nIGZvcmNlc1xuICAgIGlmKHRoaXMuYXBwbHlTcHJpbmdGb3JjZXMpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5zcHJpbmdzOyBpKyspe1xuICAgICAgICAgICAgdmFyIHMgPSBzcHJpbmdzW2ldO1xuICAgICAgICAgICAgcy5hcHBseUZvcmNlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0aGlzLmFwcGx5RGFtcGluZyl7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgaWYoYi50eXBlID09PSBCb2R5LkRZTkFNSUMpe1xuICAgICAgICAgICAgICAgIGIuYXBwbHlEYW1waW5nKGR0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJyb2FkcGhhc2VcbiAgICB2YXIgcmVzdWx0ID0gYnJvYWRwaGFzZS5nZXRDb2xsaXNpb25QYWlycyh0aGlzKTtcblxuICAgIC8vIFJlbW92ZSBpZ25vcmVkIGNvbGxpc2lvbiBwYWlyc1xuICAgIHZhciBpZ25vcmVkUGFpcnMgPSB0aGlzLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzO1xuICAgIGZvcih2YXIgaT1pZ25vcmVkUGFpcnMubGVuZ3RoLTI7IGk+PTA7IGktPTIpe1xuICAgICAgICBmb3IodmFyIGo9cmVzdWx0Lmxlbmd0aC0yOyBqPj0wOyBqLT0yKXtcbiAgICAgICAgICAgIGlmKCAoaWdub3JlZFBhaXJzW2ldICAgPT09IHJlc3VsdFtqXSAmJiBpZ25vcmVkUGFpcnNbaSsxXSA9PT0gcmVzdWx0W2orMV0pIHx8XG4gICAgICAgICAgICAgICAgKGlnbm9yZWRQYWlyc1tpKzFdID09PSByZXN1bHRbal0gJiYgaWdub3JlZFBhaXJzW2ldICAgPT09IHJlc3VsdFtqKzFdKSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNwbGljZShqLDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGNvbnN0cmFpbmVkIHBhaXJzIHdpdGggY29sbGlkZUNvbm5lY3RlZCA9PSBmYWxzZVxuICAgIHZhciBOY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5sZW5ndGg7XG4gICAgZm9yKGk9MDsgaSE9PU5jb25zdHJhaW50czsgaSsrKXtcbiAgICAgICAgdmFyIGMgPSBjb25zdHJhaW50c1tpXTtcbiAgICAgICAgaWYoIWMuY29sbGlkZUNvbm5lY3RlZCl7XG4gICAgICAgICAgICBmb3IodmFyIGo9cmVzdWx0Lmxlbmd0aC0yOyBqPj0wOyBqLT0yKXtcbiAgICAgICAgICAgICAgICBpZiggKGMuYm9keUEgPT09IHJlc3VsdFtqXSAmJiBjLmJvZHlCID09PSByZXN1bHRbaisxXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGMuYm9keUIgPT09IHJlc3VsdFtqXSAmJiBjLmJvZHlBID09PSByZXN1bHRbaisxXSkpe1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3BsaWNlKGosMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcG9zdEJyb2FkcGhhc2UgZXZlbnRcbiAgICB0aGlzLnBvc3RCcm9hZHBoYXNlRXZlbnQucGFpcnMgPSByZXN1bHQ7XG4gICAgdGhpcy5lbWl0KHRoaXMucG9zdEJyb2FkcGhhc2VFdmVudCk7XG5cbiAgICAvLyBOYXJyb3dwaGFzZVxuICAgIG5wLnJlc2V0KHRoaXMpO1xuICAgIGZvcih2YXIgaT0wLCBOcmVzdWx0cz1yZXN1bHQubGVuZ3RoOyBpIT09TnJlc3VsdHM7IGkrPTIpe1xuICAgICAgICB2YXIgYmkgPSByZXN1bHRbaV0sXG4gICAgICAgICAgICBiaiA9IHJlc3VsdFtpKzFdO1xuXG4gICAgICAgIC8vIExvb3Agb3ZlciBhbGwgc2hhcGVzIG9mIGJvZHkgaVxuICAgICAgICBmb3IodmFyIGs9MCwgTnNoYXBlc2k9Ymkuc2hhcGVzLmxlbmd0aDsgayE9PU5zaGFwZXNpOyBrKyspe1xuICAgICAgICAgICAgdmFyIHNpID0gYmkuc2hhcGVzW2tdLFxuICAgICAgICAgICAgICAgIHhpID0gYmkuc2hhcGVPZmZzZXRzW2tdLFxuICAgICAgICAgICAgICAgIGFpID0gYmkuc2hhcGVBbmdsZXNba107XG5cbiAgICAgICAgICAgIC8vIEFsbCBzaGFwZXMgb2YgYm9keSBqXG4gICAgICAgICAgICBmb3IodmFyIGw9MCwgTnNoYXBlc2o9Ymouc2hhcGVzLmxlbmd0aDsgbCE9PU5zaGFwZXNqOyBsKyspe1xuICAgICAgICAgICAgICAgIHZhciBzaiA9IGJqLnNoYXBlc1tsXSxcbiAgICAgICAgICAgICAgICAgICAgeGogPSBiai5zaGFwZU9mZnNldHNbbF0sXG4gICAgICAgICAgICAgICAgICAgIGFqID0gYmouc2hhcGVBbmdsZXNbbF07XG5cbiAgICAgICAgICAgICAgICB2YXIgY20gPSB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XG4gICAgICAgICAgICAgICAgaWYoc2kubWF0ZXJpYWwgJiYgc2oubWF0ZXJpYWwpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gdGhpcy5nZXRDb250YWN0TWF0ZXJpYWwoc2kubWF0ZXJpYWwsc2oubWF0ZXJpYWwpO1xuICAgICAgICAgICAgICAgICAgICBpZih0bXApe1xuICAgICAgICAgICAgICAgICAgICAgICAgY20gPSB0bXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJ1bk5hcnJvd3BoYXNlKG5wLGJpLHNpLHhpLGFpLGJqLHNqLHhqLGFqLGNtLHRoaXMuZnJpY3Rpb25HcmF2aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdha2UgdXAgYm9kaWVzXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcbiAgICAgICAgaWYoYm9keS5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSl7XG4gICAgICAgICAgICBib2R5Lndha2VVcCgpO1xuICAgICAgICAgICAgYm9keS5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW1pdCBlbmQgb3ZlcmxhcCBldmVudHNcbiAgICBpZih0aGlzLmhhcygnZW5kQ29udGFjdCcpKXtcbiAgICAgICAgdGhpcy5vdmVybGFwS2VlcGVyLmdldEVuZE92ZXJsYXBzKGVuZE92ZXJsYXBzKTtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmVuZENvbnRhY3RFdmVudDtcbiAgICAgICAgdmFyIGwgPSBlbmRPdmVybGFwcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlKGwtLSl7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGVuZE92ZXJsYXBzW2xdO1xuICAgICAgICAgICAgZS5zaGFwZUEgPSBkYXRhLnNoYXBlQTtcbiAgICAgICAgICAgIGUuc2hhcGVCID0gZGF0YS5zaGFwZUI7XG4gICAgICAgICAgICBlLmJvZHlBID0gZGF0YS5ib2R5QTtcbiAgICAgICAgICAgIGUuYm9keUIgPSBkYXRhLmJvZHlCO1xuICAgICAgICAgICAgdGhpcy5lbWl0KGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZVNvbHZlRXZlbnQgPSB0aGlzLnByZVNvbHZlRXZlbnQ7XG4gICAgcHJlU29sdmVFdmVudC5jb250YWN0RXF1YXRpb25zID0gbnAuY29udGFjdEVxdWF0aW9ucztcbiAgICBwcmVTb2x2ZUV2ZW50LmZyaWN0aW9uRXF1YXRpb25zID0gbnAuZnJpY3Rpb25FcXVhdGlvbnM7XG4gICAgdGhpcy5lbWl0KHByZVNvbHZlRXZlbnQpO1xuXG4gICAgLy8gdXBkYXRlIGNvbnN0cmFpbnQgZXF1YXRpb25zXG4gICAgdmFyIE5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmxlbmd0aDtcbiAgICBmb3IoaT0wOyBpIT09TmNvbnN0cmFpbnRzOyBpKyspe1xuICAgICAgICBjb25zdHJhaW50c1tpXS51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBpZihucC5jb250YWN0RXF1YXRpb25zLmxlbmd0aCB8fCBucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGggfHwgY29uc3RyYWludHMubGVuZ3RoKXtcbiAgICAgICAgaWYodGhpcy5pc2xhbmRTcGxpdCl7XG4gICAgICAgICAgICAvLyBTcGxpdCBpbnRvIGlzbGFuZHNcbiAgICAgICAgICAgIGlzbGFuZE1hbmFnZXIuZXF1YXRpb25zLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBVdGlscy5hcHBlbmRBcnJheShpc2xhbmRNYW5hZ2VyLmVxdWF0aW9ucywgbnAuY29udGFjdEVxdWF0aW9ucyk7XG4gICAgICAgICAgICBVdGlscy5hcHBlbmRBcnJheShpc2xhbmRNYW5hZ2VyLmVxdWF0aW9ucywgbnAuZnJpY3Rpb25FcXVhdGlvbnMpO1xuICAgICAgICAgICAgZm9yKGk9MDsgaSE9PU5jb25zdHJhaW50czsgaSsrKXtcbiAgICAgICAgICAgICAgICBVdGlscy5hcHBlbmRBcnJheShpc2xhbmRNYW5hZ2VyLmVxdWF0aW9ucywgY29uc3RyYWludHNbaV0uZXF1YXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzbGFuZE1hbmFnZXIuc3BsaXQodGhpcyk7XG5cbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpIT09aXNsYW5kTWFuYWdlci5pc2xhbmRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICB2YXIgaXNsYW5kID0gaXNsYW5kTWFuYWdlci5pc2xhbmRzW2ldO1xuICAgICAgICAgICAgICAgIGlmKGlzbGFuZC5lcXVhdGlvbnMubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgc29sdmVyLnNvbHZlSXNsYW5kKGR0LGlzbGFuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIEFkZCBjb250YWN0IGVxdWF0aW9ucyB0byBzb2x2ZXJcbiAgICAgICAgICAgIHNvbHZlci5hZGRFcXVhdGlvbnMobnAuY29udGFjdEVxdWF0aW9ucyk7XG4gICAgICAgICAgICBzb2x2ZXIuYWRkRXF1YXRpb25zKG5wLmZyaWN0aW9uRXF1YXRpb25zKTtcblxuICAgICAgICAgICAgLy8gQWRkIHVzZXItZGVmaW5lZCBjb25zdHJhaW50IGVxdWF0aW9uc1xuICAgICAgICAgICAgZm9yKGk9MDsgaSE9PU5jb25zdHJhaW50czsgaSsrKXtcbiAgICAgICAgICAgICAgICBzb2x2ZXIuYWRkRXF1YXRpb25zKGNvbnN0cmFpbnRzW2ldLmVxdWF0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHRoaXMuc29sdmVDb25zdHJhaW50cyl7XG4gICAgICAgICAgICAgICAgc29sdmVyLnNvbHZlKGR0LHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzb2x2ZXIucmVtb3ZlQWxsRXF1YXRpb25zKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdGVwIGZvcndhcmRcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuXG4gICAgICAgIGlmKGJvZHkuc2xlZXBTdGF0ZSAhPT0gQm9keS5TTEVFUElORyAmJiBib2R5LnR5cGUgIT09IEJvZHkuU1RBVElDKXtcbiAgICAgICAgICAgIGJvZHkuaW50ZWdyYXRlKGR0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlc2V0IGZvcmNlXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICBib2RpZXNbaV0uc2V0WmVyb0ZvcmNlKCk7XG4gICAgfVxuXG4gICAgaWYoZG9Qcm9maWxpbmcpe1xuICAgICAgICB0MSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGF0Lmxhc3RTdGVwVGltZSA9IHQxLXQwO1xuICAgIH1cblxuICAgIC8vIEVtaXQgaW1wYWN0IGV2ZW50XG4gICAgaWYodGhpcy5lbWl0SW1wYWN0RXZlbnQgJiYgdGhpcy5oYXMoJ2ltcGFjdCcpKXtcbiAgICAgICAgdmFyIGV2ID0gdGhpcy5pbXBhY3RFdmVudDtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1ucC5jb250YWN0RXF1YXRpb25zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBlcSA9IG5wLmNvbnRhY3RFcXVhdGlvbnNbaV07XG4gICAgICAgICAgICBpZihlcS5maXJzdEltcGFjdCl7XG4gICAgICAgICAgICAgICAgZXYuYm9keUEgPSBlcS5ib2R5QTtcbiAgICAgICAgICAgICAgICBldi5ib2R5QiA9IGVxLmJvZHlCO1xuICAgICAgICAgICAgICAgIGV2LnNoYXBlQSA9IGVxLnNoYXBlQTtcbiAgICAgICAgICAgICAgICBldi5zaGFwZUIgPSBlcS5zaGFwZUI7XG4gICAgICAgICAgICAgICAgZXYuY29udGFjdEVxdWF0aW9uID0gZXE7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNsZWVwaW5nIHVwZGF0ZVxuICAgIGlmKHRoaXMuc2xlZXBNb2RlID09PSBXb3JsZC5CT0RZX1NMRUVQSU5HKXtcbiAgICAgICAgZm9yKGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICBib2RpZXNbaV0uc2xlZXBUaWNrKHRoaXMudGltZSwgZmFsc2UsIGR0KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZih0aGlzLnNsZWVwTW9kZSA9PT0gV29ybGQuSVNMQU5EX1NMRUVQSU5HICYmIHRoaXMuaXNsYW5kU3BsaXQpe1xuXG4gICAgICAgIC8vIFRlbGwgYWxsIGJvZGllcyB0byBzbGVlcCB0aWNrIGJ1dCBkb250IHNsZWVwIHlldFxuICAgICAgICBmb3IoaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIGJvZGllc1tpXS5zbGVlcFRpY2sodGhpcy50aW1lLCB0cnVlLCBkdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTbGVlcCBpc2xhbmRzXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuaXNsYW5kTWFuYWdlci5pc2xhbmRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBpc2xhbmQgPSB0aGlzLmlzbGFuZE1hbmFnZXIuaXNsYW5kc1tpXTtcbiAgICAgICAgICAgIGlmKGlzbGFuZC53YW50c1RvU2xlZXAoKSl7XG4gICAgICAgICAgICAgICAgaXNsYW5kLnNsZWVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnN0ZXBwaW5nID0gZmFsc2U7XG5cbiAgICAvLyBSZW1vdmUgYm9kaWVzIHRoYXQgYXJlIHNjaGVkdWxlZCBmb3IgcmVtb3ZhbFxuICAgIGlmKHRoaXMuYm9kaWVzVG9CZVJlbW92ZWQubGVuZ3RoKXtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT10aGlzLmJvZGllc1RvQmVSZW1vdmVkLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQm9keSh0aGlzLmJvZGllc1RvQmVSZW1vdmVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvZGllc1RvQmVSZW1vdmVkLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KHRoaXMucG9zdFN0ZXBFdmVudCk7XG59O1xuXG4vKipcbiAqIFJ1bnMgbmFycm93cGhhc2UgZm9yIHRoZSBzaGFwZSBwYWlyIGkgYW5kIGouXG4gKiBAbWV0aG9kIHJ1bk5hcnJvd3BoYXNlXG4gKiBAcGFyYW0gIHtOYXJyb3dwaGFzZX0gbnBcbiAqIEBwYXJhbSAge0JvZHl9IGJpXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2lcbiAqIEBwYXJhbSAge0FycmF5fSB4aVxuICogQHBhcmFtICB7TnVtYmVyfSBhaVxuICogQHBhcmFtICB7Qm9keX0gYmpcbiAqIEBwYXJhbSAge1NoYXBlfSBzalxuICogQHBhcmFtICB7QXJyYXl9IHhqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG11XG4gKi9cbldvcmxkLnByb3RvdHlwZS5ydW5OYXJyb3dwaGFzZSA9IGZ1bmN0aW9uKG5wLGJpLHNpLHhpLGFpLGJqLHNqLHhqLGFqLGNtLGdsZW4pe1xuXG4gICAgLy8gQ2hlY2sgY29sbGlzaW9uIGdyb3VwcyBhbmQgbWFza3NcbiAgICBpZighKChzaS5jb2xsaXNpb25Hcm91cCAmIHNqLmNvbGxpc2lvbk1hc2spICE9PSAwICYmIChzai5jb2xsaXNpb25Hcm91cCAmIHNpLmNvbGxpc2lvbk1hc2spICE9PSAwKSl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgd29ybGQgcG9zaXRpb24gYW5kIGFuZ2xlIG9mIGVhY2ggc2hhcGVcbiAgICB2ZWMyLnJvdGF0ZSh4aXcsIHhpLCBiaS5hbmdsZSk7XG4gICAgdmVjMi5yb3RhdGUoeGp3LCB4aiwgYmouYW5nbGUpO1xuICAgIHZlYzIuYWRkKHhpdywgeGl3LCBiaS5wb3NpdGlvbik7XG4gICAgdmVjMi5hZGQoeGp3LCB4ancsIGJqLnBvc2l0aW9uKTtcbiAgICB2YXIgYWl3ID0gYWkgKyBiaS5hbmdsZTtcbiAgICB2YXIgYWp3ID0gYWogKyBiai5hbmdsZTtcblxuICAgIG5wLmVuYWJsZUZyaWN0aW9uID0gY20uZnJpY3Rpb24gPiAwO1xuICAgIG5wLmZyaWN0aW9uQ29lZmZpY2llbnQgPSBjbS5mcmljdGlvbjtcbiAgICB2YXIgcmVkdWNlZE1hc3M7XG4gICAgaWYoYmkudHlwZSA9PT0gQm9keS5TVEFUSUMgfHwgYmkudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpe1xuICAgICAgICByZWR1Y2VkTWFzcyA9IGJqLm1hc3M7XG4gICAgfSBlbHNlIGlmKGJqLnR5cGUgPT09IEJvZHkuU1RBVElDIHx8IGJqLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKXtcbiAgICAgICAgcmVkdWNlZE1hc3MgPSBiaS5tYXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZHVjZWRNYXNzID0gKGJpLm1hc3MqYmoubWFzcykvKGJpLm1hc3MrYmoubWFzcyk7XG4gICAgfVxuICAgIG5wLnNsaXBGb3JjZSA9IGNtLmZyaWN0aW9uKmdsZW4qcmVkdWNlZE1hc3M7XG4gICAgbnAucmVzdGl0dXRpb24gPSBjbS5yZXN0aXR1dGlvbjtcbiAgICBucC5zdXJmYWNlVmVsb2NpdHkgPSBjbS5zdXJmYWNlVmVsb2NpdHk7XG4gICAgbnAuZnJpY3Rpb25TdGlmZm5lc3MgPSBjbS5mcmljdGlvblN0aWZmbmVzcztcbiAgICBucC5mcmljdGlvblJlbGF4YXRpb24gPSBjbS5mcmljdGlvblJlbGF4YXRpb247XG4gICAgbnAuc3RpZmZuZXNzID0gY20uc3RpZmZuZXNzO1xuICAgIG5wLnJlbGF4YXRpb24gPSBjbS5yZWxheGF0aW9uO1xuICAgIG5wLmNvbnRhY3RTa2luU2l6ZSA9IGNtLmNvbnRhY3RTa2luU2l6ZTtcbiAgICBucC5lbmFibGVkRXF1YXRpb25zID0gYmkuY29sbGlzaW9uUmVzcG9uc2UgJiYgYmouY29sbGlzaW9uUmVzcG9uc2UgJiYgc2kuY29sbGlzaW9uUmVzcG9uc2UgJiYgc2ouY29sbGlzaW9uUmVzcG9uc2U7XG5cbiAgICB2YXIgcmVzb2x2ZXIgPSBucFtzaS50eXBlIHwgc2oudHlwZV0sXG4gICAgICAgIG51bUNvbnRhY3RzID0gMDtcbiAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgICAgdmFyIHNlbnNvciA9IHNpLnNlbnNvciB8fCBzai5zZW5zb3I7XG4gICAgICAgIHZhciBudW1GcmljdGlvbkJlZm9yZSA9IG5wLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aDtcbiAgICAgICAgaWYgKHNpLnR5cGUgPCBzai50eXBlKSB7XG4gICAgICAgICAgICBudW1Db250YWN0cyA9IHJlc29sdmVyLmNhbGwobnAsIGJpLHNpLHhpdyxhaXcsIGJqLHNqLHhqdyxhancsIHNlbnNvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBudW1Db250YWN0cyA9IHJlc29sdmVyLmNhbGwobnAsIGJqLHNqLHhqdyxhancsIGJpLHNpLHhpdyxhaXcsIHNlbnNvcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG51bUZyaWN0aW9uRXF1YXRpb25zID0gbnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoIC0gbnVtRnJpY3Rpb25CZWZvcmU7XG5cbiAgICAgICAgaWYobnVtQ29udGFjdHMpe1xuXG4gICAgICAgICAgICBpZiggYmkuYWxsb3dTbGVlcCAmJlxuICAgICAgICAgICAgICAgIGJpLnR5cGUgPT09IEJvZHkuRFlOQU1JQyAmJlxuICAgICAgICAgICAgICAgIGJpLnNsZWVwU3RhdGUgID09PSBCb2R5LlNMRUVQSU5HICYmXG4gICAgICAgICAgICAgICAgYmouc2xlZXBTdGF0ZSAgPT09IEJvZHkuQVdBS0UgJiZcbiAgICAgICAgICAgICAgICBiai50eXBlICE9PSBCb2R5LlNUQVRJQ1xuICAgICAgICAgICAgKXtcbiAgICAgICAgICAgICAgICB2YXIgc3BlZWRTcXVhcmVkQiA9IHZlYzIuc3F1YXJlZExlbmd0aChiai52ZWxvY2l0eSkgKyBNYXRoLnBvdyhiai5hbmd1bGFyVmVsb2NpdHksMik7XG4gICAgICAgICAgICAgICAgdmFyIHNwZWVkTGltaXRTcXVhcmVkQiA9IE1hdGgucG93KGJqLnNsZWVwU3BlZWRMaW1pdCwyKTtcbiAgICAgICAgICAgICAgICBpZihzcGVlZFNxdWFyZWRCID49IHNwZWVkTGltaXRTcXVhcmVkQioyKXtcbiAgICAgICAgICAgICAgICAgICAgYmkuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIGJqLmFsbG93U2xlZXAgJiZcbiAgICAgICAgICAgICAgICBiai50eXBlID09PSBCb2R5LkRZTkFNSUMgJiZcbiAgICAgICAgICAgICAgICBiai5zbGVlcFN0YXRlICA9PT0gQm9keS5TTEVFUElORyAmJlxuICAgICAgICAgICAgICAgIGJpLnNsZWVwU3RhdGUgID09PSBCb2R5LkFXQUtFICYmXG4gICAgICAgICAgICAgICAgYmkudHlwZSAhPT0gQm9keS5TVEFUSUNcbiAgICAgICAgICAgICl7XG4gICAgICAgICAgICAgICAgdmFyIHNwZWVkU3F1YXJlZEEgPSB2ZWMyLnNxdWFyZWRMZW5ndGgoYmkudmVsb2NpdHkpICsgTWF0aC5wb3coYmkuYW5ndWxhclZlbG9jaXR5LDIpO1xuICAgICAgICAgICAgICAgIHZhciBzcGVlZExpbWl0U3F1YXJlZEEgPSBNYXRoLnBvdyhiaS5zbGVlcFNwZWVkTGltaXQsMik7XG4gICAgICAgICAgICAgICAgaWYoc3BlZWRTcXVhcmVkQSA+PSBzcGVlZExpbWl0U3F1YXJlZEEqMil7XG4gICAgICAgICAgICAgICAgICAgIGJqLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMub3ZlcmxhcEtlZXBlci5zZXRPdmVybGFwcGluZyhiaSwgc2ksIGJqLCBzaik7XG4gICAgICAgICAgICBpZih0aGlzLmhhcygnYmVnaW5Db250YWN0JykgJiYgdGhpcy5vdmVybGFwS2VlcGVyLmlzTmV3T3ZlcmxhcChzaSwgc2opKXtcblxuICAgICAgICAgICAgICAgIC8vIFJlcG9ydCBuZXcgc2hhcGUgb3ZlcmxhcFxuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5iZWdpbkNvbnRhY3RFdmVudDtcbiAgICAgICAgICAgICAgICBlLnNoYXBlQSA9IHNpO1xuICAgICAgICAgICAgICAgIGUuc2hhcGVCID0gc2o7XG4gICAgICAgICAgICAgICAgZS5ib2R5QSA9IGJpO1xuICAgICAgICAgICAgICAgIGUuYm9keUIgPSBiajtcblxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IGNvbnRhY3QgZXF1YXRpb25zXG4gICAgICAgICAgICAgICAgZS5jb250YWN0RXF1YXRpb25zLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZih0eXBlb2YobnVtQ29udGFjdHMpPT09XCJudW1iZXJcIil7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaT1ucC5jb250YWN0RXF1YXRpb25zLmxlbmd0aC1udW1Db250YWN0czsgaTxucC5jb250YWN0RXF1YXRpb25zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuY29udGFjdEVxdWF0aW9ucy5wdXNoKG5wLmNvbnRhY3RFcXVhdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkaXZpZGUgdGhlIG1heCBmcmljdGlvbiBmb3JjZSBieSB0aGUgbnVtYmVyIG9mIGNvbnRhY3RzXG4gICAgICAgICAgICBpZih0eXBlb2YobnVtQ29udGFjdHMpPT09XCJudW1iZXJcIiAmJiBudW1GcmljdGlvbkVxdWF0aW9ucyA+IDEpeyAvLyBXaHkgZGl2aWRlIGJ5IDE/XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpPW5wLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aC1udW1GcmljdGlvbkVxdWF0aW9uczsgaTxucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gbnAuZnJpY3Rpb25FcXVhdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGYuc2V0U2xpcEZvcmNlKGYuZ2V0U2xpcEZvcmNlKCkgLyBudW1GcmljdGlvbkVxdWF0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIEFkZCBhIHNwcmluZyB0byB0aGUgc2ltdWxhdGlvblxuICpcbiAqIEBtZXRob2QgYWRkU3ByaW5nXG4gKiBAcGFyYW0ge1NwcmluZ30gc1xuICovXG5Xb3JsZC5wcm90b3R5cGUuYWRkU3ByaW5nID0gZnVuY3Rpb24ocyl7XG4gICAgdGhpcy5zcHJpbmdzLnB1c2gocyk7XG4gICAgdGhpcy5hZGRTcHJpbmdFdmVudC5zcHJpbmcgPSBzO1xuICAgIHRoaXMuZW1pdCh0aGlzLmFkZFNwcmluZ0V2ZW50KTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgc3ByaW5nXG4gKlxuICogQG1ldGhvZCByZW1vdmVTcHJpbmdcbiAqIEBwYXJhbSB7U3ByaW5nfSBzXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yZW1vdmVTcHJpbmcgPSBmdW5jdGlvbihzKXtcbiAgICB2YXIgaWR4ID0gdGhpcy5zcHJpbmdzLmluZGV4T2Yocyk7XG4gICAgaWYoaWR4IT09LTEpe1xuICAgICAgICBVdGlscy5zcGxpY2UodGhpcy5zcHJpbmdzLGlkeCwxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBhIGJvZHkgdG8gdGhlIHNpbXVsYXRpb25cbiAqXG4gKiBAbWV0aG9kIGFkZEJvZHlcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKCksXG4gKiAgICAgICAgIGJvZHkgPSBuZXcgQm9keSgpO1xuICogICAgIHdvcmxkLmFkZEJvZHkoYm9keSk7XG4gKiBAdG9kbyBXaGF0IGlmIHRoaXMgaXMgZG9uZSBkdXJpbmcgc3RlcD9cbiAqL1xuV29ybGQucHJvdG90eXBlLmFkZEJvZHkgPSBmdW5jdGlvbihib2R5KXtcbiAgICBpZih0aGlzLmJvZGllcy5pbmRleE9mKGJvZHkpID09PSAtMSl7XG4gICAgICAgIHRoaXMuYm9kaWVzLnB1c2goYm9keSk7XG4gICAgICAgIGJvZHkud29ybGQgPSB0aGlzO1xuICAgICAgICB0aGlzLmFkZEJvZHlFdmVudC5ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuYWRkQm9keUV2ZW50KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIGJvZHkgZnJvbSB0aGUgc2ltdWxhdGlvbi4gSWYgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGR1cmluZyBzdGVwKCksIHRoZSBib2R5IHJlbW92YWwgaXMgc2NoZWR1bGVkIHRvIGFmdGVyIHRoZSBzdGVwLlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlQm9keVxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKi9cbldvcmxkLnByb3RvdHlwZS5yZW1vdmVCb2R5ID0gZnVuY3Rpb24oYm9keSl7XG4gICAgaWYodGhpcy5zdGVwcGluZyl7XG4gICAgICAgIHRoaXMuYm9kaWVzVG9CZVJlbW92ZWQucHVzaChib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBib2R5LndvcmxkID0gbnVsbDtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYm9kaWVzLmluZGV4T2YoYm9keSk7XG4gICAgICAgIGlmKGlkeCE9PS0xKXtcbiAgICAgICAgICAgIFV0aWxzLnNwbGljZSh0aGlzLmJvZGllcyxpZHgsMSk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUJvZHlFdmVudC5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIGJvZHkucmVzZXRDb25zdHJhaW50VmVsb2NpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLnJlbW92ZUJvZHlFdmVudCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCBhIGJvZHkgYnkgaXRzIGlkLlxuICogQG1ldGhvZCBnZXRCb2R5QnlJZFxuICogQHJldHVybiB7Qm9keXxCb29sZWFufSBUaGUgYm9keSwgb3IgZmFsc2UgaWYgaXQgd2FzIG5vdCBmb3VuZC5cbiAqL1xuV29ybGQucHJvdG90eXBlLmdldEJvZHlCeUlkID0gZnVuY3Rpb24oaWQpe1xuICAgIHZhciBib2RpZXMgPSB0aGlzLmJvZGllcztcbiAgICBmb3IodmFyIGk9MDsgaTxib2RpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcbiAgICAgICAgaWYoYi5pZCA9PT0gaWQpe1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlIGNvbGxpc2lvbiBiZXR3ZWVuIHR3byBib2RpZXNcbiAqIEBtZXRob2QgZGlzYWJsZUNvbGxpc2lvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICovXG5Xb3JsZC5wcm90b3R5cGUuZGlzYWJsZUJvZHlDb2xsaXNpb24gPSBmdW5jdGlvbihib2R5QSxib2R5Qil7XG4gICAgdGhpcy5kaXNhYmxlZEJvZHlDb2xsaXNpb25QYWlycy5wdXNoKGJvZHlBLGJvZHlCKTtcbn07XG5cbi8qKlxuICogRW5hYmxlIGNvbGxpc2lvbnMgYmV0d2VlbiB0aGUgZ2l2ZW4gdHdvIGJvZGllc1xuICogQG1ldGhvZCBlbmFibGVDb2xsaXNpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqL1xuV29ybGQucHJvdG90eXBlLmVuYWJsZUJvZHlDb2xsaXNpb24gPSBmdW5jdGlvbihib2R5QSxib2R5Qil7XG4gICAgdmFyIHBhaXJzID0gdGhpcy5kaXNhYmxlZEJvZHlDb2xsaXNpb25QYWlycztcbiAgICBmb3IodmFyIGk9MDsgaTxwYWlycy5sZW5ndGg7IGkrPTIpe1xuICAgICAgICBpZigocGFpcnNbaV0gPT09IGJvZHlBICYmIHBhaXJzW2krMV0gPT09IGJvZHlCKSB8fCAocGFpcnNbaSsxXSA9PT0gYm9keUEgJiYgcGFpcnNbaV0gPT09IGJvZHlCKSl7XG4gICAgICAgICAgICBwYWlycy5zcGxpY2UoaSwyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuZnVuY3Rpb24gdjJhKHYpe1xuICAgIGlmKCF2KXtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJldHVybiBbdlswXSx2WzFdXTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGEsYil7XG4gICAgZm9yKHZhciBrZXkgaW4gYil7XG4gICAgICAgIGFba2V5XSA9IGJba2V5XTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNvbnRhY3RNYXRlcmlhbFRvSlNPTihjbSl7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQgOiBjbS5pZCxcbiAgICAgICAgbWF0ZXJpYWxBIDogICAgICAgICAgICAgY20ubWF0ZXJpYWxBLmlkLFxuICAgICAgICBtYXRlcmlhbEIgOiAgICAgICAgICAgICBjbS5tYXRlcmlhbEIuaWQsXG4gICAgICAgIGZyaWN0aW9uIDogICAgICAgICAgICAgIGNtLmZyaWN0aW9uLFxuICAgICAgICByZXN0aXR1dGlvbiA6ICAgICAgICAgICBjbS5yZXN0aXR1dGlvbixcbiAgICAgICAgc3RpZmZuZXNzIDogICAgICAgICAgICAgY20uc3RpZmZuZXNzLFxuICAgICAgICByZWxheGF0aW9uIDogICAgICAgICAgICBjbS5yZWxheGF0aW9uLFxuICAgICAgICBmcmljdGlvblN0aWZmbmVzcyA6ICAgICBjbS5mcmljdGlvblN0aWZmbmVzcyxcbiAgICAgICAgZnJpY3Rpb25SZWxheGF0aW9uIDogICAgY20uZnJpY3Rpb25SZWxheGF0aW9uLFxuICAgIH07XG59XG5cbi8qKlxuICogUmVzZXRzIHRoZSBXb3JsZCwgcmVtb3ZlcyBhbGwgYm9kaWVzLCBjb25zdHJhaW50cyBhbmQgc3ByaW5ncy5cbiAqXG4gKiBAbWV0aG9kIGNsZWFyXG4gKi9cbldvcmxkLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCl7XG5cbiAgICB0aGlzLnRpbWUgPSAwO1xuICAgIHRoaXMuZml4ZWRTdGVwVGltZSA9IDA7XG5cbiAgICAvLyBSZW1vdmUgYWxsIHNvbHZlciBlcXVhdGlvbnNcbiAgICBpZih0aGlzLnNvbHZlciAmJiB0aGlzLnNvbHZlci5lcXVhdGlvbnMubGVuZ3RoKXtcbiAgICAgICAgdGhpcy5zb2x2ZXIucmVtb3ZlQWxsRXF1YXRpb25zKCk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFsbCBjb25zdHJhaW50c1xuICAgIHZhciBjcyA9IHRoaXMuY29uc3RyYWludHM7XG4gICAgZm9yKHZhciBpPWNzLmxlbmd0aC0xOyBpPj0wOyBpLS0pe1xuICAgICAgICB0aGlzLnJlbW92ZUNvbnN0cmFpbnQoY3NbaV0pO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbGwgYm9kaWVzXG4gICAgdmFyIGJvZGllcyA9IHRoaXMuYm9kaWVzO1xuICAgIGZvcih2YXIgaT1ib2RpZXMubGVuZ3RoLTE7IGk+PTA7IGktLSl7XG4gICAgICAgIHRoaXMucmVtb3ZlQm9keShib2RpZXNbaV0pO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbGwgc3ByaW5nc1xuICAgIHZhciBzcHJpbmdzID0gdGhpcy5zcHJpbmdzO1xuICAgIGZvcih2YXIgaT1zcHJpbmdzLmxlbmd0aC0xOyBpPj0wOyBpLS0pe1xuICAgICAgICB0aGlzLnJlbW92ZVNwcmluZyhzcHJpbmdzW2ldKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYWxsIGNvbnRhY3QgbWF0ZXJpYWxzXG4gICAgdmFyIGNtcyA9IHRoaXMuY29udGFjdE1hdGVyaWFscztcbiAgICBmb3IodmFyIGk9Y21zLmxlbmd0aC0xOyBpPj0wOyBpLS0pe1xuICAgICAgICB0aGlzLnJlbW92ZUNvbnRhY3RNYXRlcmlhbChjbXNbaV0pO1xuICAgIH1cblxuICAgIFdvcmxkLmFwcGx5KHRoaXMpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBjb3B5IG9mIHRoaXMgV29ybGQgaW5zdGFuY2VcbiAqIEBtZXRob2QgY2xvbmVcbiAqIEByZXR1cm4ge1dvcmxkfVxuICovXG5Xb3JsZC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpe1xuICAgIHZhciB3b3JsZCA9IG5ldyBXb3JsZCgpO1xuICAgIHdvcmxkLmZyb21KU09OKHRoaXMudG9KU09OKCkpO1xuICAgIHJldHVybiB3b3JsZDtcbn07XG5cbnZhciBoaXRUZXN0X3RtcDEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGhpdFRlc3RfemVybyA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgIGhpdFRlc3RfdG1wMiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4vKipcbiAqIFRlc3QgaWYgYSB3b3JsZCBwb2ludCBvdmVybGFwcyBib2RpZXNcbiAqIEBtZXRob2QgaGl0VGVzdFxuICogQHBhcmFtICB7QXJyYXl9ICB3b3JsZFBvaW50ICBQb2ludCB0byB1c2UgZm9yIGludGVyc2VjdGlvbiB0ZXN0c1xuICogQHBhcmFtICB7QXJyYXl9ICBib2RpZXMgICAgICBBIGxpc3Qgb2Ygb2JqZWN0cyB0byBjaGVjayBmb3IgaW50ZXJzZWN0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHByZWNpc2lvbiAgIFVzZWQgZm9yIG1hdGNoaW5nIGFnYWluc3QgcGFydGljbGVzIGFuZCBsaW5lcy4gQWRkcyBzb21lIG1hcmdpbiB0byB0aGVzZSBpbmZpbml0ZXNpbWFsIG9iamVjdHMuXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgIEFycmF5IG9mIGJvZGllcyB0aGF0IG92ZXJsYXAgdGhlIHBvaW50XG4gKi9cbldvcmxkLnByb3RvdHlwZS5oaXRUZXN0ID0gZnVuY3Rpb24od29ybGRQb2ludCxib2RpZXMscHJlY2lzaW9uKXtcbiAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gfHwgMDtcblxuICAgIC8vIENyZWF0ZSBhIGR1bW15IHBhcnRpY2xlIGJvZHkgd2l0aCBhIHBhcnRpY2xlIHNoYXBlIHRvIHRlc3QgYWdhaW5zdCB0aGUgYm9kaWVzXG4gICAgdmFyIHBiID0gbmV3IEJvZHkoeyBwb3NpdGlvbjp3b3JsZFBvaW50IH0pLFxuICAgICAgICBwcyA9IG5ldyBQYXJ0aWNsZSgpLFxuICAgICAgICBweCA9IHdvcmxkUG9pbnQsXG4gICAgICAgIHBhID0gMCxcbiAgICAgICAgeCA9IGhpdFRlc3RfdG1wMSxcbiAgICAgICAgemVybyA9IGhpdFRlc3RfemVybyxcbiAgICAgICAgdG1wID0gaGl0VGVzdF90bXAyO1xuICAgIHBiLmFkZFNoYXBlKHBzKTtcblxuICAgIHZhciBuID0gdGhpcy5uYXJyb3dwaGFzZSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAvLyBDaGVjayBib2RpZXNcbiAgICBmb3IodmFyIGk9MCwgTj1ib2RpZXMubGVuZ3RoOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSBib2RpZXNbaV07XG4gICAgICAgIGZvcih2YXIgaj0wLCBOUz1iLnNoYXBlcy5sZW5ndGg7IGohPT1OUzsgaisrKXtcbiAgICAgICAgICAgIHZhciBzID0gYi5zaGFwZXNbal0sXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gYi5zaGFwZU9mZnNldHNbal0gfHwgemVybyxcbiAgICAgICAgICAgICAgICBhbmdsZSA9IGIuc2hhcGVBbmdsZXNbal0gfHwgMC4wO1xuXG4gICAgICAgICAgICAvLyBHZXQgc2hhcGUgd29ybGQgcG9zaXRpb24gKyBhbmdsZVxuICAgICAgICAgICAgdmVjMi5yb3RhdGUoeCwgb2Zmc2V0LCBiLmFuZ2xlKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKHgsIHgsIGIucG9zaXRpb24pO1xuICAgICAgICAgICAgdmFyIGEgPSBhbmdsZSArIGIuYW5nbGU7XG5cbiAgICAgICAgICAgIGlmKCAocyBpbnN0YW5jZW9mIENpcmNsZSAgICAmJiBuLmNpcmNsZVBhcnRpY2xlICAoYixzLHgsYSwgICAgIHBiLHBzLHB4LHBhLCB0cnVlKSkgfHxcbiAgICAgICAgICAgICAgICAocyBpbnN0YW5jZW9mIENvbnZleCAgICAmJiBuLnBhcnRpY2xlQ29udmV4ICAocGIscHMscHgscGEsIGIscyx4LGEsICAgICB0cnVlKSkgfHxcbiAgICAgICAgICAgICAgICAocyBpbnN0YW5jZW9mIFBsYW5lICAgICAmJiBuLnBhcnRpY2xlUGxhbmUgICAocGIscHMscHgscGEsIGIscyx4LGEsICAgICB0cnVlKSkgfHxcbiAgICAgICAgICAgICAgICAocyBpbnN0YW5jZW9mIENhcHN1bGUgICAmJiBuLnBhcnRpY2xlQ2Fwc3VsZSAocGIscHMscHgscGEsIGIscyx4LGEsICAgICB0cnVlKSkgfHxcbiAgICAgICAgICAgICAgICAocyBpbnN0YW5jZW9mIFBhcnRpY2xlICAmJiB2ZWMyLnNxdWFyZWRMZW5ndGgodmVjMi5zdWIodG1wLHgsd29ybGRQb2ludCkpIDwgcHJlY2lzaW9uKnByZWNpc2lvbilcbiAgICAgICAgICAgICAgICApe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgRXF1YXRpb24gcGFyYW1ldGVycyBmb3IgYWxsIGNvbnN0cmFpbnRzIGFuZCBjb250YWN0IG1hdGVyaWFscy5cbiAqIEBtZXRob2Qgc2V0R2xvYmFsRXF1YXRpb25QYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtZXRlcnNdXG4gKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtZXRlcnMucmVsYXhhdGlvbl1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5zdGlmZm5lc3NdXG4gKi9cbldvcmxkLnByb3RvdHlwZS5zZXRHbG9iYWxFcXVhdGlvblBhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbWV0ZXJzKXtcbiAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcblxuICAgIC8vIFNldCBmb3IgYWxsIGNvbnN0cmFpbnRzXG4gICAgZm9yKHZhciBpPTA7IGkgIT09IHRoaXMuY29uc3RyYWludHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYyA9IHRoaXMuY29uc3RyYWludHNbaV07XG4gICAgICAgIGZvcih2YXIgaj0wOyBqICE9PSBjLmVxdWF0aW9ucy5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICB2YXIgZXEgPSBjLmVxdWF0aW9uc1tqXTtcbiAgICAgICAgICAgIGlmKHR5cGVvZihwYXJhbWV0ZXJzLnN0aWZmbmVzcykgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICAgICAgICAgIGVxLnN0aWZmbmVzcyA9IHBhcmFtZXRlcnMuc3RpZmZuZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodHlwZW9mKHBhcmFtZXRlcnMucmVsYXhhdGlvbikgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICAgICAgICAgIGVxLnJlbGF4YXRpb24gPSBwYXJhbWV0ZXJzLnJlbGF4YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgZm9yIGFsbCBjb250YWN0IG1hdGVyaWFsc1xuICAgIGZvcih2YXIgaT0wOyBpICE9PSB0aGlzLmNvbnRhY3RNYXRlcmlhbHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYyA9IHRoaXMuY29udGFjdE1hdGVyaWFsc1tpXTtcbiAgICAgICAgaWYodHlwZW9mKHBhcmFtZXRlcnMuc3RpZmZuZXNzKSAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgICBjLnN0aWZmbmVzcyA9IHBhcmFtZXRlcnMuc3RpZmZuZXNzO1xuICAgICAgICAgICAgYy5mcmljdGlvblN0aWZmbmVzcyA9IHBhcmFtZXRlcnMuc3RpZmZuZXNzO1xuICAgICAgICB9XG4gICAgICAgIGlmKHR5cGVvZihwYXJhbWV0ZXJzLnJlbGF4YXRpb24pICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgIGMucmVsYXhhdGlvbiA9IHBhcmFtZXRlcnMucmVsYXhhdGlvbjtcbiAgICAgICAgICAgIGMuZnJpY3Rpb25SZWxheGF0aW9uID0gcGFyYW1ldGVycy5yZWxheGF0aW9uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IGZvciBkZWZhdWx0IGNvbnRhY3QgbWF0ZXJpYWxcbiAgICB2YXIgYyA9IHRoaXMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDtcbiAgICBpZih0eXBlb2YocGFyYW1ldGVycy5zdGlmZm5lc3MpICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgYy5zdGlmZm5lc3MgPSBwYXJhbWV0ZXJzLnN0aWZmbmVzcztcbiAgICAgICAgYy5mcmljdGlvblN0aWZmbmVzcyA9IHBhcmFtZXRlcnMuc3RpZmZuZXNzO1xuICAgIH1cbiAgICBpZih0eXBlb2YocGFyYW1ldGVycy5yZWxheGF0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgIGMucmVsYXhhdGlvbiA9IHBhcmFtZXRlcnMucmVsYXhhdGlvbjtcbiAgICAgICAgYy5mcmljdGlvblJlbGF4YXRpb24gPSBwYXJhbWV0ZXJzLnJlbGF4YXRpb247XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXQgdGhlIHN0aWZmbmVzcyBmb3IgYWxsIGVxdWF0aW9ucyBhbmQgY29udGFjdCBtYXRlcmlhbHMuXG4gKiBAbWV0aG9kIHNldEdsb2JhbFN0aWZmbmVzc1xuICogQHBhcmFtIHtOdW1iZXJ9IHN0aWZmbmVzc1xuICovXG5Xb3JsZC5wcm90b3R5cGUuc2V0R2xvYmFsU3RpZmZuZXNzID0gZnVuY3Rpb24oc3RpZmZuZXNzKXtcbiAgICB0aGlzLnNldEdsb2JhbEVxdWF0aW9uUGFyYW1ldGVycyh7XG4gICAgICAgIHN0aWZmbmVzczogc3RpZmZuZXNzXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgcmVsYXhhdGlvbiBmb3IgYWxsIGVxdWF0aW9ucyBhbmQgY29udGFjdCBtYXRlcmlhbHMuXG4gKiBAbWV0aG9kIHNldEdsb2JhbFJlbGF4YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSByZWxheGF0aW9uXG4gKi9cbldvcmxkLnByb3RvdHlwZS5zZXRHbG9iYWxSZWxheGF0aW9uID0gZnVuY3Rpb24ocmVsYXhhdGlvbil7XG4gICAgdGhpcy5zZXRHbG9iYWxFcXVhdGlvblBhcmFtZXRlcnMoe1xuICAgICAgICByZWxheGF0aW9uOiByZWxheGF0aW9uXG4gICAgfSk7XG59O1xuXG52YXIgdG1wUmF5ID0gbmV3IFJheSgpO1xuXG4vKipcbiAqIFJheSBjYXN0IGFnYWluc3QgYWxsIGJvZGllcy4gVGhlIHByb3ZpZGVkIGNhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQgZm9yIGVhY2ggaGl0IHdpdGggYSBSYXljYXN0UmVzdWx0IGFzIHNpbmdsZSBhcmd1bWVudC5cbiAqIEBtZXRob2QgcmF5Y2FzdEFsbFxuICogQHBhcmFtICB7VmVjM30gZnJvbVxuICogQHBhcmFtICB7VmVjM30gdG9cbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25NYXNrPS0xXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25Hcm91cD0tMV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLnNraXBCYWNrZmFjZXM9ZmFsc2VdXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlPXRydWVdXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW55IGJvZHkgd2FzIGhpdC5cbiAqL1xuV29ybGQucHJvdG90eXBlLnJheWNhc3RBbGwgPSBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucywgY2FsbGJhY2spe1xuICAgIG9wdGlvbnMubW9kZSA9IFJheS5BTEw7XG4gICAgb3B0aW9ucy5mcm9tID0gZnJvbTtcbiAgICBvcHRpb25zLnRvID0gdG87XG4gICAgb3B0aW9ucy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHJldHVybiB0bXBSYXkuaW50ZXJzZWN0V29ybGQodGhpcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFJheSBjYXN0LCBhbmQgc3RvcCBhdCB0aGUgZmlyc3QgcmVzdWx0LiBOb3RlIHRoYXQgdGhlIG9yZGVyIGlzIHJhbmRvbSAtIGJ1dCB0aGUgbWV0aG9kIGlzIGZhc3QuXG4gKiBAbWV0aG9kIHJheWNhc3RBbnlcbiAqIEBwYXJhbSAge1ZlYzN9IGZyb21cbiAqIEBwYXJhbSAge1ZlYzN9IHRvXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uTWFzaz0tMV1cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uR3JvdXA9LTFdXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5za2lwQmFja2ZhY2VzPWZhbHNlXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZT10cnVlXVxuICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFueSBib2R5IHdhcyBoaXQuXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yYXljYXN0QW55ID0gZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMsIHJlc3VsdCl7XG4gICAgb3B0aW9ucy5tb2RlID0gUmF5LkFOWTtcbiAgICBvcHRpb25zLmZyb20gPSBmcm9tO1xuICAgIG9wdGlvbnMudG8gPSB0bztcbiAgICBvcHRpb25zLnJlc3VsdCA9IHJlc3VsdDtcbiAgICByZXR1cm4gdG1wUmF5LmludGVyc2VjdFdvcmxkKHRoaXMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSYXkgY2FzdCwgYW5kIHJldHVybiBpbmZvcm1hdGlvbiBvZiB0aGUgY2xvc2VzdCBoaXQuXG4gKiBAbWV0aG9kIHJheWNhc3RDbG9zZXN0XG4gKiBAcGFyYW0gIHtWZWMzfSBmcm9tXG4gKiBAcGFyYW0gIHtWZWMzfSB0b1xuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbk1hc2s9LTFdXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkdyb3VwPS0xXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEJhY2tmYWNlcz1mYWxzZV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U9dHJ1ZV1cbiAqIEBwYXJhbSAge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbnkgYm9keSB3YXMgaGl0LlxuICovXG5Xb3JsZC5wcm90b3R5cGUucmF5Y2FzdENsb3Nlc3QgPSBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucywgcmVzdWx0KXtcbiAgICBvcHRpb25zLm1vZGUgPSBSYXkuQ0xPU0VTVDtcbiAgICBvcHRpb25zLmZyb20gPSBmcm9tO1xuICAgIG9wdGlvbnMudG8gPSB0bztcbiAgICBvcHRpb25zLnJlc3VsdCA9IHJlc3VsdDtcbiAgICByZXR1cm4gdG1wUmF5LmludGVyc2VjdFdvcmxkKHRoaXMsIG9wdGlvbnMpO1xufTtcbn0se1wiLi4vLi4vcGFja2FnZS5qc29uXCI6NixcIi4uL2NvbGxpc2lvbi9Ccm9hZHBoYXNlXCI6OCxcIi4uL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2VcIjoxMCxcIi4uL2NvbGxpc2lvbi9OYXJyb3dwaGFzZVwiOjExLFwiLi4vY29sbGlzaW9uL1JheVwiOjEyLFwiLi4vY29sbGlzaW9uL1NBUEJyb2FkcGhhc2VcIjoxNCxcIi4uL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnRcIjoxNSxcIi4uL2NvbnN0cmFpbnRzL0Rpc3RhbmNlQ29uc3RyYWludFwiOjE2LFwiLi4vY29uc3RyYWludHMvR2VhckNvbnN0cmFpbnRcIjoxNyxcIi4uL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50XCI6MTgsXCIuLi9jb25zdHJhaW50cy9QcmlzbWF0aWNDb25zdHJhaW50XCI6MTksXCIuLi9jb25zdHJhaW50cy9SZXZvbHV0ZUNvbnN0cmFpbnRcIjoyMCxcIi4uL2V2ZW50cy9FdmVudEVtaXR0ZXJcIjoyNyxcIi4uL21hdGVyaWFsL0NvbnRhY3RNYXRlcmlhbFwiOjI4LFwiLi4vbWF0ZXJpYWwvTWF0ZXJpYWxcIjoyOSxcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vb2JqZWN0cy9Cb2R5XCI6MzIsXCIuLi9vYmplY3RzL0xpbmVhclNwcmluZ1wiOjMzLFwiLi4vb2JqZWN0cy9Sb3RhdGlvbmFsU3ByaW5nXCI6MzQsXCIuLi9zaGFwZXMvQ2Fwc3VsZVwiOjM3LFwiLi4vc2hhcGVzL0NpcmNsZVwiOjM4LFwiLi4vc2hhcGVzL0NvbnZleFwiOjM5LFwiLi4vc2hhcGVzL0xpbmVcIjo0MSxcIi4uL3NoYXBlcy9QYXJ0aWNsZVwiOjQyLFwiLi4vc2hhcGVzL1BsYW5lXCI6NDMsXCIuLi9zaGFwZXMvUmVjdGFuZ2xlXCI6NDQsXCIuLi9zaGFwZXMvU2hhcGVcIjo0NSxcIi4uL3NvbHZlci9HU1NvbHZlclwiOjQ2LFwiLi4vc29sdmVyL1NvbHZlclwiOjQ3LFwiLi4vdXRpbHMvT3ZlcmxhcEtlZXBlclwiOjQ4LFwiLi4vdXRpbHMvVXRpbHNcIjo1MCxcIi4vSXNsYW5kTWFuYWdlclwiOjUyfV19LHt9LFszNl0pXG4oMzYpXG59KTs7IiwiIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYucG9seTJ0cmk9ZSgpfX0oZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cz17XCJ2ZXJzaW9uXCI6IFwiMS4zLjVcIn1cbn0se31dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqIFBvbHkyVHJpIENvcHlyaWdodCAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cbiAqIFxuICogcG9seTJ0cmkuanMgKEphdmFTY3JpcHQgcG9ydCkgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcjNtaS9wb2x5MnRyaS5qc1xuICogXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgMy1jbGF1c2UgQlNEIExpY2Vuc2UsIHNlZSBMSUNFTlNFLnR4dFxuICovXG5cbi8qIGpzaGludCBtYXhjb21wbGV4aXR5OjExICovXG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qXG4gKiBOb3RlXG4gKiA9PT09XG4gKiB0aGUgc3RydWN0dXJlIG9mIHRoaXMgSmF2YVNjcmlwdCB2ZXJzaW9uIG9mIHBvbHkydHJpIGludGVudGlvbmFsbHkgZm9sbG93c1xuICogYXMgY2xvc2VseSBhcyBwb3NzaWJsZSB0aGUgc3RydWN0dXJlIG9mIHRoZSByZWZlcmVuY2UgQysrIHZlcnNpb24sIHRvIG1ha2UgaXQgXG4gKiBlYXNpZXIgdG8ga2VlcCB0aGUgMiB2ZXJzaW9ucyBpbiBzeW5jLlxuICovXG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLU5vZGVcblxuLyoqXG4gKiBBZHZhbmNpbmcgZnJvbnQgbm9kZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICogQHN0cnVjdFxuICogQHBhcmFtIHshWFl9IHAgLSBQb2ludFxuICogQHBhcmFtIHtUcmlhbmdsZT19IHQgdHJpYW5nbGUgKG9wdGlvbmFsKVxuICovXG52YXIgTm9kZSA9IGZ1bmN0aW9uKHAsIHQpIHtcbiAgICAvKiogQHR5cGUge1hZfSAqL1xuICAgIHRoaXMucG9pbnQgPSBwO1xuXG4gICAgLyoqIEB0eXBlIHtUcmlhbmdsZXxudWxsfSAqL1xuICAgIHRoaXMudHJpYW5nbGUgPSB0IHx8IG51bGw7XG5cbiAgICAvKiogQHR5cGUge05vZGV8bnVsbH0gKi9cbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7Tm9kZXxudWxsfSAqL1xuICAgIHRoaXMucHJldiA9IG51bGw7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnZhbHVlID0gcC54O1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tQWR2YW5jaW5nRnJvbnRcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICogQHN0cnVjdFxuICogQHBhcmFtIHtOb2RlfSBoZWFkXG4gKiBAcGFyYW0ge05vZGV9IHRhaWxcbiAqL1xudmFyIEFkdmFuY2luZ0Zyb250ID0gZnVuY3Rpb24oaGVhZCwgdGFpbCkge1xuICAgIC8qKiBAdHlwZSB7Tm9kZX0gKi9cbiAgICB0aGlzLmhlYWRfID0gaGVhZDtcbiAgICAvKiogQHR5cGUge05vZGV9ICovXG4gICAgdGhpcy50YWlsXyA9IHRhaWw7XG4gICAgLyoqIEB0eXBlIHtOb2RlfSAqL1xuICAgIHRoaXMuc2VhcmNoX25vZGVfID0gaGVhZDtcbn07XG5cbi8qKiBAcmV0dXJuIHtOb2RlfSAqL1xuQWR2YW5jaW5nRnJvbnQucHJvdG90eXBlLmhlYWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5oZWFkXztcbn07XG5cbi8qKiBAcGFyYW0ge05vZGV9IG5vZGUgKi9cbkFkdmFuY2luZ0Zyb250LnByb3RvdHlwZS5zZXRIZWFkID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMuaGVhZF8gPSBub2RlO1xufTtcblxuLyoqIEByZXR1cm4ge05vZGV9ICovXG5BZHZhbmNpbmdGcm9udC5wcm90b3R5cGUudGFpbCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRhaWxfO1xufTtcblxuLyoqIEBwYXJhbSB7Tm9kZX0gbm9kZSAqL1xuQWR2YW5jaW5nRnJvbnQucHJvdG90eXBlLnNldFRhaWwgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy50YWlsXyA9IG5vZGU7XG59O1xuXG4vKiogQHJldHVybiB7Tm9kZX0gKi9cbkFkdmFuY2luZ0Zyb250LnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zZWFyY2hfbm9kZV87XG59O1xuXG4vKiogQHBhcmFtIHtOb2RlfSBub2RlICovXG5BZHZhbmNpbmdGcm9udC5wcm90b3R5cGUuc2V0U2VhcmNoID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMuc2VhcmNoX25vZGVfID0gbm9kZTtcbn07XG5cbi8qKiBAcmV0dXJuIHtOb2RlfSAqL1xuQWR2YW5jaW5nRnJvbnQucHJvdG90eXBlLmZpbmRTZWFyY2hOb2RlID0gZnVuY3Rpb24oLyp4Ki8pIHtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgQlNUIGluZGV4XG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoX25vZGVfO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geCB2YWx1ZVxuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuQWR2YW5jaW5nRnJvbnQucHJvdG90eXBlLmxvY2F0ZU5vZGUgPSBmdW5jdGlvbih4KSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnNlYXJjaF9ub2RlXztcblxuICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgICBpZiAoeCA8IG5vZGUudmFsdWUpIHtcbiAgICAgICAgd2hpbGUgKG5vZGUgPSBub2RlLnByZXYpIHtcbiAgICAgICAgICAgIGlmICh4ID49IG5vZGUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaF9ub2RlXyA9IG5vZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAobm9kZSA9IG5vZGUubmV4dCkge1xuICAgICAgICAgICAgaWYgKHggPCBub2RlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hfbm9kZV8gPSBub2RlLnByZXY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHshWFl9IHBvaW50IC0gUG9pbnRcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cbkFkdmFuY2luZ0Zyb250LnByb3RvdHlwZS5sb2NhdGVQb2ludCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgdmFyIHB4ID0gcG9pbnQueDtcbiAgICB2YXIgbm9kZSA9IHRoaXMuZmluZFNlYXJjaE5vZGUocHgpO1xuICAgIHZhciBueCA9IG5vZGUucG9pbnQueDtcblxuICAgIGlmIChweCA9PT0gbngpIHtcbiAgICAgICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICAgICAgaWYgKHBvaW50ICE9PSBub2RlLnBvaW50KSB7XG4gICAgICAgICAgICAvLyBXZSBtaWdodCBoYXZlIHR3byBub2RlcyB3aXRoIHNhbWUgeCB2YWx1ZSBmb3IgYSBzaG9ydCB0aW1lXG4gICAgICAgICAgICBpZiAocG9pbnQgPT09IG5vZGUucHJldi5wb2ludCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnByZXY7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvaW50ID09PSBub2RlLm5leHQucG9pbnQpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHkydHJpIEludmFsaWQgQWR2YW5jaW5nRnJvbnQubG9jYXRlUG9pbnQoKSBjYWxsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHB4IDwgbngpIHtcbiAgICAgICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuICAgICAgICB3aGlsZSAobm9kZSA9IG5vZGUucHJldikge1xuICAgICAgICAgICAgaWYgKHBvaW50ID09PSBub2RlLnBvaW50KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAobm9kZSA9IG5vZGUubmV4dCkge1xuICAgICAgICAgICAgaWYgKHBvaW50ID09PSBub2RlLnBvaW50KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZSkge1xuICAgICAgICB0aGlzLnNlYXJjaF9ub2RlXyA9IG5vZGU7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tRXhwb3J0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFkdmFuY2luZ0Zyb250O1xubW9kdWxlLmV4cG9ydHMuTm9kZSA9IE5vZGU7XG5cblxufSx7fV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogUG9seTJUcmkgQ29weXJpZ2h0IChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xuICpcbiAqIHBvbHkydHJpLmpzIChKYXZhU2NyaXB0IHBvcnQpIChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cHM6Ly9naXRodWIuY29tL3IzbWkvcG9seTJ0cmkuanNcbiAqXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSAzLWNsYXVzZSBCU0QgTGljZW5zZSwgc2VlIExJQ0VOU0UudHh0XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gKiBGdW5jdGlvbiBhZGRlZCBpbiB0aGUgSmF2YVNjcmlwdCB2ZXJzaW9uICh3YXMgbm90IHByZXNlbnQgaW4gdGhlIGMrKyB2ZXJzaW9uKVxuICovXG5cbi8qKlxuICogYXNzZXJ0IGFuZCB0aHJvdyBhbiBleGNlcHRpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZGl0aW9uICAgdGhlIGNvbmRpdGlvbiB3aGljaCBpcyBhc3NlcnRlZFxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgICAgICB0aGUgbWVzc2FnZSB3aGljaCBpcyBkaXNwbGF5IGlzIGNvbmRpdGlvbiBpcyBmYWxzeVxuICovXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgXCJBc3NlcnQgRmFpbGVkXCIpO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gYXNzZXJ0O1xuXG5cblxufSx7fV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogUG9seTJUcmkgQ29weXJpZ2h0IChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xuICogXG4gKiBwb2x5MnRyaS5qcyAoSmF2YVNjcmlwdCBwb3J0KSAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yM21pL3BvbHkydHJpLmpzXG4gKiBcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSAzLWNsYXVzZSBCU0QgTGljZW5zZSwgc2VlIExJQ0VOU0UudHh0XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLypcbiAqIE5vdGVcbiAqID09PT1cbiAqIHRoZSBzdHJ1Y3R1cmUgb2YgdGhpcyBKYXZhU2NyaXB0IHZlcnNpb24gb2YgcG9seTJ0cmkgaW50ZW50aW9uYWxseSBmb2xsb3dzXG4gKiBhcyBjbG9zZWx5IGFzIHBvc3NpYmxlIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIHJlZmVyZW5jZSBDKysgdmVyc2lvbiwgdG8gbWFrZSBpdCBcbiAqIGVhc2llciB0byBrZWVwIHRoZSAyIHZlcnNpb25zIGluIHN5bmMuXG4gKi9cblxudmFyIHh5ID0gX2RlcmVxXygnLi94eScpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1Qb2ludFxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBwb2ludFxuICogQGV4YW1wbGVcbiAqICAgICAgdmFyIHBvaW50ID0gbmV3IHBvbHkydHJpLlBvaW50KDE1MCwgMTUwKTtcbiAqIEBwdWJsaWNcbiAqIEBjb25zdHJ1Y3RvclxuICogQHN0cnVjdFxuICogQHBhcmFtIHtudW1iZXI9fSB4ICAgIGNvb3JkaW5hdGUgKDAgaWYgdW5kZWZpbmVkKVxuICogQHBhcmFtIHtudW1iZXI9fSB5ICAgIGNvb3JkaW5hdGUgKDAgaWYgdW5kZWZpbmVkKVxuICovXG52YXIgUG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgdGhpcy54ID0gK3ggfHwgMDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICB0aGlzLnkgPSAreSB8fCAwO1xuXG4gICAgLy8gQWxsIGV4dHJhIGZpZWxkcyBhZGRlZCB0byBQb2ludCBhcmUgcHJlZml4ZWQgd2l0aCBfcDJ0X1xuICAgIC8vIHRvIGF2b2lkIGNvbGxpc2lvbnMgaWYgY3VzdG9tIFBvaW50IGNsYXNzIGlzIHVzZWQuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRnZXMgdGhpcyBwb2ludCBjb25zdGl0dXRlcyBhbiB1cHBlciBlbmRpbmcgcG9pbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheS48RWRnZT59XG4gICAgICovXG4gICAgdGhpcy5fcDJ0X2VkZ2VfbGlzdCA9IG51bGw7XG59O1xuXG4vKipcbiAqIEZvciBwcmV0dHkgcHJpbnRpbmdcbiAqIEBleGFtcGxlXG4gKiAgICAgIFwicD1cIiArIG5ldyBwb2x5MnRyaS5Qb2ludCg1LDQyKVxuICogICAgICAvLyDihpIgXCJwPSg1OzQyKVwiXG4gKiBAcmV0dXJucyB7c3RyaW5nfSA8Y29kZT5cIih4O3kpXCI8L2NvZGU+XG4gKi9cblBvaW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4eS50b1N0cmluZ0Jhc2UodGhpcyk7XG59O1xuXG4vKipcbiAqIEpTT04gb3V0cHV0LCBvbmx5IGNvb3JkaW5hdGVzXG4gKiBAZXhhbXBsZVxuICogICAgICBKU09OLnN0cmluZ2lmeShuZXcgcG9seTJ0cmkuUG9pbnQoMSwyKSlcbiAqICAgICAgLy8g4oaSICd7XCJ4XCI6MSxcInlcIjoyfSdcbiAqL1xuUG9pbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7IHg6IHRoaXMueCwgeTogdGhpcy55IH07XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgUG9pbnQgb2JqZWN0LlxuICogQHJldHVybiB7UG9pbnR9IG5ldyBjbG9uZWQgcG9pbnRcbiAqL1xuUG9pbnQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG59O1xuXG4vKipcbiAqIFNldCB0aGlzIFBvaW50IGluc3RhbmNlIHRvIHRoZSBvcmlnby4gPGNvZGU+KDA7IDApPC9jb2RlPlxuICogQHJldHVybiB7UG9pbnR9IHRoaXMgKGZvciBjaGFpbmluZylcbiAqL1xuUG9pbnQucHJvdG90eXBlLnNldF96ZXJvID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy54ID0gMC4wO1xuICAgIHRoaXMueSA9IDAuMDtcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhpcyBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4ICAgY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHkgICBjb29yZGluYXRlXG4gKiBAcmV0dXJuIHtQb2ludH0gdGhpcyAoZm9yIGNoYWluaW5nKVxuICovXG5Qb2ludC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMueCA9ICt4IHx8IDA7XG4gICAgdGhpcy55ID0gK3kgfHwgMDtcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG59O1xuXG4vKipcbiAqIE5lZ2F0ZSB0aGlzIFBvaW50IGluc3RhbmNlLiAoY29tcG9uZW50LXdpc2UpXG4gKiBAcmV0dXJuIHtQb2ludH0gdGhpcyAoZm9yIGNoYWluaW5nKVxuICovXG5Qb2ludC5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy54ID0gLXRoaXMueDtcbiAgICB0aGlzLnkgPSAtdGhpcy55O1xuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcbn07XG5cbi8qKlxuICogQWRkIGFub3RoZXIgUG9pbnQgb2JqZWN0IHRvIHRoaXMgaW5zdGFuY2UuIChjb21wb25lbnQtd2lzZSlcbiAqIEBwYXJhbSB7IVBvaW50fSBuIC0gUG9pbnQgb2JqZWN0LlxuICogQHJldHVybiB7UG9pbnR9IHRoaXMgKGZvciBjaGFpbmluZylcbiAqL1xuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0aGlzLnggKz0gbi54O1xuICAgIHRoaXMueSArPSBuLnk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdCB0aGlzIFBvaW50IGluc3RhbmNlIHdpdGggYW5vdGhlciBwb2ludCBnaXZlbi4gKGNvbXBvbmVudC13aXNlKVxuICogQHBhcmFtIHshUG9pbnR9IG4gLSBQb2ludCBvYmplY3QuXG4gKiBAcmV0dXJuIHtQb2ludH0gdGhpcyAoZm9yIGNoYWluaW5nKVxuICovXG5Qb2ludC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24obikge1xuICAgIHRoaXMueCAtPSBuLng7XG4gICAgdGhpcy55IC09IG4ueTtcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG59O1xuXG4vKipcbiAqIE11bHRpcGx5IHRoaXMgUG9pbnQgaW5zdGFuY2UgYnkgYSBzY2FsYXIuIChjb21wb25lbnQtd2lzZSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzICAgc2NhbGFyLlxuICogQHJldHVybiB7UG9pbnR9IHRoaXMgKGZvciBjaGFpbmluZylcbiAqL1xuUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKHMpIHtcbiAgICB0aGlzLnggKj0gcztcbiAgICB0aGlzLnkgKj0gcztcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgZGlzdGFuY2Ugb2YgdGhpcyBQb2ludCBpbnN0YW5jZSBmcm9tIHRoZSBvcmlnby5cbiAqIEByZXR1cm4ge251bWJlcn0gZGlzdGFuY2VcbiAqL1xuUG9pbnQucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIHRoaXMgUG9pbnQgaW5zdGFuY2UgKGFzIGEgdmVjdG9yKS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG9yaWdpbmFsIGRpc3RhbmNlIG9mIHRoaXMgaW5zdGFuY2UgZnJvbSB0aGUgb3JpZ28uXG4gKi9cblBvaW50LnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgICB0aGlzLnggLz0gbGVuO1xuICAgIHRoaXMueSAvPSBsZW47XG4gICAgcmV0dXJuIGxlbjtcbn07XG5cbi8qKlxuICogVGVzdCB0aGlzIFBvaW50IG9iamVjdCB3aXRoIGFub3RoZXIgZm9yIGVxdWFsaXR5LlxuICogQHBhcmFtIHshWFl9IHAgLSBhbnkgXCJQb2ludCBsaWtlXCIgb2JqZWN0IHdpdGgge3gseX1cbiAqIEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIHNhbWUgeCBhbmQgeSBjb29yZGluYXRlcywgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqL1xuUG9pbnQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gdGhpcy54ID09PSBwLnggJiYgdGhpcy55ID09PSBwLnk7XG59O1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tUG9pbnQgKFwic3RhdGljXCIgbWV0aG9kcylcblxuLyoqXG4gKiBOZWdhdGUgYSBwb2ludCBjb21wb25lbnQtd2lzZSBhbmQgcmV0dXJuIHRoZSByZXN1bHQgYXMgYSBuZXcgUG9pbnQgb2JqZWN0LlxuICogQHBhcmFtIHshWFl9IHAgLSBhbnkgXCJQb2ludCBsaWtlXCIgb2JqZWN0IHdpdGgge3gseX1cbiAqIEByZXR1cm4ge1BvaW50fSB0aGUgcmVzdWx0aW5nIFBvaW50IG9iamVjdC5cbiAqL1xuUG9pbnQubmVnYXRlID0gZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiBuZXcgUG9pbnQoLXAueCwgLXAueSk7XG59O1xuXG4vKipcbiAqIEFkZCB0d28gcG9pbnRzIGNvbXBvbmVudC13aXNlIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBhcyBhIG5ldyBQb2ludCBvYmplY3QuXG4gKiBAcGFyYW0geyFYWX0gYSAtIGFueSBcIlBvaW50IGxpa2VcIiBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHshWFl9IGIgLSBhbnkgXCJQb2ludCBsaWtlXCIgb2JqZWN0IHdpdGgge3gseX1cbiAqIEByZXR1cm4ge1BvaW50fSB0aGUgcmVzdWx0aW5nIFBvaW50IG9iamVjdC5cbiAqL1xuUG9pbnQuYWRkID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBuZXcgUG9pbnQoYS54ICsgYi54LCBhLnkgKyBiLnkpO1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdCB0d28gcG9pbnRzIGNvbXBvbmVudC13aXNlIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBhcyBhIG5ldyBQb2ludCBvYmplY3QuXG4gKiBAcGFyYW0geyFYWX0gYSAtIGFueSBcIlBvaW50IGxpa2VcIiBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHshWFl9IGIgLSBhbnkgXCJQb2ludCBsaWtlXCIgb2JqZWN0IHdpdGgge3gseX1cbiAqIEByZXR1cm4ge1BvaW50fSB0aGUgcmVzdWx0aW5nIFBvaW50IG9iamVjdC5cbiAqL1xuUG9pbnQuc3ViID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBuZXcgUG9pbnQoYS54IC0gYi54LCBhLnkgLSBiLnkpO1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSBhIHBvaW50IGJ5IGEgc2NhbGFyIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBhcyBhIG5ldyBQb2ludCBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gcyAtIHRoZSBzY2FsYXJcbiAqIEBwYXJhbSB7IVhZfSBwIC0gYW55IFwiUG9pbnQgbGlrZVwiIG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcmV0dXJuIHtQb2ludH0gdGhlIHJlc3VsdGluZyBQb2ludCBvYmplY3QuXG4gKi9cblBvaW50Lm11bCA9IGZ1bmN0aW9uKHMsIHApIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KHMgKiBwLngsIHMgKiBwLnkpO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHRoZSBjcm9zcyBwcm9kdWN0IG9uIGVpdGhlciB0d28gcG9pbnRzICh0aGlzIHByb2R1Y2VzIGEgc2NhbGFyKVxuICogb3IgYSBwb2ludCBhbmQgYSBzY2FsYXIgKHRoaXMgcHJvZHVjZXMgYSBwb2ludCkuXG4gKiBUaGlzIGZ1bmN0aW9uIHJlcXVpcmVzIHR3byBwYXJhbWV0ZXJzLCBlaXRoZXIgbWF5IGJlIGEgUG9pbnQgb2JqZWN0IG9yIGFcbiAqIG51bWJlci5cbiAqIEBwYXJhbSAge1hZfG51bWJlcn0gYSAtIFBvaW50IG9iamVjdCBvciBzY2FsYXIuXG4gKiBAcGFyYW0gIHtYWXxudW1iZXJ9IGIgLSBQb2ludCBvYmplY3Qgb3Igc2NhbGFyLlxuICogQHJldHVybiB7UG9pbnR8bnVtYmVyfSBhIFBvaW50IG9iamVjdCBvciBhIG51bWJlciwgZGVwZW5kaW5nIG9uIHRoZSBwYXJhbWV0ZXJzLlxuICovXG5Qb2ludC5jcm9zcyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBpZiAodHlwZW9mKGEpID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAodHlwZW9mKGIpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGEgKiBiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgtYSAqIGIueSwgYSAqIGIueCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mKGIpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChiICogYS55LCAtYiAqIGEueCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYS54ICogYi55IC0gYS55ICogYi54O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiUG9pbnQtTGlrZVwiXG4vKlxuICogVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgb3BlcmF0ZSBvbiBcIlBvaW50XCIgb3IgYW55IFwiUG9pbnQgbGlrZVwiIG9iamVjdCBcbiAqIHdpdGgge3gseX0gKGR1Y2sgdHlwaW5nKS5cbiAqL1xuXG5Qb2ludC50b1N0cmluZyA9IHh5LnRvU3RyaW5nO1xuUG9pbnQuY29tcGFyZSA9IHh5LmNvbXBhcmU7XG5Qb2ludC5jbXAgPSB4eS5jb21wYXJlOyAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5Qb2ludC5lcXVhbHMgPSB4eS5lcXVhbHM7XG5cbi8qKlxuICogUGVmb3JtIHRoZSBkb3QgcHJvZHVjdCBvbiB0d28gdmVjdG9ycy5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7IVhZfSBhIC0gYW55IFwiUG9pbnQgbGlrZVwiIG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0geyFYWX0gYiAtIGFueSBcIlBvaW50IGxpa2VcIiBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZG90IHByb2R1Y3RcbiAqL1xuUG9pbnQuZG90ID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhLnggKiBiLnggKyBhLnkgKiBiLnk7XG59O1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLUV4cG9ydHMgKHB1YmxpYyBBUEkpXG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG5cbn0se1wiLi94eVwiOjExfV0sNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogUG9seTJUcmkgQ29weXJpZ2h0IChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xuICogXG4gKiBwb2x5MnRyaS5qcyAoSmF2YVNjcmlwdCBwb3J0KSAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yM21pL3BvbHkydHJpLmpzXG4gKiBcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSAzLWNsYXVzZSBCU0QgTGljZW5zZSwgc2VlIExJQ0VOU0UudHh0XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gKiBDbGFzcyBhZGRlZCBpbiB0aGUgSmF2YVNjcmlwdCB2ZXJzaW9uICh3YXMgbm90IHByZXNlbnQgaW4gdGhlIGMrKyB2ZXJzaW9uKVxuICovXG5cbnZhciB4eSA9IF9kZXJlcV8oJy4veHknKTtcblxuLyoqXG4gKiBDdXN0b20gZXhjZXB0aW9uIGNsYXNzIHRvIGluZGljYXRlIGludmFsaWQgUG9pbnQgdmFsdWVzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqIEBleHRlbmRzIEVycm9yXG4gKiBAc3RydWN0XG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgLSBlcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge0FycmF5LjxYWT49fSBwb2ludHMgLSBpbnZhbGlkIHBvaW50c1xuICovXG52YXIgUG9pbnRFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHBvaW50cykge1xuICAgIHRoaXMubmFtZSA9IFwiUG9pbnRFcnJvclwiO1xuICAgIC8qKlxuICAgICAqIEludmFsaWQgcG9pbnRzXG4gICAgICogQHB1YmxpY1xuICAgICAqIEB0eXBlIHtBcnJheS48WFk+fVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRzID0gcG9pbnRzID0gcG9pbnRzIHx8IFtdO1xuICAgIC8qKlxuICAgICAqIEVycm9yIG1lc3NhZ2VcbiAgICAgKiBAcHVibGljXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IFwiSW52YWxpZCBQb2ludHMhXCI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlICs9IFwiIFwiICsgeHkudG9TdHJpbmcocG9pbnRzW2ldKTtcbiAgICB9XG59O1xuUG9pbnRFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblBvaW50RXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9pbnRFcnJvcjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50RXJyb3I7XG5cbn0se1wiLi94eVwiOjExfV0sNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKlxuICogUG9seTJUcmkgQ29weXJpZ2h0IChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xuICogXG4gKiBwb2x5MnRyaS5qcyAoSmF2YVNjcmlwdCBwb3J0KSAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yM21pL3BvbHkydHJpLmpzXG4gKlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAqIE5laXRoZXIgdGhlIG5hbWUgb2YgUG9seTJUcmkgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxuICogICB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXG4gKiAgIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcbiAqIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogUHVibGljIEFQSSBmb3IgcG9seTJ0cmkuanNcbiAqIEBtb2R1bGUgcG9seTJ0cmlcbiAqL1xuXG5cbi8qKlxuICogSWYgeW91IGFyZSBub3QgdXNpbmcgYSBtb2R1bGUgc3lzdGVtIChlLmcuIENvbW1vbkpTLCBSZXF1aXJlSlMpLCB5b3UgY2FuIGFjY2VzcyB0aGlzIGxpYnJhcnlcbiAqIGFzIGEgZ2xvYmFsIHZhcmlhYmxlIDxjb2RlPnBvbHkydHJpPC9jb2RlPiBpLmUuIDxjb2RlPndpbmRvdy5wb2x5MnRyaTwvY29kZT4gaW4gYSBicm93c2VyLlxuICogQG5hbWUgcG9seTJ0cmlcbiAqIEBnbG9iYWxcbiAqIEBwdWJsaWNcbiAqIEB0eXBlIHttb2R1bGU6cG9seTJ0cml9XG4gKi9cbnZhciBwcmV2aW91c1BvbHkydHJpID0gZ2xvYmFsLnBvbHkydHJpO1xuLyoqXG4gKiBGb3IgQnJvd3NlciArICZsdDtzY3JpcHQmZ3Q7IDpcbiAqIHJldmVydHMgdGhlIHtAbGlua2NvZGUgcG9seTJ0cml9IGdsb2JhbCBvYmplY3QgdG8gaXRzIHByZXZpb3VzIHZhbHVlLFxuICogYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlIGNhbGxlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgICAgICAgICAgIHZhciBwID0gcG9seTJ0cmkubm9Db25mbGljdCgpO1xuICogQHB1YmxpY1xuICogQHJldHVybiB7bW9kdWxlOnBvbHkydHJpfSBpbnN0YW5jZSBjYWxsZWRcbiAqL1xuLy8gKHRoaXMgZmVhdHVyZSBpcyBub3QgYXV0b21hdGljYWxseSBwcm92aWRlZCBieSBicm93c2VyaWZ5KS5cbmV4cG9ydHMubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIGdsb2JhbC5wb2x5MnRyaSA9IHByZXZpb3VzUG9seTJ0cmk7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG59O1xuXG4vKipcbiAqIHBvbHkydHJpIGxpYnJhcnkgdmVyc2lvblxuICogQHB1YmxpY1xuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuVkVSU0lPTiA9IF9kZXJlcV8oJy4uL2Rpc3QvdmVyc2lvbi5qc29uJykudmVyc2lvbjtcblxuLyoqXG4gKiBFeHBvcnRzIHRoZSB7QGxpbmtjb2RlIFBvaW50RXJyb3J9IGNsYXNzLlxuICogQHB1YmxpY1xuICogQHR5cGVkZWYge1BvaW50RXJyb3J9IG1vZHVsZTpwb2x5MnRyaS5Qb2ludEVycm9yXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0cy5Qb2ludEVycm9yID0gX2RlcmVxXygnLi9wb2ludGVycm9yJyk7XG4vKipcbiAqIEV4cG9ydHMgdGhlIHtAbGlua2NvZGUgUG9pbnR9IGNsYXNzLlxuICogQHB1YmxpY1xuICogQHR5cGVkZWYge1BvaW50fSBtb2R1bGU6cG9seTJ0cmkuUG9pbnRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnRzLlBvaW50ID0gX2RlcmVxXygnLi9wb2ludCcpO1xuLyoqXG4gKiBFeHBvcnRzIHRoZSB7QGxpbmtjb2RlIFRyaWFuZ2xlfSBjbGFzcy5cbiAqIEBwdWJsaWNcbiAqIEB0eXBlZGVmIHtUcmlhbmdsZX0gbW9kdWxlOnBvbHkydHJpLlRyaWFuZ2xlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0cy5UcmlhbmdsZSA9IF9kZXJlcV8oJy4vdHJpYW5nbGUnKTtcbi8qKlxuICogRXhwb3J0cyB0aGUge0BsaW5rY29kZSBTd2VlcENvbnRleHR9IGNsYXNzLlxuICogQHB1YmxpY1xuICogQHR5cGVkZWYge1N3ZWVwQ29udGV4dH0gbW9kdWxlOnBvbHkydHJpLlN3ZWVwQ29udGV4dFxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydHMuU3dlZXBDb250ZXh0ID0gX2RlcmVxXygnLi9zd2VlcGNvbnRleHQnKTtcblxuXG4vLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5XG52YXIgc3dlZXAgPSBfZGVyZXFfKCcuL3N3ZWVwJyk7XG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlcHJlY2F0ZWQgdXNlIHtAbGlua2NvZGUgU3dlZXBDb250ZXh0I3RyaWFuZ3VsYXRlfSBpbnN0ZWFkXG4gKi9cbmV4cG9ydHMudHJpYW5ndWxhdGUgPSBzd2VlcC50cmlhbmd1bGF0ZTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIHtAbGlua2NvZGUgU3dlZXBDb250ZXh0I3RyaWFuZ3VsYXRlfSBpbnN0ZWFkXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBUcmlhbmd1bGF0ZSAtIHVzZSB7QGxpbmtjb2RlIFN3ZWVwQ29udGV4dCN0cmlhbmd1bGF0ZX0gaW5zdGVhZFxuICovXG5leHBvcnRzLnN3ZWVwID0ge1RyaWFuZ3VsYXRlOiBzd2VlcC50cmlhbmd1bGF0ZX07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4uL2Rpc3QvdmVyc2lvbi5qc29uXCI6MSxcIi4vcG9pbnRcIjo0LFwiLi9wb2ludGVycm9yXCI6NSxcIi4vc3dlZXBcIjo3LFwiLi9zd2VlcGNvbnRleHRcIjo4LFwiLi90cmlhbmdsZVwiOjl9XSw3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBQb2x5MlRyaSBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXG4gKiBcbiAqIHBvbHkydHJpLmpzIChKYXZhU2NyaXB0IHBvcnQpIChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cHM6Ly9naXRodWIuY29tL3IzbWkvcG9seTJ0cmkuanNcbiAqIFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIDMtY2xhdXNlIEJTRCBMaWNlbnNlLCBzZWUgTElDRU5TRS50eHRcbiAqL1xuXG4vKiBqc2hpbnQgbGF0ZWRlZjpub2Z1bmMsIG1heGNvbXBsZXhpdHk6OSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBUaGlzICdTd2VlcCcgbW9kdWxlIGlzIHByZXNlbnQgaW4gb3JkZXIgdG8ga2VlcCB0aGlzIEphdmFTY3JpcHQgdmVyc2lvblxuICogYXMgY2xvc2UgYXMgcG9zc2libGUgdG8gdGhlIHJlZmVyZW5jZSBDKysgdmVyc2lvbiwgZXZlbiB0aG91Z2ggYWxtb3N0IGFsbFxuICogZnVuY3Rpb25zIGNvdWxkIGJlIGRlY2xhcmVkIGFzIG1ldGhvZHMgb24gdGhlIHtAbGlua2NvZGUgbW9kdWxlOnN3ZWVwY29udGV4dH5Td2VlcENvbnRleHR9IG9iamVjdC5cbiAqIEBtb2R1bGVcbiAqIEBwcml2YXRlXG4gKi9cblxuLypcbiAqIE5vdGVcbiAqID09PT1cbiAqIHRoZSBzdHJ1Y3R1cmUgb2YgdGhpcyBKYXZhU2NyaXB0IHZlcnNpb24gb2YgcG9seTJ0cmkgaW50ZW50aW9uYWxseSBmb2xsb3dzXG4gKiBhcyBjbG9zZWx5IGFzIHBvc3NpYmxlIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIHJlZmVyZW5jZSBDKysgdmVyc2lvbiwgdG8gbWFrZSBpdCBcbiAqIGVhc2llciB0byBrZWVwIHRoZSAyIHZlcnNpb25zIGluIHN5bmMuXG4gKi9cblxudmFyIGFzc2VydCA9IF9kZXJlcV8oJy4vYXNzZXJ0Jyk7XG52YXIgUG9pbnRFcnJvciA9IF9kZXJlcV8oJy4vcG9pbnRlcnJvcicpO1xudmFyIFRyaWFuZ2xlID0gX2RlcmVxXygnLi90cmlhbmdsZScpO1xudmFyIE5vZGUgPSBfZGVyZXFfKCcuL2FkdmFuY2luZ2Zyb250JykuTm9kZTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS11dGlsc1xuXG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuL3V0aWxzJyk7XG5cbi8qKiBAY29uc3QgKi9cbnZhciBFUFNJTE9OID0gdXRpbHMuRVBTSUxPTjtcblxuLyoqIEBjb25zdCAqL1xudmFyIE9yaWVudGF0aW9uID0gdXRpbHMuT3JpZW50YXRpb247XG4vKiogQGNvbnN0ICovXG52YXIgb3JpZW50MmQgPSB1dGlscy5vcmllbnQyZDtcbi8qKiBAY29uc3QgKi9cbnZhciBpblNjYW5BcmVhID0gdXRpbHMuaW5TY2FuQXJlYTtcbi8qKiBAY29uc3QgKi9cbnZhciBpc0FuZ2xlT2J0dXNlID0gdXRpbHMuaXNBbmdsZU9idHVzZTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1Td2VlcFxuXG4vKipcbiAqIFRyaWFuZ3VsYXRlIHRoZSBwb2x5Z29uIHdpdGggaG9sZXMgYW5kIFN0ZWluZXIgcG9pbnRzLlxuICogRG8gdGhpcyBBRlRFUiB5b3UndmUgYWRkZWQgdGhlIHBvbHlsaW5lLCBob2xlcywgYW5kIFN0ZWluZXIgcG9pbnRzXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHshU3dlZXBDb250ZXh0fSB0Y3ggLSBTd2VlcENvbnRleHQgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHRyaWFuZ3VsYXRlKHRjeCkge1xuICAgIHRjeC5pbml0VHJpYW5ndWxhdGlvbigpO1xuICAgIHRjeC5jcmVhdGVBZHZhbmNpbmdGcm9udCgpO1xuICAgIC8vIFN3ZWVwIHBvaW50czsgYnVpbGQgbWVzaFxuICAgIHN3ZWVwUG9pbnRzKHRjeCk7XG4gICAgLy8gQ2xlYW4gdXBcbiAgICBmaW5hbGl6YXRpb25Qb2x5Z29uKHRjeCk7XG59XG5cbi8qKlxuICogU3RhcnQgc3dlZXBpbmcgdGhlIFktc29ydGVkIHBvaW50IHNldCBmcm9tIGJvdHRvbSB0byB0b3BcbiAqIEBwYXJhbSB7IVN3ZWVwQ29udGV4dH0gdGN4IC0gU3dlZXBDb250ZXh0IG9iamVjdFxuICovXG5mdW5jdGlvbiBzd2VlcFBvaW50cyh0Y3gpIHtcbiAgICB2YXIgaSwgbGVuID0gdGN4LnBvaW50Q291bnQoKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gdGN4LmdldFBvaW50KGkpO1xuICAgICAgICB2YXIgbm9kZSA9IHBvaW50RXZlbnQodGN4LCBwb2ludCk7XG4gICAgICAgIHZhciBlZGdlcyA9IHBvaW50Ll9wMnRfZWRnZV9saXN0O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgZWRnZXMgJiYgaiA8IGVkZ2VzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBlZGdlRXZlbnRCeUVkZ2UodGN4LCBlZGdlc1tqXSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHshU3dlZXBDb250ZXh0fSB0Y3ggLSBTd2VlcENvbnRleHQgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGZpbmFsaXphdGlvblBvbHlnb24odGN4KSB7XG4gICAgLy8gR2V0IGFuIEludGVybmFsIHRyaWFuZ2xlIHRvIHN0YXJ0IHdpdGhcbiAgICB2YXIgdCA9IHRjeC5mcm9udCgpLmhlYWQoKS5uZXh0LnRyaWFuZ2xlO1xuICAgIHZhciBwID0gdGN4LmZyb250KCkuaGVhZCgpLm5leHQucG9pbnQ7XG4gICAgd2hpbGUgKCF0LmdldENvbnN0cmFpbmVkRWRnZUNXKHApKSB7XG4gICAgICAgIHQgPSB0Lm5laWdoYm9yQ0NXKHApO1xuICAgIH1cblxuICAgIC8vIENvbGxlY3QgaW50ZXJpb3IgdHJpYW5nbGVzIGNvbnN0cmFpbmVkIGJ5IGVkZ2VzXG4gICAgdGN4Lm1lc2hDbGVhbih0KTtcbn1cblxuLyoqXG4gKiBGaW5kIGNsb3NlcyBub2RlIHRvIHRoZSBsZWZ0IG9mIHRoZSBuZXcgcG9pbnQgYW5kXG4gKiBjcmVhdGUgYSBuZXcgdHJpYW5nbGUuIElmIG5lZWRlZCBuZXcgaG9sZXMgYW5kIGJhc2luc1xuICogd2lsbCBiZSBmaWxsZWQgdG8uXG4gKiBAcGFyYW0geyFTd2VlcENvbnRleHR9IHRjeCAtIFN3ZWVwQ29udGV4dCBvYmplY3RcbiAqIEBwYXJhbSB7IVhZfSBwb2ludCAgIFBvaW50XG4gKi9cbmZ1bmN0aW9uIHBvaW50RXZlbnQodGN4LCBwb2ludCkge1xuICAgIHZhciBub2RlID0gdGN4LmxvY2F0ZU5vZGUocG9pbnQpO1xuICAgIHZhciBuZXdfbm9kZSA9IG5ld0Zyb250VHJpYW5nbGUodGN4LCBwb2ludCwgbm9kZSk7XG5cbiAgICAvLyBPbmx5IG5lZWQgdG8gY2hlY2sgK2Vwc2lsb24gc2luY2UgcG9pbnQgbmV2ZXIgaGF2ZSBzbWFsbGVyXG4gICAgLy8geCB2YWx1ZSB0aGFuIG5vZGUgZHVlIHRvIGhvdyB3ZSBmZXRjaCBub2RlcyBmcm9tIHRoZSBmcm9udFxuICAgIGlmIChwb2ludC54IDw9IG5vZGUucG9pbnQueCArIChFUFNJTE9OKSkge1xuICAgICAgICBmaWxsKHRjeCwgbm9kZSk7XG4gICAgfVxuXG4gICAgLy90Y3guQWRkTm9kZShuZXdfbm9kZSk7XG5cbiAgICBmaWxsQWR2YW5jaW5nRnJvbnQodGN4LCBuZXdfbm9kZSk7XG4gICAgcmV0dXJuIG5ld19ub2RlO1xufVxuXG5mdW5jdGlvbiBlZGdlRXZlbnRCeUVkZ2UodGN4LCBlZGdlLCBub2RlKSB7XG4gICAgdGN4LmVkZ2VfZXZlbnQuY29uc3RyYWluZWRfZWRnZSA9IGVkZ2U7XG4gICAgdGN4LmVkZ2VfZXZlbnQucmlnaHQgPSAoZWRnZS5wLnggPiBlZGdlLnEueCk7XG5cbiAgICBpZiAoaXNFZGdlU2lkZU9mVHJpYW5nbGUobm9kZS50cmlhbmdsZSwgZWRnZS5wLCBlZGdlLnEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGb3Igbm93IHdlIHdpbGwgZG8gYWxsIG5lZWRlZCBmaWxsaW5nXG4gICAgLy8gVE9ETzogaW50ZWdyYXRlIHdpdGggZmxpcCBwcm9jZXNzIG1pZ2h0IGdpdmUgc29tZSBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAgICAvLyAgICAgICBidXQgZm9yIG5vdyB0aGlzIGF2b2lkIHRoZSBpc3N1ZSB3aXRoIGNhc2VzIHRoYXQgbmVlZHMgYm90aCBmbGlwcyBhbmQgZmlsbHNcbiAgICBmaWxsRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XG4gICAgZWRnZUV2ZW50QnlQb2ludHModGN4LCBlZGdlLnAsIGVkZ2UucSwgbm9kZS50cmlhbmdsZSwgZWRnZS5xKTtcbn1cblxuZnVuY3Rpb24gZWRnZUV2ZW50QnlQb2ludHModGN4LCBlcCwgZXEsIHRyaWFuZ2xlLCBwb2ludCkge1xuICAgIGlmIChpc0VkZ2VTaWRlT2ZUcmlhbmdsZSh0cmlhbmdsZSwgZXAsIGVxKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHAxID0gdHJpYW5nbGUucG9pbnRDQ1cocG9pbnQpO1xuICAgIHZhciBvMSA9IG9yaWVudDJkKGVxLCBwMSwgZXApO1xuICAgIGlmIChvMSA9PT0gT3JpZW50YXRpb24uQ09MTElORUFSKSB7XG4gICAgICAgIC8vIFRPRE8gaW50ZWdyYXRlIGhlcmUgY2hhbmdlcyBmcm9tIEMrKyB2ZXJzaW9uXG4gICAgICAgIC8vIChDKysgcmVwbyByZXZpc2lvbiAwOTg4MGE4NjkwOTUgZGF0ZWQgTWFyY2ggOCwgMjAxMSlcbiAgICAgICAgdGhyb3cgbmV3IFBvaW50RXJyb3IoJ3BvbHkydHJpIEVkZ2VFdmVudDogQ29sbGluZWFyIG5vdCBzdXBwb3J0ZWQhJywgW2VxLCBwMSwgZXBdKTtcbiAgICB9XG5cbiAgICB2YXIgcDIgPSB0cmlhbmdsZS5wb2ludENXKHBvaW50KTtcbiAgICB2YXIgbzIgPSBvcmllbnQyZChlcSwgcDIsIGVwKTtcbiAgICBpZiAobzIgPT09IE9yaWVudGF0aW9uLkNPTExJTkVBUikge1xuICAgICAgICAvLyBUT0RPIGludGVncmF0ZSBoZXJlIGNoYW5nZXMgZnJvbSBDKysgdmVyc2lvblxuICAgICAgICAvLyAoQysrIHJlcG8gcmV2aXNpb24gMDk4ODBhODY5MDk1IGRhdGVkIE1hcmNoIDgsIDIwMTEpXG4gICAgICAgIHRocm93IG5ldyBQb2ludEVycm9yKCdwb2x5MnRyaSBFZGdlRXZlbnQ6IENvbGxpbmVhciBub3Qgc3VwcG9ydGVkIScsIFtlcSwgcDIsIGVwXSk7XG4gICAgfVxuXG4gICAgaWYgKG8xID09PSBvMikge1xuICAgICAgICAvLyBOZWVkIHRvIGRlY2lkZSBpZiB3ZSBhcmUgcm90YXRpbmcgQ1cgb3IgQ0NXIHRvIGdldCB0byBhIHRyaWFuZ2xlXG4gICAgICAgIC8vIHRoYXQgd2lsbCBjcm9zcyBlZGdlXG4gICAgICAgIGlmIChvMSA9PT0gT3JpZW50YXRpb24uQ1cpIHtcbiAgICAgICAgICAgIHRyaWFuZ2xlID0gdHJpYW5nbGUubmVpZ2hib3JDQ1cocG9pbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJpYW5nbGUgPSB0cmlhbmdsZS5uZWlnaGJvckNXKHBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlZGdlRXZlbnRCeVBvaW50cyh0Y3gsIGVwLCBlcSwgdHJpYW5nbGUsIHBvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHRyaWFuZ2xlIGNyb3NzZXMgY29uc3RyYWludCBzbyBsZXRzIGZsaXBwaW4gc3RhcnQhXG4gICAgICAgIGZsaXBFZGdlRXZlbnQodGN4LCBlcCwgZXEsIHRyaWFuZ2xlLCBwb2ludCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0VkZ2VTaWRlT2ZUcmlhbmdsZSh0cmlhbmdsZSwgZXAsIGVxKSB7XG4gICAgdmFyIGluZGV4ID0gdHJpYW5nbGUuZWRnZUluZGV4KGVwLCBlcSk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB0cmlhbmdsZS5tYXJrQ29uc3RyYWluZWRFZGdlQnlJbmRleChpbmRleCk7XG4gICAgICAgIHZhciB0ID0gdHJpYW5nbGUuZ2V0TmVpZ2hib3IoaW5kZXgpO1xuICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgdC5tYXJrQ29uc3RyYWluZWRFZGdlQnlQb2ludHMoZXAsIGVxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZnJvbnQgdHJpYW5nbGUgYW5kIGxlZ2FsaXplIGl0XG4gKiBAcGFyYW0geyFTd2VlcENvbnRleHR9IHRjeCAtIFN3ZWVwQ29udGV4dCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gbmV3RnJvbnRUcmlhbmdsZSh0Y3gsIHBvaW50LCBub2RlKSB7XG4gICAgdmFyIHRyaWFuZ2xlID0gbmV3IFRyaWFuZ2xlKHBvaW50LCBub2RlLnBvaW50LCBub2RlLm5leHQucG9pbnQpO1xuXG4gICAgdHJpYW5nbGUubWFya05laWdoYm9yKG5vZGUudHJpYW5nbGUpO1xuICAgIHRjeC5hZGRUb01hcCh0cmlhbmdsZSk7XG5cbiAgICB2YXIgbmV3X25vZGUgPSBuZXcgTm9kZShwb2ludCk7XG4gICAgbmV3X25vZGUubmV4dCA9IG5vZGUubmV4dDtcbiAgICBuZXdfbm9kZS5wcmV2ID0gbm9kZTtcbiAgICBub2RlLm5leHQucHJldiA9IG5ld19ub2RlO1xuICAgIG5vZGUubmV4dCA9IG5ld19ub2RlO1xuXG4gICAgaWYgKCFsZWdhbGl6ZSh0Y3gsIHRyaWFuZ2xlKSkge1xuICAgICAgICB0Y3gubWFwVHJpYW5nbGVUb05vZGVzKHRyaWFuZ2xlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3X25vZGU7XG59XG5cbi8qKlxuICogQWRkcyBhIHRyaWFuZ2xlIHRvIHRoZSBhZHZhbmNpbmcgZnJvbnQgdG8gZmlsbCBhIGhvbGUuXG4gKiBAcGFyYW0geyFTd2VlcENvbnRleHR9IHRjeCAtIFN3ZWVwQ29udGV4dCBvYmplY3RcbiAqIEBwYXJhbSBub2RlIC0gbWlkZGxlIG5vZGUsIHRoYXQgaXMgdGhlIGJvdHRvbSBvZiB0aGUgaG9sZVxuICovXG5mdW5jdGlvbiBmaWxsKHRjeCwgbm9kZSkge1xuICAgIHZhciB0cmlhbmdsZSA9IG5ldyBUcmlhbmdsZShub2RlLnByZXYucG9pbnQsIG5vZGUucG9pbnQsIG5vZGUubmV4dC5wb2ludCk7XG5cbiAgICAvLyBUT0RPOiBzaG91bGQgY29weSB0aGUgY29uc3RyYWluZWRfZWRnZSB2YWx1ZSBmcm9tIG5laWdoYm9yIHRyaWFuZ2xlc1xuICAgIC8vICAgICAgIGZvciBub3cgY29uc3RyYWluZWRfZWRnZSB2YWx1ZXMgYXJlIGNvcGllZCBkdXJpbmcgdGhlIGxlZ2FsaXplXG4gICAgdHJpYW5nbGUubWFya05laWdoYm9yKG5vZGUucHJldi50cmlhbmdsZSk7XG4gICAgdHJpYW5nbGUubWFya05laWdoYm9yKG5vZGUudHJpYW5nbGUpO1xuXG4gICAgdGN4LmFkZFRvTWFwKHRyaWFuZ2xlKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgYWR2YW5jaW5nIGZyb250XG4gICAgbm9kZS5wcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XG5cblxuICAgIC8vIElmIGl0IHdhcyBsZWdhbGl6ZWQgdGhlIHRyaWFuZ2xlIGhhcyBhbHJlYWR5IGJlZW4gbWFwcGVkXG4gICAgaWYgKCFsZWdhbGl6ZSh0Y3gsIHRyaWFuZ2xlKSkge1xuICAgICAgICB0Y3gubWFwVHJpYW5nbGVUb05vZGVzKHRyaWFuZ2xlKTtcbiAgICB9XG5cbiAgICAvL3RjeC5yZW1vdmVOb2RlKG5vZGUpO1xufVxuXG4vKipcbiAqIEZpbGxzIGhvbGVzIGluIHRoZSBBZHZhbmNpbmcgRnJvbnRcbiAqIEBwYXJhbSB7IVN3ZWVwQ29udGV4dH0gdGN4IC0gU3dlZXBDb250ZXh0IG9iamVjdFxuICovXG5mdW5jdGlvbiBmaWxsQWR2YW5jaW5nRnJvbnQodGN4LCBuKSB7XG4gICAgLy8gRmlsbCByaWdodCBob2xlc1xuICAgIHZhciBub2RlID0gbi5uZXh0O1xuICAgIHdoaWxlIChub2RlLm5leHQpIHtcbiAgICAgICAgLy8gVE9ETyBpbnRlZ3JhdGUgaGVyZSBjaGFuZ2VzIGZyb20gQysrIHZlcnNpb25cbiAgICAgICAgLy8gKEMrKyByZXBvIHJldmlzaW9uIGFjZjgxZjFmMTc2NCBkYXRlZCBBcHJpbCA3LCAyMDEyKVxuICAgICAgICBpZiAoaXNBbmdsZU9idHVzZShub2RlLnBvaW50LCBub2RlLm5leHQucG9pbnQsIG5vZGUucHJldi5wb2ludCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGZpbGwodGN4LCBub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICB9XG5cbiAgICAvLyBGaWxsIGxlZnQgaG9sZXNcbiAgICBub2RlID0gbi5wcmV2O1xuICAgIHdoaWxlIChub2RlLnByZXYpIHtcbiAgICAgICAgLy8gVE9ETyBpbnRlZ3JhdGUgaGVyZSBjaGFuZ2VzIGZyb20gQysrIHZlcnNpb25cbiAgICAgICAgLy8gKEMrKyByZXBvIHJldmlzaW9uIGFjZjgxZjFmMTc2NCBkYXRlZCBBcHJpbCA3LCAyMDEyKVxuICAgICAgICBpZiAoaXNBbmdsZU9idHVzZShub2RlLnBvaW50LCBub2RlLm5leHQucG9pbnQsIG5vZGUucHJldi5wb2ludCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGZpbGwodGN4LCBub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUucHJldjtcbiAgICB9XG5cbiAgICAvLyBGaWxsIHJpZ2h0IGJhc2luc1xuICAgIGlmIChuLm5leHQgJiYgbi5uZXh0Lm5leHQpIHtcbiAgICAgICAgaWYgKGlzQmFzaW5BbmdsZVJpZ2h0KG4pKSB7XG4gICAgICAgICAgICBmaWxsQmFzaW4odGN4LCBuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgYmFzaW4gYW5nbGUgaXMgZGVjaWRlZCBhZ2FpbnN0IHRoZSBob3Jpem9udGFsIGxpbmUgWzEsMF0uXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgYW5nbGUgPCAzKs+ALzRcbiAqL1xuZnVuY3Rpb24gaXNCYXNpbkFuZ2xlUmlnaHQobm9kZSkge1xuICAgIHZhciBheCA9IG5vZGUucG9pbnQueCAtIG5vZGUubmV4dC5uZXh0LnBvaW50Lng7XG4gICAgdmFyIGF5ID0gbm9kZS5wb2ludC55IC0gbm9kZS5uZXh0Lm5leHQucG9pbnQueTtcbiAgICBhc3NlcnQoYXkgPj0gMCwgXCJ1bm9yZGVyZWQgeVwiKTtcbiAgICByZXR1cm4gKGF4ID49IDAgfHwgTWF0aC5hYnMoYXgpIDwgYXkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0cmlhbmdsZSB3YXMgbGVnYWxpemVkXG4gKiBAcGFyYW0geyFTd2VlcENvbnRleHR9IHRjeCAtIFN3ZWVwQ29udGV4dCBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGxlZ2FsaXplKHRjeCwgdCkge1xuICAgIC8vIFRvIGxlZ2FsaXplIGEgdHJpYW5nbGUgd2Ugc3RhcnQgYnkgZmluZGluZyBpZiBhbnkgb2YgdGhlIHRocmVlIGVkZ2VzXG4gICAgLy8gdmlvbGF0ZSB0aGUgRGVsYXVuYXkgY29uZGl0aW9uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgaWYgKHQuZGVsYXVuYXlfZWRnZVtpXSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG90ID0gdC5nZXROZWlnaGJvcihpKTtcbiAgICAgICAgaWYgKG90KSB7XG4gICAgICAgICAgICB2YXIgcCA9IHQuZ2V0UG9pbnQoaSk7XG4gICAgICAgICAgICB2YXIgb3AgPSBvdC5vcHBvc2l0ZVBvaW50KHQsIHApO1xuICAgICAgICAgICAgdmFyIG9pID0gb3QuaW5kZXgob3ApO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgQ29uc3RyYWluZWQgRWRnZSBvciBhIERlbGF1bmF5IEVkZ2Uob25seSBkdXJpbmcgcmVjdXJzaXZlIGxlZ2FsaXphdGlvbilcbiAgICAgICAgICAgIC8vIHRoZW4gd2Ugc2hvdWxkIG5vdCB0cnkgdG8gbGVnYWxpemVcbiAgICAgICAgICAgIGlmIChvdC5jb25zdHJhaW5lZF9lZGdlW29pXSB8fCBvdC5kZWxhdW5heV9lZGdlW29pXSkge1xuICAgICAgICAgICAgICAgIHQuY29uc3RyYWluZWRfZWRnZVtpXSA9IG90LmNvbnN0cmFpbmVkX2VkZ2Vbb2ldO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5zaWRlID0gaW5DaXJjbGUocCwgdC5wb2ludENDVyhwKSwgdC5wb2ludENXKHApLCBvcCk7XG4gICAgICAgICAgICBpZiAoaW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgLy8gTGV0cyBtYXJrIHRoaXMgc2hhcmVkIGVkZ2UgYXMgRGVsYXVuYXlcbiAgICAgICAgICAgICAgICB0LmRlbGF1bmF5X2VkZ2VbaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIG90LmRlbGF1bmF5X2VkZ2Vbb2ldID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIExldHMgcm90YXRlIHNoYXJlZCBlZGdlIG9uZSB2ZXJ0ZXggQ1cgdG8gbGVnYWxpemUgaXRcbiAgICAgICAgICAgICAgICByb3RhdGVUcmlhbmdsZVBhaXIodCwgcCwgb3QsIG9wKTtcblxuICAgICAgICAgICAgICAgIC8vIFdlIG5vdyBnb3Qgb25lIHZhbGlkIERlbGF1bmF5IEVkZ2Ugc2hhcmVkIGJ5IHR3byB0cmlhbmdsZXNcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGdpdmVzIHVzIDQgbmV3IGVkZ2VzIHRvIGNoZWNrIGZvciBEZWxhdW5heVxuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdHJpYW5nbGUgdG8gbm9kZSBtYXBwaW5nIGlzIGRvbmUgb25seSBvbmUgdGltZSBmb3IgYSBzcGVjaWZpYyB0cmlhbmdsZVxuICAgICAgICAgICAgICAgIHZhciBub3RfbGVnYWxpemVkID0gIWxlZ2FsaXplKHRjeCwgdCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vdF9sZWdhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGN4Lm1hcFRyaWFuZ2xlVG9Ob2Rlcyh0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub3RfbGVnYWxpemVkID0gIWxlZ2FsaXplKHRjeCwgb3QpO1xuICAgICAgICAgICAgICAgIGlmIChub3RfbGVnYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRjeC5tYXBUcmlhbmdsZVRvTm9kZXMob3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgRGVsYXVuYXkgZWRnZXMsIHNpbmNlIHRoZXkgb25seSBhcmUgdmFsaWQgRGVsYXVuYXkgZWRnZXNcbiAgICAgICAgICAgICAgICAvLyB1bnRpbCB3ZSBhZGQgYSBuZXcgdHJpYW5nbGUgb3IgcG9pbnQuXG4gICAgICAgICAgICAgICAgLy8gWFhYOiBuZWVkIHRvIHRoaW5rIGFib3V0IHRoaXMuIENhbiB0aGVzZSBlZGdlcyBiZSB0cmllZCBhZnRlciB3ZVxuICAgICAgICAgICAgICAgIC8vICAgICAgcmV0dXJuIHRvIHByZXZpb3VzIHJlY3Vyc2l2ZSBsZXZlbD9cbiAgICAgICAgICAgICAgICB0LmRlbGF1bmF5X2VkZ2VbaV0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBvdC5kZWxhdW5heV9lZGdlW29pXSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdHJpYW5nbGUgaGF2ZSBiZWVuIGxlZ2FsaXplZCBubyBuZWVkIHRvIGNoZWNrIHRoZSBvdGhlciBlZGdlcyBzaW5jZVxuICAgICAgICAgICAgICAgIC8vIHRoZSByZWN1cnNpdmUgbGVnYWxpemF0aW9uIHdpbGwgaGFuZGxlcyB0aG9zZSBzbyB3ZSBjYW4gZW5kIGhlcmUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIDxiPlJlcXVpcmVtZW50PC9iPjo8YnI+XG4gKiAxLiBhLGIgYW5kIGMgZm9ybSBhIHRyaWFuZ2xlLjxicj5cbiAqIDIuIGEgYW5kIGQgaXMga25vdyB0byBiZSBvbiBvcHBvc2l0ZSBzaWRlIG9mIGJjPGJyPlxuICogPHByZT5cbiAqICAgICAgICAgICAgICAgIGFcbiAqICAgICAgICAgICAgICAgICtcbiAqICAgICAgICAgICAgICAgLyBcXFxuICogICAgICAgICAgICAgIC8gICBcXFxuICogICAgICAgICAgICBiLyAgICAgXFxjXG4gKiAgICAgICAgICAgICstLS0tLS0tK1xuICogICAgICAgICAgIC8gICAgZCAgICBcXFxuICogICAgICAgICAgLyAgICAgICAgICAgXFxcbiAqIDwvcHJlPlxuICogPGI+RmFjdDwvYj46IGQgaGFzIHRvIGJlIGluIGFyZWEgQiB0byBoYXZlIGEgY2hhbmNlIHRvIGJlIGluc2lkZSB0aGUgY2lyY2xlIGZvcm1lZCBieVxuICogIGEsYiBhbmQgYzxicj5cbiAqICBkIGlzIG91dHNpZGUgQiBpZiBvcmllbnQyZChhLGIsZCkgb3Igb3JpZW50MmQoYyxhLGQpIGlzIENXPGJyPlxuICogIFRoaXMgcHJla25vd2xlZGdlIGdpdmVzIHVzIGEgd2F5IHRvIG9wdGltaXplIHRoZSBpbmNpcmNsZSB0ZXN0XG4gKiBAcGFyYW0gcGEgLSB0cmlhbmdsZSBwb2ludCwgb3Bwb3NpdGUgZFxuICogQHBhcmFtIHBiIC0gdHJpYW5nbGUgcG9pbnRcbiAqIEBwYXJhbSBwYyAtIHRyaWFuZ2xlIHBvaW50XG4gKiBAcGFyYW0gcGQgLSBwb2ludCBvcHBvc2l0ZSBhXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGQgaXMgaW5zaWRlIGNpcmNsZSwgZmFsc2UgaWYgb24gY2lyY2xlIGVkZ2VcbiAqL1xuZnVuY3Rpb24gaW5DaXJjbGUocGEsIHBiLCBwYywgcGQpIHtcbiAgICB2YXIgYWR4ID0gcGEueCAtIHBkLng7XG4gICAgdmFyIGFkeSA9IHBhLnkgLSBwZC55O1xuICAgIHZhciBiZHggPSBwYi54IC0gcGQueDtcbiAgICB2YXIgYmR5ID0gcGIueSAtIHBkLnk7XG5cbiAgICB2YXIgYWR4YmR5ID0gYWR4ICogYmR5O1xuICAgIHZhciBiZHhhZHkgPSBiZHggKiBhZHk7XG4gICAgdmFyIG9hYmQgPSBhZHhiZHkgLSBiZHhhZHk7XG4gICAgaWYgKG9hYmQgPD0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGNkeCA9IHBjLnggLSBwZC54O1xuICAgIHZhciBjZHkgPSBwYy55IC0gcGQueTtcblxuICAgIHZhciBjZHhhZHkgPSBjZHggKiBhZHk7XG4gICAgdmFyIGFkeGNkeSA9IGFkeCAqIGNkeTtcbiAgICB2YXIgb2NhZCA9IGNkeGFkeSAtIGFkeGNkeTtcbiAgICBpZiAob2NhZCA8PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgYmR4Y2R5ID0gYmR4ICogY2R5O1xuICAgIHZhciBjZHhiZHkgPSBjZHggKiBiZHk7XG5cbiAgICB2YXIgYWxpZnQgPSBhZHggKiBhZHggKyBhZHkgKiBhZHk7XG4gICAgdmFyIGJsaWZ0ID0gYmR4ICogYmR4ICsgYmR5ICogYmR5O1xuICAgIHZhciBjbGlmdCA9IGNkeCAqIGNkeCArIGNkeSAqIGNkeTtcblxuICAgIHZhciBkZXQgPSBhbGlmdCAqIChiZHhjZHkgLSBjZHhiZHkpICsgYmxpZnQgKiBvY2FkICsgY2xpZnQgKiBvYWJkO1xuICAgIHJldHVybiBkZXQgPiAwO1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYSB0cmlhbmdsZSBwYWlyIG9uZSB2ZXJ0ZXggQ1dcbiAqPHByZT5cbiAqICAgICAgIG4yICAgICAgICAgICAgICAgICAgICBuMlxuICogIFAgKy0tLS0tKyAgICAgICAgICAgICBQICstLS0tLStcbiAqICAgIHwgdCAgL3wgICAgICAgICAgICAgICB8XFwgIHQgfFxuICogICAgfCAgIC8gfCAgICAgICAgICAgICAgIHwgXFwgICB8XG4gKiAgbjF8ICAvICB8bjMgICAgICAgICAgIG4xfCAgXFwgIHxuM1xuICogICAgfCAvICAgfCAgICBhZnRlciBDVyAgIHwgICBcXCB8XG4gKiAgICB8LyBvVCB8ICAgICAgICAgICAgICAgfCBvVCBcXHxcbiAqICAgICstLS0tLSsgb1AgICAgICAgICAgICArLS0tLS0rXG4gKiAgICAgICBuNCAgICAgICAgICAgICAgICAgICAgbjRcbiAqIDwvcHJlPlxuICovXG5mdW5jdGlvbiByb3RhdGVUcmlhbmdsZVBhaXIodCwgcCwgb3QsIG9wKSB7XG4gICAgdmFyIG4xLCBuMiwgbjMsIG40O1xuICAgIG4xID0gdC5uZWlnaGJvckNDVyhwKTtcbiAgICBuMiA9IHQubmVpZ2hib3JDVyhwKTtcbiAgICBuMyA9IG90Lm5laWdoYm9yQ0NXKG9wKTtcbiAgICBuNCA9IG90Lm5laWdoYm9yQ1cob3ApO1xuXG4gICAgdmFyIGNlMSwgY2UyLCBjZTMsIGNlNDtcbiAgICBjZTEgPSB0LmdldENvbnN0cmFpbmVkRWRnZUNDVyhwKTtcbiAgICBjZTIgPSB0LmdldENvbnN0cmFpbmVkRWRnZUNXKHApO1xuICAgIGNlMyA9IG90LmdldENvbnN0cmFpbmVkRWRnZUNDVyhvcCk7XG4gICAgY2U0ID0gb3QuZ2V0Q29uc3RyYWluZWRFZGdlQ1cob3ApO1xuXG4gICAgdmFyIGRlMSwgZGUyLCBkZTMsIGRlNDtcbiAgICBkZTEgPSB0LmdldERlbGF1bmF5RWRnZUNDVyhwKTtcbiAgICBkZTIgPSB0LmdldERlbGF1bmF5RWRnZUNXKHApO1xuICAgIGRlMyA9IG90LmdldERlbGF1bmF5RWRnZUNDVyhvcCk7XG4gICAgZGU0ID0gb3QuZ2V0RGVsYXVuYXlFZGdlQ1cob3ApO1xuXG4gICAgdC5sZWdhbGl6ZShwLCBvcCk7XG4gICAgb3QubGVnYWxpemUob3AsIHApO1xuXG4gICAgLy8gUmVtYXAgZGVsYXVuYXlfZWRnZVxuICAgIG90LnNldERlbGF1bmF5RWRnZUNDVyhwLCBkZTEpO1xuICAgIHQuc2V0RGVsYXVuYXlFZGdlQ1cocCwgZGUyKTtcbiAgICB0LnNldERlbGF1bmF5RWRnZUNDVyhvcCwgZGUzKTtcbiAgICBvdC5zZXREZWxhdW5heUVkZ2VDVyhvcCwgZGU0KTtcblxuICAgIC8vIFJlbWFwIGNvbnN0cmFpbmVkX2VkZ2VcbiAgICBvdC5zZXRDb25zdHJhaW5lZEVkZ2VDQ1cocCwgY2UxKTtcbiAgICB0LnNldENvbnN0cmFpbmVkRWRnZUNXKHAsIGNlMik7XG4gICAgdC5zZXRDb25zdHJhaW5lZEVkZ2VDQ1cob3AsIGNlMyk7XG4gICAgb3Quc2V0Q29uc3RyYWluZWRFZGdlQ1cob3AsIGNlNCk7XG5cbiAgICAvLyBSZW1hcCBuZWlnaGJvcnNcbiAgICAvLyBYWFg6IG1pZ2h0IG9wdGltaXplIHRoZSBtYXJrTmVpZ2hib3IgYnkga2VlcGluZyB0cmFjayBvZlxuICAgIC8vICAgICAgd2hhdCBzaWRlIHNob3VsZCBiZSBhc3NpZ25lZCB0byB3aGF0IG5laWdoYm9yIGFmdGVyIHRoZVxuICAgIC8vICAgICAgcm90YXRpb24uIE5vdyBtYXJrIG5laWdoYm9yIGRvZXMgbG90cyBvZiB0ZXN0aW5nIHRvIGZpbmRcbiAgICAvLyAgICAgIHRoZSByaWdodCBzaWRlLlxuICAgIHQuY2xlYXJOZWlnaGJvcnMoKTtcbiAgICBvdC5jbGVhck5laWdoYm9ycygpO1xuICAgIGlmIChuMSkge1xuICAgICAgICBvdC5tYXJrTmVpZ2hib3IobjEpO1xuICAgIH1cbiAgICBpZiAobjIpIHtcbiAgICAgICAgdC5tYXJrTmVpZ2hib3IobjIpO1xuICAgIH1cbiAgICBpZiAobjMpIHtcbiAgICAgICAgdC5tYXJrTmVpZ2hib3IobjMpO1xuICAgIH1cbiAgICBpZiAobjQpIHtcbiAgICAgICAgb3QubWFya05laWdoYm9yKG40KTtcbiAgICB9XG4gICAgdC5tYXJrTmVpZ2hib3Iob3QpO1xufVxuXG4vKipcbiAqIEZpbGxzIGEgYmFzaW4gdGhhdCBoYXMgZm9ybWVkIG9uIHRoZSBBZHZhbmNpbmcgRnJvbnQgdG8gdGhlIHJpZ2h0XG4gKiBvZiBnaXZlbiBub2RlLjxicj5cbiAqIEZpcnN0IHdlIGRlY2lkZSBhIGxlZnQsYm90dG9tIGFuZCByaWdodCBub2RlIHRoYXQgZm9ybXMgdGhlXG4gKiBib3VuZGFyaWVzIG9mIHRoZSBiYXNpbi4gVGhlbiB3ZSBkbyBhIHJlcXVyc2l2ZSBmaWxsLlxuICpcbiAqIEBwYXJhbSB7IVN3ZWVwQ29udGV4dH0gdGN4IC0gU3dlZXBDb250ZXh0IG9iamVjdFxuICogQHBhcmFtIG5vZGUgLSBzdGFydGluZyBub2RlLCB0aGlzIG9yIG5leHQgbm9kZSB3aWxsIGJlIGxlZnQgbm9kZVxuICovXG5mdW5jdGlvbiBmaWxsQmFzaW4odGN4LCBub2RlKSB7XG4gICAgaWYgKG9yaWVudDJkKG5vZGUucG9pbnQsIG5vZGUubmV4dC5wb2ludCwgbm9kZS5uZXh0Lm5leHQucG9pbnQpID09PSBPcmllbnRhdGlvbi5DQ1cpIHtcbiAgICAgICAgdGN4LmJhc2luLmxlZnRfbm9kZSA9IG5vZGUubmV4dC5uZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRjeC5iYXNpbi5sZWZ0X25vZGUgPSBub2RlLm5leHQ7XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgYm90dG9tIGFuZCByaWdodCBub2RlXG4gICAgdGN4LmJhc2luLmJvdHRvbV9ub2RlID0gdGN4LmJhc2luLmxlZnRfbm9kZTtcbiAgICB3aGlsZSAodGN4LmJhc2luLmJvdHRvbV9ub2RlLm5leHQgJiYgdGN4LmJhc2luLmJvdHRvbV9ub2RlLnBvaW50LnkgPj0gdGN4LmJhc2luLmJvdHRvbV9ub2RlLm5leHQucG9pbnQueSkge1xuICAgICAgICB0Y3guYmFzaW4uYm90dG9tX25vZGUgPSB0Y3guYmFzaW4uYm90dG9tX25vZGUubmV4dDtcbiAgICB9XG4gICAgaWYgKHRjeC5iYXNpbi5ib3R0b21fbm9kZSA9PT0gdGN4LmJhc2luLmxlZnRfbm9kZSkge1xuICAgICAgICAvLyBObyB2YWxpZCBiYXNpblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGN4LmJhc2luLnJpZ2h0X25vZGUgPSB0Y3guYmFzaW4uYm90dG9tX25vZGU7XG4gICAgd2hpbGUgKHRjeC5iYXNpbi5yaWdodF9ub2RlLm5leHQgJiYgdGN4LmJhc2luLnJpZ2h0X25vZGUucG9pbnQueSA8IHRjeC5iYXNpbi5yaWdodF9ub2RlLm5leHQucG9pbnQueSkge1xuICAgICAgICB0Y3guYmFzaW4ucmlnaHRfbm9kZSA9IHRjeC5iYXNpbi5yaWdodF9ub2RlLm5leHQ7XG4gICAgfVxuICAgIGlmICh0Y3guYmFzaW4ucmlnaHRfbm9kZSA9PT0gdGN4LmJhc2luLmJvdHRvbV9ub2RlKSB7XG4gICAgICAgIC8vIE5vIHZhbGlkIGJhc2luc1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGN4LmJhc2luLndpZHRoID0gdGN4LmJhc2luLnJpZ2h0X25vZGUucG9pbnQueCAtIHRjeC5iYXNpbi5sZWZ0X25vZGUucG9pbnQueDtcbiAgICB0Y3guYmFzaW4ubGVmdF9oaWdoZXN0ID0gdGN4LmJhc2luLmxlZnRfbm9kZS5wb2ludC55ID4gdGN4LmJhc2luLnJpZ2h0X25vZGUucG9pbnQueTtcblxuICAgIGZpbGxCYXNpblJlcSh0Y3gsIHRjeC5iYXNpbi5ib3R0b21fbm9kZSk7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlIGFsZ29yaXRobSB0byBmaWxsIGEgQmFzaW4gd2l0aCB0cmlhbmdsZXNcbiAqXG4gKiBAcGFyYW0geyFTd2VlcENvbnRleHR9IHRjeCAtIFN3ZWVwQ29udGV4dCBvYmplY3RcbiAqIEBwYXJhbSBub2RlIC0gYm90dG9tX25vZGVcbiAqL1xuZnVuY3Rpb24gZmlsbEJhc2luUmVxKHRjeCwgbm9kZSkge1xuICAgIC8vIGlmIHNoYWxsb3cgc3RvcCBmaWxsaW5nXG4gICAgaWYgKGlzU2hhbGxvdyh0Y3gsIG5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmaWxsKHRjeCwgbm9kZSk7XG5cbiAgICB2YXIgbztcbiAgICBpZiAobm9kZS5wcmV2ID09PSB0Y3guYmFzaW4ubGVmdF9ub2RlICYmIG5vZGUubmV4dCA9PT0gdGN4LmJhc2luLnJpZ2h0X25vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAobm9kZS5wcmV2ID09PSB0Y3guYmFzaW4ubGVmdF9ub2RlKSB7XG4gICAgICAgIG8gPSBvcmllbnQyZChub2RlLnBvaW50LCBub2RlLm5leHQucG9pbnQsIG5vZGUubmV4dC5uZXh0LnBvaW50KTtcbiAgICAgICAgaWYgKG8gPT09IE9yaWVudGF0aW9uLkNXKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICB9IGVsc2UgaWYgKG5vZGUubmV4dCA9PT0gdGN4LmJhc2luLnJpZ2h0X25vZGUpIHtcbiAgICAgICAgbyA9IG9yaWVudDJkKG5vZGUucG9pbnQsIG5vZGUucHJldi5wb2ludCwgbm9kZS5wcmV2LnByZXYucG9pbnQpO1xuICAgICAgICBpZiAobyA9PT0gT3JpZW50YXRpb24uQ0NXKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucHJldjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBuZWlnaGJvciBub2RlIHdpdGggbG93ZXN0IFkgdmFsdWVcbiAgICAgICAgaWYgKG5vZGUucHJldi5wb2ludC55IDwgbm9kZS5uZXh0LnBvaW50LnkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnByZXY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmlsbEJhc2luUmVxKHRjeCwgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIGlzU2hhbGxvdyh0Y3gsIG5vZGUpIHtcbiAgICB2YXIgaGVpZ2h0O1xuICAgIGlmICh0Y3guYmFzaW4ubGVmdF9oaWdoZXN0KSB7XG4gICAgICAgIGhlaWdodCA9IHRjeC5iYXNpbi5sZWZ0X25vZGUucG9pbnQueSAtIG5vZGUucG9pbnQueTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBoZWlnaHQgPSB0Y3guYmFzaW4ucmlnaHRfbm9kZS5wb2ludC55IC0gbm9kZS5wb2ludC55O1xuICAgIH1cblxuICAgIC8vIGlmIHNoYWxsb3cgc3RvcCBmaWxsaW5nXG4gICAgaWYgKHRjeC5iYXNpbi53aWR0aCA+IGhlaWdodCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBmaWxsRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSkge1xuICAgIGlmICh0Y3guZWRnZV9ldmVudC5yaWdodCkge1xuICAgICAgICBmaWxsUmlnaHRBYm92ZUVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbGxMZWZ0QWJvdmVFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbGxSaWdodEFib3ZlRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSkge1xuICAgIHdoaWxlIChub2RlLm5leHQucG9pbnQueCA8IGVkZ2UucC54KSB7XG4gICAgICAgIC8vIENoZWNrIGlmIG5leHQgbm9kZSBpcyBiZWxvdyB0aGUgZWRnZVxuICAgICAgICBpZiAob3JpZW50MmQoZWRnZS5xLCBub2RlLm5leHQucG9pbnQsIGVkZ2UucCkgPT09IE9yaWVudGF0aW9uLkNDVykge1xuICAgICAgICAgICAgZmlsbFJpZ2h0QmVsb3dFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbGxSaWdodEJlbG93RWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSkge1xuICAgIGlmIChub2RlLnBvaW50LnggPCBlZGdlLnAueCkge1xuICAgICAgICBpZiAob3JpZW50MmQobm9kZS5wb2ludCwgbm9kZS5uZXh0LnBvaW50LCBub2RlLm5leHQubmV4dC5wb2ludCkgPT09IE9yaWVudGF0aW9uLkNDVykge1xuICAgICAgICAgICAgLy8gQ29uY2F2ZVxuICAgICAgICAgICAgZmlsbFJpZ2h0Q29uY2F2ZUVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ29udmV4XG4gICAgICAgICAgICBmaWxsUmlnaHRDb252ZXhFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcbiAgICAgICAgICAgIC8vIFJldHJ5IHRoaXMgb25lXG4gICAgICAgICAgICBmaWxsUmlnaHRCZWxvd0VkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWxsUmlnaHRDb25jYXZlRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSkge1xuICAgIGZpbGwodGN4LCBub2RlLm5leHQpO1xuICAgIGlmIChub2RlLm5leHQucG9pbnQgIT09IGVkZ2UucCkge1xuICAgICAgICAvLyBOZXh0IGFib3ZlIG9yIGJlbG93IGVkZ2U/XG4gICAgICAgIGlmIChvcmllbnQyZChlZGdlLnEsIG5vZGUubmV4dC5wb2ludCwgZWRnZS5wKSA9PT0gT3JpZW50YXRpb24uQ0NXKSB7XG4gICAgICAgICAgICAvLyBCZWxvd1xuICAgICAgICAgICAgaWYgKG9yaWVudDJkKG5vZGUucG9pbnQsIG5vZGUubmV4dC5wb2ludCwgbm9kZS5uZXh0Lm5leHQucG9pbnQpID09PSBPcmllbnRhdGlvbi5DQ1cpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXh0IGlzIGNvbmNhdmVcbiAgICAgICAgICAgICAgICBmaWxsUmlnaHRDb25jYXZlRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5leHQgaXMgY29udmV4XG4gICAgICAgICAgICAgICAgLyoganNoaW50IG5vZW1wdHk6ZmFsc2UgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsbFJpZ2h0Q29udmV4RWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSkge1xuICAgIC8vIE5leHQgY29uY2F2ZSBvciBjb252ZXg/XG4gICAgaWYgKG9yaWVudDJkKG5vZGUubmV4dC5wb2ludCwgbm9kZS5uZXh0Lm5leHQucG9pbnQsIG5vZGUubmV4dC5uZXh0Lm5leHQucG9pbnQpID09PSBPcmllbnRhdGlvbi5DQ1cpIHtcbiAgICAgICAgLy8gQ29uY2F2ZVxuICAgICAgICBmaWxsUmlnaHRDb25jYXZlRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZS5uZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb252ZXhcbiAgICAgICAgLy8gTmV4dCBhYm92ZSBvciBiZWxvdyBlZGdlP1xuICAgICAgICBpZiAob3JpZW50MmQoZWRnZS5xLCBub2RlLm5leHQubmV4dC5wb2ludCwgZWRnZS5wKSA9PT0gT3JpZW50YXRpb24uQ0NXKSB7XG4gICAgICAgICAgICAvLyBCZWxvd1xuICAgICAgICAgICAgZmlsbFJpZ2h0Q29udmV4RWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZS5uZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFib3ZlXG4gICAgICAgICAgICAvKiBqc2hpbnQgbm9lbXB0eTpmYWxzZSAqL1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWxsTGVmdEFib3ZlRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSkge1xuICAgIHdoaWxlIChub2RlLnByZXYucG9pbnQueCA+IGVkZ2UucC54KSB7XG4gICAgICAgIC8vIENoZWNrIGlmIG5leHQgbm9kZSBpcyBiZWxvdyB0aGUgZWRnZVxuICAgICAgICBpZiAob3JpZW50MmQoZWRnZS5xLCBub2RlLnByZXYucG9pbnQsIGVkZ2UucCkgPT09IE9yaWVudGF0aW9uLkNXKSB7XG4gICAgICAgICAgICBmaWxsTGVmdEJlbG93RWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wcmV2O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWxsTGVmdEJlbG93RWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSkge1xuICAgIGlmIChub2RlLnBvaW50LnggPiBlZGdlLnAueCkge1xuICAgICAgICBpZiAob3JpZW50MmQobm9kZS5wb2ludCwgbm9kZS5wcmV2LnBvaW50LCBub2RlLnByZXYucHJldi5wb2ludCkgPT09IE9yaWVudGF0aW9uLkNXKSB7XG4gICAgICAgICAgICAvLyBDb25jYXZlXG4gICAgICAgICAgICBmaWxsTGVmdENvbmNhdmVFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENvbnZleFxuICAgICAgICAgICAgZmlsbExlZnRDb252ZXhFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcbiAgICAgICAgICAgIC8vIFJldHJ5IHRoaXMgb25lXG4gICAgICAgICAgICBmaWxsTGVmdEJlbG93RWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbGxMZWZ0Q29udmV4RWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSkge1xuICAgIC8vIE5leHQgY29uY2F2ZSBvciBjb252ZXg/XG4gICAgaWYgKG9yaWVudDJkKG5vZGUucHJldi5wb2ludCwgbm9kZS5wcmV2LnByZXYucG9pbnQsIG5vZGUucHJldi5wcmV2LnByZXYucG9pbnQpID09PSBPcmllbnRhdGlvbi5DVykge1xuICAgICAgICAvLyBDb25jYXZlXG4gICAgICAgIGZpbGxMZWZ0Q29uY2F2ZUVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUucHJldik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29udmV4XG4gICAgICAgIC8vIE5leHQgYWJvdmUgb3IgYmVsb3cgZWRnZT9cbiAgICAgICAgaWYgKG9yaWVudDJkKGVkZ2UucSwgbm9kZS5wcmV2LnByZXYucG9pbnQsIGVkZ2UucCkgPT09IE9yaWVudGF0aW9uLkNXKSB7XG4gICAgICAgICAgICAvLyBCZWxvd1xuICAgICAgICAgICAgZmlsbExlZnRDb252ZXhFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlLnByZXYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQWJvdmVcbiAgICAgICAgICAgIC8qIGpzaGludCBub2VtcHR5OmZhbHNlICovXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbGxMZWZ0Q29uY2F2ZUVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpIHtcbiAgICBmaWxsKHRjeCwgbm9kZS5wcmV2KTtcbiAgICBpZiAobm9kZS5wcmV2LnBvaW50ICE9PSBlZGdlLnApIHtcbiAgICAgICAgLy8gTmV4dCBhYm92ZSBvciBiZWxvdyBlZGdlP1xuICAgICAgICBpZiAob3JpZW50MmQoZWRnZS5xLCBub2RlLnByZXYucG9pbnQsIGVkZ2UucCkgPT09IE9yaWVudGF0aW9uLkNXKSB7XG4gICAgICAgICAgICAvLyBCZWxvd1xuICAgICAgICAgICAgaWYgKG9yaWVudDJkKG5vZGUucG9pbnQsIG5vZGUucHJldi5wb2ludCwgbm9kZS5wcmV2LnByZXYucG9pbnQpID09PSBPcmllbnRhdGlvbi5DVykge1xuICAgICAgICAgICAgICAgIC8vIE5leHQgaXMgY29uY2F2ZVxuICAgICAgICAgICAgICAgIGZpbGxMZWZ0Q29uY2F2ZUVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOZXh0IGlzIGNvbnZleFxuICAgICAgICAgICAgICAgIC8qIGpzaGludCBub2VtcHR5OmZhbHNlICovXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZsaXBFZGdlRXZlbnQodGN4LCBlcCwgZXEsIHQsIHApIHtcbiAgICB2YXIgb3QgPSB0Lm5laWdoYm9yQWNyb3NzKHApO1xuICAgIGFzc2VydChvdCwgXCJGTElQIGZhaWxlZCBkdWUgdG8gbWlzc2luZyB0cmlhbmdsZSFcIik7XG5cbiAgICB2YXIgb3AgPSBvdC5vcHBvc2l0ZVBvaW50KHQsIHApO1xuXG4gICAgLy8gQWRkaXRpb25hbCBjaGVjayBmcm9tIEphdmEgdmVyc2lvbiAoc2VlIGlzc3VlICM4OClcbiAgICBpZiAodC5nZXRDb25zdHJhaW5lZEVkZ2VBY3Jvc3MocCkpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdC5pbmRleChwKTtcbiAgICAgICAgdGhyb3cgbmV3IFBvaW50RXJyb3IoXCJwb2x5MnRyaSBJbnRlcnNlY3RpbmcgQ29uc3RyYWludHNcIixcbiAgICAgICAgICAgICAgICBbcCwgb3AsIHQuZ2V0UG9pbnQoKGluZGV4ICsgMSkgJSAzKSwgdC5nZXRQb2ludCgoaW5kZXggKyAyKSAlIDMpXSk7XG4gICAgfVxuXG4gICAgaWYgKGluU2NhbkFyZWEocCwgdC5wb2ludENDVyhwKSwgdC5wb2ludENXKHApLCBvcCkpIHtcbiAgICAgICAgLy8gTGV0cyByb3RhdGUgc2hhcmVkIGVkZ2Ugb25lIHZlcnRleCBDV1xuICAgICAgICByb3RhdGVUcmlhbmdsZVBhaXIodCwgcCwgb3QsIG9wKTtcbiAgICAgICAgdGN4Lm1hcFRyaWFuZ2xlVG9Ob2Rlcyh0KTtcbiAgICAgICAgdGN4Lm1hcFRyaWFuZ2xlVG9Ob2RlcyhvdCk7XG5cbiAgICAgICAgLy8gWFhYOiBpbiB0aGUgb3JpZ2luYWwgQysrIGNvZGUgZm9yIHRoZSBuZXh0IDIgbGluZXMsIHdlIGFyZVxuICAgICAgICAvLyBjb21wYXJpbmcgcG9pbnQgdmFsdWVzIChhbmQgbm90IHBvaW50ZXJzKS4gSW4gdGhpcyBKYXZhU2NyaXB0XG4gICAgICAgIC8vIGNvZGUsIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcyAocG9pbnRlcnMpLiBUaGlzIHdvcmtzXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgY2FuJ3QgaGF2ZSAyIGRpZmZlcmVudCBwb2ludHMgd2l0aCB0aGUgc2FtZSB2YWx1ZXMuXG4gICAgICAgIC8vIEJ1dCB0byBiZSByZWFsbHkgZXF1aXZhbGVudCwgd2Ugc2hvdWxkIHVzZSBcIlBvaW50LmVxdWFsc1wiIGhlcmUuXG4gICAgICAgIGlmIChwID09PSBlcSAmJiBvcCA9PT0gZXApIHtcbiAgICAgICAgICAgIGlmIChlcSA9PT0gdGN4LmVkZ2VfZXZlbnQuY29uc3RyYWluZWRfZWRnZS5xICYmIGVwID09PSB0Y3guZWRnZV9ldmVudC5jb25zdHJhaW5lZF9lZGdlLnApIHtcbiAgICAgICAgICAgICAgICB0Lm1hcmtDb25zdHJhaW5lZEVkZ2VCeVBvaW50cyhlcCwgZXEpO1xuICAgICAgICAgICAgICAgIG90Lm1hcmtDb25zdHJhaW5lZEVkZ2VCeVBvaW50cyhlcCwgZXEpO1xuICAgICAgICAgICAgICAgIGxlZ2FsaXplKHRjeCwgdCk7XG4gICAgICAgICAgICAgICAgbGVnYWxpemUodGN4LCBvdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFhYWDogSSB0aGluayBvbmUgb2YgdGhlIHRyaWFuZ2xlcyBzaG91bGQgYmUgbGVnYWxpemVkIGhlcmU/XG4gICAgICAgICAgICAgICAgLyoganNoaW50IG5vZW1wdHk6ZmFsc2UgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvID0gb3JpZW50MmQoZXEsIG9wLCBlcCk7XG4gICAgICAgICAgICB0ID0gbmV4dEZsaXBUcmlhbmdsZSh0Y3gsIG8sIHQsIG90LCBwLCBvcCk7XG4gICAgICAgICAgICBmbGlwRWRnZUV2ZW50KHRjeCwgZXAsIGVxLCB0LCBwKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXdQID0gbmV4dEZsaXBQb2ludChlcCwgZXEsIG90LCBvcCk7XG4gICAgICAgIGZsaXBTY2FuRWRnZUV2ZW50KHRjeCwgZXAsIGVxLCB0LCBvdCwgbmV3UCk7XG4gICAgICAgIGVkZ2VFdmVudEJ5UG9pbnRzKHRjeCwgZXAsIGVxLCB0LCBwKTtcbiAgICB9XG59XG5cbi8qKlxuICogQWZ0ZXIgYSBmbGlwIHdlIGhhdmUgdHdvIHRyaWFuZ2xlcyBhbmQga25vdyB0aGF0IG9ubHkgb25lIHdpbGwgc3RpbGwgYmVcbiAqIGludGVyc2VjdGluZyB0aGUgZWRnZS4gU28gZGVjaWRlIHdoaWNoIHRvIGNvbnRpdW5lIHdpdGggYW5kIGxlZ2FsaXplIHRoZSBvdGhlclxuICpcbiAqIEBwYXJhbSB7IVN3ZWVwQ29udGV4dH0gdGN4IC0gU3dlZXBDb250ZXh0IG9iamVjdFxuICogQHBhcmFtIG8gLSBzaG91bGQgYmUgdGhlIHJlc3VsdCBvZiBhbiBvcmllbnQyZCggZXEsIG9wLCBlcCApXG4gKiBAcGFyYW0gdCAtIHRyaWFuZ2xlIDFcbiAqIEBwYXJhbSBvdCAtIHRyaWFuZ2xlIDJcbiAqIEBwYXJhbSBwIC0gYSBwb2ludCBzaGFyZWQgYnkgYm90aCB0cmlhbmdsZXNcbiAqIEBwYXJhbSBvcCAtIGFub3RoZXIgcG9pbnQgc2hhcmVkIGJ5IGJvdGggdHJpYW5nbGVzXG4gKiBAcmV0dXJuIHJldHVybnMgdGhlIHRyaWFuZ2xlIHN0aWxsIGludGVyc2VjdGluZyB0aGUgZWRnZVxuICovXG5mdW5jdGlvbiBuZXh0RmxpcFRyaWFuZ2xlKHRjeCwgbywgdCwgb3QsIHAsIG9wKSB7XG4gICAgdmFyIGVkZ2VfaW5kZXg7XG4gICAgaWYgKG8gPT09IE9yaWVudGF0aW9uLkNDVykge1xuICAgICAgICAvLyBvdCBpcyBub3QgY3Jvc3NpbmcgZWRnZSBhZnRlciBmbGlwXG4gICAgICAgIGVkZ2VfaW5kZXggPSBvdC5lZGdlSW5kZXgocCwgb3ApO1xuICAgICAgICBvdC5kZWxhdW5heV9lZGdlW2VkZ2VfaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgbGVnYWxpemUodGN4LCBvdCk7XG4gICAgICAgIG90LmNsZWFyRGVsYXVuYXlFZGdlcygpO1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG5cbiAgICAvLyB0IGlzIG5vdCBjcm9zc2luZyBlZGdlIGFmdGVyIGZsaXBcbiAgICBlZGdlX2luZGV4ID0gdC5lZGdlSW5kZXgocCwgb3ApO1xuXG4gICAgdC5kZWxhdW5heV9lZGdlW2VkZ2VfaW5kZXhdID0gdHJ1ZTtcbiAgICBsZWdhbGl6ZSh0Y3gsIHQpO1xuICAgIHQuY2xlYXJEZWxhdW5heUVkZ2VzKCk7XG4gICAgcmV0dXJuIG90O1xufVxuXG4vKipcbiAqIFdoZW4gd2UgbmVlZCB0byB0cmF2ZXJzZSBmcm9tIG9uZSB0cmlhbmdsZSB0byB0aGUgbmV4dCB3ZSBuZWVkXG4gKiB0aGUgcG9pbnQgaW4gY3VycmVudCB0cmlhbmdsZSB0aGF0IGlzIHRoZSBvcHBvc2l0ZSBwb2ludCB0byB0aGUgbmV4dFxuICogdHJpYW5nbGUuXG4gKi9cbmZ1bmN0aW9uIG5leHRGbGlwUG9pbnQoZXAsIGVxLCBvdCwgb3ApIHtcbiAgICB2YXIgbzJkID0gb3JpZW50MmQoZXEsIG9wLCBlcCk7XG4gICAgaWYgKG8yZCA9PT0gT3JpZW50YXRpb24uQ1cpIHtcbiAgICAgICAgLy8gUmlnaHRcbiAgICAgICAgcmV0dXJuIG90LnBvaW50Q0NXKG9wKTtcbiAgICB9IGVsc2UgaWYgKG8yZCA9PT0gT3JpZW50YXRpb24uQ0NXKSB7XG4gICAgICAgIC8vIExlZnRcbiAgICAgICAgcmV0dXJuIG90LnBvaW50Q1cob3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBQb2ludEVycm9yKFwicG9seTJ0cmkgW1Vuc3VwcG9ydGVkXSBuZXh0RmxpcFBvaW50OiBvcHBvc2luZyBwb2ludCBvbiBjb25zdHJhaW5lZCBlZGdlIVwiLCBbZXEsIG9wLCBlcF0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTY2FuIHBhcnQgb2YgdGhlIEZsaXBTY2FuIGFsZ29yaXRobTxicj5cbiAqIFdoZW4gYSB0cmlhbmdsZSBwYWlyIGlzbid0IGZsaXBwYWJsZSB3ZSB3aWxsIHNjYW4gZm9yIHRoZSBuZXh0XG4gKiBwb2ludCB0aGF0IGlzIGluc2lkZSB0aGUgZmxpcCB0cmlhbmdsZSBzY2FuIGFyZWEuIFdoZW4gZm91bmRcbiAqIHdlIGdlbmVyYXRlIGEgbmV3IGZsaXBFZGdlRXZlbnRcbiAqXG4gKiBAcGFyYW0geyFTd2VlcENvbnRleHR9IHRjeCAtIFN3ZWVwQ29udGV4dCBvYmplY3RcbiAqIEBwYXJhbSBlcCAtIGxhc3QgcG9pbnQgb24gdGhlIGVkZ2Ugd2UgYXJlIHRyYXZlcnNpbmdcbiAqIEBwYXJhbSBlcSAtIGZpcnN0IHBvaW50IG9uIHRoZSBlZGdlIHdlIGFyZSB0cmF2ZXJzaW5nXG4gKiBAcGFyYW0geyFUcmlhbmdsZX0gZmxpcF90cmlhbmdsZSAtIHRoZSBjdXJyZW50IHRyaWFuZ2xlIHNoYXJpbmcgdGhlIHBvaW50IGVxIHdpdGggZWRnZVxuICogQHBhcmFtIHRcbiAqIEBwYXJhbSBwXG4gKi9cbmZ1bmN0aW9uIGZsaXBTY2FuRWRnZUV2ZW50KHRjeCwgZXAsIGVxLCBmbGlwX3RyaWFuZ2xlLCB0LCBwKSB7XG4gICAgdmFyIG90ID0gdC5uZWlnaGJvckFjcm9zcyhwKTtcbiAgICBhc3NlcnQob3QsIFwiRkxJUCBmYWlsZWQgZHVlIHRvIG1pc3NpbmcgdHJpYW5nbGVcIik7XG5cbiAgICB2YXIgb3AgPSBvdC5vcHBvc2l0ZVBvaW50KHQsIHApO1xuXG4gICAgaWYgKGluU2NhbkFyZWEoZXEsIGZsaXBfdHJpYW5nbGUucG9pbnRDQ1coZXEpLCBmbGlwX3RyaWFuZ2xlLnBvaW50Q1coZXEpLCBvcCkpIHtcbiAgICAgICAgLy8gZmxpcCB3aXRoIG5ldyBlZGdlIG9wLmVxXG4gICAgICAgIGZsaXBFZGdlRXZlbnQodGN4LCBlcSwgb3AsIG90LCBvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5ld1AgPSBuZXh0RmxpcFBvaW50KGVwLCBlcSwgb3QsIG9wKTtcbiAgICAgICAgZmxpcFNjYW5FZGdlRXZlbnQodGN4LCBlcCwgZXEsIGZsaXBfdHJpYW5nbGUsIG90LCBuZXdQKTtcbiAgICB9XG59XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLUV4cG9ydHNcblxuZXhwb3J0cy50cmlhbmd1bGF0ZSA9IHRyaWFuZ3VsYXRlO1xuXG59LHtcIi4vYWR2YW5jaW5nZnJvbnRcIjoyLFwiLi9hc3NlcnRcIjozLFwiLi9wb2ludGVycm9yXCI6NSxcIi4vdHJpYW5nbGVcIjo5LFwiLi91dGlsc1wiOjEwfV0sODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogUG9seTJUcmkgQ29weXJpZ2h0IChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xuICogXG4gKiBwb2x5MnRyaS5qcyAoSmF2YVNjcmlwdCBwb3J0KSAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yM21pL3BvbHkydHJpLmpzXG4gKiBcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSAzLWNsYXVzZSBCU0QgTGljZW5zZSwgc2VlIExJQ0VOU0UudHh0XG4gKi9cblxuLyoganNoaW50IG1heGNvbXBsZXhpdHk6NiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKlxuICogTm90ZVxuICogPT09PVxuICogdGhlIHN0cnVjdHVyZSBvZiB0aGlzIEphdmFTY3JpcHQgdmVyc2lvbiBvZiBwb2x5MnRyaSBpbnRlbnRpb25hbGx5IGZvbGxvd3NcbiAqIGFzIGNsb3NlbHkgYXMgcG9zc2libGUgdGhlIHN0cnVjdHVyZSBvZiB0aGUgcmVmZXJlbmNlIEMrKyB2ZXJzaW9uLCB0byBtYWtlIGl0IFxuICogZWFzaWVyIHRvIGtlZXAgdGhlIDIgdmVyc2lvbnMgaW4gc3luYy5cbiAqL1xuXG52YXIgUG9pbnRFcnJvciA9IF9kZXJlcV8oJy4vcG9pbnRlcnJvcicpO1xudmFyIFBvaW50ID0gX2RlcmVxXygnLi9wb2ludCcpO1xudmFyIFRyaWFuZ2xlID0gX2RlcmVxXygnLi90cmlhbmdsZScpO1xudmFyIHN3ZWVwID0gX2RlcmVxXygnLi9zd2VlcCcpO1xudmFyIEFkdmFuY2luZ0Zyb250ID0gX2RlcmVxXygnLi9hZHZhbmNpbmdmcm9udCcpO1xudmFyIE5vZGUgPSBBZHZhbmNpbmdGcm9udC5Ob2RlO1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXV0aWxzXG5cbi8qKlxuICogSW5pdGlhbCB0cmlhbmdsZSBmYWN0b3IsIHNlZWQgdHJpYW5nbGUgd2lsbCBleHRlbmQgMzAlIG9mXG4gKiBQb2ludFNldCB3aWR0aCB0byBib3RoIGxlZnQgYW5kIHJpZ2h0LlxuICogQHByaXZhdGVcbiAqIEBjb25zdFxuICovXG52YXIga0FscGhhID0gMC4zO1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1FZGdlXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzaW1wbGUgcG9seWdvbidzIGVkZ2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHN0cnVjdFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UG9pbnR9IHAxXG4gKiBAcGFyYW0ge1BvaW50fSBwMlxuICogQHRocm93IHtQb2ludEVycm9yfSBpZiBwMSBpcyBzYW1lIGFzIHAyXG4gKi9cbnZhciBFZGdlID0gZnVuY3Rpb24ocDEsIHAyKSB7XG4gICAgdGhpcy5wID0gcDE7XG4gICAgdGhpcy5xID0gcDI7XG5cbiAgICBpZiAocDEueSA+IHAyLnkpIHtcbiAgICAgICAgdGhpcy5xID0gcDE7XG4gICAgICAgIHRoaXMucCA9IHAyO1xuICAgIH0gZWxzZSBpZiAocDEueSA9PT0gcDIueSkge1xuICAgICAgICBpZiAocDEueCA+IHAyLngpIHtcbiAgICAgICAgICAgIHRoaXMucSA9IHAxO1xuICAgICAgICAgICAgdGhpcy5wID0gcDI7XG4gICAgICAgIH0gZWxzZSBpZiAocDEueCA9PT0gcDIueCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBvaW50RXJyb3IoJ3BvbHkydHJpIEludmFsaWQgRWRnZSBjb25zdHJ1Y3RvcjogcmVwZWF0ZWQgcG9pbnRzIScsIFtwMV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnEuX3AydF9lZGdlX2xpc3QpIHtcbiAgICAgICAgdGhpcy5xLl9wMnRfZWRnZV9saXN0ID0gW107XG4gICAgfVxuICAgIHRoaXMucS5fcDJ0X2VkZ2VfbGlzdC5wdXNoKHRoaXMpO1xufTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1CYXNpblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBzdHJ1Y3RcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBCYXNpbiA9IGZ1bmN0aW9uKCkge1xuICAgIC8qKiBAdHlwZSB7Tm9kZX0gKi9cbiAgICB0aGlzLmxlZnRfbm9kZSA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtOb2RlfSAqL1xuICAgIHRoaXMuYm90dG9tX25vZGUgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7Tm9kZX0gKi9cbiAgICB0aGlzLnJpZ2h0X25vZGUgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMud2lkdGggPSAwLjA7XG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgIHRoaXMubGVmdF9oaWdoZXN0ID0gZmFsc2U7XG59O1xuXG5CYXNpbi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmxlZnRfbm9kZSA9IG51bGw7XG4gICAgdGhpcy5ib3R0b21fbm9kZSA9IG51bGw7XG4gICAgdGhpcy5yaWdodF9ub2RlID0gbnVsbDtcbiAgICB0aGlzLndpZHRoID0gMC4wO1xuICAgIHRoaXMubGVmdF9oaWdoZXN0ID0gZmFsc2U7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLUVkZ2VFdmVudFxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBzdHJ1Y3RcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBFZGdlRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAvKiogQHR5cGUge0VkZ2V9ICovXG4gICAgdGhpcy5jb25zdHJhaW5lZF9lZGdlID0gbnVsbDtcbiAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5yaWdodCA9IGZhbHNlO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVN3ZWVwQ29udGV4dCAocHVibGljIEFQSSlcbi8qKlxuICogU3dlZXBDb250ZXh0IGNvbnN0cnVjdG9yIG9wdGlvblxuICogQHR5cGVkZWYge09iamVjdH0gU3dlZXBDb250ZXh0T3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFuPX0gY2xvbmVBcnJheXMgLSBpZiA8Y29kZT50cnVlPC9jb2RlPiwgZG8gYSBzaGFsbG93IGNvcHkgb2YgdGhlIEFycmF5IHBhcmFtZXRlcnNcbiAqICAgICAgICAgICAgICAgICAgKGNvbnRvdXIsIGhvbGVzKS4gUG9pbnRzIGluc2lkZSBhcnJheXMgYXJlIG5ldmVyIGNvcGllZC5cbiAqICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyA8Y29kZT5mYWxzZTwvY29kZT4gOiBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBhcnJheSBhcmd1bWVudHMsXG4gKiAgICAgICAgICAgICAgICAgIHdobyB3aWxsIGJlIG1vZGlmaWVkIGluIHBsYWNlLlxuICovXG4vKipcbiAqIENvbnN0cnVjdG9yIGZvciB0aGUgdHJpYW5ndWxhdGlvbiBjb250ZXh0LlxuICogSXQgYWNjZXB0cyBhIHNpbXBsZSBwb2x5bGluZSAod2l0aCBub24gcmVwZWF0aW5nIHBvaW50cyksIFxuICogd2hpY2ggZGVmaW5lcyB0aGUgY29uc3RyYWluZWQgZWRnZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAgICAgIHZhciBjb250b3VyID0gW1xuICogICAgICAgICAgICAgIG5ldyBwb2x5MnRyaS5Qb2ludCgxMDAsIDEwMCksXG4gKiAgICAgICAgICAgICAgbmV3IHBvbHkydHJpLlBvaW50KDEwMCwgMzAwKSxcbiAqICAgICAgICAgICAgICBuZXcgcG9seTJ0cmkuUG9pbnQoMzAwLCAzMDApLFxuICogICAgICAgICAgICAgIG5ldyBwb2x5MnRyaS5Qb2ludCgzMDAsIDEwMClcbiAqICAgICAgICAgIF07XG4gKiAgICAgICAgICB2YXIgc3djdHggPSBuZXcgcG9seTJ0cmkuU3dlZXBDb250ZXh0KGNvbnRvdXIsIHtjbG9uZUFycmF5czogdHJ1ZX0pO1xuICogQGV4YW1wbGVcbiAqICAgICAgICAgIHZhciBjb250b3VyID0gW3t4OjEwMCwgeToxMDB9LCB7eDoxMDAsIHk6MzAwfSwge3g6MzAwLCB5OjMwMH0sIHt4OjMwMCwgeToxMDB9XTtcbiAqICAgICAgICAgIHZhciBzd2N0eCA9IG5ldyBwb2x5MnRyaS5Td2VlcENvbnRleHQoY29udG91ciwge2Nsb25lQXJyYXlzOiB0cnVlfSk7XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqIEBzdHJ1Y3RcbiAqIEBwYXJhbSB7QXJyYXkuPFhZPn0gY29udG91ciAtIGFycmF5IG9mIHBvaW50IG9iamVjdHMuIFRoZSBwb2ludHMgY2FuIGJlIGVpdGhlciB7QGxpbmtjb2RlIFBvaW50fSBpbnN0YW5jZXMsXG4gKiAgICAgICAgICBvciBhbnkgXCJQb2ludCBsaWtlXCIgY3VzdG9tIGNsYXNzIHdpdGggPGNvZGU+e3gsIHl9PC9jb2RlPiBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtTd2VlcENvbnRleHRPcHRpb25zPX0gb3B0aW9ucyAtIGNvbnN0cnVjdG9yIG9wdGlvbnNcbiAqL1xudmFyIFN3ZWVwQ29udGV4dCA9IGZ1bmN0aW9uKGNvbnRvdXIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnRyaWFuZ2xlc18gPSBbXTtcbiAgICB0aGlzLm1hcF8gPSBbXTtcbiAgICB0aGlzLnBvaW50c18gPSAob3B0aW9ucy5jbG9uZUFycmF5cyA/IGNvbnRvdXIuc2xpY2UoMCkgOiBjb250b3VyKTtcbiAgICB0aGlzLmVkZ2VfbGlzdCA9IFtdO1xuXG4gICAgLy8gQm91bmRpbmcgYm94IG9mIGFsbCBwb2ludHMuIENvbXB1dGVkIGF0IHRoZSBzdGFydCBvZiB0aGUgdHJpYW5ndWxhdGlvbiwgXG4gICAgLy8gaXQgaXMgc3RvcmVkIGluIGNhc2UgaXQgaXMgbmVlZGVkIGJ5IHRoZSBjYWxsZXIuXG4gICAgdGhpcy5wbWluXyA9IHRoaXMucG1heF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQWR2YW5jaW5nIGZyb250XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QWR2YW5jaW5nRnJvbnR9XG4gICAgICovXG4gICAgdGhpcy5mcm9udF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogaGVhZCBwb2ludCB1c2VkIHdpdGggYWR2YW5jaW5nIGZyb250XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICovXG4gICAgdGhpcy5oZWFkXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiB0YWlsIHBvaW50IHVzZWQgd2l0aCBhZHZhbmNpbmcgZnJvbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaWxfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge05vZGV9XG4gICAgICovXG4gICAgdGhpcy5hZl9oZWFkXyA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Tm9kZX1cbiAgICAgKi9cbiAgICB0aGlzLmFmX21pZGRsZV8gPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge05vZGV9XG4gICAgICovXG4gICAgdGhpcy5hZl90YWlsXyA9IG51bGw7XG5cbiAgICB0aGlzLmJhc2luID0gbmV3IEJhc2luKCk7XG4gICAgdGhpcy5lZGdlX2V2ZW50ID0gbmV3IEVkZ2VFdmVudCgpO1xuXG4gICAgdGhpcy5pbml0RWRnZXModGhpcy5wb2ludHNfKTtcbn07XG5cblxuLyoqXG4gKiBBZGQgYSBob2xlIHRvIHRoZSBjb25zdHJhaW50c1xuICogQGV4YW1wbGVcbiAqICAgICAgdmFyIHN3Y3R4ID0gbmV3IHBvbHkydHJpLlN3ZWVwQ29udGV4dChjb250b3VyKTtcbiAqICAgICAgdmFyIGhvbGUgPSBbXG4gKiAgICAgICAgICBuZXcgcG9seTJ0cmkuUG9pbnQoMjAwLCAyMDApLFxuICogICAgICAgICAgbmV3IHBvbHkydHJpLlBvaW50KDIwMCwgMjUwKSxcbiAqICAgICAgICAgIG5ldyBwb2x5MnRyaS5Qb2ludCgyNTAsIDI1MClcbiAqICAgICAgXTtcbiAqICAgICAgc3djdHguYWRkSG9sZShob2xlKTtcbiAqIEBleGFtcGxlXG4gKiAgICAgIHZhciBzd2N0eCA9IG5ldyBwb2x5MnRyaS5Td2VlcENvbnRleHQoY29udG91cik7XG4gKiAgICAgIHN3Y3R4LmFkZEhvbGUoW3t4OjIwMCwgeToyMDB9LCB7eDoyMDAsIHk6MjUwfSwge3g6MjUwLCB5OjI1MH1dKTtcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7QXJyYXkuPFhZPn0gcG9seWxpbmUgLSBhcnJheSBvZiBcIlBvaW50IGxpa2VcIiBvYmplY3RzIHdpdGgge3gseX1cbiAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5hZGRIb2xlID0gZnVuY3Rpb24ocG9seWxpbmUpIHtcbiAgICB0aGlzLmluaXRFZGdlcyhwb2x5bGluZSk7XG4gICAgdmFyIGksIGxlbiA9IHBvbHlsaW5lLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5wb2ludHNfLnB1c2gocG9seWxpbmVbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG59O1xuXG4vKipcbiAqIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gKiBAZnVuY3Rpb25cbiAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmtjb2RlIFN3ZWVwQ29udGV4dCNhZGRIb2xlfSBpbnN0ZWFkXG4gKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUuQWRkSG9sZSA9IFN3ZWVwQ29udGV4dC5wcm90b3R5cGUuYWRkSG9sZTtcblxuXG4vKipcbiAqIEFkZCBzZXZlcmFsIGhvbGVzIHRvIHRoZSBjb25zdHJhaW50c1xuICogQGV4YW1wbGVcbiAqICAgICAgdmFyIHN3Y3R4ID0gbmV3IHBvbHkydHJpLlN3ZWVwQ29udGV4dChjb250b3VyKTtcbiAqICAgICAgdmFyIGhvbGVzID0gW1xuICogICAgICAgICAgWyBuZXcgcG9seTJ0cmkuUG9pbnQoMjAwLCAyMDApLCBuZXcgcG9seTJ0cmkuUG9pbnQoMjAwLCAyNTApLCBuZXcgcG9seTJ0cmkuUG9pbnQoMjUwLCAyNTApIF0sXG4gKiAgICAgICAgICBbIG5ldyBwb2x5MnRyaS5Qb2ludCgzMDAsIDMwMCksIG5ldyBwb2x5MnRyaS5Qb2ludCgzMDAsIDM1MCksIG5ldyBwb2x5MnRyaS5Qb2ludCgzNTAsIDM1MCkgXVxuICogICAgICBdO1xuICogICAgICBzd2N0eC5hZGRIb2xlcyhob2xlcyk7XG4gKiBAZXhhbXBsZVxuICogICAgICB2YXIgc3djdHggPSBuZXcgcG9seTJ0cmkuU3dlZXBDb250ZXh0KGNvbnRvdXIpO1xuICogICAgICB2YXIgaG9sZXMgPSBbXG4gKiAgICAgICAgICBbe3g6MjAwLCB5OjIwMH0sIHt4OjIwMCwgeToyNTB9LCB7eDoyNTAsIHk6MjUwfV0sXG4gKiAgICAgICAgICBbe3g6MzAwLCB5OjMwMH0sIHt4OjMwMCwgeTozNTB9LCB7eDozNTAsIHk6MzUwfV1cbiAqICAgICAgXTtcbiAqICAgICAgc3djdHguYWRkSG9sZXMoaG9sZXMpO1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPFhZPj59IGhvbGVzIC0gYXJyYXkgb2YgYXJyYXkgb2YgXCJQb2ludCBsaWtlXCIgb2JqZWN0cyB3aXRoIHt4LHl9XG4gKi9cbi8vIE1ldGhvZCBhZGRlZCBpbiB0aGUgSmF2YVNjcmlwdCB2ZXJzaW9uICh3YXMgbm90IHByZXNlbnQgaW4gdGhlIGMrKyB2ZXJzaW9uKVxuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5hZGRIb2xlcyA9IGZ1bmN0aW9uKGhvbGVzKSB7XG4gICAgdmFyIGksIGxlbiA9IGhvbGVzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5pbml0RWRnZXMoaG9sZXNbaV0pO1xuICAgIH1cbiAgICB0aGlzLnBvaW50c18gPSB0aGlzLnBvaW50c18uY29uY2F0LmFwcGx5KHRoaXMucG9pbnRzXywgaG9sZXMpO1xuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcbn07XG5cblxuLyoqXG4gKiBBZGQgYSBTdGVpbmVyIHBvaW50IHRvIHRoZSBjb25zdHJhaW50c1xuICogQGV4YW1wbGVcbiAqICAgICAgdmFyIHN3Y3R4ID0gbmV3IHBvbHkydHJpLlN3ZWVwQ29udGV4dChjb250b3VyKTtcbiAqICAgICAgdmFyIHBvaW50ID0gbmV3IHBvbHkydHJpLlBvaW50KDE1MCwgMTUwKTtcbiAqICAgICAgc3djdHguYWRkUG9pbnQocG9pbnQpO1xuICogQGV4YW1wbGVcbiAqICAgICAgdmFyIHN3Y3R4ID0gbmV3IHBvbHkydHJpLlN3ZWVwQ29udGV4dChjb250b3VyKTtcbiAqICAgICAgc3djdHguYWRkUG9pbnQoe3g6MTUwLCB5OjE1MH0pO1xuICogQHB1YmxpY1xuICogQHBhcmFtIHtYWX0gcG9pbnQgLSBhbnkgXCJQb2ludCBsaWtlXCIgb2JqZWN0IHdpdGgge3gseX1cbiAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5hZGRQb2ludCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgdGhpcy5wb2ludHNfLnB1c2gocG9pbnQpO1xuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcbn07XG5cbi8qKlxuICogRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAqIEBmdW5jdGlvblxuICogQGRlcHJlY2F0ZWQgdXNlIHtAbGlua2NvZGUgU3dlZXBDb250ZXh0I2FkZFBvaW50fSBpbnN0ZWFkXG4gKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUuQWRkUG9pbnQgPSBTd2VlcENvbnRleHQucHJvdG90eXBlLmFkZFBvaW50O1xuXG5cbi8qKlxuICogQWRkIHNldmVyYWwgU3RlaW5lciBwb2ludHMgdG8gdGhlIGNvbnN0cmFpbnRzXG4gKiBAZXhhbXBsZVxuICogICAgICB2YXIgc3djdHggPSBuZXcgcG9seTJ0cmkuU3dlZXBDb250ZXh0KGNvbnRvdXIpO1xuICogICAgICB2YXIgcG9pbnRzID0gW1xuICogICAgICAgICAgbmV3IHBvbHkydHJpLlBvaW50KDE1MCwgMTUwKSxcbiAqICAgICAgICAgIG5ldyBwb2x5MnRyaS5Qb2ludCgyMDAsIDI1MCksXG4gKiAgICAgICAgICBuZXcgcG9seTJ0cmkuUG9pbnQoMjUwLCAyNTApXG4gKiAgICAgIF07XG4gKiAgICAgIHN3Y3R4LmFkZFBvaW50cyhwb2ludHMpO1xuICogQGV4YW1wbGVcbiAqICAgICAgdmFyIHN3Y3R4ID0gbmV3IHBvbHkydHJpLlN3ZWVwQ29udGV4dChjb250b3VyKTtcbiAqICAgICAgc3djdHguYWRkUG9pbnRzKFt7eDoxNTAsIHk6MTUwfSwge3g6MjAwLCB5OjI1MH0sIHt4OjI1MCwgeToyNTB9XSk7XG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0FycmF5LjxYWT59IHBvaW50cyAtIGFycmF5IG9mIFwiUG9pbnQgbGlrZVwiIG9iamVjdCB3aXRoIHt4LHl9XG4gKi9cbi8vIE1ldGhvZCBhZGRlZCBpbiB0aGUgSmF2YVNjcmlwdCB2ZXJzaW9uICh3YXMgbm90IHByZXNlbnQgaW4gdGhlIGMrKyB2ZXJzaW9uKVxuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5hZGRQb2ludHMgPSBmdW5jdGlvbihwb2ludHMpIHtcbiAgICB0aGlzLnBvaW50c18gPSB0aGlzLnBvaW50c18uY29uY2F0KHBvaW50cyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xufTtcblxuXG4vKipcbiAqIFRyaWFuZ3VsYXRlIHRoZSBwb2x5Z29uIHdpdGggaG9sZXMgYW5kIFN0ZWluZXIgcG9pbnRzLlxuICogRG8gdGhpcyBBRlRFUiB5b3UndmUgYWRkZWQgdGhlIHBvbHlsaW5lLCBob2xlcywgYW5kIFN0ZWluZXIgcG9pbnRzXG4gKiBAZXhhbXBsZVxuICogICAgICB2YXIgc3djdHggPSBuZXcgcG9seTJ0cmkuU3dlZXBDb250ZXh0KGNvbnRvdXIpO1xuICogICAgICBzd2N0eC50cmlhbmd1bGF0ZSgpO1xuICogICAgICB2YXIgdHJpYW5nbGVzID0gc3djdHguZ2V0VHJpYW5nbGVzKCk7XG4gKiBAcHVibGljXG4gKi9cbi8vIFNob3J0Y3V0IG1ldGhvZCBmb3Igc3dlZXAudHJpYW5ndWxhdGUoU3dlZXBDb250ZXh0KS5cbi8vIE1ldGhvZCBhZGRlZCBpbiB0aGUgSmF2YVNjcmlwdCB2ZXJzaW9uICh3YXMgbm90IHByZXNlbnQgaW4gdGhlIGMrKyB2ZXJzaW9uKVxuU3dlZXBDb250ZXh0LnByb3RvdHlwZS50cmlhbmd1bGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHN3ZWVwLnRyaWFuZ3VsYXRlKHRoaXMpO1xuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgcHJvdmlkZWQgY29uc3RyYWludHMgKGNvbnRvdXIsIGhvbGVzIGFuZCBcbiAqIFN0ZWludGVyIHBvaW50cykuIFdhcm5pbmcgOiB0aGVzZSB2YWx1ZXMgYXJlIG5vdCBhdmFpbGFibGUgaWYgdGhlIHRyaWFuZ3VsYXRpb24gXG4gKiBoYXMgbm90IGJlZW4gZG9uZSB5ZXQuXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyB7e21pbjpQb2ludCxtYXg6UG9pbnR9fSBvYmplY3Qgd2l0aCAnbWluJyBhbmQgJ21heCcgUG9pbnRcbiAqL1xuLy8gTWV0aG9kIGFkZGVkIGluIHRoZSBKYXZhU2NyaXB0IHZlcnNpb24gKHdhcyBub3QgcHJlc2VudCBpbiB0aGUgYysrIHZlcnNpb24pXG5Td2VlcENvbnRleHQucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHttaW46IHRoaXMucG1pbl8sIG1heDogdGhpcy5wbWF4X307XG59O1xuXG4vKipcbiAqIEdldCByZXN1bHQgb2YgdHJpYW5ndWxhdGlvbi5cbiAqIFRoZSBvdXRwdXQgdHJpYW5nbGVzIGhhdmUgdmVydGljZXMgd2hpY2ggYXJlIHJlZmVyZW5jZXNcbiAqIHRvIHRoZSBpbml0aWFsIGlucHV0IHBvaW50cyAobm90IGNvcGllcyk6IGFueSBjdXN0b20gZmllbGRzIGluIHRoZVxuICogaW5pdGlhbCBwb2ludHMgY2FuIGJlIHJldHJpZXZlZCBpbiB0aGUgb3V0cHV0IHRyaWFuZ2xlcy5cbiAqIEBleGFtcGxlXG4gKiAgICAgIHZhciBzd2N0eCA9IG5ldyBwb2x5MnRyaS5Td2VlcENvbnRleHQoY29udG91cik7XG4gKiAgICAgIHN3Y3R4LnRyaWFuZ3VsYXRlKCk7XG4gKiAgICAgIHZhciB0cmlhbmdsZXMgPSBzd2N0eC5nZXRUcmlhbmdsZXMoKTtcbiAqIEBleGFtcGxlXG4gKiAgICAgIHZhciBjb250b3VyID0gW3t4OjEwMCwgeToxMDAsIGlkOjF9LCB7eDoxMDAsIHk6MzAwLCBpZDoyfSwge3g6MzAwLCB5OjMwMCwgaWQ6M31dO1xuICogICAgICB2YXIgc3djdHggPSBuZXcgcG9seTJ0cmkuU3dlZXBDb250ZXh0KGNvbnRvdXIpO1xuICogICAgICBzd2N0eC50cmlhbmd1bGF0ZSgpO1xuICogICAgICB2YXIgdHJpYW5nbGVzID0gc3djdHguZ2V0VHJpYW5nbGVzKCk7XG4gKiAgICAgIHR5cGVvZiB0cmlhbmdsZXNbMF0uZ2V0UG9pbnQoMCkuaWRcbiAqICAgICAgLy8g4oaSIFwibnVtYmVyXCJcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIHthcnJheTxUcmlhbmdsZT59ICAgYXJyYXkgb2YgdHJpYW5nbGVzXG4gKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUuZ2V0VHJpYW5nbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJpYW5nbGVzXztcbn07XG5cbi8qKlxuICogRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAqIEBmdW5jdGlvblxuICogQGRlcHJlY2F0ZWQgdXNlIHtAbGlua2NvZGUgU3dlZXBDb250ZXh0I2dldFRyaWFuZ2xlc30gaW5zdGVhZFxuICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLkdldFRyaWFuZ2xlcyA9IFN3ZWVwQ29udGV4dC5wcm90b3R5cGUuZ2V0VHJpYW5nbGVzO1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVN3ZWVwQ29udGV4dCAocHJpdmF0ZSBBUEkpXG5cbi8qKiBAcHJpdmF0ZSAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5mcm9udCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZyb250Xztcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5wb2ludENvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzXy5sZW5ndGg7XG59O1xuXG4vKiogQHByaXZhdGUgKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUuaGVhZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmhlYWRfO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLnNldEhlYWQgPSBmdW5jdGlvbihwMSkge1xuICAgIHRoaXMuaGVhZF8gPSBwMTtcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS50YWlsID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGFpbF87XG59O1xuXG4vKiogQHByaXZhdGUgKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUuc2V0VGFpbCA9IGZ1bmN0aW9uKHAxKSB7XG4gICAgdGhpcy50YWlsXyA9IHAxO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLmdldE1hcCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1hcF87XG59O1xuXG4vKiogQHByaXZhdGUgKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUuaW5pdFRyaWFuZ3VsYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgeG1heCA9IHRoaXMucG9pbnRzX1swXS54O1xuICAgIHZhciB4bWluID0gdGhpcy5wb2ludHNfWzBdLng7XG4gICAgdmFyIHltYXggPSB0aGlzLnBvaW50c19bMF0ueTtcbiAgICB2YXIgeW1pbiA9IHRoaXMucG9pbnRzX1swXS55O1xuXG4gICAgLy8gQ2FsY3VsYXRlIGJvdW5kc1xuICAgIHZhciBpLCBsZW4gPSB0aGlzLnBvaW50c18ubGVuZ3RoO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgcCA9IHRoaXMucG9pbnRzX1tpXTtcbiAgICAgICAgLyoganNoaW50IGV4cHI6dHJ1ZSAqL1xuICAgICAgICAocC54ID4geG1heCkgJiYgKHhtYXggPSBwLngpO1xuICAgICAgICAocC54IDwgeG1pbikgJiYgKHhtaW4gPSBwLngpO1xuICAgICAgICAocC55ID4geW1heCkgJiYgKHltYXggPSBwLnkpO1xuICAgICAgICAocC55IDwgeW1pbikgJiYgKHltaW4gPSBwLnkpO1xuICAgIH1cbiAgICB0aGlzLnBtaW5fID0gbmV3IFBvaW50KHhtaW4sIHltaW4pO1xuICAgIHRoaXMucG1heF8gPSBuZXcgUG9pbnQoeG1heCwgeW1heCk7XG5cbiAgICB2YXIgZHggPSBrQWxwaGEgKiAoeG1heCAtIHhtaW4pO1xuICAgIHZhciBkeSA9IGtBbHBoYSAqICh5bWF4IC0geW1pbik7XG4gICAgdGhpcy5oZWFkXyA9IG5ldyBQb2ludCh4bWF4ICsgZHgsIHltaW4gLSBkeSk7XG4gICAgdGhpcy50YWlsXyA9IG5ldyBQb2ludCh4bWluIC0gZHgsIHltaW4gLSBkeSk7XG5cbiAgICAvLyBTb3J0IHBvaW50cyBhbG9uZyB5LWF4aXNcbiAgICB0aGlzLnBvaW50c18uc29ydChQb2ludC5jb21wYXJlKTtcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5pbml0RWRnZXMgPSBmdW5jdGlvbihwb2x5bGluZSkge1xuICAgIHZhciBpLCBsZW4gPSBwb2x5bGluZS5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHRoaXMuZWRnZV9saXN0LnB1c2gobmV3IEVkZ2UocG9seWxpbmVbaV0sIHBvbHlsaW5lWyhpICsgMSkgJSBsZW5dKSk7XG4gICAgfVxufTtcblxuLyoqIEBwcml2YXRlICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHNfW2luZGV4XTtcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5hZGRUb01hcCA9IGZ1bmN0aW9uKHRyaWFuZ2xlKSB7XG4gICAgdGhpcy5tYXBfLnB1c2godHJpYW5nbGUpO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLmxvY2F0ZU5vZGUgPSBmdW5jdGlvbihwb2ludCkge1xuICAgIHJldHVybiB0aGlzLmZyb250Xy5sb2NhdGVOb2RlKHBvaW50LngpO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5Td2VlcENvbnRleHQucHJvdG90eXBlLmNyZWF0ZUFkdmFuY2luZ0Zyb250ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhlYWQ7XG4gICAgdmFyIG1pZGRsZTtcbiAgICB2YXIgdGFpbDtcbiAgICAvLyBJbml0aWFsIHRyaWFuZ2xlXG4gICAgdmFyIHRyaWFuZ2xlID0gbmV3IFRyaWFuZ2xlKHRoaXMucG9pbnRzX1swXSwgdGhpcy50YWlsXywgdGhpcy5oZWFkXyk7XG5cbiAgICB0aGlzLm1hcF8ucHVzaCh0cmlhbmdsZSk7XG5cbiAgICBoZWFkID0gbmV3IE5vZGUodHJpYW5nbGUuZ2V0UG9pbnQoMSksIHRyaWFuZ2xlKTtcbiAgICBtaWRkbGUgPSBuZXcgTm9kZSh0cmlhbmdsZS5nZXRQb2ludCgwKSwgdHJpYW5nbGUpO1xuICAgIHRhaWwgPSBuZXcgTm9kZSh0cmlhbmdsZS5nZXRQb2ludCgyKSk7XG5cbiAgICB0aGlzLmZyb250XyA9IG5ldyBBZHZhbmNpbmdGcm9udChoZWFkLCB0YWlsKTtcblxuICAgIGhlYWQubmV4dCA9IG1pZGRsZTtcbiAgICBtaWRkbGUubmV4dCA9IHRhaWw7XG4gICAgbWlkZGxlLnByZXYgPSBoZWFkO1xuICAgIHRhaWwucHJldiA9IG1pZGRsZTtcbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5yZW1vdmVOb2RlID0gZnVuY3Rpb24obm9kZSkge1xuICAgIC8vIGRvIG5vdGhpbmdcbiAgICAvKiBqc2hpbnQgdW51c2VkOmZhbHNlICovXG59O1xuXG4vKiogQHByaXZhdGUgKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUubWFwVHJpYW5nbGVUb05vZGVzID0gZnVuY3Rpb24odCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgICAgIGlmICghdC5nZXROZWlnaGJvcihpKSkge1xuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLmZyb250Xy5sb2NhdGVQb2ludCh0LnBvaW50Q1codC5nZXRQb2ludChpKSkpO1xuICAgICAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgICAgICBuLnRyaWFuZ2xlID0gdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKiBAcHJpdmF0ZSAqL1xuU3dlZXBDb250ZXh0LnByb3RvdHlwZS5yZW1vdmVGcm9tTWFwID0gZnVuY3Rpb24odHJpYW5nbGUpIHtcbiAgICB2YXIgaSwgbWFwID0gdGhpcy5tYXBfLCBsZW4gPSBtYXAubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAobWFwW2ldID09PSB0cmlhbmdsZSkge1xuICAgICAgICAgICAgbWFwLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBEbyBhIGRlcHRoIGZpcnN0IHRyYXZlcnNhbCB0byBjb2xsZWN0IHRyaWFuZ2xlc1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7VHJpYW5nbGV9IHRyaWFuZ2xlIHN0YXJ0XG4gKi9cblN3ZWVwQ29udGV4dC5wcm90b3R5cGUubWVzaENsZWFuID0gZnVuY3Rpb24odHJpYW5nbGUpIHtcbiAgICAvLyBOZXcgaW1wbGVtZW50YXRpb24gYXZvaWRzIHJlY3Vyc2l2ZSBjYWxscyBhbmQgdXNlIGEgbG9vcCBpbnN0ZWFkLlxuICAgIC8vIENmLiBpc3N1ZXMgIyA1NywgNjUgYW5kIDY5LlxuICAgIHZhciB0cmlhbmdsZXMgPSBbdHJpYW5nbGVdLCB0LCBpO1xuICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgICB3aGlsZSAodCA9IHRyaWFuZ2xlcy5wb3AoKSkge1xuICAgICAgICBpZiAoIXQuaXNJbnRlcmlvcigpKSB7XG4gICAgICAgICAgICB0LnNldEludGVyaW9yKHRydWUpO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZXNfLnB1c2godCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0LmNvbnN0cmFpbmVkX2VkZ2VbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2godC5nZXROZWlnaGJvcihpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLUV4cG9ydHNcblxubW9kdWxlLmV4cG9ydHMgPSBTd2VlcENvbnRleHQ7XG5cbn0se1wiLi9hZHZhbmNpbmdmcm9udFwiOjIsXCIuL3BvaW50XCI6NCxcIi4vcG9pbnRlcnJvclwiOjUsXCIuL3N3ZWVwXCI6NyxcIi4vdHJpYW5nbGVcIjo5fV0sOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogUG9seTJUcmkgQ29weXJpZ2h0IChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xuICogXG4gKiBwb2x5MnRyaS5qcyAoSmF2YVNjcmlwdCBwb3J0KSAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yM21pL3BvbHkydHJpLmpzXG4gKlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIDMtY2xhdXNlIEJTRCBMaWNlbnNlLCBzZWUgTElDRU5TRS50eHRcbiAqL1xuXG4vKiBqc2hpbnQgbWF4Y29tcGxleGl0eToxMCAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKlxuICogTm90ZVxuICogPT09PVxuICogdGhlIHN0cnVjdHVyZSBvZiB0aGlzIEphdmFTY3JpcHQgdmVyc2lvbiBvZiBwb2x5MnRyaSBpbnRlbnRpb25hbGx5IGZvbGxvd3NcbiAqIGFzIGNsb3NlbHkgYXMgcG9zc2libGUgdGhlIHN0cnVjdHVyZSBvZiB0aGUgcmVmZXJlbmNlIEMrKyB2ZXJzaW9uLCB0byBtYWtlIGl0IFxuICogZWFzaWVyIHRvIGtlZXAgdGhlIDIgdmVyc2lvbnMgaW4gc3luYy5cbiAqL1xuXG52YXIgeHkgPSBfZGVyZXFfKFwiLi94eVwiKTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1UcmlhbmdsZVxuLyoqXG4gKiBUcmlhbmdsZSBjbGFzcy48YnI+XG4gKiBUcmlhbmdsZS1iYXNlZCBkYXRhIHN0cnVjdHVyZXMgYXJlIGtub3duIHRvIGhhdmUgYmV0dGVyIHBlcmZvcm1hbmNlIHRoYW5cbiAqIHF1YWQtZWRnZSBzdHJ1Y3R1cmVzLlxuICogU2VlOiBKLiBTaGV3Y2h1aywgXCJUcmlhbmdsZTogRW5naW5lZXJpbmcgYSAyRCBRdWFsaXR5IE1lc2ggR2VuZXJhdG9yIGFuZFxuICogRGVsYXVuYXkgVHJpYW5ndWxhdG9yXCIsIFwiVHJpYW5ndWxhdGlvbnMgaW4gQ0dBTFwiXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3RydWN0XG4gKiBAcGFyYW0geyFYWX0gcGEgIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0geyFYWX0gcGIgIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0geyFYWX0gcGMgIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKi9cbnZhciBUcmlhbmdsZSA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAvKipcbiAgICAgKiBUcmlhbmdsZSBwb2ludHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheS48WFk+fVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRzXyA9IFthLCBiLCBjXTtcblxuICAgIC8qKlxuICAgICAqIE5laWdoYm9yIGxpc3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheS48VHJpYW5nbGU+fVxuICAgICAqL1xuICAgIHRoaXMubmVpZ2hib3JzXyA9IFtudWxsLCBudWxsLCBudWxsXTtcblxuICAgIC8qKlxuICAgICAqIEhhcyB0aGlzIHRyaWFuZ2xlIGJlZW4gbWFya2VkIGFzIGFuIGludGVyaW9yIHRyaWFuZ2xlP1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pbnRlcmlvcl8gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEZsYWdzIHRvIGRldGVybWluZSBpZiBhbiBlZGdlIGlzIGEgQ29uc3RyYWluZWQgZWRnZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5Ljxib29sZWFuPn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnN0cmFpbmVkX2VkZ2UgPSBbZmFsc2UsIGZhbHNlLCBmYWxzZV07XG5cbiAgICAvKipcbiAgICAgKiBGbGFncyB0byBkZXRlcm1pbmUgaWYgYW4gZWRnZSBpcyBhIERlbGF1bmV5IGVkZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheS48Ym9vbGVhbj59XG4gICAgICovXG4gICAgdGhpcy5kZWxhdW5heV9lZGdlID0gW2ZhbHNlLCBmYWxzZSwgZmFsc2VdO1xufTtcblxudmFyIHAycyA9IHh5LnRvU3RyaW5nO1xuLyoqXG4gKiBGb3IgcHJldHR5IHByaW50aW5nIGV4LiA8Y29kZT5cIlsoNTs0MikoMTA7MjApKDIxOzMwKV1cIjwvY29kZT4uXG4gKiBAcHVibGljXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoXCJbXCIgKyBwMnModGhpcy5wb2ludHNfWzBdKSArIHAycyh0aGlzLnBvaW50c19bMV0pICsgcDJzKHRoaXMucG9pbnRzX1syXSkgKyBcIl1cIik7XG59O1xuXG4vKipcbiAqIEdldCBvbmUgdmVydGljZSBvZiB0aGUgdHJpYW5nbGUuXG4gKiBUaGUgb3V0cHV0IHRyaWFuZ2xlcyBvZiBhIHRyaWFuZ3VsYXRpb24gaGF2ZSB2ZXJ0aWNlcyB3aGljaCBhcmUgcmVmZXJlbmNlc1xuICogdG8gdGhlIGluaXRpYWwgaW5wdXQgcG9pbnRzIChub3QgY29waWVzKTogYW55IGN1c3RvbSBmaWVsZHMgaW4gdGhlXG4gKiBpbml0aWFsIHBvaW50cyBjYW4gYmUgcmV0cmlldmVkIGluIHRoZSBvdXRwdXQgdHJpYW5nbGVzLlxuICogQGV4YW1wbGVcbiAqICAgICAgdmFyIGNvbnRvdXIgPSBbe3g6MTAwLCB5OjEwMCwgaWQ6MX0sIHt4OjEwMCwgeTozMDAsIGlkOjJ9LCB7eDozMDAsIHk6MzAwLCBpZDozfV07XG4gKiAgICAgIHZhciBzd2N0eCA9IG5ldyBwb2x5MnRyaS5Td2VlcENvbnRleHQoY29udG91cik7XG4gKiAgICAgIHN3Y3R4LnRyaWFuZ3VsYXRlKCk7XG4gKiAgICAgIHZhciB0cmlhbmdsZXMgPSBzd2N0eC5nZXRUcmlhbmdsZXMoKTtcbiAqICAgICAgdHlwZW9mIHRyaWFuZ2xlc1swXS5nZXRQb2ludCgwKS5pZFxuICogICAgICAvLyDihpIgXCJudW1iZXJcIlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdmVydGljZSBpbmRleDogMCwgMSBvciAyXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyB7WFl9XG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzX1tpbmRleF07XG59O1xuXG4vKipcbiAqIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gKiBAZnVuY3Rpb25cbiAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmtjb2RlIFRyaWFuZ2xlI2dldFBvaW50fSBpbnN0ZWFkXG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5HZXRQb2ludCA9IFRyaWFuZ2xlLnByb3RvdHlwZS5nZXRQb2ludDtcblxuLyoqXG4gKiBHZXQgYWxsIDMgdmVydGljZXMgb2YgdGhlIHRyaWFuZ2xlIGFzIGFuIGFycmF5XG4gKiBAcHVibGljXG4gKiBAcmV0dXJuIHtBcnJheS48WFk+fVxuICovXG4vLyBNZXRob2QgYWRkZWQgaW4gdGhlIEphdmFTY3JpcHQgdmVyc2lvbiAod2FzIG5vdCBwcmVzZW50IGluIHRoZSBjKysgdmVyc2lvbilcblRyaWFuZ2xlLnByb3RvdHlwZS5nZXRQb2ludHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHNfO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcmV0dXJucyB7P1RyaWFuZ2xlfVxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUuZ2V0TmVpZ2hib3IgPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLm5laWdoYm9yc19baW5kZXhdO1xufTtcblxuLyoqXG4gKiBUZXN0IGlmIHRoaXMgVHJpYW5nbGUgY29udGFpbnMgdGhlIFBvaW50IG9iamVjdCBnaXZlbiBhcyBwYXJhbWV0ZXIgYXMgb25lIG9mIGl0cyB2ZXJ0aWNlcy5cbiAqIE9ubHkgcG9pbnQgcmVmZXJlbmNlcyBhcmUgY29tcGFyZWQsIG5vdCB2YWx1ZXMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge1hZfSBwb2ludCAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcmV0dXJuIHtib29sZWFufSA8Y29kZT5UcnVlPC9jb2RlPiBpZiB0aGUgUG9pbnQgb2JqZWN0IGlzIG9mIHRoZSBUcmlhbmdsZSdzIHZlcnRpY2VzLFxuICogICAgICAgICA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzXztcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgIHJldHVybiAocG9pbnQgPT09IHBvaW50c1swXSB8fCBwb2ludCA9PT0gcG9pbnRzWzFdIHx8IHBvaW50ID09PSBwb2ludHNbMl0pO1xufTtcblxuLyoqXG4gKiBUZXN0IGlmIHRoaXMgVHJpYW5nbGUgY29udGFpbnMgdGhlIEVkZ2Ugb2JqZWN0IGdpdmVuIGFzIHBhcmFtZXRlciBhcyBpdHNcbiAqIGJvdW5kaW5nIGVkZ2VzLiBPbmx5IHBvaW50IHJlZmVyZW5jZXMgYXJlIGNvbXBhcmVkLCBub3QgdmFsdWVzLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RWRnZX0gZWRnZVxuICogQHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+VHJ1ZTwvY29kZT4gaWYgdGhlIEVkZ2Ugb2JqZWN0IGlzIG9mIHRoZSBUcmlhbmdsZSdzIGJvdW5kaW5nXG4gKiAgICAgICAgIGVkZ2VzLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUuY29udGFpbnNFZGdlID0gZnVuY3Rpb24oZWRnZSkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5zUG9pbnQoZWRnZS5wKSAmJiB0aGlzLmNvbnRhaW5zUG9pbnQoZWRnZS5xKTtcbn07XG5cbi8qKlxuICogVGVzdCBpZiB0aGlzIFRyaWFuZ2xlIGNvbnRhaW5zIHRoZSB0d28gUG9pbnQgb2JqZWN0cyBnaXZlbiBhcyBwYXJhbWV0ZXJzIGFtb25nIGl0cyB2ZXJ0aWNlcy5cbiAqIE9ubHkgcG9pbnQgcmVmZXJlbmNlcyBhcmUgY29tcGFyZWQsIG5vdCB2YWx1ZXMuXG4gKiBAcGFyYW0ge1hZfSBwMSAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0ge1hZfSBwMiAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUuY29udGFpbnNQb2ludHMgPSBmdW5jdGlvbihwMSwgcDIpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluc1BvaW50KHAxKSAmJiB0aGlzLmNvbnRhaW5zUG9pbnQocDIpO1xufTtcblxuLyoqXG4gKiBIYXMgdGhpcyB0cmlhbmdsZSBiZWVuIG1hcmtlZCBhcyBhbiBpbnRlcmlvciB0cmlhbmdsZT9cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUuaXNJbnRlcmlvciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludGVyaW9yXztcbn07XG5cbi8qKlxuICogTWFyayB0aGlzIHRyaWFuZ2xlIGFzIGFuIGludGVyaW9yIHRyaWFuZ2xlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBpbnRlcmlvclxuICogQHJldHVybnMge1RyaWFuZ2xlfSB0aGlzXG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5zZXRJbnRlcmlvciA9IGZ1bmN0aW9uKGludGVyaW9yKSB7XG4gICAgdGhpcy5pbnRlcmlvcl8gPSBpbnRlcmlvcjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVXBkYXRlIG5laWdoYm9yIHBvaW50ZXJzLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WFl9IHAxIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7WFl9IHAyIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7VHJpYW5nbGV9IHQgVHJpYW5nbGUgb2JqZWN0LlxuICogQHRocm93cyB7RXJyb3J9IGlmIGNhbid0IGZpbmQgb2JqZWN0c1xuICovXG5UcmlhbmdsZS5wcm90b3R5cGUubWFya05laWdoYm9yUG9pbnRlcnMgPSBmdW5jdGlvbihwMSwgcDIsIHQpIHtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHNfO1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgaWYgKChwMSA9PT0gcG9pbnRzWzJdICYmIHAyID09PSBwb2ludHNbMV0pIHx8IChwMSA9PT0gcG9pbnRzWzFdICYmIHAyID09PSBwb2ludHNbMl0pKSB7XG4gICAgICAgIHRoaXMubmVpZ2hib3JzX1swXSA9IHQ7XG4gICAgfSBlbHNlIGlmICgocDEgPT09IHBvaW50c1swXSAmJiBwMiA9PT0gcG9pbnRzWzJdKSB8fCAocDEgPT09IHBvaW50c1syXSAmJiBwMiA9PT0gcG9pbnRzWzBdKSkge1xuICAgICAgICB0aGlzLm5laWdoYm9yc19bMV0gPSB0O1xuICAgIH0gZWxzZSBpZiAoKHAxID09PSBwb2ludHNbMF0gJiYgcDIgPT09IHBvaW50c1sxXSkgfHwgKHAxID09PSBwb2ludHNbMV0gJiYgcDIgPT09IHBvaW50c1swXSkpIHtcbiAgICAgICAgdGhpcy5uZWlnaGJvcnNfWzJdID0gdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHkydHJpIEludmFsaWQgVHJpYW5nbGUubWFya05laWdoYm9yUG9pbnRlcnMoKSBjYWxsJyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFeGhhdXN0aXZlIHNlYXJjaCB0byB1cGRhdGUgbmVpZ2hib3IgcG9pbnRlcnNcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyFUcmlhbmdsZX0gdFxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUubWFya05laWdoYm9yID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50c187XG4gICAgaWYgKHQuY29udGFpbnNQb2ludHMocG9pbnRzWzFdLCBwb2ludHNbMl0pKSB7XG4gICAgICAgIHRoaXMubmVpZ2hib3JzX1swXSA9IHQ7XG4gICAgICAgIHQubWFya05laWdoYm9yUG9pbnRlcnMocG9pbnRzWzFdLCBwb2ludHNbMl0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAodC5jb250YWluc1BvaW50cyhwb2ludHNbMF0sIHBvaW50c1syXSkpIHtcbiAgICAgICAgdGhpcy5uZWlnaGJvcnNfWzFdID0gdDtcbiAgICAgICAgdC5tYXJrTmVpZ2hib3JQb2ludGVycyhwb2ludHNbMF0sIHBvaW50c1syXSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmICh0LmNvbnRhaW5zUG9pbnRzKHBvaW50c1swXSwgcG9pbnRzWzFdKSkge1xuICAgICAgICB0aGlzLm5laWdoYm9yc19bMl0gPSB0O1xuICAgICAgICB0Lm1hcmtOZWlnaGJvclBvaW50ZXJzKHBvaW50c1swXSwgcG9pbnRzWzFdLCB0aGlzKTtcbiAgICB9XG59O1xuXG5cblRyaWFuZ2xlLnByb3RvdHlwZS5jbGVhck5laWdoYm9ycyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubmVpZ2hib3JzX1swXSA9IG51bGw7XG4gICAgdGhpcy5uZWlnaGJvcnNfWzFdID0gbnVsbDtcbiAgICB0aGlzLm5laWdoYm9yc19bMl0gPSBudWxsO1xufTtcblxuVHJpYW5nbGUucHJvdG90eXBlLmNsZWFyRGVsYXVuYXlFZGdlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGVsYXVuYXlfZWRnZVswXSA9IGZhbHNlO1xuICAgIHRoaXMuZGVsYXVuYXlfZWRnZVsxXSA9IGZhbHNlO1xuICAgIHRoaXMuZGVsYXVuYXlfZWRnZVsyXSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwb2ludCBjbG9ja3dpc2UgdG8gdGhlIGdpdmVuIHBvaW50LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WFl9IHAgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUucG9pbnRDVyA9IGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHNfO1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgaWYgKHAgPT09IHBvaW50c1swXSkge1xuICAgICAgICByZXR1cm4gcG9pbnRzWzJdO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gcG9pbnRzWzFdKSB7XG4gICAgICAgIHJldHVybiBwb2ludHNbMF07XG4gICAgfSBlbHNlIGlmIChwID09PSBwb2ludHNbMl0pIHtcbiAgICAgICAgcmV0dXJuIHBvaW50c1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBvaW50IGNvdW50ZXItY2xvY2t3aXNlIHRvIHRoZSBnaXZlbiBwb2ludC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1hZfSBwIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLnBvaW50Q0NXID0gZnVuY3Rpb24ocCkge1xuICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50c187XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICBpZiAocCA9PT0gcG9pbnRzWzBdKSB7XG4gICAgICAgIHJldHVybiBwb2ludHNbMV07XG4gICAgfSBlbHNlIGlmIChwID09PSBwb2ludHNbMV0pIHtcbiAgICAgICAgcmV0dXJuIHBvaW50c1syXTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IHBvaW50c1syXSkge1xuICAgICAgICByZXR1cm4gcG9pbnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmVpZ2hib3IgY2xvY2t3aXNlIHRvIGdpdmVuIHBvaW50LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WFl9IHAgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUubmVpZ2hib3JDVyA9IGZ1bmN0aW9uKHApIHtcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgIGlmIChwID09PSB0aGlzLnBvaW50c19bMF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVpZ2hib3JzX1sxXTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IHRoaXMucG9pbnRzX1sxXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWlnaGJvcnNfWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5laWdoYm9yc19bMF07XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZWlnaGJvciBjb3VudGVyLWNsb2Nrd2lzZSB0byBnaXZlbiBwb2ludC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1hZfSBwIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLm5laWdoYm9yQ0NXID0gZnVuY3Rpb24ocCkge1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgaWYgKHAgPT09IHRoaXMucG9pbnRzX1swXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWlnaGJvcnNfWzJdO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzFdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5laWdoYm9yc19bMF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVpZ2hib3JzX1sxXTtcbiAgICB9XG59O1xuXG5UcmlhbmdsZS5wcm90b3R5cGUuZ2V0Q29uc3RyYWluZWRFZGdlQ1cgPSBmdW5jdGlvbihwKSB7XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzBdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMV07XG4gICAgfSBlbHNlIGlmIChwID09PSB0aGlzLnBvaW50c19bMV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWluZWRfZWRnZVsyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJhaW5lZF9lZGdlWzBdO1xuICAgIH1cbn07XG5cblRyaWFuZ2xlLnByb3RvdHlwZS5nZXRDb25zdHJhaW5lZEVkZ2VDQ1cgPSBmdW5jdGlvbihwKSB7XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzBdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMl07XG4gICAgfSBlbHNlIGlmIChwID09PSB0aGlzLnBvaW50c19bMV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWluZWRfZWRnZVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJhaW5lZF9lZGdlWzFdO1xuICAgIH1cbn07XG5cbi8vIEFkZGl0aW9uYWwgY2hlY2sgZnJvbSBKYXZhIHZlcnNpb24gKHNlZSBpc3N1ZSAjODgpXG5UcmlhbmdsZS5wcm90b3R5cGUuZ2V0Q29uc3RyYWluZWRFZGdlQWNyb3NzID0gZnVuY3Rpb24ocCkge1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgaWYgKHAgPT09IHRoaXMucG9pbnRzX1swXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJhaW5lZF9lZGdlWzBdO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzFdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWluZWRfZWRnZVsyXTtcbiAgICB9XG59O1xuXG5UcmlhbmdsZS5wcm90b3R5cGUuc2V0Q29uc3RyYWluZWRFZGdlQ1cgPSBmdW5jdGlvbihwLCBjZSkge1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgaWYgKHAgPT09IHRoaXMucG9pbnRzX1swXSkge1xuICAgICAgICB0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMV0gPSBjZTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IHRoaXMucG9pbnRzX1sxXSkge1xuICAgICAgICB0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMl0gPSBjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnN0cmFpbmVkX2VkZ2VbMF0gPSBjZTtcbiAgICB9XG59O1xuXG5UcmlhbmdsZS5wcm90b3R5cGUuc2V0Q29uc3RyYWluZWRFZGdlQ0NXID0gZnVuY3Rpb24ocCwgY2UpIHtcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgIGlmIChwID09PSB0aGlzLnBvaW50c19bMF0pIHtcbiAgICAgICAgdGhpcy5jb25zdHJhaW5lZF9lZGdlWzJdID0gY2U7XG4gICAgfSBlbHNlIGlmIChwID09PSB0aGlzLnBvaW50c19bMV0pIHtcbiAgICAgICAgdGhpcy5jb25zdHJhaW5lZF9lZGdlWzBdID0gY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb25zdHJhaW5lZF9lZGdlWzFdID0gY2U7XG4gICAgfVxufTtcblxuVHJpYW5nbGUucHJvdG90eXBlLmdldERlbGF1bmF5RWRnZUNXID0gZnVuY3Rpb24ocCkge1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgaWYgKHAgPT09IHRoaXMucG9pbnRzX1swXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxhdW5heV9lZGdlWzFdO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzFdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGF1bmF5X2VkZ2VbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsYXVuYXlfZWRnZVswXTtcbiAgICB9XG59O1xuXG5UcmlhbmdsZS5wcm90b3R5cGUuZ2V0RGVsYXVuYXlFZGdlQ0NXID0gZnVuY3Rpb24ocCkge1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgaWYgKHAgPT09IHRoaXMucG9pbnRzX1swXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxhdW5heV9lZGdlWzJdO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzFdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGF1bmF5X2VkZ2VbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsYXVuYXlfZWRnZVsxXTtcbiAgICB9XG59O1xuXG5UcmlhbmdsZS5wcm90b3R5cGUuc2V0RGVsYXVuYXlFZGdlQ1cgPSBmdW5jdGlvbihwLCBlKSB7XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzBdKSB7XG4gICAgICAgIHRoaXMuZGVsYXVuYXlfZWRnZVsxXSA9IGU7XG4gICAgfSBlbHNlIGlmIChwID09PSB0aGlzLnBvaW50c19bMV0pIHtcbiAgICAgICAgdGhpcy5kZWxhdW5heV9lZGdlWzJdID0gZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlbGF1bmF5X2VkZ2VbMF0gPSBlO1xuICAgIH1cbn07XG5cblRyaWFuZ2xlLnByb3RvdHlwZS5zZXREZWxhdW5heUVkZ2VDQ1cgPSBmdW5jdGlvbihwLCBlKSB7XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzBdKSB7XG4gICAgICAgIHRoaXMuZGVsYXVuYXlfZWRnZVsyXSA9IGU7XG4gICAgfSBlbHNlIGlmIChwID09PSB0aGlzLnBvaW50c19bMV0pIHtcbiAgICAgICAgdGhpcy5kZWxhdW5heV9lZGdlWzBdID0gZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlbGF1bmF5X2VkZ2VbMV0gPSBlO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhlIG5laWdoYm9yIGFjcm9zcyB0byBnaXZlbiBwb2ludC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1hZfSBwIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEByZXR1cm5zIHtUcmlhbmdsZX1cbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLm5laWdoYm9yQWNyb3NzID0gZnVuY3Rpb24ocCkge1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgaWYgKHAgPT09IHRoaXMucG9pbnRzX1swXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWlnaGJvcnNfWzBdO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gdGhpcy5wb2ludHNfWzFdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5laWdoYm9yc19bMV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVpZ2hib3JzX1syXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyFUcmlhbmdsZX0gdCBUcmlhbmdsZSBvYmplY3QuXG4gKiBAcGFyYW0ge1hZfSBwIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLm9wcG9zaXRlUG9pbnQgPSBmdW5jdGlvbih0LCBwKSB7XG4gICAgdmFyIGN3ID0gdC5wb2ludENXKHApO1xuICAgIHJldHVybiB0aGlzLnBvaW50Q1coY3cpO1xufTtcblxuLyoqXG4gKiBMZWdhbGl6ZSB0cmlhbmdsZSBieSByb3RhdGluZyBjbG9ja3dpc2UgYXJvdW5kIG9Qb2ludFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WFl9IG9wb2ludCAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0ge1hZfSBucG9pbnQgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHRocm93cyB7RXJyb3J9IGlmIG9Qb2ludCBjYW4gbm90IGJlIGZvdW5kXG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5sZWdhbGl6ZSA9IGZ1bmN0aW9uKG9wb2ludCwgbnBvaW50KSB7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzXztcbiAgICAvLyBIZXJlIHdlIGFyZSBjb21wYXJpbmcgcG9pbnQgcmVmZXJlbmNlcywgbm90IHZhbHVlc1xuICAgIGlmIChvcG9pbnQgPT09IHBvaW50c1swXSkge1xuICAgICAgICBwb2ludHNbMV0gPSBwb2ludHNbMF07XG4gICAgICAgIHBvaW50c1swXSA9IHBvaW50c1syXTtcbiAgICAgICAgcG9pbnRzWzJdID0gbnBvaW50O1xuICAgIH0gZWxzZSBpZiAob3BvaW50ID09PSBwb2ludHNbMV0pIHtcbiAgICAgICAgcG9pbnRzWzJdID0gcG9pbnRzWzFdO1xuICAgICAgICBwb2ludHNbMV0gPSBwb2ludHNbMF07XG4gICAgICAgIHBvaW50c1swXSA9IG5wb2ludDtcbiAgICB9IGVsc2UgaWYgKG9wb2ludCA9PT0gcG9pbnRzWzJdKSB7XG4gICAgICAgIHBvaW50c1swXSA9IHBvaW50c1syXTtcbiAgICAgICAgcG9pbnRzWzJdID0gcG9pbnRzWzFdO1xuICAgICAgICBwb2ludHNbMV0gPSBucG9pbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5MnRyaSBJbnZhbGlkIFRyaWFuZ2xlLmxlZ2FsaXplKCkgY2FsbCcpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW5kZXggb2YgYSBwb2ludCBpbiB0aGUgdHJpYW5nbGUuIFxuICogVGhlIHBvaW50ICptdXN0KiBiZSBhIHJlZmVyZW5jZSB0byBvbmUgb2YgdGhlIHRyaWFuZ2xlJ3MgdmVydGljZXMuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtYWX0gcCAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBpbmRleCAwLCAxIG9yIDJcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBwIGNhbiBub3QgYmUgZm91bmRcbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24ocCkge1xuICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50c187XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXNcbiAgICBpZiAocCA9PT0gcG9pbnRzWzBdKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gcG9pbnRzWzFdKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gcG9pbnRzWzJdKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncG9seTJ0cmkgSW52YWxpZCBUcmlhbmdsZS5pbmRleCgpIGNhbGwnKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1hZfSBwMSAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcGFyYW0ge1hZfSBwMiAtIHBvaW50IG9iamVjdCB3aXRoIHt4LHl9XG4gKiBAcmV0dXJuIHtudW1iZXJ9IGluZGV4IDAsIDEgb3IgMiwgb3IgLTEgaWYgZXJycm9yXG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5lZGdlSW5kZXggPSBmdW5jdGlvbihwMSwgcDIpIHtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHNfO1xuICAgIC8vIEhlcmUgd2UgYXJlIGNvbXBhcmluZyBwb2ludCByZWZlcmVuY2VzLCBub3QgdmFsdWVzXG4gICAgaWYgKHAxID09PSBwb2ludHNbMF0pIHtcbiAgICAgICAgaWYgKHAyID09PSBwb2ludHNbMV0pIHtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9IGVsc2UgaWYgKHAyID09PSBwb2ludHNbMl0pIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChwMSA9PT0gcG9pbnRzWzFdKSB7XG4gICAgICAgIGlmIChwMiA9PT0gcG9pbnRzWzJdKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIGlmIChwMiA9PT0gcG9pbnRzWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocDEgPT09IHBvaW50c1syXSkge1xuICAgICAgICBpZiAocDIgPT09IHBvaW50c1swXSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAocDIgPT09IHBvaW50c1sxXSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBNYXJrIGFuIGVkZ2Ugb2YgdGhpcyB0cmlhbmdsZSBhcyBjb25zdHJhaW5lZC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBlZGdlIGluZGV4XG4gKi9cblRyaWFuZ2xlLnByb3RvdHlwZS5tYXJrQ29uc3RyYWluZWRFZGdlQnlJbmRleCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgdGhpcy5jb25zdHJhaW5lZF9lZGdlW2luZGV4XSA9IHRydWU7XG59O1xuLyoqXG4gKiBNYXJrIGFuIGVkZ2Ugb2YgdGhpcyB0cmlhbmdsZSBhcyBjb25zdHJhaW5lZC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0VkZ2V9IGVkZ2UgaW5zdGFuY2VcbiAqL1xuVHJpYW5nbGUucHJvdG90eXBlLm1hcmtDb25zdHJhaW5lZEVkZ2VCeUVkZ2UgPSBmdW5jdGlvbihlZGdlKSB7XG4gICAgdGhpcy5tYXJrQ29uc3RyYWluZWRFZGdlQnlQb2ludHMoZWRnZS5wLCBlZGdlLnEpO1xufTtcbi8qKlxuICogTWFyayBhbiBlZGdlIG9mIHRoaXMgdHJpYW5nbGUgYXMgY29uc3RyYWluZWQuXG4gKiBUaGlzIG1ldGhvZCB0YWtlcyB0d28gUG9pbnQgaW5zdGFuY2VzIGRlZmluaW5nIHRoZSBlZGdlIG9mIHRoZSB0cmlhbmdsZS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1hZfSBwIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7WFl9IHEgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICovXG5UcmlhbmdsZS5wcm90b3R5cGUubWFya0NvbnN0cmFpbmVkRWRnZUJ5UG9pbnRzID0gZnVuY3Rpb24ocCwgcSkge1xuICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50c187XG4gICAgLy8gSGVyZSB3ZSBhcmUgY29tcGFyaW5nIHBvaW50IHJlZmVyZW5jZXMsIG5vdCB2YWx1ZXMgICAgICAgIFxuICAgIGlmICgocSA9PT0gcG9pbnRzWzBdICYmIHAgPT09IHBvaW50c1sxXSkgfHwgKHEgPT09IHBvaW50c1sxXSAmJiBwID09PSBwb2ludHNbMF0pKSB7XG4gICAgICAgIHRoaXMuY29uc3RyYWluZWRfZWRnZVsyXSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICgocSA9PT0gcG9pbnRzWzBdICYmIHAgPT09IHBvaW50c1syXSkgfHwgKHEgPT09IHBvaW50c1syXSAmJiBwID09PSBwb2ludHNbMF0pKSB7XG4gICAgICAgIHRoaXMuY29uc3RyYWluZWRfZWRnZVsxXSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICgocSA9PT0gcG9pbnRzWzFdICYmIHAgPT09IHBvaW50c1syXSkgfHwgKHEgPT09IHBvaW50c1syXSAmJiBwID09PSBwb2ludHNbMV0pKSB7XG4gICAgICAgIHRoaXMuY29uc3RyYWluZWRfZWRnZVswXSA9IHRydWU7XG4gICAgfVxufTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1FeHBvcnRzIChwdWJsaWMgQVBJKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyaWFuZ2xlO1xuXG59LHtcIi4veHlcIjoxMX1dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBQb2x5MlRyaSBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXG4gKiBcbiAqIHBvbHkydHJpLmpzIChKYXZhU2NyaXB0IHBvcnQpIChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cHM6Ly9naXRodWIuY29tL3IzbWkvcG9seTJ0cmkuanNcbiAqIFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIDMtY2xhdXNlIEJTRCBMaWNlbnNlLCBzZWUgTElDRU5TRS50eHRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBQcmVjaXNpb24gdG8gZGV0ZWN0IHJlcGVhdGVkIG9yIGNvbGxpbmVhciBwb2ludHNcbiAqIEBwcml2YXRlXG4gKiBAY29uc3Qge251bWJlcn1cbiAqIEBkZWZhdWx0XG4gKi9cbnZhciBFUFNJTE9OID0gMWUtMTI7XG5leHBvcnRzLkVQU0lMT04gPSBFUFNJTE9OO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZW51bSB7bnVtYmVyfVxuICogQHJlYWRvbmx5XG4gKi9cbnZhciBPcmllbnRhdGlvbiA9IHtcbiAgICBcIkNXXCI6IDEsXG4gICAgXCJDQ1dcIjogLTEsXG4gICAgXCJDT0xMSU5FQVJcIjogMFxufTtcbmV4cG9ydHMuT3JpZW50YXRpb24gPSBPcmllbnRhdGlvbjtcblxuXG4vKipcbiAqIEZvcm11bGEgdG8gY2FsY3VsYXRlIHNpZ25lZCBhcmVhPGJyPlxuICogUG9zaXRpdmUgaWYgQ0NXPGJyPlxuICogTmVnYXRpdmUgaWYgQ1c8YnI+XG4gKiAwIGlmIGNvbGxpbmVhcjxicj5cbiAqIDxwcmU+XG4gKiBBW1AxLFAyLFAzXSAgPSAgKHgxKnkyIC0geTEqeDIpICsgKHgyKnkzIC0geTIqeDMpICsgKHgzKnkxIC0geTMqeDEpXG4gKiAgICAgICAgICAgICAgPSAgKHgxLXgzKSooeTIteTMpIC0gKHkxLXkzKSooeDIteDMpXG4gKiA8L3ByZT5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHshWFl9IHBhICBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHshWFl9IHBiICBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHshWFl9IHBjICBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHJldHVybiB7T3JpZW50YXRpb259XG4gKi9cbmZ1bmN0aW9uIG9yaWVudDJkKHBhLCBwYiwgcGMpIHtcbiAgICB2YXIgZGV0bGVmdCA9IChwYS54IC0gcGMueCkgKiAocGIueSAtIHBjLnkpO1xuICAgIHZhciBkZXRyaWdodCA9IChwYS55IC0gcGMueSkgKiAocGIueCAtIHBjLngpO1xuICAgIHZhciB2YWwgPSBkZXRsZWZ0IC0gZGV0cmlnaHQ7XG4gICAgaWYgKHZhbCA+IC0oRVBTSUxPTikgJiYgdmFsIDwgKEVQU0lMT04pKSB7XG4gICAgICAgIHJldHVybiBPcmllbnRhdGlvbi5DT0xMSU5FQVI7XG4gICAgfSBlbHNlIGlmICh2YWwgPiAwKSB7XG4gICAgICAgIHJldHVybiBPcmllbnRhdGlvbi5DQ1c7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9yaWVudGF0aW9uLkNXO1xuICAgIH1cbn1cbmV4cG9ydHMub3JpZW50MmQgPSBvcmllbnQyZDtcblxuXG4vKipcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHshWFl9IHBhICBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHshWFl9IHBiICBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHshWFl9IHBjICBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHshWFl9IHBkICBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaW5TY2FuQXJlYShwYSwgcGIsIHBjLCBwZCkge1xuICAgIHZhciBvYWRiID0gKHBhLnggLSBwYi54KSAqIChwZC55IC0gcGIueSkgLSAocGQueCAtIHBiLngpICogKHBhLnkgLSBwYi55KTtcbiAgICBpZiAob2FkYiA+PSAtRVBTSUxPTikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG9hZGMgPSAocGEueCAtIHBjLngpICogKHBkLnkgLSBwYy55KSAtIChwZC54IC0gcGMueCkgKiAocGEueSAtIHBjLnkpO1xuICAgIGlmIChvYWRjIDw9IEVQU0lMT04pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuaW5TY2FuQXJlYSA9IGluU2NhbkFyZWE7XG5cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYW5nbGUgYmV0d2VlbiAocGEscGIpIGFuZCAocGEscGMpIGlzIG9idHVzZSBpLmUuIChhbmdsZSA+IM+ALzIgfHwgYW5nbGUgPCAtz4AvMilcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHshWFl9IHBhICBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHshWFl9IHBiICBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHBhcmFtIHshWFl9IHBjICBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBhbmdsZSBpcyBvYnR1c2VcbiAqL1xuZnVuY3Rpb24gaXNBbmdsZU9idHVzZShwYSwgcGIsIHBjKSB7XG4gICAgdmFyIGF4ID0gcGIueCAtIHBhLng7XG4gICAgdmFyIGF5ID0gcGIueSAtIHBhLnk7XG4gICAgdmFyIGJ4ID0gcGMueCAtIHBhLng7XG4gICAgdmFyIGJ5ID0gcGMueSAtIHBhLnk7XG4gICAgcmV0dXJuIChheCAqIGJ4ICsgYXkgKiBieSkgPCAwO1xufVxuZXhwb3J0cy5pc0FuZ2xlT2J0dXNlID0gaXNBbmdsZU9idHVzZTtcblxuXG59LHt9XSwxMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogUG9seTJUcmkgQ29weXJpZ2h0IChjKSAyMDA5LTIwMTQsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xuICogXG4gKiBwb2x5MnRyaS5qcyAoSmF2YVNjcmlwdCBwb3J0KSAoYykgMjAwOS0yMDE0LCBQb2x5MlRyaSBDb250cmlidXRvcnNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yM21pL3BvbHkydHJpLmpzXG4gKiBcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSAzLWNsYXVzZSBCU0QgTGljZW5zZSwgc2VlIExJQ0VOU0UudHh0XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgb3BlcmF0ZSBvbiBcIlBvaW50XCIgb3IgYW55IFwiUG9pbnQgbGlrZVwiIG9iamVjdCB3aXRoIHt4LHl9LFxuICogYXMgZGVmaW5lZCBieSB0aGUge0BsaW5rIFhZfSB0eXBlXG4gKiAoW2R1Y2sgdHlwaW5nXXtAbGluayBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0R1Y2tfdHlwaW5nfSkuXG4gKiBAbW9kdWxlXG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qKlxuICogcG9seTJ0cmkuanMgc3VwcG9ydHMgdXNpbmcgY3VzdG9tIHBvaW50IGNsYXNzIGluc3RlYWQgb2Yge0BsaW5rY29kZSBQb2ludH0uXG4gKiBBbnkgXCJQb2ludCBsaWtlXCIgb2JqZWN0IHdpdGggPGNvZGU+e3gsIHl9PC9jb2RlPiBhdHRyaWJ1dGVzIGlzIHN1cHBvcnRlZFxuICogdG8gaW5pdGlhbGl6ZSB0aGUgU3dlZXBDb250ZXh0IHBvbHlsaW5lcyBhbmQgcG9pbnRzXG4gKiAoW2R1Y2sgdHlwaW5nXXtAbGluayBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0R1Y2tfdHlwaW5nfSkuXG4gKlxuICogcG9seTJ0cmkuanMgbWlnaHQgYWRkIGV4dHJhIGZpZWxkcyB0byB0aGUgcG9pbnQgb2JqZWN0cyB3aGVuIGNvbXB1dGluZyB0aGVcbiAqIHRyaWFuZ3VsYXRpb24gOiB0aGV5IGFyZSBwcmVmaXhlZCB3aXRoIDxjb2RlPl9wMnRfPC9jb2RlPiB0byBhdm9pZCBjb2xsaXNpb25zXG4gKiB3aXRoIGZpZWxkcyBpbiB0aGUgY3VzdG9tIGNsYXNzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgIHZhciBjb250b3VyID0gW3t4OjEwMCwgeToxMDB9LCB7eDoxMDAsIHk6MzAwfSwge3g6MzAwLCB5OjMwMH0sIHt4OjMwMCwgeToxMDB9XTtcbiAqICAgICAgdmFyIHN3Y3R4ID0gbmV3IHBvbHkydHJpLlN3ZWVwQ29udGV4dChjb250b3VyKTtcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBYWVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggLSB4IGNvb3JkaW5hdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IC0geSBjb29yZGluYXRlXG4gKi9cblxuXG4vKipcbiAqIFBvaW50IHByZXR0eSBwcmludGluZyA6IHByaW50cyB4IGFuZCB5IGNvb3JkaW5hdGVzLlxuICogQGV4YW1wbGVcbiAqICAgICAgeHkudG9TdHJpbmdCYXNlKHt4OjUsIHk6NDJ9KVxuICogICAgICAvLyDihpIgXCIoNTs0MilcIlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHshWFl9IHAgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHJldHVybnMge3N0cmluZ30gPGNvZGU+XCIoeDt5KVwiPC9jb2RlPlxuICovXG5mdW5jdGlvbiB0b1N0cmluZ0Jhc2UocCkge1xuICAgIHJldHVybiAoXCIoXCIgKyBwLnggKyBcIjtcIiArIHAueSArIFwiKVwiKTtcbn1cblxuLyoqXG4gKiBQb2ludCBwcmV0dHkgcHJpbnRpbmcuIERlbGVnYXRlcyB0byB0aGUgcG9pbnQncyBjdXN0b20gXCJ0b1N0cmluZygpXCIgbWV0aG9kIGlmIGV4aXN0cyxcbiAqIGVsc2Ugc2ltcGx5IHByaW50cyB4IGFuZCB5IGNvb3JkaW5hdGVzLlxuICogQGV4YW1wbGVcbiAqICAgICAgeHkudG9TdHJpbmcoe3g6NSwgeTo0Mn0pXG4gKiAgICAgIC8vIOKGkiBcIig1OzQyKVwiXG4gKiBAZXhhbXBsZVxuICogICAgICB4eS50b1N0cmluZyh7eDo1LHk6NDIsdG9TdHJpbmc6ZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMueCtcIjpcIit0aGlzLnk7fX0pXG4gKiAgICAgIC8vIOKGkiBcIjU6NDJcIlxuICogQHBhcmFtIHshWFl9IHAgLSBwb2ludCBvYmplY3Qgd2l0aCB7eCx5fVxuICogQHJldHVybnMge3N0cmluZ30gPGNvZGU+XCIoeDt5KVwiPC9jb2RlPlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyhwKSB7XG4gICAgLy8gVHJ5IGEgY3VzdG9tIHRvU3RyaW5nIGZpcnN0LCBhbmQgZmFsbGJhY2sgdG8gb3duIGltcGxlbWVudGF0aW9uIGlmIG5vbmVcbiAgICB2YXIgcyA9IHAudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gKHMgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gdG9TdHJpbmdCYXNlKHApIDogcyk7XG59XG5cblxuLyoqXG4gKiBDb21wYXJlIHR3byBwb2ludHMgY29tcG9uZW50LXdpc2UuIE9yZGVyZWQgYnkgeSBheGlzIGZpcnN0LCB0aGVuIHggYXhpcy5cbiAqIEBwYXJhbSB7IVhZfSBhIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7IVhZfSBiIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEByZXR1cm4ge251bWJlcn0gPGNvZGU+Jmx0OyAwPC9jb2RlPiBpZiA8Y29kZT5hICZsdDsgYjwvY29kZT4sXG4gKiAgICAgICAgIDxjb2RlPiZndDsgMDwvY29kZT4gaWYgPGNvZGU+YSAmZ3Q7IGI8L2NvZGU+LCBcbiAqICAgICAgICAgPGNvZGU+MDwvY29kZT4gb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICBpZiAoYS55ID09PSBiLnkpIHtcbiAgICAgICAgcmV0dXJuIGEueCAtIGIueDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYS55IC0gYi55O1xuICAgIH1cbn1cblxuLyoqXG4gKiBUZXN0IHR3byBQb2ludCBvYmplY3RzIGZvciBlcXVhbGl0eS5cbiAqIEBwYXJhbSB7IVhZfSBhIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEBwYXJhbSB7IVhZfSBiIC0gcG9pbnQgb2JqZWN0IHdpdGgge3gseX1cbiAqIEByZXR1cm4ge2Jvb2xlYW59IDxjb2RlPlRydWU8L2NvZGU+IGlmIDxjb2RlPmEgPT0gYjwvY29kZT4sIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHRvU3RyaW5nOiB0b1N0cmluZyxcbiAgICB0b1N0cmluZ0Jhc2U6IHRvU3RyaW5nQmFzZSxcbiAgICBjb21wYXJlOiBjb21wYXJlLFxuICAgIGVxdWFsczogZXF1YWxzXG59O1xuXG59LHt9XX0se30sWzZdKVxuKDYpXG59KTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0TU9WRV9UTzogMSxcblx0TElORV9UTzogMixcblx0QkVaSUVSX1RPOiAzLFxuXHRRVUFEUkFfVE86IDQsXG5cdENJUkNMRTogNSxcblx0RUxMSVBTRTogNlxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdGRlZmluaXRpb246IDEsXG5cdHdvcmxkV2lkdGg6IDIwLFxuXHRtdWx0aUNhbnZhczogdHJ1ZSxcblx0d2luZDogMyxcblx0ZGVidWc6IGZhbHNlLFxuXHRncmF2aXR5OiBbMCwgLTkuOF0sXG5cdGdyb3Vwczpcblx0e1xuXHRcdGRlZmF1bHQ6IHsgZml4ZWQ6IHRydWUsIHBoeXNpY3M6IHsgYm9keVR5cGU6ICdnaG9zdCcgfSB9LFxuXHRcdGdob3N0OiB7IGZpeGVkOiB0cnVlLCBwaHlzaWNzOiB7IGJvZHlUeXBlOiAnZ2hvc3QnIH0gfSxcblx0XHRtZXRhbDpcblx0XHR7XG5cdFx0XHRwaHlzaWNzOlxuXHRcdFx0e1xuXHRcdFx0XHRtYXNzOiAxMDAsXG5cdFx0XHRcdGJvZHlUeXBlOiAnaGFyZCdcblx0XHRcdH1cblx0XHR9LFxuXHRcdHN0b25lOlxuXHRcdHtcblx0XHRcdHBoeXNpY3M6XG5cdFx0XHR7XG5cdFx0XHRcdG1hc3M6IDEwLFxuXHRcdFx0XHRib2R5VHlwZTogJ2hhcmQnXG5cdFx0XHR9XG5cdFx0fSxcblx0XHR3b29kOlxuXHRcdHtcblx0XHRcdHBoeXNpY3M6XG5cdFx0XHR7XG5cdFx0XHRcdG1hc3M6IDEsXG5cdFx0XHRcdGJvZHlUeXBlOiAnaGFyZCdcblx0XHRcdH1cblx0XHR9LFxuXHRcdGJhbGxvb246XG5cdFx0e1xuXHRcdFx0cGh5c2ljczpcblx0XHRcdHtcblx0XHRcdFx0bWFzczogMSxcblx0XHRcdFx0Z3Jhdml0eVNjYWxlOiAtMTUsXG5cdFx0XHRcdGJvZHlUeXBlOiAnaGFyZCdcblx0XHRcdH1cblx0XHR9LFxuXHRcdHRyZWU6XG5cdFx0e1xuXHRcdFx0c3RydWN0dXJlOiAndHJpYW5ndWxhdGUnLFxuXHRcdFx0bm9kZVJhZGl1czogMC4wMTMsXG5cdFx0XHRwaHlzaWNzOlxuXHRcdFx0e1xuXHRcdFx0XHRqb2ludHM6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGRpc3RhbmNlQ29uc3RyYWludDogbnVsbCxcblx0XHRcdFx0XHRcdGxvY2tDb25zdHJhaW50OlxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRzdGlmZm5lc3M6IDEwMDAwLFxuXHRcdFx0XHRcdFx0XHRyZWxheGF0aW9uOiAwLjlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG1hc3M6IDEsXG5cdFx0XHRcdGRhbXBpbmc6IDAuOCxcblx0XHRcdFx0c3RydWN0dXJhbE1hc3NEZWNheTogMyxcblx0XHRcdFx0Ym9keVR5cGU6ICdzb2Z0J1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZmxvcmE6XG5cdFx0e1xuXHRcdFx0c3RydWN0dXJlOiAnbGluZScsXG5cdFx0XHRub2RlUmFkaXVzOiAwLjAxMyxcblx0XHRcdHBoeXNpY3M6XG5cdFx0XHR7XG5cdFx0XHRcdGpvaW50czpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZGlzdGFuY2VDb25zdHJhaW50OiBudWxsLFxuXHRcdFx0XHRcdFx0bG9ja0NvbnN0cmFpbnQ6XG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHN0aWZmbmVzczogMTAwMCxcblx0XHRcdFx0XHRcdFx0cmVsYXhhdGlvbjogMVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0bWFzczogMSxcblx0XHRcdFx0c3RydWN0dXJhbE1hc3NEZWNheTogMyxcblx0XHRcdFx0Ym9keVR5cGU6ICdzb2Z0J1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cnViYmVyOlxuXHRcdHtcblx0XHRcdHN0cnVjdHVyZTogJ3RyaWFuZ3VsYXRlJyxcblx0XHRcdG5vZGVSYWRpdXM6IDAuMDEzLFxuXHRcdFx0cGh5c2ljczpcblx0XHRcdHtcblx0XHRcdFx0am9pbnRzOiB7XG5cdFx0XHRcdFx0ZGVmYXVsdDoge1xuXHRcdFx0XHRcdFx0ZGlzdGFuY2VDb25zdHJhaW50OlxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRzdGlmZm5lc3M6IDEwMDAwMCxcblx0XHRcdFx0XHRcdFx0cmVsYXhhdGlvbjogMVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0bWFzczogMC4xLFxuXHRcdFx0XHRib2R5VHlwZTogJ3NvZnQnXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRqZWxseTpcblx0XHR7XG5cdFx0XHRzdHJ1Y3R1cmU6ICdoZXhhRmlsbCcsXG5cdFx0XHRpbm5lclN0cnVjdHVyZURlZjogMC4wMSxcblx0XHRcdG5vZGVSYWRpdXM6IDAuMDEzLFxuXHRcdFx0cGh5c2ljczpcblx0XHRcdHtcblx0XHRcdFx0am9pbnRzOlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRkaXN0YW5jZUNvbnN0cmFpbnQ6XG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHN0aWZmbmVzczogMTAwMDAsXG5cdFx0XHRcdFx0XHRcdHJlbGF4YXRpb246IDMwXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRtYXNzOiAwLjEzLFxuXHRcdFx0XHRib2R5VHlwZTogJ3NvZnQnXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzcG9uZ2U6XG5cdFx0e1xuXHRcdFx0c3RydWN0dXJlOiAncHJlY2lzZUhleGFGaWxsJyxcblx0XHRcdGlubmVyU3RydWN0dXJlRGVmOiAwLjAyLFxuXHRcdFx0bm9kZVJhZGl1czogMC4wMTMsXG5cdFx0XHRwaHlzaWNzOlxuXHRcdFx0e1xuXHRcdFx0XHRqb2ludHM6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHJldm9sdXRlQ29uc3RyYWludDpcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0c3RpZmZuZXNzOiAxMDAwLFxuXHRcdFx0XHRcdFx0XHRyZWxheGF0aW9uOiA1XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRtYXRlcmlhbDogJ3J1YmJlcicsXG5cdFx0XHRcdG1hc3M6IDAuMTMsXG5cdFx0XHRcdGJvZHlUeXBlOiAnc29mdCdcblx0XHRcdH1cblx0XHR9LFxuXHRcdGxpcXVpZDpcblx0XHR7XG5cdFx0XHRzdHJ1Y3R1cmU6ICdoZXhhRmlsbCcsXG5cdFx0XHRpbm5lclN0cnVjdHVyZURlZjogMC4wMixcblx0XHRcdG5vZGVSYWRpdXM6IDAuMDgsXG5cdFx0XHRkcmF3Tm9kZXNTZXBhcmF0ZWx5OiB0cnVlLFxuXHRcdFx0cGh5c2ljczpcblx0XHRcdHtcblx0XHRcdFx0am9pbnRzOlxuXHRcdFx0XHR7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG1hc3M6IDAuMDEzLFxuXHRcdFx0XHRtYXRlcmlhbDogJ2xpcXVpZCcsXG5cdFx0XHRcdGJvZHlUeXBlOiAnc29mdCdcblx0XHRcdH1cblx0XHR9LFxuXHRcdHJvcGU6XG5cdFx0e1xuXHRcdFx0c3RydWN0dXJlOiAnbGluZScsXG5cdFx0XHRub2RlUmFkaXVzOiAwLjAxMyxcblx0XHRcdHBoeXNpY3M6XG5cdFx0XHR7XG5cdFx0XHRcdGpvaW50czpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZGlzdGFuY2VDb25zdHJhaW50OlxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRzdGlmZm5lc3M6IDEwMDAsXG5cdFx0XHRcdFx0XHRcdHJlbGF4YXRpb246IDFcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG1hc3M6IDEsXG5cdFx0XHRcdGJvZHlUeXBlOiAnc29mdCdcblx0XHRcdH1cblx0XHR9LFxuXHRcdHN0YXRpYzpcblx0XHR7XG5cdFx0XHRmaXhlZDogdHJ1ZSxcblx0XHRcdHBoeXNpY3M6XG5cdFx0XHR7XG5cdFx0XHRcdG1hc3M6IDAsXG5cdFx0XHRcdGJvZHlUeXBlOiAnaGFyZCdcblx0XHRcdH1cblx0XHR9LFxuXHRcdG5vQ29sbGlkZTpcblx0XHR7XG5cdFx0XHRwaHlzaWNzOlxuXHRcdFx0e1xuXHRcdFx0XHRtYXNzOiAwLjEzLFxuXHRcdFx0XHRib2R5VHlwZTogJ2hhcmQnLFxuXHRcdFx0XHRub0NvbGxpZGU6IHRydWVcblx0XHRcdH1cblx0XHR9LFxuXHRcdGxlYXZlczpcblx0XHR7XG5cdFx0XHRwaHlzaWNzOlxuXHRcdFx0e1xuXHRcdFx0XHRtYXNzOiAwLjAwMDEzLFxuXHRcdFx0XHRncmF2aXR5U2NhbGU6IDAsXG5cdFx0XHRcdGJvZHlUeXBlOiAnaGFyZCcsXG5cdFx0XHRcdG5vQ29sbGlkZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0bWF0ZXJpYWxzOlxuXHR7XG5cdFx0ZGVmYXVsdDpcblx0XHR7XG5cdFx0XHRib3VuY2luZXNzOiAxLFxuXHRcdFx0ZnJpY3Rpb246IDAuNVxuXHRcdH0sXG5cdFx0cnViYmVyOlxuXHRcdHtcblx0XHRcdGJvdW5jaW5lc3M6IDEwLFxuXHRcdFx0ZnJpY3Rpb246IDEwMFxuXHRcdH0sXG5cdFx0bGlxdWlkOlxuXHRcdHtcblx0XHRcdGJvdW5jaW5lc3M6IDEwMDAsXG5cdFx0XHRmcmljdGlvbjogMFxuXHRcdH1cblx0fSxcblx0Y29uc3RyYWludHM6XG5cdHtcblx0XHRkZWZhdWx0OlxuXHRcdHtcblx0XHRcdGxvY2tDb25zdHJhaW50OlxuXHRcdFx0e1xuXHRcdFx0XHRzdGlmZm5lc3M6IDEwMDAwMDAwMDAwMDAwLFxuXHRcdFx0XHRyZWxheGF0aW9uOiAwLFxuXHRcdFx0XHRjb2xsaWRlQ29ubmVjdGVkOiBmYWxzZVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YXhpczpcblx0XHR7XG5cdFx0XHRyZXZvbHV0ZUNvbnN0cmFpbnQ6XG5cdFx0XHR7XG5cdFx0XHRcdHN0aWZmbmVzczogMTAwMDAsXG5cdFx0XHRcdHJlbGF4YXRpb246IDAuMSxcblx0XHRcdFx0bW90b3I6IGZhbHNlLFxuXHRcdFx0XHRjb2xsaWRlQ29ubmVjdGVkOiBmYWxzZVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hvY2tBYnNvcmJlcjpcblx0XHR7XG5cdFx0XHRwcmlzbWF0aWNDb25zdHJhaW50OlxuXHRcdFx0e1xuXHRcdFx0XHRzdGlmZm5lc3M6IDEwMDAwLFxuXHRcdFx0XHRyZWxheGF0aW9uOiAwLjEsXG5cdFx0XHRcdGNhblJvdGF0ZTogZmFsc2Vcblx0XHRcdH0sXG5cdFx0XHRsaW5lYXJTcHJpbmc6XG5cdFx0XHR7XG5cdFx0XHRcdHN0aWZmbmVzczogNDAwLFxuXHRcdFx0XHRkYW1waW5nOiAwLjRcblx0XHRcdH1cblx0XHR9LFxuXHRcdHdpcmU6XG5cdFx0e1xuXHRcdFx0ZGlzdGFuY2VDb25zdHJhaW50OlxuXHRcdFx0e1xuXHRcdFx0XHRzdGlmZm5lc3M6IDEwMDAsXG5cdFx0XHRcdHJlbGF4YXRpb246IDFcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNwcmluZzpcblx0XHR7XG5cdFx0XHRkaXN0YW5jZUNvbnN0cmFpbnQ6XG5cdFx0XHR7XG5cdFx0XHRcdHN0aWZmbmVzczogMTAwMDAwLFxuXHRcdFx0XHRyZWxheGF0aW9uOiAwXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjb250aW51b3VzTW90b3I6XG5cdFx0e1xuXHRcdFx0cmV2b2x1dGVDb25zdHJhaW50OlxuXHRcdFx0e1xuXHRcdFx0XHRtb3RvcjogdHJ1ZSxcblx0XHRcdFx0Y29udGludW91c01vdG9yOiB0cnVlLFxuXHRcdFx0XHRtb3RvclBvd2VyOiA0XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4iLCJ2YXIgRGVjb3JhdGlvbkRyYXdpbmcgPVxue1xuXHRzZXRTY2FsZTogZnVuY3Rpb24gKCRzY2FsZVgsICRzY2FsZVkpXG5cdHtcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5jb21tYW5kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgY29tbWFuZCA9IHRoaXMuY29tbWFuZHNbaV07XG5cdFx0XHRjb21tYW5kLnNldFNjYWxlKCRzY2FsZVgsICRzY2FsZVkpO1xuXHRcdH1cblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWNvcmF0aW9uRHJhd2luZztcbiIsInZhciBDb21tYW5kcyA9IHJlcXVpcmUoJy4vQ29tbWFuZHMnKTtcblxudmFyIERlY29yYXRpb25EcmF3aW5nQ29tbWFuZCA9IGZ1bmN0aW9uICgkaW5zdHJ1Y3Rpb25zLCAkcGh5c2ljc01hbmFnZXIpXG57XG5cdHRoaXMucGh5c2ljc01hbmFnZXIgPSAkcGh5c2ljc01hbmFnZXI7XG5cdHRoaXMubmFtZSA9ICRpbnN0cnVjdGlvbnMubmFtZTtcblx0dGhpcy5wb2ludCA9ICRpbnN0cnVjdGlvbnMucG9pbnQ7XG5cdHRoaXMub3B0aW9ucyA9ICRpbnN0cnVjdGlvbnMub3B0aW9ucztcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR0aGlzLnBoeXNpY3NNYW5hZ2VyLmFkZGVkVG9Xb3JsZC50aGVuKGZ1bmN0aW9uICgpXG5cdHtcblx0XHRzZWxmLnJlbGF0aXZlUG9pbnQgPVxuXHRcdFtcblx0XHRcdHNlbGYucG9pbnRbMF0gLSAkcGh5c2ljc01hbmFnZXIuZ2V0WCgpLFxuXHRcdFx0c2VsZi5wb2ludFsxXSAtICRwaHlzaWNzTWFuYWdlci5nZXRZKClcblx0XHRdO1xuXHRcdGlmIChzZWxmLm5hbWUgPT09IENvbW1hbmRzLkJFWklFUl9UTyB8fCBzZWxmLm5hbWUgPT09IENvbW1hbmRzLlFVQURSQV9UTylcblx0XHR7XG5cdFx0XHRzZWxmLmNwMSA9XG5cdFx0XHRbXG5cdFx0XHRcdHNlbGYucmVsYXRpdmVQb2ludFswXSArIHNlbGYub3B0aW9uc1swXVswXSxcblx0XHRcdFx0c2VsZi5yZWxhdGl2ZVBvaW50WzFdICsgc2VsZi5vcHRpb25zWzBdWzFdXG5cdFx0XHRdO1xuXHRcdH1cblx0XHRpZiAoc2VsZi5uYW1lID09PSBDb21tYW5kcy5CRVpJRVJfVE8pXG5cdFx0e1xuXHRcdFx0c2VsZi5jcDIgPVxuXHRcdFx0W1xuXHRcdFx0XHRzZWxmLnJlbGF0aXZlUG9pbnRbMF0gKyBzZWxmLm9wdGlvbnNbMV1bMF0sXG5cdFx0XHRcdHNlbGYucmVsYXRpdmVQb2ludFsxXSArIHNlbGYub3B0aW9uc1sxXVsxXVxuXHRcdFx0XTtcblx0XHR9XG5cdH0pO1xufTtcblxuRGVjb3JhdGlvbkRyYXdpbmdDb21tYW5kLnByb3RvdHlwZS5zZXRTY2FsZSA9IGZ1bmN0aW9uICgkc2NhbGVYLCAkc2NhbGVZKVxue1xuXHR0aGlzLnNjYWxlWCA9ICRzY2FsZVg7XG5cdHRoaXMuc2NhbGVZID0gJHNjYWxlWTtcblxuXHRpZiAodGhpcy5uYW1lID09PSBDb21tYW5kcy5DSVJDTEUgfHwgdGhpcy5uYW1lID09PSBDb21tYW5kcy5FTExJUFNFKVxuXHR7XG5cdFx0dGhpcy5yYWRpdXMgPSB0aGlzLm9wdGlvbnNbMF0gKiB0aGlzLnNjYWxlWDtcblx0fVxuXHRpZiAodGhpcy5uYW1lID09PSBDb21tYW5kcy5FTExJUFNFKVxuXHR7XG5cdFx0dGhpcy5yYWRpdXNCID0gdGhpcy5vcHRpb25zWzFdICogdGhpcy5zY2FsZVg7XG5cdH1cbn07XG5cbkRlY29yYXRpb25EcmF3aW5nQ29tbWFuZC5wcm90b3R5cGUuZ2V0Um90YXRpb24gPSBmdW5jdGlvbiAoKVxue1xuXHR2YXIgcm90YSA9ICh0aGlzLnBoeXNpY3NNYW5hZ2VyLmdldEFuZ2xlKCkpO1xuXHRyZXR1cm4gdGhpcy5vcHRpb25zWzJdIC0gcm90YTsvL3RoaXMucGh5c2ljc01hbmFnZXIuZ2V0QW5nbGUoKSAqIDE4MCAvIE1hdGguUEk7XG59O1xuXG5EZWNvcmF0aW9uRHJhd2luZ0NvbW1hbmQucHJvdG90eXBlLmdldENvbnRyb2xQb2ludCA9IGZ1bmN0aW9uICgkY3ApXG57XG5cdHZhciBhbmdsZSA9IC10aGlzLnBoeXNpY3NNYW5hZ2VyLmdldEFuZ2xlKCk7XG5cdHZhciB4ID0gJGNwWzBdO1xuXHR2YXIgeSA9ICRjcFsxXTtcblx0cmV0dXJuIFtcblx0XHQodGhpcy5waHlzaWNzTWFuYWdlci5nZXRYKCkgKyB4ICogTWF0aC5jb3MoYW5nbGUpIC0geSAqIE1hdGguc2luKGFuZ2xlKSkgKiB0aGlzLnNjYWxlWCxcblx0XHQodGhpcy5waHlzaWNzTWFuYWdlci5nZXRZKCkgKyB5ICogTWF0aC5jb3MoYW5nbGUpICsgeCAqIE1hdGguc2luKGFuZ2xlKSkgKiB0aGlzLnNjYWxlWVxuXHRdO1xufTtcblxuRGVjb3JhdGlvbkRyYXdpbmdDb21tYW5kLnByb3RvdHlwZS5nZXRDUDEgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5nZXRDb250cm9sUG9pbnQodGhpcy5jcDEpO1xufTtcblxuRGVjb3JhdGlvbkRyYXdpbmdDb21tYW5kLnByb3RvdHlwZS5nZXRDUDIgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5nZXRDb250cm9sUG9pbnQodGhpcy5jcDIpO1xufTtcblxuRGVjb3JhdGlvbkRyYXdpbmdDb21tYW5kLnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKClcbntcblx0dmFyIGFuZ2xlID0gLXRoaXMucGh5c2ljc01hbmFnZXIuZ2V0QW5nbGUoKTtcblx0dmFyIHggPSB0aGlzLnJlbGF0aXZlUG9pbnRbMF07XG5cdHZhciB5ID0gdGhpcy5yZWxhdGl2ZVBvaW50WzFdO1xuXHRyZXR1cm4gKHRoaXMucGh5c2ljc01hbmFnZXIuZ2V0WCgpICsgeCAqIE1hdGguY29zKGFuZ2xlKSAtIHkgKiBNYXRoLnNpbihhbmdsZSkpICogdGhpcy5zY2FsZVg7XG59O1xuXG5EZWNvcmF0aW9uRHJhd2luZ0NvbW1hbmQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKVxue1xuXHR2YXIgYW5nbGUgPSAtdGhpcy5waHlzaWNzTWFuYWdlci5nZXRBbmdsZSgpO1xuXHR2YXIgeCA9IHRoaXMucmVsYXRpdmVQb2ludFswXTtcblx0dmFyIHkgPSB0aGlzLnJlbGF0aXZlUG9pbnRbMV07XG5cdHJldHVybiAodGhpcy5waHlzaWNzTWFuYWdlci5nZXRZKCkgKyB5ICogTWF0aC5jb3MoYW5nbGUpICsgeCAqIE1hdGguc2luKGFuZ2xlKSkgKiB0aGlzLnNjYWxlWTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGVjb3JhdGlvbkRyYXdpbmdDb21tYW5kO1xuIiwidmFyIEdyaWQgPVxue1xuXHRpbml0OiBmdW5jdGlvbiAoJGdyYXBoKVxuXHR7XG5cdFx0dGhpcy5fZ3JhcGggPSAkZ3JhcGg7XG5cdFx0dmFyIG5vZGVzQXJyYXkgPSB0aGlzLl9ub2Rlc0FycmF5ID0gW107XG5cdFx0dGhpcy5fZ3JhcGguZm9yRWFjaChmdW5jdGlvbiAoJGxpbmUpXG5cdFx0e1xuXHRcdFx0aWYgKCRsaW5lKVxuXHRcdFx0e1xuXHRcdFx0XHQkbGluZS5mb3JFYWNoKGZ1bmN0aW9uICgkbm9kZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmICgkbm9kZSkgeyBub2Rlc0FycmF5LnB1c2goJG5vZGUpOyB9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNyZWF0ZUZyb21Qb2x5Z29uOiBmdW5jdGlvbiAoJHBvbHlnb24sICRkZWYsICRoZXhhKVxuXHR7XG5cdFx0dmFyIGJvdW5kaW5nQm94ID0gJHBvbHlnb24uZ2V0Qm91bmRpbmdCb3goKTtcblxuXHRcdHZhciBkZWYgPSAkZGVmO1xuXHRcdC8vdmFyIGRlZiA9IHdpZHRoIC8gJGRlZjtcblx0XHR2YXIgdG9SZXR1cm4gPSBbXTtcblx0XHR2YXIgeUluYyA9ICRoZXhhID8gZGVmICogKE1hdGguc3FydCgzKSAvIDIpIDogZGVmO1xuXHRcdHZhciBoYWxmRGVmID0gZGVmICogMC41O1xuXHRcdGZvciAodmFyIHlQb3MgPSBib3VuZGluZ0JveFswXVsxXTsgeVBvcyA8PSBib3VuZGluZ0JveFsxXVsxXTsgeVBvcyArPSB5SW5jKVxuXHRcdHtcblx0XHRcdHZhciBsaW5lID0gW107XG5cdFx0XHQvL3ZhciBpbnRlcnNlY3Rpb25zID0gJHBvbHlnb24uZ2V0SW50ZXJzZWN0aW9uc0F0WSh5UG9zKTtcblx0XHRcdHZhciB4UG9zID0gYm91bmRpbmdCb3hbMF1bMF07XG5cdFx0XHR4UG9zID0gKCRoZXhhICYmIHRvUmV0dXJuLmxlbmd0aCAlIDIgIT09IDApID8geFBvcyArIGhhbGZEZWYgOiB4UG9zO1xuXHRcdFx0Zm9yICh4UG9zOyB4UG9zIDw9IGJvdW5kaW5nQm94WzFdWzBdICsgaGFsZkRlZjsgeFBvcyArPSBkZWYpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICgkcG9seWdvbi5pc0luc2lkZShbeFBvcywgeVBvc10pKSB7IGxpbmUucHVzaChbeFBvcywgeVBvc10pOyB9XG5cdFx0XHRcdGVsc2UgeyBsaW5lLnB1c2gobnVsbCk7IH1cblx0XHRcdH1cblx0XHRcdHRvUmV0dXJuLnB1c2gobGluZSk7XG5cdFx0fVxuXHRcdHJldHVybiBPYmplY3QuY3JlYXRlKEdyaWQpLmluaXQodG9SZXR1cm4pO1xuXHR9LFxuXG5cdGdldEdyYXBoOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9ncmFwaDsgfSxcblxuXHRnZXROb2Rlc0FycmF5OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9ub2Rlc0FycmF5OyB9LFxuXG5cdGdldENsb3Nlc3Q6IGZ1bmN0aW9uICgkeCwgJHksICRzaXplKVxuXHR7XG5cdFx0dmFyIHNpemUgPSAkc2l6ZSB8fCAxO1xuXHRcdHZhciBjbG9zZXN0ID0gdGhpcy5fbm9kZXNBcnJheS5jb25jYXQoKTtcblx0XHRjbG9zZXN0LnNvcnQoZnVuY3Rpb24gKCRhLCAkYilcblx0XHR7XG5cdFx0XHRpZiAoJGEgPT09IG51bGwgfHwgJGIgPT09IG51bGwpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdHZhciBzaWRlWDEgPSBNYXRoLmFicygkYVswXSAtICR4KTtcblx0XHRcdHZhciBzaWRlWTEgPSBNYXRoLmFicygkYVsxXSAtICR5KTtcblx0XHRcdHZhciBkaXN0MSA9IE1hdGguc3FydChzaWRlWDEgKiBzaWRlWDEgKyBzaWRlWTEgKiBzaWRlWTEpO1xuXG5cdFx0XHR2YXIgc2lkZVgyID0gTWF0aC5hYnMoJGJbMF0gLSAkeCk7XG5cdFx0XHR2YXIgc2lkZVkyID0gTWF0aC5hYnMoJGJbMV0gLSAkeSk7XG5cdFx0XHR2YXIgZGlzdDIgPSBNYXRoLnNxcnQoc2lkZVgyICogc2lkZVgyICsgc2lkZVkyICogc2lkZVkyKTtcblxuXHRcdFx0cmV0dXJuIGRpc3QxIC0gZGlzdDI7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGNsb3Nlc3Quc2xpY2UoMCwgc2l6ZSk7XG5cdH0sXG5cblx0Z2V0TmVpZ2hib3VyczogZnVuY3Rpb24gKCR4LCAkeSwgJHJldHVybkVtcHR5KVxuXHR7XG5cdFx0dmFyIHRvUmV0dXJuID0gW107XG5cdFx0dmFyIGdyYXBoID0gdGhpcy5fZ3JhcGg7XG5cdFx0dmFyIGV2ZW4gPSAkeSAlIDIgPiAwO1xuXHRcdHZhciBsZWZ0ID0gZXZlbiA/ICR4IDogJHggLSAxO1xuXHRcdHZhciByaWdodCA9IGV2ZW4gPyAkeCArIDEgOiAkeDtcblxuXHRcdHZhciBORSA9IGdyYXBoWyR5IC0gMV0gJiYgZ3JhcGhbJHkgLSAxXVtyaWdodF0gPyBncmFwaFskeSAtIDFdW3JpZ2h0XSA6IG51bGw7XG5cdFx0dmFyIEUgPSBncmFwaFskeSArIDBdICYmIGdyYXBoWyR5ICsgMF1bJHggKyAxXSA/IGdyYXBoWyR5XVskeCArIDFdIDogbnVsbDtcblx0XHR2YXIgU0UgPSBncmFwaFskeSArIDFdICYmIGdyYXBoWyR5ICsgMV1bcmlnaHRdID8gZ3JhcGhbJHkgKyAxXVtyaWdodF0gOiBudWxsO1xuXHRcdHZhciBTVyA9IGdyYXBoWyR5ICsgMV0gJiYgZ3JhcGhbJHkgKyAxXVtsZWZ0XSA/IGdyYXBoWyR5ICsgMV1bbGVmdF0gOiBudWxsO1xuXHRcdHZhciBXID0gZ3JhcGhbJHkgKyAwXSAmJiBncmFwaFskeSArIDBdWyR4IC0gMV0gPyBncmFwaFskeV1bJHggLSAxXSA6IG51bGw7XG5cdFx0dmFyIE5XID0gZ3JhcGhbJHkgLSAxXSAmJiBncmFwaFskeSAtIDFdW2xlZnRdID8gZ3JhcGhbJHkgLSAxXVtsZWZ0XSA6IG51bGw7XG5cblx0XHRpZiAoTkUgfHwgJHJldHVybkVtcHR5KSB7IHRvUmV0dXJuLnB1c2goTkUpOyB9XG5cdFx0aWYgKEUgfHwgJHJldHVybkVtcHR5KSB7IHRvUmV0dXJuLnB1c2goRSk7IH1cblx0XHRpZiAoU0UgfHwgJHJldHVybkVtcHR5KSB7IHRvUmV0dXJuLnB1c2goU0UpOyB9XG5cdFx0aWYgKFNXIHx8ICRyZXR1cm5FbXB0eSkgeyB0b1JldHVybi5wdXNoKFNXKTsgfVxuXHRcdGlmIChXIHx8ICRyZXR1cm5FbXB0eSkgeyB0b1JldHVybi5wdXNoKFcpOyB9XG5cdFx0aWYgKE5XIHx8ICRyZXR1cm5FbXB0eSkgeyB0b1JldHVybi5wdXNoKE5XKTsgfVxuXG5cdFx0cmV0dXJuIHRvUmV0dXJuO1xuXHR9LFxuXG5cdGdldE5ldHdvcms6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXIgZ3JhcGggPSB0aGlzLl9ncmFwaDtcblx0XHR2YXIgbmV0d29yayA9IFtdO1xuXHRcdHZhciB2aXNpdGVkID0gW107XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHZhciByb3dzTGVuZ3RoID0gZ3JhcGgubGVuZ3RoO1xuXHRcdGZvciAoaTsgaSA8IHJvd3NMZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgayA9IDA7XG5cdFx0XHR2YXIgcG9pbnRzTGVuZ3RoID0gZ3JhcGhbaV0ubGVuZ3RoO1xuXHRcdFx0Zm9yIChrOyBrIDwgcG9pbnRzTGVuZ3RoOyBrICs9IDEpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBjdXJyUG9pbnQgPSBncmFwaFtpXVtrXTtcblx0XHRcdFx0aWYgKGN1cnJQb2ludClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhciBjdXJyUG9pbnROZWlnaGJvdXJzID0gdGhpcy5nZXROZWlnaGJvdXJzKGssIGkpO1xuXHRcdFx0XHRcdGZvciAodmFyIG0gPSAwLCBuZWlnaGJvdXJzTGVuZ3RoID0gY3VyclBvaW50TmVpZ2hib3Vycy5sZW5ndGg7IG0gPCBuZWlnaGJvdXJzTGVuZ3RoOyBtICs9IDEpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dmFyIGN1cnJOZWlnaCA9IGN1cnJQb2ludE5laWdoYm91cnNbbV07XG5cdFx0XHRcdFx0XHRpZiAoY3Vyck5laWdoICYmIHZpc2l0ZWQuaW5kZXhPZihjdXJyTmVpZ2gpID09PSAtMSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0bmV0d29yay5wdXNoKFtjdXJyUG9pbnQsIGN1cnJOZWlnaF0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2aXNpdGVkLnB1c2goY3VyclBvaW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbmV0d29yaztcblx0fSxcblxuXHRnZXRPdXRsaW5lOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0aWYgKCF0aGlzLm91dGxpbmUpXG5cdFx0e1xuXHRcdFx0dmFyIGdyYXBoID0gdGhpcy5fZ3JhcGg7XG5cdFx0XHR2YXIgb3V0bGluZUdyYXBoID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgcm93c0xlbmd0aCA9IGdyYXBoLmxlbmd0aDsgaSA8IHJvd3NMZW5ndGg7IGkgKz0gMSlcblx0XHRcdHtcblx0XHRcdFx0b3V0bGluZUdyYXBoW2ldID0gW107XG5cdFx0XHRcdGZvciAodmFyIGsgPSAwLCBwb2ludHNMZW5ndGggPSBncmFwaFtpXS5sZW5ndGg7IGsgPCBwb2ludHNMZW5ndGg7IGsgKz0gMSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhciBwb2ludCA9IGdyYXBoW2ldW2tdO1xuXHRcdFx0XHRcdG91dGxpbmVHcmFwaFtpXVtrXSA9IG51bGw7XG5cdFx0XHRcdFx0aWYgKHBvaW50KVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBpc0VkZ2UgPSB0aGlzLmdldE5laWdoYm91cnMoaywgaSkubGVuZ3RoIDwgNjtcblx0XHRcdFx0XHRcdGlmIChpc0VkZ2UpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdG91dGxpbmVHcmFwaFtpXVtrXSA9IFtrLCBpXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMub3V0bGluZSA9IE9iamVjdC5jcmVhdGUoR3JpZCkuaW5pdChvdXRsaW5lR3JhcGgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm91dGxpbmU7XG5cdH0sXG5cblx0Z2V0U2hhcGVQYXRoOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0dmFyIHBhdGggPSBbXTtcblx0XHR2YXIgY3VycmVudE91dGxpbmUgPSB0aGlzLmdldE91dGxpbmVzKClbMF07XG5cdFx0dmFyIG91dGxpbmVHcmFwaCA9IGN1cnJlbnRPdXRsaW5lLmdldEdyYXBoKCk7XG5cdFx0dmFyIGdldFN0YXJ0aW5nSW5kZXggPSBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvdXRsaW5lR3JhcGgubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICghb3V0bGluZUdyYXBoW2ldKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRcdGZvciAodmFyIGsgPSAwLCBwb2ludHNMZW5ndGggPSBvdXRsaW5lR3JhcGhbaV0ubGVuZ3RoOyBrIDwgcG9pbnRzTGVuZ3RoOyBrICs9IDEpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgY3VyclBvaW50ID0gb3V0bGluZUdyYXBoW2ldW2tdO1xuXHRcdFx0XHRcdC8vIGlmIChjdXJyUG9pbnQpXG5cdFx0XHRcdFx0Ly8ge1xuXHRcdFx0XHRcdC8vIFx0Y29uc29sZS5sb2coY3VyclBvaW50LCBjdXJyZW50T3V0bGluZS5nZXROZWlnaGJvdXJzKGN1cnJQb2ludFswXSwgY3VyclBvaW50WzFdKSk7XG5cdFx0XHRcdFx0Ly8gfVxuXHRcdFx0XHRcdGlmIChjdXJyUG9pbnQgJiYgY3VycmVudE91dGxpbmUuZ2V0TmVpZ2hib3VycyhjdXJyUG9pbnRbMF0sIGN1cnJQb2ludFsxXSkubGVuZ3RoID09PSAyKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHJldHVybiBjdXJyUG9pbnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciB2aXNpdGVkID0gW107XG5cdFx0dmFyIHN0YXJ0aW5nSW5kZXggPSBnZXRTdGFydGluZ0luZGV4LmNhbGwodGhpcyk7XG5cdFx0aWYgKCFzdGFydGluZ0luZGV4KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGdldEFuZ2xlID0gZnVuY3Rpb24gKCRpbmRleClcblx0XHR7XG5cdFx0XHR2YXIgYW5nbGUgPSAoJGluZGV4ICsgMSkgKiA2MDtcblx0XHRcdGFuZ2xlID0gYW5nbGUgPT09IDAgPyAzNjAgOiBhbmdsZTtcblx0XHRcdHJldHVybiBhbmdsZTtcblx0XHR9O1xuXHRcdHZhciBnZXROZWlnaGJvdXJJbmRleCA9IGZ1bmN0aW9uICgkcG9pbnQsICRuZWlnaGJvdXIpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGN1cnJlbnRPdXRsaW5lLmdldE5laWdoYm91cnMoJHBvaW50WzBdLCAkcG9pbnRbMV0sIHRydWUpLmluZGV4T2YoJG5laWdoYm91cik7XG5cdFx0fTtcblxuXHRcdHZhciBuZXh0ID0gY3VycmVudE91dGxpbmUuZ2V0TmVpZ2hib3VycyhzdGFydGluZ0luZGV4WzBdLCBzdGFydGluZ0luZGV4WzFdKVswXTtcblx0XHR2YXIgbGFzdEFuZ2xlID0gZ2V0QW5nbGUoZ2V0TmVpZ2hib3VySW5kZXgoc3RhcnRpbmdJbmRleCwgbmV4dCkpO1xuXHRcdHZhciBjdXJySW5kZXggPSBuZXh0O1xuXHRcdHBhdGgucHVzaCh0aGlzLl9ncmFwaFtzdGFydGluZ0luZGV4WzFdXVtzdGFydGluZ0luZGV4WzBdXSk7XG5cdFx0cGF0aC5wdXNoKHRoaXMuX2dyYXBoW25leHRbMV1dW25leHRbMF1dKTtcblx0XHR2aXNpdGVkLnB1c2goc3RhcnRpbmdJbmRleCk7XG5cblx0XHR2YXIgYmVzdDtcblx0XHR2YXIgbmVpZ2hib3Vycztcblx0XHR2YXIgYmVzdEFuZ2xlO1xuXHRcdHZhciBvdXRsaW5lTm9kZXNBcnJheSA9IGN1cnJlbnRPdXRsaW5lLmdldE5vZGVzQXJyYXkoKTtcblx0XHR2YXIgb3V0bGluZVBvaW50c0xlbmd0aCA9IG91dGxpbmVOb2Rlc0FycmF5Lmxlbmd0aDtcblxuXHRcdHdoaWxlICh2aXNpdGVkLmxlbmd0aCA8IG91dGxpbmVQb2ludHNMZW5ndGggLSAxKS8vY3VyckluZGV4ICE9PSBzdGFydGluZ0luZGV4KVxuXHRcdHtcblx0XHRcdG5laWdoYm91cnMgPSBjdXJyZW50T3V0bGluZS5nZXROZWlnaGJvdXJzKGN1cnJJbmRleFswXSwgY3VyckluZGV4WzFdKTtcblx0XHRcdHZhciBiZXN0U2NvcmUgPSAwO1xuXHRcdFx0YmVzdCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG5laWdoYm91cnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBjdXJyTmVpZ2ggPSBuZWlnaGJvdXJzW2ldO1xuXHRcdFx0XHR2YXIgY3VyclNjb3JlID0gMDtcblx0XHRcdFx0dmFyIGN1cnJBbmdsZSA9IGdldEFuZ2xlKGdldE5laWdoYm91ckluZGV4KGN1cnJJbmRleCwgY3Vyck5laWdoKSk7XG5cdFx0XHRcdGN1cnJTY29yZSA9IGN1cnJBbmdsZSAtIGxhc3RBbmdsZTtcblx0XHRcdFx0aWYgKGN1cnJTY29yZSA+IDE4MCkgeyBjdXJyU2NvcmUgPSBjdXJyU2NvcmUgLSAzNjA7IH1cblx0XHRcdFx0aWYgKGN1cnJTY29yZSA8IC0xODApIHsgY3VyclNjb3JlID0gY3VyclNjb3JlICsgMzYwOyB9XG5cdFx0XHRcdHZhciBuZWlnaEluZGV4ID0gdmlzaXRlZC5pbmRleE9mKGN1cnJOZWlnaCk7XG5cdFx0XHRcdGlmIChuZWlnaEluZGV4ICE9PSAtMSkgeyBjdXJyU2NvcmUgPSBuZWlnaEluZGV4IC8gdmlzaXRlZC5sZW5ndGggKiAxMDAwMCArIDEwMDAwICsgY3VyclNjb3JlOyB9XG5cdFx0XHRcdGlmICghYmVzdCB8fCBjdXJyU2NvcmUgPCBiZXN0U2NvcmUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRiZXN0U2NvcmUgPSBjdXJyU2NvcmU7XG5cdFx0XHRcdFx0YmVzdCA9IGN1cnJOZWlnaDtcblx0XHRcdFx0XHRiZXN0QW5nbGUgPSBjdXJyQW5nbGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxhc3RBbmdsZSA9IGJlc3RBbmdsZTtcblx0XHRcdGlmICh2aXNpdGVkLmluZGV4T2YoY3VyckluZGV4KSAhPT0gLTEpIHsgdmlzaXRlZC5zcGxpY2UodmlzaXRlZC5pbmRleE9mKGN1cnJJbmRleCksIDEpOyB9XG5cdFx0XHR2aXNpdGVkLnB1c2goY3VyckluZGV4KTtcblx0XHRcdGN1cnJJbmRleCA9IGJlc3Q7XG5cblx0XHRcdHBhdGgucHVzaCh0aGlzLl9ncmFwaFtjdXJySW5kZXhbMV1dW2N1cnJJbmRleFswXV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcGF0aDtcblx0fSxcblxuXHRnZXRPdXRsaW5lczogZnVuY3Rpb24gKClcblx0e1xuXHRcdHZhciB0b1JldHVybiA9IFtdO1xuXHRcdHZhciBjdXJyZW50R3JhcGg7XG5cdFx0dmFyIG91dGxpbmUgPSB0aGlzLmdldE91dGxpbmUoKTtcblx0XHR2YXIgcmVtYWluaW5nID0gb3V0bGluZS5nZXROb2Rlc0FycmF5KCkuY29uY2F0KCk7XG5cblx0XHR2YXIgcmVjdXIgPSBmdW5jdGlvbiAoJHBvaW50KVxuXHRcdHtcblx0XHRcdGN1cnJlbnRHcmFwaFskcG9pbnRbMV1dID0gY3VycmVudEdyYXBoWyRwb2ludFsxXV0gfHwgW107XG5cdFx0XHRjdXJyZW50R3JhcGhbJHBvaW50WzFdXVskcG9pbnRbMF1dID0gJHBvaW50O1xuXHRcdFx0dmFyIG5laWdoYm91cnMgPSBvdXRsaW5lLmdldE5laWdoYm91cnMoJHBvaW50WzBdLCAkcG9pbnRbMV0pO1xuXHRcdFx0cmVtYWluaW5nLnNwbGljZShyZW1haW5pbmcuaW5kZXhPZigkcG9pbnQpLCAxKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBuZWlnaGJvdXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgbmVpZ2ggPSBuZWlnaGJvdXJzW2ldO1xuXHRcdFx0XHRpZiAocmVtYWluaW5nLmluZGV4T2YobmVpZ2gpICE9PSAtMSkgeyByZWN1cihuZWlnaCk7IH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0d2hpbGUgKHJlbWFpbmluZy5sZW5ndGgpXG5cdFx0e1xuXHRcdFx0Y3VycmVudEdyYXBoID0gW107XG5cdFx0XHR2YXIgc3RhcnRpbmdQb2ludCA9IHJlbWFpbmluZ1swXTtcblx0XHRcdHJlY3VyKHN0YXJ0aW5nUG9pbnQpO1xuXHRcdFx0dG9SZXR1cm4ucHVzaChPYmplY3QuY3JlYXRlKEdyaWQpLmluaXQoY3VycmVudEdyYXBoKSk7XG5cdFx0fVxuXHRcdHJldHVybiB0b1JldHVybjtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmlkO1xuXG4iLCJ2YXIgQ29tbWFuZHMgPSByZXF1aXJlKCcuL0NvbW1hbmRzJyk7XG5cbnZhciBOb2RlRHJhd2luZ0NvbW1hbmQgPSBmdW5jdGlvbiAoJG5hbWUsICRub2RlLCAkaW5zdHJ1Y3Rpb25zKVxue1xuXHR0aGlzLm5vZGUgPSAkbm9kZTtcblx0dGhpcy5uYW1lID0gJG5hbWU7XG5cdGlmICgkaW5zdHJ1Y3Rpb25zKVxuXHR7XG5cdFx0dGhpcy5wb2ludCA9ICRpbnN0cnVjdGlvbnMucG9pbnQ7XG5cdFx0dGhpcy5vcHRpb25zID0gJGluc3RydWN0aW9ucy5vcHRpb25zO1xuXHR9XG5cdHRoaXMucHJvcGVydGllcyA9IHt9O1xufTtcblxuTm9kZURyYXdpbmdDb21tYW5kLnByb3RvdHlwZS5zZXRTY2FsZSA9IGZ1bmN0aW9uICgkc2NhbGVYLCAkc2NhbGVZKVxue1xuXHR0aGlzLnNjYWxlWCA9ICRzY2FsZVg7XG5cdHRoaXMuc2NhbGVZID0gJHNjYWxlWTtcblxuXHRpZiAodGhpcy5uYW1lID09PSBDb21tYW5kcy5DSVJDTEUgfHwgdGhpcy5uYW1lID09PSBDb21tYW5kcy5FTExJUFNFKVxuXHR7XG5cdFx0dGhpcy5yYWRpdXMgPSB0aGlzLm9wdGlvbnNbMF0gKiB0aGlzLnNjYWxlWDtcblx0fVxuXHRpZiAodGhpcy5uYW1lID09PSBDb21tYW5kcy5FTExJUFNFKVxuXHR7XG5cdFx0dGhpcy5yYWRpdXNCID0gdGhpcy5vcHRpb25zWzFdICogdGhpcy5zY2FsZVg7XG5cdH1cbn07XG5cbk5vZGVEcmF3aW5nQ29tbWFuZC5wcm90b3R5cGUuZ2V0Q29udHJvbFBvaW50ID0gZnVuY3Rpb24gKCRjcClcbntcblx0cmV0dXJuIFtcblx0XHQodGhpcy5ub2RlLnBoeXNpY3NNYW5hZ2VyLmdldFgoKSArICRjcFswXSkgKiB0aGlzLnNjYWxlWCxcblx0XHQodGhpcy5ub2RlLnBoeXNpY3NNYW5hZ2VyLmdldFkoKSArICRjcFsxXSkgKiB0aGlzLnNjYWxlWVxuXHRdO1xufTtcblxuTm9kZURyYXdpbmdDb21tYW5kLnByb3RvdHlwZS5nZXRDUDEgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5nZXRDb250cm9sUG9pbnQodGhpcy5vcHRpb25zWzBdKTtcbn07XG5cbk5vZGVEcmF3aW5nQ29tbWFuZC5wcm90b3R5cGUuZ2V0Q1AyID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMuZ2V0Q29udHJvbFBvaW50KHRoaXMub3B0aW9uc1sxXSk7XG59O1xuXG5Ob2RlRHJhd2luZ0NvbW1hbmQucHJvdG90eXBlLmdldFJvdGF0aW9uID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMub3B0aW9uc1syXSAtIHRoaXMubm9kZS5waHlzaWNzTWFuYWdlci5nZXRBbmdsZSgpO1xufTtcblxuTm9kZURyYXdpbmdDb21tYW5kLnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMubm9kZS5waHlzaWNzTWFuYWdlci5nZXRYKCkgKiB0aGlzLnNjYWxlWDtcbn07XG5cbk5vZGVEcmF3aW5nQ29tbWFuZC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLm5vZGUucGh5c2ljc01hbmFnZXIuZ2V0WSgpICogdGhpcy5zY2FsZVk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVEcmF3aW5nQ29tbWFuZDtcbiIsInZhciBOb2RlR3JhcGggPSBmdW5jdGlvbiAoKVxue1xuXHR0aGlzLnZlcnRpY2VzID0gW107XG5cdHRoaXMuZWRnZXMgPSBbXTtcbn07XG5cbk5vZGVHcmFwaC5wcm90b3R5cGUuZ2V0VmVydGV4ID0gZnVuY3Rpb24gKCRub2RlKVxue1xuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzW2ldO1xuXHRcdGlmICh2ZXJ0ZXgubm9kZSA9PT0gJG5vZGUpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHZlcnRleDtcblx0XHR9XG5cdH1cbn07XG5cbk5vZGVHcmFwaC5wcm90b3R5cGUuY3JlYXRlVmVydGV4ID0gZnVuY3Rpb24gKCRub2RlKVxue1xuXHR2YXIgdmVydGV4ID0geyBub2RlOiAkbm9kZSB9O1xuXHR0aGlzLnZlcnRpY2VzLnB1c2godmVydGV4KTtcblx0cmV0dXJuIHZlcnRleDtcbn07XG5cbk5vZGVHcmFwaC5wcm90b3R5cGUuZ2V0RWRnZVdlaWdodCA9IGZ1bmN0aW9uICgkZWRnZSlcbntcblx0dmFyIGRYID0gTWF0aC5hYnMoJGVkZ2UudmVydGV4QS5ub2RlLm9YIC0gJGVkZ2UudmVydGV4Qi5ub2RlLm9YKTtcblx0dmFyIGRZID0gTWF0aC5hYnMoJGVkZ2UudmVydGV4QS5ub2RlLm9ZIC0gJGVkZ2UudmVydGV4Qi5ub2RlLm9ZKTtcblx0dmFyIGRpc3QgPSBNYXRoLnNxcnQoZFggKiBkWCArIGRZICogZFkpO1xuXHRyZXR1cm4gZGlzdDtcbn07XG5cbk5vZGVHcmFwaC5wcm90b3R5cGUuZ2V0VmVydGV4RWRnZXMgPSBmdW5jdGlvbiAoJHZlcnRleClcbntcblx0dmFyIHRvUmV0dXJuID0gW107XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLmVkZ2VzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGVkZ2UgPSB0aGlzLmVkZ2VzW2ldO1xuXHRcdGlmIChlZGdlLnZlcnRleEEgPT09ICR2ZXJ0ZXggfHwgZWRnZS52ZXJ0ZXhCID09PSAkdmVydGV4KVxuXHRcdHtcblx0XHRcdHRvUmV0dXJuLnB1c2goZWRnZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0b1JldHVybjtcbn07XG5cbk5vZGVHcmFwaC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgkQU5vZGUsICRCTm9kZSlcbntcblx0dmFyIHZlcnRleEEgPSB0aGlzLmdldFZlcnRleCgkQU5vZGUpIHx8IHRoaXMuY3JlYXRlVmVydGV4KCRBTm9kZSk7XG5cdHZhciB2ZXJ0ZXhCID0gdGhpcy5nZXRWZXJ0ZXgoJEJOb2RlKSB8fCB0aGlzLmNyZWF0ZVZlcnRleCgkQk5vZGUpO1xuXG5cdHZhciBleGlzdHMgPSBmYWxzZTtcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuZWRnZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgZWRnZSA9IHRoaXMuZWRnZXNbaV07XG5cdFx0aWYgKChlZGdlLnZlcnRleEEgPT09IHZlcnRleEEgJiZcblx0XHRcdGVkZ2UudmVydGV4QiA9PT0gdmVydGV4QikgfHxcblx0XHRcdChlZGdlLnZlcnRleEEgPT09IHZlcnRleEIgJiZcblx0XHRcdGVkZ2UudmVydGV4QiA9PT0gdmVydGV4QSkpXG5cdFx0e1xuXHRcdFx0ZXhpc3RzID0gdHJ1ZTtcblx0XHR9XG5cdH1cblx0aWYgKCFleGlzdHMpXG5cdHtcblx0XHR0aGlzLmVkZ2VzLnB1c2goeyB2ZXJ0ZXhBOiB2ZXJ0ZXhBLCB2ZXJ0ZXhCOiB2ZXJ0ZXhCIH0pO1xuXHR9XG59O1xuXG5Ob2RlR3JhcGgucHJvdG90eXBlLnRyYXZlcnNlID0gZnVuY3Rpb24gKCRzdGFydGluZ1ZlcnRpY2VzKVxue1xuXHR2YXIgaTtcblx0dmFyIG9wZW5MaXN0ID0gW107XG5cdHZhciBlZGdlc0xlbmd0aDtcblx0dmFyIHZlcnRleEVkZ2VzO1xuXHR2YXIgc3RhcnRpbmdWZXJ0aWNlc0xlbmd0aCA9ICRzdGFydGluZ1ZlcnRpY2VzLmxlbmd0aDtcblx0Zm9yIChpID0gMDsgaSA8IHN0YXJ0aW5nVmVydGljZXNMZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdCRzdGFydGluZ1ZlcnRpY2VzW2ldLm1hcFZhbHVlID0gMDtcblx0XHQkc3RhcnRpbmdWZXJ0aWNlc1tpXS5vcGVuZWQgPSB0cnVlO1xuXHRcdG9wZW5MaXN0LnB1c2goJHN0YXJ0aW5nVmVydGljZXNbaV0pO1xuXHR9XG5cblx0d2hpbGUgKG9wZW5MaXN0Lmxlbmd0aClcblx0e1xuXHRcdHZhciBjbG9zZWRWZXJ0ZXggPSBvcGVuTGlzdC5zaGlmdCgpO1xuXHRcdGNsb3NlZFZlcnRleC5jbG9zZWQgPSB0cnVlO1xuXG5cdFx0dmVydGV4RWRnZXMgPSB0aGlzLmdldFZlcnRleEVkZ2VzKGNsb3NlZFZlcnRleCk7XG5cdFx0ZWRnZXNMZW5ndGggPSB2ZXJ0ZXhFZGdlcy5sZW5ndGg7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGVkZ2VzTGVuZ3RoOyBpICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJFZGdlID0gdmVydGV4RWRnZXNbaV07XG5cdFx0XHR2YXIgb3RoZXJWZXJ0ZXggPSBjdXJyRWRnZS52ZXJ0ZXhBID09PSBjbG9zZWRWZXJ0ZXggPyBjdXJyRWRnZS52ZXJ0ZXhCIDogY3VyckVkZ2UudmVydGV4QTtcblx0XHRcdGlmIChvdGhlclZlcnRleC5jbG9zZWQpIHsgY29udGludWU7IH1cblx0XHRcdFxuXHRcdFx0aWYgKCFvdGhlclZlcnRleC5vcGVuZWQpXG5cdFx0XHR7XG5cdFx0XHRcdG90aGVyVmVydGV4Lm9wZW5lZCA9IHRydWU7XG5cdFx0XHRcdG9wZW5MaXN0LnB1c2gob3RoZXJWZXJ0ZXgpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHZhbCA9IGNsb3NlZFZlcnRleC5tYXBWYWx1ZSArIHRoaXMuZ2V0RWRnZVdlaWdodChjdXJyRWRnZSk7XG5cdFx0XHRvdGhlclZlcnRleC5tYXBWYWx1ZSA9IG90aGVyVmVydGV4Lm1hcFZhbHVlIDwgdmFsID8gb3RoZXJWZXJ0ZXgubWFwVmFsdWUgOiB2YWw7IC8vd29ya3MgZXZlbiBpZiB1bmRlZmluZWRcblx0XHR9XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZUdyYXBoO1xuIiwidmFyIE5vZGVEcmF3aW5nQ29tbWFuZCA9IHJlcXVpcmUoJy4vTm9kZURyYXdpbmdDb21tYW5kJyk7XG52YXIgQ29tbWFuZHMgPSByZXF1aXJlKCcuL0NvbW1hbmRzJyk7XG52YXIgRGVjb3JhdGlvbkRyYXdpbmcgPSByZXF1aXJlKCcuL0RlY29yYXRpb25EcmF3aW5nJyk7XG5cbnZhciBPYmplY3REcmF3aW5nID0gT2JqZWN0LmNyZWF0ZShEZWNvcmF0aW9uRHJhd2luZyk7XG5PYmplY3REcmF3aW5nLmNyZWF0ZSA9IGZ1bmN0aW9uICgkZ3JvdXApXG57XG5cdHZhciBpbnN0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3REcmF3aW5nKTtcblx0aW5zdC5ncm91cCA9ICRncm91cDtcblx0aW5zdC5jb21tYW5kcyA9IFtdO1xuXHRpbnN0LmNvbW1hbmRzTGVuZ3RoID0gMDtcblx0aW5zdC5wcm9wZXJ0aWVzID0gdW5kZWZpbmVkO1xuXHRyZXR1cm4gaW5zdDtcbn07XG5cbk9iamVjdERyYXdpbmcuc2V0UHJvcGVydGllcyA9IGZ1bmN0aW9uICgkcHJvcGVydGllcylcbntcblx0dGhpcy5wcm9wZXJ0aWVzID0gJHByb3BlcnRpZXM7XG5cdHRoaXMudXNlRHluYW1pY0dyYWRpZW50ID0gdGhpcy5ncm91cC5jb25mLnN0cnVjdHVyZSA9PT0gJ2xpbmUnICYmIHRoaXMucHJvcGVydGllcy5zdHJva2VHcmFkaWVudDtcbn07XG5cbk9iamVjdERyYXdpbmcuc2V0Q29tbWFuZHMgPSBmdW5jdGlvbiAoKVxue1xuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5ncm91cC5zdHJ1Y3R1cmUubm9kZVByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3VyciA9IHRoaXMuZ3JvdXAuc3RydWN0dXJlLm5vZGVQcm9wZXJ0aWVzW2ldO1xuXHRcdHRoaXMuYWRkQ29tbWFuZChjdXJyLm5vZGUsIGN1cnIuY29tbWFuZFByb3BlcnRpZXMsIGN1cnIuaXNFbnZlbG9wZSk7XG5cdH1cbn07XG5cbk9iamVjdERyYXdpbmcuYWRkQ29tbWFuZCA9IGZ1bmN0aW9uICgkbm9kZSwgJGNvbW1hbmRQcm9wZXJ0aWVzLCAkZW52ZWxvcGUpXG57XG5cdHZhciBjb21tYW5kTmFtZTtcblx0dmFyIHByb3BlcnRpZXMgPSAkY29tbWFuZFByb3BlcnRpZXM7XG5cdGlmICgkZW52ZWxvcGUgPT09IGZhbHNlICYmICF0aGlzLmdyb3VwLmNvbmYuZHJhd05vZGVzU2VwYXJhdGVseSlcblx0e1xuXHRcdHJldHVybjtcblx0fVxuXHRpZiAocHJvcGVydGllcykgeyBjb21tYW5kTmFtZSA9IHByb3BlcnRpZXMubmFtZTsgfVxuXHRlbHNlXG5cdHtcblx0XHRpZiAodGhpcy5ncm91cC5jb25mLmRyYXdOb2Rlc1NlcGFyYXRlbHkpXG5cdFx0e1xuXHRcdFx0Y29tbWFuZE5hbWUgPSBDb21tYW5kcy5DSVJDTEU7XG5cdFx0XHRwcm9wZXJ0aWVzID0ge307XG5cdFx0XHRwcm9wZXJ0aWVzLm9wdGlvbnMgPSBbXTtcblx0XHRcdHByb3BlcnRpZXMub3B0aW9uc1swXSA9IHRoaXMuZ3JvdXAuY29uZi5ub2RlUmFkaXVzO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0Y29tbWFuZE5hbWUgPSB0aGlzLmNvbW1hbmRzTGVuZ3RoID09PSAwID8gQ29tbWFuZHMuTU9WRV9UTyA6IENvbW1hbmRzLkxJTkVfVE87XG5cdFx0fVxuXHR9XG5cdC8vIGNvbW1hbmROYW1lID0gQ29tbWFuZHMuQ0lSQ0xFO1xuXHQvLyAkcHJvcGVydGllcy5vcHRpb25zWzBdID0gNTtcblx0Ly8gJHByb3BlcnRpZXMub3B0aW9uc1sxXSA9IDU7XG5cdHZhciBjb21tYW5kID0gbmV3IE5vZGVEcmF3aW5nQ29tbWFuZChjb21tYW5kTmFtZSwgJG5vZGUsIHByb3BlcnRpZXMpO1xuXHR0aGlzLmNvbW1hbmRzLnB1c2goY29tbWFuZCk7XG5cdHRoaXMuY29tbWFuZHNbMF0uZW5kQ29tbWFuZCA9IGNvbW1hbmQ7XG5cdHRoaXMuY29tbWFuZHNMZW5ndGggKz0gMTtcbn07XG5cbk9iamVjdERyYXdpbmcuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5ncm91cC5waHlzaWNzTWFuYWdlci5nZXRCb3VuZGluZ0JveCgpO1xufTtcblxuT2JqZWN0RHJhd2luZy5pc1N0YXRpYyA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLmdyb3VwLmNvbmYuZml4ZWQgPT09IHRydWU7XG59O1xuXG5PYmplY3REcmF3aW5nLndpbGxOb3RJbnRlcnNlY3QgPSBmdW5jdGlvbiAoKVxue1xuXHRpZiAodGhpcy5ncm91cC5jb25mLnBoeXNpY3MuYm9keVR5cGUgPT09ICdoYXJkJylcblx0e1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbk9iamVjdERyYXdpbmcuaXNTaW1wbGVEcmF3aW5nID0gZnVuY3Rpb24gKClcbntcblx0aWYgKHRoaXMuZ3JvdXAuY29uZi5waHlzaWNzLmJvZHlUeXBlID09PSAnaGFyZCcgfHwgdGhpcy5ncm91cC5jb25mLnBoeXNpY3MuYm9keVR5cGUgPT09ICdzb2Z0Jylcblx0e1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0RHJhd2luZztcbiIsInZhciBQb2x5Z29uID1cbntcblx0aW5pdDogZnVuY3Rpb24gKCRwb2ludHMpXG5cdHtcblx0XHR2YXIgcG9seWdvbiA9IE9iamVjdC5jcmVhdGUoUG9seWdvbik7XG5cdFx0cG9seWdvbi5wb2ludHMgPSAkcG9pbnRzO1xuXHRcdHBvbHlnb24uX2JvdW5kaW5nQm94ID0gdW5kZWZpbmVkO1xuXHRcdHJldHVybiBwb2x5Z29uO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXIgc3VtQSA9IDA7XG5cdFx0dmFyIHN1bUIgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgY3VyclBvaW50ID0gdGhpcy5wb2ludHNbaV07XG5cdFx0XHR2YXIgbmV4dCA9IGkgPT09IGxlbmd0aCAtIDEgPyB0aGlzLnBvaW50c1swXSA6IHRoaXMucG9pbnRzW2kgKyAxXTtcblxuXHRcdFx0c3VtQSArPSBjdXJyUG9pbnRbMF0gKiBuZXh0WzFdO1xuXHRcdFx0c3VtQiArPSBjdXJyUG9pbnRbMV0gKiBuZXh0WzBdO1xuXHRcdH1cblxuXHRcdHJldHVybiBNYXRoLmFicygoc3VtQSAtIHN1bUIpICogMC41KTtcblx0fSxcblxuXHRnZXRCb3VuZGluZ0JveDogZnVuY3Rpb24gKClcblx0e1xuXHRcdGlmICghdGhpcy5fYm91bmRpbmdCb3gpXG5cdFx0e1xuXHRcdFx0dmFyIG1pblggPSB0aGlzLnBvaW50c1swXVswXTtcblx0XHRcdHZhciBtYXhYID0gbWluWDtcblx0XHRcdHZhciBtaW5ZID0gdGhpcy5wb2ludHNbMF1bMV07XG5cdFx0XHR2YXIgbWF4WSA9IG1pblk7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIHBvaW50ID0gdGhpcy5wb2ludHNbaV07XG5cdFx0XHRcdG1pblggPSBNYXRoLm1pbihtaW5YLCBwb2ludFswXSk7XG5cdFx0XHRcdG1heFggPSBNYXRoLm1heChtYXhYLCBwb2ludFswXSk7XG5cdFx0XHRcdG1pblkgPSBNYXRoLm1pbihtaW5ZLCBwb2ludFsxXSk7XG5cdFx0XHRcdG1heFkgPSBNYXRoLm1heChtYXhZLCBwb2ludFsxXSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9ib3VuZGluZ0JveCA9IFtbbWluWCwgbWluWV0sIFttYXhYLCBtYXhZXV07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9ib3VuZGluZ0JveDtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXIgYm91bmRpbmcgPSB0aGlzLmdldEJvdW5kaW5nQm94KCk7XG5cdFx0dmFyIHggPSBib3VuZGluZ1swXVswXSArIChib3VuZGluZ1sxXVswXSAtIGJvdW5kaW5nWzBdWzBdKSAvIDI7XG5cdFx0dmFyIHkgPSBib3VuZGluZ1swXVsxXSArIChib3VuZGluZ1sxXVsxXSAtIGJvdW5kaW5nWzBdWzFdKSAvIDI7XG5cdFx0cmV0dXJuIFt4LCB5XTtcblx0fSxcblxuXHRnZXRTZWdtZW50czogZnVuY3Rpb24gKClcblx0e1xuXHRcdHZhciBzZWdtZW50cyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLnBvaW50cy5sZW5ndGggLSAxOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdFx0e1xuXHRcdFx0c2VnbWVudHMucHVzaChbdGhpcy5wb2ludHNbaV0sIHRoaXMucG9pbnRzW2kgKyAxXV0pO1xuXHRcdH1cblx0XHRzZWdtZW50cy5wdXNoKFt0aGlzLnBvaW50c1t0aGlzLnBvaW50cy5sZW5ndGggLSAxXSwgdGhpcy5wb2ludHNbMF1dKTtcblx0XHRyZXR1cm4gc2VnbWVudHM7XG5cdH0sXG5cblx0Z2V0SW50ZXJzZWN0aW9uc0F0WTogZnVuY3Rpb24gKCR0ZXN0WSlcblx0e1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuZ2V0U2VnbWVudHMoKTtcblx0XHR2YXIgaW50ZXJzZWN0aW9ucyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgY3VyclNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdHZhciB4MSA9IGN1cnJTZWdtZW50WzBdWzBdO1xuXHRcdFx0dmFyIHkxID0gY3VyclNlZ21lbnRbMF1bMV07XG5cdFx0XHR2YXIgeDIgPSBjdXJyU2VnbWVudFsxXVswXTtcblx0XHRcdHZhciB5MiA9IGN1cnJTZWdtZW50WzFdWzFdO1xuXHRcdFx0dmFyIHNtYWxsWSA9IE1hdGgubWluKHkxLCB5Mik7XG5cdFx0XHR2YXIgYmlnWSA9IE1hdGgubWF4KHkxLCB5Mik7XG5cblx0XHRcdGlmICgkdGVzdFkgPiBzbWFsbFkgJiYgJHRlc3RZIDwgYmlnWSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIHBZID0geTIgLSAkdGVzdFk7XG5cdFx0XHRcdHZhciBzZWdZID0geTIgLSB5MTtcblx0XHRcdFx0dmFyIHNlZ1ggPSB4MiAtIHgxO1xuXHRcdFx0XHR2YXIgcFggPSBwWSAqIHNlZ1ggLyBzZWdZO1xuXHRcdFx0XHRpbnRlcnNlY3Rpb25zLnB1c2goeDIgLSBwWCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBpbnRlcnNlY3Rpb25zO1xuXHR9LFxuXG5cdGlzSW5zaWRlOiBmdW5jdGlvbiAoJHBvaW50KVxuXHR7XG5cdFx0dmFyIGluZk51bWJlciA9IDA7XG5cdFx0dmFyIGludGVyc2VjdGlvbnMgPSB0aGlzLmdldEludGVyc2VjdGlvbnNBdFkoJHBvaW50WzFdKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gaW50ZXJzZWN0aW9ucy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHRpZiAoJHBvaW50WzBdIDwgaW50ZXJzZWN0aW9uc1tpXSkgeyBpbmZOdW1iZXIgKz0gMTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gaW5mTnVtYmVyICUgMiA+IDA7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9seWdvbjtcblxuIiwidmFyIENvbW1hbmRzID0gcmVxdWlyZSgnLi9Db21tYW5kcycpO1xudmFyIE9iamVjdERyYXdpbmcgPSByZXF1aXJlKCcuL09iamVjdERyYXdpbmcnKTtcbnZhciBDSVJDTEUgPSBDb21tYW5kcy5DSVJDTEU7XG52YXIgTElORV9UTyA9IENvbW1hbmRzLkxJTkVfVE87XG52YXIgTU9WRV9UTyA9IENvbW1hbmRzLk1PVkVfVE87XG52YXIgQkVaSUVSX1RPID0gQ29tbWFuZHMuQkVaSUVSX1RPO1xudmFyIFFVQURSQV9UTyA9IENvbW1hbmRzLlFVQURSQV9UTztcbnZhciBFTExJUFNFID0gQ29tbWFuZHMuRUxMSVBTRTtcbnZhciBvbmx5RHJhd2luZ0VsZW1lbnRzID0gJzpub3QoZyk6bm90KHRpdGxlKTpub3QoW2lkKj1cImpvaW50XCJdKTpub3QoW2lkKj1cImNvbnN0cmFpbnRcIl0pOm5vdCh0aXRsZSk6bm90KGxpbmVhckdyYWRpZW50KTpub3QocmFkaWFsR3JhZGllbnQpOm5vdChzdG9wKSc7XG5cbnZhciBTVkdQYXJzZXIgPSBmdW5jdGlvbiAoKSB7fTtcbi8vdmFyIGlzUG9seWdvbiA9IC9wb2x5Z29ufHJlY3QvaWc7XG4vLyB2YXIgaXNMaW5lID0gL3BvbHlsaW5lfGxpbmV8cGF0aC9pZztcbi8vIHZhciBsaW5lVGFncyA9ICdwb2x5bGluZSwgbGluZSwgcGF0aCc7XG5cblNWR1BhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoJHdvcmxkLCAkU1ZHKVxue1xuXHR0aGlzLlNWRyA9ICRTVkc7XG5cdHZhciB2aWV3Qm94QXR0ciA9IHRoaXMuU1ZHLmdldEF0dHJpYnV0ZSgndmlld0JveCcpO1xuXHR0aGlzLnZpZXdCb3hXaWR0aCA9IHZpZXdCb3hBdHRyID8gTnVtYmVyKHZpZXdCb3hBdHRyLnNwbGl0KCcgJylbMl0pIDogTnVtYmVyKHRoaXMuU1ZHLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSk7XG5cdHRoaXMudmlld0JveEhlaWdodCA9IHZpZXdCb3hBdHRyID8gTnVtYmVyKHZpZXdCb3hBdHRyLnNwbGl0KCcgJylbM10pIDogTnVtYmVyKHRoaXMuU1ZHLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpO1xuXHR0aGlzLnJhdGlvID0gJHdvcmxkLmdldFdpZHRoKCkgLyB0aGlzLnZpZXdCb3hXaWR0aDtcblx0dGhpcy53b3JsZCA9ICR3b3JsZDtcblx0dGhpcy53b3JsZC5zZXRIZWlnaHQodGhpcy52aWV3Qm94SGVpZ2h0ICogdGhpcy5yYXRpbyk7XG5cblx0Ly90ZW1wXG5cdHRoaXMuZWxlbWVudHNRdWVyeSA9ICdnOm5vdChbaWQqPVwiZGVjb3JhdGlvblwiXSk+JyArIG9ubHlEcmF3aW5nRWxlbWVudHMgKyAnLCcgKyAnc3ZnPicgKyBvbmx5RHJhd2luZ0VsZW1lbnRzO1xuXHQvLyB0aGlzLmVsZW1lbnRzUXVlcnkgPSAnKjpub3QoZGVmcyk6bm90KGcpOm5vdCh0aXRsZSk6bm90KGxpbmVhckdyYWRpZW50KTpub3QocmFkaWFsR3JhZGllbnQpOm5vdChzdG9wKTpub3QoW2lkKj1cImpvaW50XCJdKTpub3QoW2lkKj1cImNvbnN0cmFpbnRcIl0pJztcblx0dmFyIGVsZW1SYXdzID0gdGhpcy5TVkcucXVlcnlTZWxlY3RvckFsbCh0aGlzLmVsZW1lbnRzUXVlcnkpO1xuXG5cdHZhciBpID0gMDtcblx0dmFyIHJhd0dyb3VwUGFpcmluZ3MgPSBbXTtcblx0dmFyIGVsZW1zTGVuZ3RoID0gZWxlbVJhd3MubGVuZ3RoO1xuXG5cdGZvciAoaSA9IDA7IGkgPCBlbGVtc0xlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIHJhd0VsZW1lbnQgPSBlbGVtUmF3c1tpXTtcblx0XHQvL2lmIChyYXdFbGVtZW50Lm5vZGVUeXBlID09PSAzKSB7IGNvbnRpbnVlOyB9XG5cdFx0dmFyIGdyb3VwSW5mb3MgPSB0aGlzLmdldEdyb3VwSW5mb3MocmF3RWxlbWVudCk7XG5cdFx0dmFyIGN1cnJHcm91cCA9ICR3b3JsZC5jcmVhdGVHcm91cChncm91cEluZm9zLnR5cGUsIGdyb3VwSW5mb3MuSUQpO1xuXHRcdGN1cnJHcm91cC5yYXdTVkdFbGVtZW50ID0gcmF3RWxlbWVudDtcblxuXHRcdHZhciBkcmF3aW5nQ29tbWFuZHMgPSB0aGlzLnBhcnNlRWxlbWVudChyYXdFbGVtZW50KTtcblx0XHRjdXJyR3JvdXAuc3RydWN0dXJlLmNyZWF0ZShkcmF3aW5nQ29tbWFuZHMpO1xuXHRcdHZhciBvYmplY3REcmF3aW5nID0gT2JqZWN0RHJhd2luZy5jcmVhdGUoY3Vyckdyb3VwKTtcblx0XHRvYmplY3REcmF3aW5nLnNldENvbW1hbmRzKCk7XG5cdFx0Y3Vyckdyb3VwLmRyYXdpbmcgPSBvYmplY3REcmF3aW5nO1xuXHRcdHRoaXMud29ybGQuYWRkRHJhd2luZyhvYmplY3REcmF3aW5nKTtcblx0XHR0aGlzLnNldEdyYXBoaWNJbnN0cnVjdGlvbnMob2JqZWN0RHJhd2luZywgcmF3RWxlbWVudCwgZHJhd2luZ0NvbW1hbmRzKTtcblxuXHRcdHRoaXMucGFyc2VEZWNvcmF0aW9uKGN1cnJHcm91cCwgcmF3RWxlbWVudCk7XG5cdFx0cmF3R3JvdXBQYWlyaW5ncy5wdXNoKHsgZ3JvdXA6IGN1cnJHcm91cCwgcmF3OiByYXdFbGVtZW50LnBhcmVudE5vZGUgfSk7XG5cdH1cblxuXHR0aGlzLnBhcnNlQ29uc3RyYWludHMoKTtcblx0dGhpcy5wYXJzZUN1c3RvbUpvaW50cygpO1xuXG5cdHRoaXMud29ybGQuYWRkR3JvdXBzVG9Xb3JsZCgpO1xufTtcblxuU1ZHUGFyc2VyLnByb3RvdHlwZS5wYXJzZURlY29yYXRpb24gPSBmdW5jdGlvbiAoJGdyb3VwLCAkcmF3RWxlbWVudClcbntcblx0dmFyIHJhd0NoaWxkcmVuID0gJHJhd0VsZW1lbnQucGFyZW50Tm9kZS5jaGlsZE5vZGVzOy8vKCdbaWQ9XCJkZWNvcmF0aW9uXCJdIDpub3QoZyknKTtcblx0Ly9pZiAoIWRlY29yYXRpb25SYXdFbGVtZW50cykgeyByZXR1cm47IH1cblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIHJhd0NoaWxkID0gcmF3Q2hpbGRyZW5baV07XG5cdFx0aWYgKHJhd0NoaWxkLm5vZGVUeXBlID09PSAzKSB7IGNvbnRpbnVlOyB9XG5cdFx0aWYgKC9kZWNvcmF0aW9uLy50ZXN0KHJhd0NoaWxkLmlkKSlcblx0XHR7XG5cdFx0XHR2YXIgcmF3RWxlbWVudHMgPSByYXdDaGlsZC5xdWVyeVNlbGVjdG9yQWxsKG9ubHlEcmF3aW5nRWxlbWVudHMpO1xuXHRcdFx0aWYgKCFyYXdFbGVtZW50cykgeyBjb250aW51ZTsgfVxuXHRcdFx0Zm9yICh2YXIgayA9IDAsIHJhd0VsZW1lbnRzTGVuZ3RoID0gcmF3RWxlbWVudHMubGVuZ3RoOyBrIDwgcmF3RWxlbWVudHNMZW5ndGg7IGsgKz0gMSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIHJhd0VsZW1lbnQgPSByYXdFbGVtZW50c1trXTtcblx0XHRcdFx0dmFyIGRyYXdpbmdDb21tYW5kcyA9IHRoaXMucGFyc2VFbGVtZW50KHJhd0VsZW1lbnQpO1xuXHRcdFx0XHR2YXIgZGVjb3JhdGlvbkRyYXdpbmcgPSAkZ3JvdXAucGh5c2ljc01hbmFnZXIuZ2V0RGVjb3JhdGlvbkRyYXdpbmcoJGdyb3VwKTtcblx0XHRcdFx0ZGVjb3JhdGlvbkRyYXdpbmcuc2V0RHJhd2luZ0NvbW1hbmRzKGRyYXdpbmdDb21tYW5kcyk7XG5cdFx0XHRcdHRoaXMuc2V0R3JhcGhpY0luc3RydWN0aW9ucyhkZWNvcmF0aW9uRHJhd2luZywgcmF3RWxlbWVudCwgZHJhd2luZ0NvbW1hbmRzKTtcblx0XHRcdFx0dGhpcy53b3JsZC5hZGREcmF3aW5nKGRlY29yYXRpb25EcmF3aW5nKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuU1ZHUGFyc2VyLnByb3RvdHlwZS5nZXRHcm91cEluZm9zID0gZnVuY3Rpb24gKCRyYXdHcm91cClcbntcblx0dmFyIGdyb3VwRWxlbWVudCA9ICghJHJhd0dyb3VwLmlkIHx8ICRyYXdHcm91cC5pZC5pbmRleE9mKCdzdmcnKSA9PT0gMCkgJiYgJHJhd0dyb3VwLnBhcmVudE5vZGUudGFnTmFtZSAhPT0gJ3N2ZycgPyAkcmF3R3JvdXAucGFyZW50Tm9kZSA6ICRyYXdHcm91cDtcblx0dmFyIHR5cGU7XG5cdHZhciBJRDtcblx0dmFyIHJlZ2V4ID0gLyhbYS16XFxkXSspXFx3Ki9pZ207XG5cdHZhciBmaXJzdCA9IHJlZ2V4LmV4ZWMoZ3JvdXBFbGVtZW50LmlkKTtcblx0dmFyIHNlY29uZCA9IHJlZ2V4LmV4ZWMoZ3JvdXBFbGVtZW50LmlkKTtcblxuXHR0eXBlID0gZmlyc3QgPyBmaXJzdFsxXSA6IHVuZGVmaW5lZDtcblx0SUQgPSBzZWNvbmQgPyBzZWNvbmRbMV0gOiBudWxsO1xuXHR2YXIgdGl0bGUgPSBncm91cEVsZW1lbnQucXVlcnlTZWxlY3RvcigndGl0bGUnKTtcblx0aWYgKElEID09PSBudWxsKSB7IElEID0gdGl0bGUgPyB0aXRsZS5ub2RlVmFsdWUgOiBJRDsgfVxuXG5cdHJldHVybiB7IElEOiBJRCwgdHlwZTogdHlwZSB9O1xufTtcblxuU1ZHUGFyc2VyLnByb3RvdHlwZS5nZXRQb2ludHMgPSBmdW5jdGlvbiAoJHBvaW50Q29tbWFuZHMpXG57XG5cdHZhciBwb2ludHMgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9ICRwb2ludENvbW1hbmRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJQb2ludENvbW1hbmQgPSAkcG9pbnRDb21tYW5kc1tpXTtcblx0XHRwb2ludHMucHVzaChjdXJyUG9pbnRDb21tYW5kLnBvaW50KTtcblx0fVxuXHRyZXR1cm4gcG9pbnRzO1xufTtcblxuU1ZHUGFyc2VyLnByb3RvdHlwZS5nZXRHcm91cEZyb21SYXdTVkdFbGVtZW50ID0gZnVuY3Rpb24gKCRyYXcpXG57XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLndvcmxkLmdyb3Vwcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJyR3JvdXAgPSB0aGlzLndvcmxkLmdyb3Vwc1tpXTtcblx0XHRpZiAoY3Vyckdyb3VwLnJhd1NWR0VsZW1lbnQgPT09ICRyYXcpIHsgcmV0dXJuIGN1cnJHcm91cDsgfVxuXHR9XG59O1xuXG5TVkdQYXJzZXIucHJvdG90eXBlLnBhcnNlQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoKVxue1xuXHR2YXIgcmF3Q29uc3RyYWludHMgPSB0aGlzLlNWRy5xdWVyeVNlbGVjdG9yQWxsKCdbaWQqPVwiY29uc3RyYWludFwiXScpO1xuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gcmF3Q29uc3RyYWludHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3VyclJhd0NvbnN0cmFpbnQgPSByYXdDb25zdHJhaW50c1tpXTtcblx0XHR2YXIgcmF3RWxlbWVudHMgPSBjdXJyUmF3Q29uc3RyYWludC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5lbGVtZW50c1F1ZXJ5KTtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5nZXRQb2ludHModGhpcy5wYXJzZUVsZW1lbnQoY3VyclJhd0NvbnN0cmFpbnQpLnBvaW50Q29tbWFuZHMpO1xuXHRcdHZhciByZXN1bHQgPSAvY29uc3RyYWludC0oW2EtelxcZF0qKS0/KFthLXpcXGRdKik/L2lnLmV4ZWMoY3VyclJhd0NvbnN0cmFpbnQuaWQpO1xuXHRcdHZhciBwYXJlbnRHcm91cElEID0gcmVzdWx0ID8gcmVzdWx0WzFdIDogdW5kZWZpbmVkO1xuXHRcdGlmIChwYXJlbnRHcm91cElEID09PSAnd29ybGQnKSB7IHBhcmVudEdyb3VwSUQgPSB1bmRlZmluZWQ7IH1cblx0XHR2YXIgY29uc3RyYWludFR5cGUgPSByZXN1bHQgJiYgcmVzdWx0WzJdID8gcmVzdWx0WzJdIDogJ2RlZmF1bHQnO1xuXHRcdHZhciBwYXJlbnRHcm91cCA9IHBhcmVudEdyb3VwSUQgPyB0aGlzLndvcmxkLmdldEdyb3VwQnlJRChwYXJlbnRHcm91cElEKSA6IHVuZGVmaW5lZDtcblxuXHRcdGZvciAodmFyIGsgPSAwLCByYXdFbGVtZW50c0xlbmd0aCA9IHJhd0VsZW1lbnRzLmxlbmd0aDsgayA8IHJhd0VsZW1lbnRzTGVuZ3RoOyBrICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJSYXdFbGVtZW50ID0gcmF3RWxlbWVudHNba107XG5cdFx0XHR2YXIgZ3JvdXAgPSB0aGlzLmdldEdyb3VwRnJvbVJhd1NWR0VsZW1lbnQoY3VyclJhd0VsZW1lbnQpO1xuXHRcdFx0Ly9jb25zb2xlLmxvZyhncm91cCk7XG5cdFx0XHR0cnlcblx0XHRcdHtcblx0XHRcdFx0dGhpcy53b3JsZC5jb25zdHJhaW5Hcm91cHMoZ3JvdXAsIHBhcmVudEdyb3VwLCBwb2ludHMsIGNvbnN0cmFpbnRUeXBlKTtcblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ2NvbnN0cmFpbmluZyBwcm9ibGVtJywgZ3JvdXAudHlwZSwgZ3JvdXAuSUQpO1xuXHRcdFx0XHRjb25zb2xlLmxvZyhlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUucGFyc2VDdXN0b21Kb2ludHMgPSBmdW5jdGlvbiAoKVxue1xuXHR2YXIgcmF3Sm9pbnQgPSB0aGlzLlNWRy5xdWVyeVNlbGVjdG9yQWxsKCdbaWQqPVwiam9pbnRcIl0nKTtcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHJhd0pvaW50Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJSYXdKb2ludCA9IHJhd0pvaW50W2ldO1xuXHRcdHZhciByYXdFbGVtZW50cyA9IGN1cnJSYXdKb2ludC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5lbGVtZW50c1F1ZXJ5KTtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5nZXRQb2ludHModGhpcy5wYXJzZUVsZW1lbnQoY3VyclJhd0pvaW50KS5wb2ludENvbW1hbmRzKTtcblx0XHR2YXIgcmVzdWx0ID0gL2pvaW50LShbYS16XFxkXSopL2lnLmV4ZWMoY3VyclJhd0pvaW50LmlkKTtcblx0XHR2YXIgdHlwZSA9IHJlc3VsdCA/IHJlc3VsdFsxXSA6IHVuZGVmaW5lZDtcblxuXHRcdGZvciAodmFyIGsgPSAwLCByYXdFbGVtZW50c0xlbmd0aCA9IHJhd0VsZW1lbnRzLmxlbmd0aDsgayA8IHJhd0VsZW1lbnRzTGVuZ3RoOyBrICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJSYXdFbGVtZW50ID0gcmF3RWxlbWVudHNba107XG5cdFx0XHR2YXIgZ3JvdXAgPSB0aGlzLmdldEdyb3VwRnJvbVJhd1NWR0VsZW1lbnQoY3VyclJhd0VsZW1lbnQpO1xuXHRcdFx0dmFyIG5vZGVBID0gZ3JvdXAuZ2V0Tm9kZUF0UG9pbnQocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuXHRcdFx0dmFyIG5vZGVCID0gZ3JvdXAuZ2V0Tm9kZUF0UG9pbnQocG9pbnRzWzFdWzBdLCBwb2ludHNbMV1bMV0pO1xuXHRcdFx0Z3JvdXAuY3JlYXRlSm9pbnQobm9kZUEsIG5vZGVCLCB0eXBlLCB0cnVlKTtcblx0XHRcdC8vY29uc29sZS5sb2coZ3JvdXApO1xuXHRcdFx0Ly90aGlzLndvcmxkLmNvbnN0cmFpbkdyb3Vwcyhncm91cCwgcGFyZW50R3JvdXAsIHBvaW50cyk7XG5cdFx0fVxuXHR9XG5cdC8vIHZhciBjaGlsZHJlbiA9ICRyYXdHcm91cC5jaGlsZE5vZGVzOy8vJHJhd0dyb3VwLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZCo9XCJjb25zdHJhaW50XCJdJyk7XG5cblx0Ly8gZm9yICh2YXIgaSA9IDAsIGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkgKz0gMSlcblx0Ly8ge1xuXHQvLyBcdGlmIChjaGlsZHJlbltpXS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgfHwgY2hpbGRyZW5baV0uaWQuc2VhcmNoKC9qb2ludC9pKSA8IDApIHsgY29udGludWU7IH1cblxuXHQvLyBcdHZhciBjdXJyUmF3Sm9pbnQgPSBjaGlsZHJlbltpXTtcblx0Ly8gXHR2YXIgcDF4ID0gdGhpcy5nZXRDb29yZChjdXJyUmF3Sm9pbnQuZ2V0QXR0cmlidXRlKCd4MScpKTtcblx0Ly8gXHR2YXIgcDF5ID0gdGhpcy5nZXRDb29yZChjdXJyUmF3Sm9pbnQuZ2V0QXR0cmlidXRlKCd5MScpKTtcblx0Ly8gXHR2YXIgcDJ4ID0gdGhpcy5nZXRDb29yZChjdXJyUmF3Sm9pbnQuZ2V0QXR0cmlidXRlKCd4MicpKTtcblx0Ly8gXHR2YXIgcDJ5ID0gdGhpcy5nZXRDb29yZChjdXJyUmF3Sm9pbnQuZ2V0QXR0cmlidXRlKCd5MicpKTtcblxuXHQvLyBcdHZhciBuMSA9ICRncm91cC5nZXROb2RlQXRQb2ludChwMXgsIHAxeSkgfHwgJGdyb3VwLmNyZWF0ZU5vZGUocDF4LCBwMXkpO1xuXHQvLyBcdHZhciBuMiA9ICRncm91cC5nZXROb2RlQXRQb2ludChwMngsIHAyeSkgfHwgJGdyb3VwLmNyZWF0ZU5vZGUocDJ4LCBwMnkpO1xuXHQvLyBcdCRncm91cC5jcmVhdGVKb2ludChuMSwgbjIpO1xuXHQvLyB9XG59O1xuXG5TVkdQYXJzZXIucHJvdG90eXBlLnBhcnNlRWxlbWVudCA9IGZ1bmN0aW9uICgkcmF3RWxlbWVudClcbntcblx0dmFyIHRhZ05hbWUgPSAkcmF3RWxlbWVudC50YWdOYW1lO1xuXG5cdHN3aXRjaCAodGFnTmFtZSlcblx0e1xuXHRcdGNhc2UgJ2xpbmUnOlxuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2VMaW5lKCRyYXdFbGVtZW50KTtcblx0XHRjYXNlICdyZWN0Jzpcblx0XHRcdHJldHVybiB0aGlzLnBhcnNlUmVjdCgkcmF3RWxlbWVudCk7XG5cblx0XHRjYXNlICdwb2x5Z29uJzpcblx0XHRjYXNlICdwb2x5bGluZSc6XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZVBvbHkoJHJhd0VsZW1lbnQpO1xuXG5cdFx0Y2FzZSAncGF0aCc6XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZVBhdGgoJHJhd0VsZW1lbnQpO1xuXG5cdFx0Y2FzZSAnY2lyY2xlJzpcblx0XHRjYXNlICdlbGxpcHNlJzpcblx0XHRcdHJldHVybiB0aGlzLnBhcnNlQ2lyY2xlKCRyYXdFbGVtZW50KTtcblx0fVxufTtcblxuU1ZHUGFyc2VyLnByb3RvdHlwZS5zZXRHcmFwaGljSW5zdHJ1Y3Rpb25zID0gZnVuY3Rpb24gKCRkcmF3aW5nLCAkcmF3LCAkZHJhd2luZ0NvbW1hbmRzKVxue1xuXHQvL2RyYXdpbmcuY29tbWFuZHMgPSAkbm9kZXNUb0RyYXc7XG5cdHZhciBwcm9wcyA9IHt9O1xuXHQvL3NvcnRpbmcgbm9kZXNUb0RyYXcgc28gdGhlIHBhdGggaXMgZHJhd24gY29ycmVjdGx5XG5cdC8vIHZhciBzdGFydDtcblx0Ly8gZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9ICRub2Rlc1RvRHJhdy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0Ly8ge1xuXHQvLyBcdHZhciBjdXJyTm9kZSA9ICRub2Rlc1RvRHJhd1tpXTtcblx0Ly8gXHRpZiAoY3Vyck5vZGUuZHJhd2luZy5jb21tYW5kID09PSBNT1ZFX1RPIHx8IGkgPT09IGxlbmd0aCAtIDEpXG5cdC8vIFx0e1xuXHQvLyBcdFx0aWYgKHN0YXJ0KSB7IHN0YXJ0LmRyYXdpbmcuZW5kTm9kZSA9IGN1cnJOb2RlOyB9XG5cdC8vIFx0XHRzdGFydCA9IGN1cnJOb2RlO1xuXHQvLyBcdH1cblxuXHQvLyBcdCRncm91cC5ub2Rlcy5zcGxpY2UoJGdyb3VwLm5vZGVzLmluZGV4T2YoY3Vyck5vZGUpLCAxKTtcblx0Ly8gXHQkZ3JvdXAubm9kZXMuc3BsaWNlKGksIDAsIGN1cnJOb2RlKTtcblx0Ly8gfVxuXG5cdHZhciByYXdGaWxsID0gJHJhdy5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKTtcblx0dmFyIHJhd1N0cm9rZSA9ICRyYXcuZ2V0QXR0cmlidXRlKCdzdHJva2UnKTtcblx0dmFyIHJhd0xpbmVjYXAgPSAkcmF3LmdldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnKTtcblx0dmFyIHJhd0xpbmVqb2luID0gJHJhdy5nZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicpO1xuXHR2YXIgcmF3T3BhY2l0eSA9ICRyYXcuZ2V0QXR0cmlidXRlKCdvcGFjaXR5Jyk7XG5cblx0cHJvcHMuZmlsbCA9IHJhd0ZpbGwgfHwgJyMwMDAwMDAnO1xuXHRwcm9wcy5saW5lV2lkdGggPSB0aGlzLmdldFRoaWNrbmVzcygkcmF3KTsvL3Jhd1N0cm9rZVdpZHRoICogdGhpcy5yYXRpbyB8fCAwO1xuXHRwcm9wcy5zdHJva2UgPSByYXdTdHJva2UgJiYgcHJvcHMubGluZVdpZHRoICE9PSAwID8gcmF3U3Ryb2tlIDogJ25vbmUnO1xuXHRwcm9wcy5saW5lQ2FwID0gcmF3TGluZWNhcCAmJiByYXdMaW5lY2FwICE9PSAnbnVsbCcgPyByYXdMaW5lY2FwIDogJ2J1dHQnO1xuXHRwcm9wcy5saW5lSm9pbiA9IHJhd0xpbmVqb2luICYmIHJhd0xpbmVqb2luICE9PSAnbnVsbCcgPyByYXdMaW5lam9pbiA6ICdtaXRlcic7XG5cdHByb3BzLm9wYWNpdHkgPSByYXdPcGFjaXR5ICE9PSBudWxsID8gTnVtYmVyKHJhd09wYWNpdHkpIDogMTtcblxuXHRwcm9wcy5jbG9zZVBhdGggPSAkZHJhd2luZ0NvbW1hbmRzLmNsb3NlUGF0aDtcblxuXHRwcm9wcy5yYWRpdXNYID0gJGRyYXdpbmdDb21tYW5kcy5yYWRpdXNYO1xuXHRwcm9wcy5yYWRpdXNZID0gJGRyYXdpbmdDb21tYW5kcy5yYWRpdXNZO1xuXG5cdHByb3BzLnN0cm9rZUdyYWRpZW50ID0gdGhpcy5nZXRHcmFkaWVudChwcm9wcy5zdHJva2UpO1xuXHRwcm9wcy5maWxsR3JhZGllbnQgPSB0aGlzLmdldEdyYWRpZW50KHByb3BzLmZpbGwpO1xuXG5cdCRkcmF3aW5nLnNldFByb3BlcnRpZXMocHJvcHMpO1xufTtcblxuU1ZHUGFyc2VyLnByb3RvdHlwZS5nZXRHcmFkaWVudCA9IGZ1bmN0aW9uICgkdmFsdWUpXG57XG5cdHZhciBncmFkaWVudElEID0gL3VybFxcKCMoLiopXFwpL2ltLmV4ZWMoJHZhbHVlKTtcblx0aWYgKGdyYWRpZW50SUQpXG5cdHtcblx0XHR2YXIgZ3JhZGllbnRFbGVtZW50ID0gdGhpcy5TVkcucXVlcnlTZWxlY3RvcignIycgKyBncmFkaWVudElEWzFdKTtcblx0XHR2YXIgbSA9IHRoaXMuZ2V0TWF0cml4KGdyYWRpZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VHJhbnNmb3JtJykpO1xuXG5cdFx0aWYgKGdyYWRpZW50RWxlbWVudC50YWdOYW1lICE9PSAnbGluZWFyR3JhZGllbnQnICYmIGdyYWRpZW50RWxlbWVudC50YWdOYW1lICE9PSAncmFkaWFsR3JhZGllbnQnKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGdyYWRpZW50ID0geyBzdG9wczogW10sIHR5cGU6IGdyYWRpZW50RWxlbWVudC50YWdOYW1lIH07XG5cblx0XHRpZiAoZ3JhZGllbnRFbGVtZW50LnRhZ05hbWUgPT09ICdsaW5lYXJHcmFkaWVudCcpXG5cdFx0e1xuXHRcdFx0Z3JhZGllbnQueDEgPSB0aGlzLmdldENvb3JkKGdyYWRpZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3gxJykpO1xuXHRcdFx0Z3JhZGllbnQueTEgPSB0aGlzLmdldENvb3JkKGdyYWRpZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3kxJykpO1xuXHRcdFx0Z3JhZGllbnQueDIgPSB0aGlzLmdldENvb3JkKGdyYWRpZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3gyJykpO1xuXHRcdFx0Z3JhZGllbnQueTIgPSB0aGlzLmdldENvb3JkKGdyYWRpZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3kyJykpO1xuXG5cdFx0XHRpZiAobSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIHAxID0gdGhpcy5tdWx0aXBseVBvaW50QnlNYXRyaXgoW2dyYWRpZW50LngxLCBncmFkaWVudC55MV0sIG0pO1xuXHRcdFx0XHR2YXIgcDIgPSB0aGlzLm11bHRpcGx5UG9pbnRCeU1hdHJpeChbZ3JhZGllbnQueDIsIGdyYWRpZW50LnkyXSwgbSk7XG5cblx0XHRcdFx0Z3JhZGllbnQueDEgPSBwMVswXTtcblx0XHRcdFx0Z3JhZGllbnQueTEgPSBwMVsxXTtcblx0XHRcdFx0Z3JhZGllbnQueDIgPSBwMlswXTtcblx0XHRcdFx0Z3JhZGllbnQueTIgPSBwMlsxXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGdyYWRpZW50RWxlbWVudC50YWdOYW1lID09PSAncmFkaWFsR3JhZGllbnQnKVxuXHRcdHtcblx0XHRcdGdyYWRpZW50LmN4ID0gdGhpcy5nZXRDb29yZChncmFkaWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjeCcpKTtcblx0XHRcdGdyYWRpZW50LmN5ID0gdGhpcy5nZXRDb29yZChncmFkaWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjeScpKTtcblx0XHRcdGdyYWRpZW50LmZ4ID0gZ3JhZGllbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZngnKSA/IHRoaXMuZ2V0Q29vcmQoZ3JhZGllbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZngnKSkgOiBncmFkaWVudC5jeDtcblx0XHRcdGdyYWRpZW50LmZ5ID0gZ3JhZGllbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZnknKSA/IHRoaXMuZ2V0Q29vcmQoZ3JhZGllbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZnknKSkgOiBncmFkaWVudC5jeTtcblx0XHRcdGdyYWRpZW50LnIgPSB0aGlzLmdldENvb3JkKGdyYWRpZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3InKSk7XG5cblx0XHRcdGlmIChtKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgYyA9IHRoaXMubXVsdGlwbHlQb2ludEJ5TWF0cml4KFtncmFkaWVudC5jeCwgZ3JhZGllbnQuY3ldLCBtKTtcblx0XHRcdFx0dmFyIGYgPSB0aGlzLm11bHRpcGx5UG9pbnRCeU1hdHJpeChbZ3JhZGllbnQuZngsIGdyYWRpZW50LmZ5XSwgbSk7XG5cblx0XHRcdFx0Z3JhZGllbnQuY3ggPSBjWzBdO1xuXHRcdFx0XHRncmFkaWVudC5jeSA9IGNbMV07XG5cdFx0XHRcdGdyYWRpZW50LmZ4ID0gZlswXTtcblx0XHRcdFx0Z3JhZGllbnQuZnkgPSBmWzFdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBzdG9wcyA9IGdyYWRpZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdG9wJyk7XG5cdFx0Zm9yICh2YXIgayA9IDAsIHN0b3BMZW5ndGggPSBzdG9wcy5sZW5ndGg7IGsgPCBzdG9wTGVuZ3RoOyBrICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJTdG9wID0gc3RvcHNba107XG5cdFx0XHR2YXIgb2Zmc2V0ID0gTnVtYmVyKGN1cnJTdG9wLmdldEF0dHJpYnV0ZSgnb2Zmc2V0JykpO1xuXHRcdFx0dmFyIGNvbG9yUmVnZXhSZXN1bHQgPSAvc3RvcC1jb2xvcjooLis/KSg7fCQpL2cuZXhlYyhjdXJyU3RvcC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpO1xuXHRcdFx0dmFyIGNvbG9yID0gY3VyclN0b3AuZ2V0QXR0cmlidXRlKCdzdG9wLWNvbG9yJykgfHwgKGNvbG9yUmVnZXhSZXN1bHQgPyBjb2xvclJlZ2V4UmVzdWx0WzFdIDogdW5kZWZpbmVkKTtcblx0XHRcdHZhciBvcGFjaXR5UmVnZXhSZXN1bHQgPSAvc3RvcC1vcGFjaXR5OihbXFxkLi1dKykvZy5leGVjKGN1cnJTdG9wLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSk7XG5cdFx0XHR2YXIgb3BhY2l0eSA9IGN1cnJTdG9wLmdldEF0dHJpYnV0ZSgnc3RvcC1vcGFjaXR5JykgfHwgKG9wYWNpdHlSZWdleFJlc3VsdCA/IG9wYWNpdHlSZWdleFJlc3VsdFsxXSA6IDEpO1xuXHRcdFx0aWYgKGNvbG9yLmluZGV4T2YoJyMnKSA+IC0xKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgUiA9IHBhcnNlSW50KGNvbG9yLnN1YnN0cigxLCAyKSwgMTYpO1xuXHRcdFx0XHR2YXIgRyA9IHBhcnNlSW50KGNvbG9yLnN1YnN0cigzLCAyKSwgMTYpO1xuXHRcdFx0XHR2YXIgQiA9IHBhcnNlSW50KGNvbG9yLnN1YnN0cig1LCAyKSwgMTYpO1xuXHRcdFx0XHRjb2xvciA9ICdyZ2JhKCcgKyBSICsgJywnICsgRyArICcsJyArIEIgKyAnLCcgKyBvcGFjaXR5ICsgJyknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbG9yLmluZGV4T2YoJ3JnYignKSA+IC0xKSB7IGNvbG9yID0gJ3JnYmEnICsgY29sb3Iuc3Vic3RyaW5nKDQsIC0xKSArICcsJyArIG9wYWNpdHkgKyAnKSc7IH1cblx0XHRcdGlmIChjb2xvci5pbmRleE9mKCdoc2woJykgPiAtMSkgeyBjb2xvciA9ICdoc2xhJyArIGNvbG9yLnN1YnN0cmluZyg0LCAtMSkgKyAnLCcgKyBvcGFjaXR5ICsgJyknOyB9XG5cdFx0XHRncmFkaWVudC5zdG9wcy5wdXNoKHsgb2Zmc2V0OiBvZmZzZXQsIGNvbG9yOiBjb2xvciwgb3BhY2l0eTogb3BhY2l0eSB9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZ3JhZGllbnQ7XG5cdH1cbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUucGFyc2VDaXJjbGUgPSBmdW5jdGlvbiAoJHJhd0NpcmNsZSlcbntcblx0dmFyIHhQb3MgPSB0aGlzLmdldENvb3JkKCRyYXdDaXJjbGUuZ2V0QXR0cmlidXRlKCdjeCcpIHx8IDApO1xuXHR2YXIgeVBvcyA9IHRoaXMuZ2V0Q29vcmQoJHJhd0NpcmNsZS5nZXRBdHRyaWJ1dGUoJ2N5JykgfHwgMCk7XG5cdHZhciByYWRpdXNBdHRyWCA9ICRyYXdDaXJjbGUuZ2V0QXR0cmlidXRlKCdyJykgfHwgJHJhd0NpcmNsZS5nZXRBdHRyaWJ1dGUoJ3J4Jyk7XG5cdHZhciByYWRpdXNBdHRyWSA9ICRyYXdDaXJjbGUuZ2V0QXR0cmlidXRlKCdyeScpO1xuXHR2YXIgcmFkaXVzWCA9IHRoaXMuZ2V0Q29vcmQocmFkaXVzQXR0clgpO1xuXHR2YXIgcmFkaXVzWSA9IHRoaXMuZ2V0Q29vcmQocmFkaXVzQXR0clkpIHx8IHJhZGl1c1g7XG5cdHZhciByb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oJHJhd0NpcmNsZS5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpKTtcblx0dmFyIHBvaW50Q29tbWFuZHMgPSBbeyBuYW1lOiByYWRpdXNZICE9PSByYWRpdXNYID8gRUxMSVBTRSA6IENJUkNMRSwgcG9pbnQ6IFt4UG9zLCB5UG9zXSwgb3B0aW9uczogW3JhZGl1c1gsIHJhZGl1c1ksIHJvdGF0aW9uXSB9XTtcblx0cmV0dXJuIHsgdHlwZTogJ2VsbGlwc2UnLCBwb2ludENvbW1hbmRzOiBwb2ludENvbW1hbmRzLCByYWRpdXNYOiByYWRpdXNYLCByYWRpdXNZOiByYWRpdXNZLCBjbG9zZVBhdGg6IGZhbHNlLCB0aGlja25lc3M6IHRoaXMuZ2V0VGhpY2tuZXNzKCRyYXdDaXJjbGUpIH07XG59O1xuXG5TVkdQYXJzZXIucHJvdG90eXBlLnBhcnNlTGluZSA9IGZ1bmN0aW9uICgkcmF3TGluZSlcbntcblx0dmFyIHgxID0gdGhpcy5nZXRDb29yZCgkcmF3TGluZS5nZXRBdHRyaWJ1dGUoJ3gxJykpO1xuXHR2YXIgeDIgPSB0aGlzLmdldENvb3JkKCRyYXdMaW5lLmdldEF0dHJpYnV0ZSgneDInKSk7XG5cdHZhciB5MSA9IHRoaXMuZ2V0Q29vcmQoJHJhd0xpbmUuZ2V0QXR0cmlidXRlKCd5MScpKTtcblx0dmFyIHkyID0gdGhpcy5nZXRDb29yZCgkcmF3TGluZS5nZXRBdHRyaWJ1dGUoJ3kyJykpO1xuXHR2YXIgcG9pbnRDb21tYW5kcyA9IFtdO1xuXHRwb2ludENvbW1hbmRzLnB1c2goeyBuYW1lOiBNT1ZFX1RPLCBwb2ludDogW3gxLCB5MV0sIG9wdGlvbnM6IFtdIH0pO1xuXHRwb2ludENvbW1hbmRzLnB1c2goeyBuYW1lOiBMSU5FX1RPLCBwb2ludDogW3gyLCB5Ml0sIG9wdGlvbnM6IFtdIH0pO1xuXHRyZXR1cm4geyB0eXBlOiAnbGluZScsIHBvaW50Q29tbWFuZHM6IHBvaW50Q29tbWFuZHMsIGNsb3NlUGF0aDogZmFsc2UsIHRoaWNrbmVzczogdGhpcy5nZXRUaGlja25lc3MoJHJhd0xpbmUpIH07XG59O1xuXG5TVkdQYXJzZXIucHJvdG90eXBlLnBhcnNlUmVjdCA9IGZ1bmN0aW9uICgkcmF3UmVjdClcbntcblx0dmFyIHgxID0gJHJhd1JlY3QuZ2V0QXR0cmlidXRlKCd4JykgPyB0aGlzLmdldENvb3JkKCRyYXdSZWN0LmdldEF0dHJpYnV0ZSgneCcpKSA6IDA7XG5cdHZhciB5MSA9ICRyYXdSZWN0LmdldEF0dHJpYnV0ZSgneScpID8gdGhpcy5nZXRDb29yZCgkcmF3UmVjdC5nZXRBdHRyaWJ1dGUoJ3knKSkgOiAwO1xuXHR2YXIgeDIgPSB4MSArIHRoaXMuZ2V0Q29vcmQoJHJhd1JlY3QuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKTtcblx0dmFyIHkyID0geTEgKyB0aGlzLmdldENvb3JkKCRyYXdSZWN0LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpO1xuXG5cdHZhciBwb2ludHMgPVxuXHRbXG5cdFx0W3gxLCB5MV0sXG5cdFx0W3gxLCB5Ml0sXG5cdFx0W3gyLCB5Ml0sXG5cdFx0W3gyLCB5MV1cblx0XTtcblxuXHR2YXIgbSA9IHRoaXMuZ2V0TWF0cml4KCRyYXdSZWN0LmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykpO1xuXHRpZiAobSlcblx0e1xuXHRcdHBvaW50cyA9XG5cdFx0W1xuXHRcdFx0dGhpcy5tdWx0aXBseVBvaW50QnlNYXRyaXgocG9pbnRzWzBdLCBtKSxcblx0XHRcdHRoaXMubXVsdGlwbHlQb2ludEJ5TWF0cml4KHBvaW50c1sxXSwgbSksXG5cdFx0XHR0aGlzLm11bHRpcGx5UG9pbnRCeU1hdHJpeChwb2ludHNbMl0sIG0pLFxuXHRcdFx0dGhpcy5tdWx0aXBseVBvaW50QnlNYXRyaXgocG9pbnRzWzNdLCBtKVxuXHRcdF07XG5cdH1cblxuXHR2YXIgcG9pbnRDb21tYW5kcyA9IFtdO1xuXHRwb2ludENvbW1hbmRzLnB1c2goeyBuYW1lOiBNT1ZFX1RPLCBwb2ludDogcG9pbnRzWzBdLCBvcHRpb25zOiBbXSB9KTtcblx0cG9pbnRDb21tYW5kcy5wdXNoKHsgbmFtZTogTElORV9UTywgcG9pbnQ6IHBvaW50c1sxXSwgb3B0aW9uczogW10gfSk7XG5cdHBvaW50Q29tbWFuZHMucHVzaCh7IG5hbWU6IExJTkVfVE8sIHBvaW50OiBwb2ludHNbMl0sIG9wdGlvbnM6IFtdIH0pO1xuXHRwb2ludENvbW1hbmRzLnB1c2goeyBuYW1lOiBMSU5FX1RPLCBwb2ludDogcG9pbnRzWzNdLCBvcHRpb25zOiBbXSB9KTtcblxuXHRyZXR1cm4geyB0eXBlOiAncG9seWdvbicsIHBvaW50Q29tbWFuZHM6IHBvaW50Q29tbWFuZHMsIGNsb3NlUGF0aDogdHJ1ZSwgdGhpY2tuZXNzOiB0aGlzLmdldFRoaWNrbmVzcygkcmF3UmVjdCkgfTtcbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUucGFyc2VQb2x5ID0gZnVuY3Rpb24gKCRyYXdQb2x5KVxue1xuXHR2YXIgcmVnZXggPSAvKFtcXC0uXFxkXSspWywgXShbXFwtLlxcZF0rKS9pZztcblx0dmFyIHJlc3VsdCA9IHJlZ2V4LmV4ZWMoJHJhd1BvbHkuZ2V0QXR0cmlidXRlKCdwb2ludHMnKSk7XG5cdHZhciBwb2ludENvbW1hbmRzID0gW107XG5cblx0d2hpbGUgKHJlc3VsdClcblx0e1xuXHRcdHZhciBuYW1lID0gcG9pbnRDb21tYW5kcy5sZW5ndGggPT09IDAgPyBNT1ZFX1RPIDogTElORV9UTztcblx0XHR2YXIgcG9pbnQgPSBbdGhpcy5nZXRDb29yZChyZXN1bHRbMV0pLCB0aGlzLmdldENvb3JkKHJlc3VsdFsyXSldO1xuXHRcdHBvaW50Q29tbWFuZHMucHVzaCh7IG5hbWU6IG5hbWUsIHBvaW50OiBwb2ludCwgb3B0aW9uczogW10gfSk7XG5cdFx0cmVzdWx0ID0gcmVnZXguZXhlYygkcmF3UG9seS5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpKTtcblx0fVxuXHRyZXR1cm4geyB0eXBlOiAkcmF3UG9seS50YWdOYW1lLCBwb2ludENvbW1hbmRzOiBwb2ludENvbW1hbmRzLCBjbG9zZVBhdGg6ICRyYXdQb2x5LnRhZ05hbWUgIT09ICdwb2x5bGluZScsIHRoaWNrbmVzczogdGhpcy5nZXRUaGlja25lc3MoJHJhd1BvbHkpIH07XG59O1xuXG5TVkdQYXJzZXIucHJvdG90eXBlLnBhcnNlUGF0aCA9IGZ1bmN0aW9uICgkcmF3UGF0aClcbntcblx0dmFyIGQgPSAkcmF3UGF0aC5nZXRBdHRyaWJ1dGUoJ2QnKTtcblx0dmFyIHBhdGhSZWcgPSAvKFthLXldKShbLlxcLSxcXGRdKykvaWdtO1xuXHR2YXIgcmVzdWx0O1xuXHR2YXIgY2xvc2VQYXRoID0gL3ovaWdtLnRlc3QoZCk7XG5cdHZhciBjb29yZHNSZWdleCA9IC8tP1tcXGQuXSsvaWdtO1xuXHR2YXIgcG9pbnRDb21tYW5kcyA9IFtdO1xuXHR2YXIgbGFzdFggPSB0aGlzLmdldENvb3JkKDApO1xuXHR2YXIgbGFzdFkgPSB0aGlzLmdldENvb3JkKDApO1xuXG5cdHZhciBzZWxmID0gdGhpcztcblx0dmFyIGdldFBvaW50ID0gZnVuY3Rpb24gKCR4LCAkeSwgJHJlbGF0aXZlKVxuXHR7XG5cdFx0dmFyIHggPSAkeCA9PT0gdW5kZWZpbmVkID8gbGFzdFggOiBzZWxmLmdldENvb3JkKCR4KTtcblx0XHR2YXIgeSA9ICR5ID09PSB1bmRlZmluZWQgPyBsYXN0WSA6IHNlbGYuZ2V0Q29vcmQoJHkpO1xuXHRcdGlmICgkcmVsYXRpdmUpXG5cdFx0e1xuXHRcdFx0eCA9ICR4ID09PSB1bmRlZmluZWQgPyB4IDogbGFzdFggKyB4O1xuXHRcdFx0eSA9ICR5ID09PSB1bmRlZmluZWQgPyB5IDogbGFzdFkgKyB5O1xuXHRcdH1cblx0XHRyZXR1cm4gW3gsIHldO1xuXHR9O1xuXG5cdHZhciBnZXRSZWxhdGl2ZVBvaW50ID0gZnVuY3Rpb24gKCRwb2ludCwgJHgsICR5LCAkcmVsYXRpdmUpXG5cdHtcblx0XHR2YXIgeCA9IHNlbGYuZ2V0Q29vcmQoJHgpO1xuXHRcdHZhciB5ID0gc2VsZi5nZXRDb29yZCgkeSk7XG5cdFx0aWYgKCRyZWxhdGl2ZSlcblx0XHR7XG5cdFx0XHR4ID0gbGFzdFggKyB4O1xuXHRcdFx0eSA9IGxhc3RZICsgeTtcblx0XHR9XG5cdFx0eCA9IHggLSAkcG9pbnRbMF07XG5cdFx0eSA9IHkgLSAkcG9pbnRbMV07XG5cdFx0cmV0dXJuIFt4LCB5XTtcblx0fTtcblxuXHR2YXIgY3JlYXRlUG9pbnQgPSBmdW5jdGlvbiAoJGNvbW1hbmROYW1lLCAkcG9pbnQsICRvcHRpb25zKVxuXHR7XG5cdFx0dmFyIGluZm8gPSB7IG5hbWU6ICRjb21tYW5kTmFtZSwgcG9pbnQ6ICRwb2ludCwgb3B0aW9uczogJG9wdGlvbnMgfHwgW10gfTtcblx0XHRsYXN0WCA9IGluZm8ucG9pbnRbMF07XG5cdFx0bGFzdFkgPSBpbmZvLnBvaW50WzFdO1xuXHRcdHBvaW50Q29tbWFuZHMucHVzaChpbmZvKTtcblx0fTtcblxuXHR2YXIgcG9pbnQ7XG5cdHZhciBjdWJpYzE7XG5cdHZhciBjdWJpYzI7XG5cdHZhciBxdWFkcmExO1xuXG5cdHJlc3VsdCA9IHBhdGhSZWcuZXhlYyhkKTtcblxuXHR3aGlsZSAocmVzdWx0KVxuXHR7XG5cdFx0dmFyIGluc3RydWN0aW9uID0gcmVzdWx0WzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0dmFyIGNvb3JkcyA9IHJlc3VsdFsyXS5tYXRjaChjb29yZHNSZWdleCk7XG5cdFx0dmFyIGlzTG93c2VyQ2FzZSA9IC9bYS16XS8udGVzdChyZXN1bHRbMV0pO1xuXG5cdFx0c3dpdGNoIChpbnN0cnVjdGlvbilcblx0XHR7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0Y2FzZSAnbSc6XG5cdFx0XHRcdHF1YWRyYTEgPSBudWxsO1xuXHRcdFx0XHRjdWJpYzIgPSBudWxsO1xuXHRcdFx0XHRwb2ludCA9IGdldFBvaW50KGNvb3Jkc1swXSwgY29vcmRzWzFdLCBpc0xvd3NlckNhc2UpO1xuXHRcdFx0XHRjcmVhdGVQb2ludChNT1ZFX1RPLCBwb2ludCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnbCc6XG5cdFx0XHRcdHF1YWRyYTEgPSBudWxsO1xuXHRcdFx0XHRjdWJpYzIgPSBudWxsO1xuXHRcdFx0XHRwb2ludCA9IGdldFBvaW50KGNvb3Jkc1swXSwgY29vcmRzWzFdLCBpc0xvd3NlckNhc2UpO1xuXHRcdFx0XHRjcmVhdGVQb2ludChMSU5FX1RPLCBwb2ludCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndic6XG5cdFx0XHRcdHF1YWRyYTEgPSBudWxsO1xuXHRcdFx0XHRjdWJpYzIgPSBudWxsO1xuXHRcdFx0XHRwb2ludCA9IGdldFBvaW50KHVuZGVmaW5lZCwgY29vcmRzWzBdLCBpc0xvd3NlckNhc2UpO1xuXHRcdFx0XHRjcmVhdGVQb2ludChMSU5FX1RPLCBwb2ludCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnaCc6XG5cdFx0XHRcdHF1YWRyYTEgPSBudWxsO1xuXHRcdFx0XHRjdWJpYzIgPSBudWxsO1xuXHRcdFx0XHRwb2ludCA9IGdldFBvaW50KGNvb3Jkc1swXSwgdW5kZWZpbmVkLCBpc0xvd3NlckNhc2UpO1xuXHRcdFx0XHRjcmVhdGVQb2ludChMSU5FX1RPLCBwb2ludCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdHF1YWRyYTEgPSBudWxsO1xuXHRcdFx0XHRwb2ludCA9IGdldFBvaW50KGNvb3Jkc1s0XSwgY29vcmRzWzVdLCBpc0xvd3NlckNhc2UpO1xuXHRcdFx0XHRjdWJpYzEgPSBnZXRSZWxhdGl2ZVBvaW50KHBvaW50LCBjb29yZHNbMF0sIGNvb3Jkc1sxXSwgaXNMb3dzZXJDYXNlKTtcblx0XHRcdFx0Y3ViaWMyID0gZ2V0UmVsYXRpdmVQb2ludChwb2ludCwgY29vcmRzWzJdLCBjb29yZHNbM10sIGlzTG93c2VyQ2FzZSk7XG5cdFx0XHRcdGNyZWF0ZVBvaW50KEJFWklFUl9UTywgcG9pbnQsIFtjdWJpYzEsIGN1YmljMl0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3MnOlxuXHRcdFx0XHRxdWFkcmExID0gbnVsbDtcblx0XHRcdFx0cG9pbnQgPSBnZXRQb2ludChjb29yZHNbMl0sIGNvb3Jkc1szXSwgaXNMb3dzZXJDYXNlKTtcblx0XHRcdFx0Y3ViaWMxID0gY3ViaWMyID8gW2xhc3RYIC0gY3ViaWMyWzBdIC0gcG9pbnRbMF0sIGxhc3RZIC0gY3ViaWMyWzFdIC0gcG9pbnRbMV1dIDogdW5kZWZpbmVkO1xuXHRcdFx0XHRjdWJpYzIgPSBnZXRSZWxhdGl2ZVBvaW50KHBvaW50LCBjb29yZHNbMF0sIGNvb3Jkc1sxXSwgaXNMb3dzZXJDYXNlKTtcblx0XHRcdFx0Y3ViaWMxID0gY3ViaWMxIHx8IFtjdWJpYzJbMF0sIGN1YmljMlsxXV07XG5cdFx0XHRcdGNyZWF0ZVBvaW50KEJFWklFUl9UTywgcG9pbnQsIFtjdWJpYzEsIGN1YmljMl0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3EnOlxuXHRcdFx0XHRjdWJpYzIgPSBudWxsO1xuXHRcdFx0XHRwb2ludCA9IGdldFBvaW50KGNvb3Jkc1syXSwgY29vcmRzWzNdLCBpc0xvd3NlckNhc2UpO1xuXHRcdFx0XHRxdWFkcmExID0gZ2V0UmVsYXRpdmVQb2ludChwb2ludCwgY29vcmRzWzBdLCBjb29yZHNbMV0sIGlzTG93c2VyQ2FzZSk7XG5cdFx0XHRcdGNyZWF0ZVBvaW50KFFVQURSQV9UTywgcG9pbnQsIFtxdWFkcmExXSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndCc6XG5cdFx0XHRcdGN1YmljMiA9IG51bGw7XG5cdFx0XHRcdHF1YWRyYTEgPSBxdWFkcmExID8gcXVhZHJhMSA6IHBvaW50O1xuXHRcdFx0XHRwb2ludCA9IGdldFBvaW50KGNvb3Jkc1swXSwgY29vcmRzWzFdLCBpc0xvd3NlckNhc2UpO1xuXHRcdFx0XHRjcmVhdGVQb2ludChRVUFEUkFfVE8sIHBvaW50LCBbcXVhZHJhMV0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2EnOlxuXHRcdFx0XHRjdWJpYzIgPSBudWxsO1xuXHRcdFx0XHRxdWFkcmExID0gbnVsbDtcblx0XHRcdFx0cG9pbnQgPSBnZXRQb2ludChjb29yZHNbNV0sIGNvb3Jkc1s2XSwgaXNMb3dzZXJDYXNlKTtcblx0XHRcdFx0Y3JlYXRlUG9pbnQoJ2FyY1RvJywgcG9pbnQpO1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ25vdCBzdXBwb3J0ZWQnKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmVzdWx0ID0gcGF0aFJlZy5leGVjKGQpO1xuXHR9XG5cblx0cmV0dXJuIHsgdHlwZTogJ3BhdGgnLCBwb2ludENvbW1hbmRzOiBwb2ludENvbW1hbmRzLCBjbG9zZVBhdGg6IGNsb3NlUGF0aCwgdGhpY2tuZXNzOiB0aGlzLmdldFRoaWNrbmVzcygkcmF3UGF0aCkgfTtcbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUucm91bmQgPSBmdW5jdGlvbiAoJG51bWJlcilcbntcblx0Ly8gdmFyIG51bWJlciA9IE51bWJlcigkbnVtYmVyKTtcblx0Ly8gcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyICogMTAwKSAvIDEwMDtcblx0cmV0dXJuICRudW1iZXI7XG5cdC8vcmV0dXJuIE1hdGguZmxvb3IoTnVtYmVyKCRudW1iZXIpKTtcbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUuZ2V0VGhpY2tuZXNzID0gZnVuY3Rpb24gKCRyYXcpXG57XG5cdHZhciByYXdUaGlja25lc3MgPSAkcmF3LmdldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJykgfHwgMTtcblx0cmV0dXJuIHRoaXMuZ2V0Q29vcmQocmF3VGhpY2tuZXNzKTtcbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUuZ2V0TWF0cml4ID0gZnVuY3Rpb24gKCRhdHRyaWJ1dGUpXG57XG5cdGlmICghJGF0dHJpYnV0ZSkgeyByZXR1cm4gbnVsbDsgfVxuXG5cdHZhciBURlR5cGUgPSAkYXR0cmlidXRlLm1hdGNoKC8oW2Etel0rKS9pZ20pWzBdO1xuXHR2YXIgdmFsdWVzID0gJGF0dHJpYnV0ZS5tYXRjaCgvKC0/W1xcZC5dKykvaWdtKTtcblxuXHR2YXIgbWF0cmljZXMgPSBbXTtcblx0dmFyIHRYO1xuXHR2YXIgdFk7XG5cdHZhciBhbmdsZTtcblxuXHRpZiAoVEZUeXBlID09PSAnbWF0cml4Jylcblx0e1xuXHRcdHJldHVybiBbTnVtYmVyKHZhbHVlc1swXSksIE51bWJlcih2YWx1ZXNbMl0pLCB0aGlzLmdldENvb3JkKHZhbHVlc1s0XSksIE51bWJlcih2YWx1ZXNbMV0pLCBOdW1iZXIodmFsdWVzWzNdKSwgdGhpcy5nZXRDb29yZCh2YWx1ZXNbNV0pLCAwLCAwLCAxXTtcblx0fVxuXHRlbHNlIGlmIChURlR5cGUgPT09ICdyb3RhdGUnKVxuXHR7XG5cdFx0YW5nbGUgPSBOdW1iZXIodmFsdWVzWzBdKSAqIChNYXRoLlBJIC8gMTgwKTtcblx0XHR0WCA9IHRoaXMuZ2V0Q29vcmQoTnVtYmVyKHZhbHVlc1sxXSB8fCAwKSk7XG5cdFx0dFkgPSB0aGlzLmdldENvb3JkKE51bWJlcih2YWx1ZXNbMl0gfHwgMCkpO1xuXHRcdHZhciBtMSA9IFsxLCAwLCB0WCwgMCwgMSwgdFksIDAsIDAsIDFdO1xuXHRcdHZhciBtMiA9IFtNYXRoLmNvcyhhbmdsZSksIC1NYXRoLnNpbihhbmdsZSksIDAsIE1hdGguc2luKGFuZ2xlKSwgTWF0aC5jb3MoYW5nbGUpLCAwLCAwLCAwLCAxXTtcblx0XHR2YXIgbTMgPSBbMSwgMCwgLXRYLCAwLCAxLCAtdFksIDAsIDAsIDFdO1xuXG5cdFx0bWF0cmljZXMucHVzaChtMSwgbTIsIG0zKTtcblx0XHR2YXIgcCA9IG0xO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDEsIG1hdHJpY2VzTGVuZ3RoID0gbWF0cmljZXMubGVuZ3RoOyBpIDwgbWF0cmljZXNMZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgY3Vyck1hdCA9IG1hdHJpY2VzW2ldO1xuXHRcdFx0dmFyIG5ld1AgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG5cdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IDk7IGsgKz0gMSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIHJvdyA9IE1hdGguZmxvb3IoayAvIDMpO1xuXHRcdFx0XHR2YXIgY29sID0gayAlIDM7XG5cdFx0XHRcdC8vdmFyIG1WYWwgPSBwW3JvdyAqIGNvbCAtIDFdO1xuXHRcdFx0XHRmb3IgKHZhciBwb3MgPSAwOyBwb3MgPCAzOyBwb3MgKz0gMSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5ld1Bba10gPSBuZXdQW2tdICsgcFtyb3cgKiAzICsgcG9zXSAqIGN1cnJNYXRbcG9zICogMyArIGNvbF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHAgPSBuZXdQO1xuXHRcdH1cblx0XHRyZXR1cm4gcDtcblx0fVxuXHRlbHNlIGlmIChURlR5cGUgPT09ICd0cmFuc2xhdGUnKVxuXHR7XG5cdFx0dFggPSB0aGlzLmdldENvb3JkKE51bWJlcih2YWx1ZXNbMF0gfHwgMCkpO1xuXHRcdHRZID0gdGhpcy5nZXRDb29yZChOdW1iZXIodmFsdWVzWzFdIHx8IDApKTtcblx0XHRyZXR1cm4gWzEsIDAsIHRYLCAwLCAxLCB0WSwgMCwgMCwgMV07XG5cdH1cblx0ZWxzZSBpZiAoVEZUeXBlID09PSAnc2NhbGUnKVxuXHR7XG5cdFx0dmFyIHNYID0gdGhpcy5nZXRDb29yZChOdW1iZXIodmFsdWVzWzBdIHx8IDApKTtcblx0XHR2YXIgc1kgPSB0aGlzLmdldENvb3JkKE51bWJlcih2YWx1ZXNbMV0gfHwgMCkpO1xuXHRcdHJldHVybiBbc1gsIDAsIDAsIDAsIHNZLCAwXTtcblx0fVxuXHRlbHNlIGlmIChURlR5cGUgPT09ICdza2V3WCcpXG5cdHtcblx0XHRhbmdsZSA9IE51bWJlcih2YWx1ZXNbMF0pICogKE1hdGguUEkgLyAxODApO1xuXHRcdHJldHVybiBbMSwgTWF0aC50YW4oYW5nbGUpLCAwLCAwLCAxLCAwLCAwLCAwLCAxXTtcblx0fVxuXHRlbHNlIGlmIChURlR5cGUgPT09ICdza2V3WScpXG5cdHtcblx0XHRhbmdsZSA9IE51bWJlcih2YWx1ZXNbMF0pICogKE1hdGguUEkgLyAxODApO1xuXHRcdHJldHVybiBbMSwgMCwgMCwgTWF0aC50YW4oYW5nbGUpLCAxLCAwLCAwLCAwLCAxXTtcblx0fVxufTtcblxuU1ZHUGFyc2VyLnByb3RvdHlwZS5tdWx0aXBseVBvaW50QnlNYXRyaXggPSBmdW5jdGlvbiAoJHBvaW50LCBtKVxue1xuXHR2YXIgaCA9IFskcG9pbnRbMF0sICRwb2ludFsxXSwgMV07XG5cdHZhciBwID1cblx0W1xuXHRcdG1bMF0gKiBoWzBdICsgbVsxXSAqIGhbMV0gKyBtWzJdICogaFsyXSxcblx0XHRtWzNdICogaFswXSArIG1bNF0gKiBoWzFdICsgbVs1XSAqIGhbMl0sXG5cdFx0bVs2XSAqIGhbMF0gKyBtWzddICogaFsxXSArIG1bOF0gKiBoWzJdXG5cdF07XG5cdHJldHVybiBbcFswXSAvIHBbMl0sIHBbMV0gLyBwWzJdXTtcbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUuZ2V0Um90YXRpb24gPSBmdW5jdGlvbiAoJGF0dHJpYnV0ZSlcbntcblx0dmFyIG1hdHJpeCA9IHRoaXMuZ2V0TWF0cml4KCRhdHRyaWJ1dGUpO1xuXHRpZiAobWF0cml4KVxuXHR7XG5cdFx0cmV0dXJuIE1hdGguYXRhbjIobWF0cml4WzBdLCBtYXRyaXhbM10pO1xuXHR9XG5cdHJldHVybiAwO1xufTtcblxuU1ZHUGFyc2VyLnByb3RvdHlwZS5nZXRDb29yZCA9IGZ1bmN0aW9uICgkY29vcmRTVFIpXG57XG5cdHZhciBudW1iZXIgPSB0aGlzLnJvdW5kKCRjb29yZFNUUik7XG5cdHJldHVybiBudW1iZXIgKiB0aGlzLnJhdGlvO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkdQYXJzZXI7XG5cbiIsInZhciBTVkplbGx5Tm9kZSA9IHJlcXVpcmUoJy4vU1ZKZWxseU5vZGUnKTtcbnZhciBTVkplbGx5Sm9pbnQgPSByZXF1aXJlKCcuL1NWSmVsbHlKb2ludCcpO1xuXG52YXIgU1ZKZWxseUdyb3VwID0gZnVuY3Rpb24gKCR0eXBlLCAkY29uZiwgJElEKVxue1xuXHR0aGlzLnBoeXNpY3NNYW5hZ2VyID0gdW5kZWZpbmVkO1xuXHR0aGlzLnN0cnVjdHVyZSA9IHVuZGVmaW5lZDtcblx0dGhpcy5ub2Rlc0xlbmd0aCA9IHVuZGVmaW5lZDtcblx0dGhpcy5jb25mID0gJGNvbmY7XG5cdHRoaXMuZHJhd2luZyA9IHVuZGVmaW5lZDtcblx0dGhpcy5maXhlZCA9IHRoaXMuY29uZi5maXhlZDtcblx0dGhpcy50eXBlID0gJHR5cGU7XG5cdHRoaXMubm9kZXMgPSBbXTtcblx0dGhpcy5qb2ludHMgPSBbXTtcblx0dGhpcy5JRCA9ICRJRDtcbn07XG5cblNWSmVsbHlHcm91cC5wcm90b3R5cGUuZ2V0Tm9kZUF0UG9pbnQgPSBmdW5jdGlvbiAoJHgsICR5KVxue1xuXHRmb3IgKHZhciBpID0gMCwgbm9kZXNMZW5ndGggPSB0aGlzLm5vZGVzLmxlbmd0aDsgaSA8IG5vZGVzTGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgbm9kZSA9IHRoaXMubm9kZXNbaV07XG5cblx0XHRpZiAobm9kZS5vWCA9PT0gJHggJiYgbm9kZS5vWSA9PT0gJHkpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0fVxuXHR9XG59O1xuXG5TVkplbGx5R3JvdXAucHJvdG90eXBlLmNyZWF0ZU5vZGUgPSBmdW5jdGlvbiAoJHB4LCAkcHksICRvcHRpb25zLCAkb3ZlcndyaXRlKVxue1xuXHR2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZUF0UG9pbnQoJHB4LCAkcHkpO1xuXHRpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmICRvdmVyd3JpdGUpXG5cdHtcblx0XHRub2RlLnNldE9wdGlvbnMoJG9wdGlvbnMpO1xuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdG5vZGUgPSBuZXcgU1ZKZWxseU5vZGUoJHB4LCAkcHksICRvcHRpb25zKTtcblx0XHR0aGlzLm5vZGVzLnB1c2gobm9kZSk7XG5cdH1cblxuXHRub2RlLklEID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuXHRub2RlLnBoeXNpY3NNYW5hZ2VyID0gdGhpcy5waHlzaWNzTWFuYWdlci5nZXROb2RlUGh5c2ljc01hbmFnZXIobm9kZSk7XG5cdC8vdGhpcy5waHlzaWNzTWFuYWdlci5hZGROb2RlVG9Xb3JsZChub2RlKTtcblxuXHR0aGlzLm5vZGVzTGVuZ3RoID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG5cblx0cmV0dXJuIG5vZGU7XG59O1xuXG5TVkplbGx5R3JvdXAucHJvdG90eXBlLmdldENsb3Nlc3RQb2ludCA9IGZ1bmN0aW9uICgkcG9pbnRzLCAkbm9kZXMpXG57XG5cdHZhciBub2RlcyA9ICRub2RlcyB8fCB0aGlzLm5vZGVzO1xuXHR2YXIgY2xvc2VzdERpc3QgPSBJbmZpbml0eTtcblx0dmFyIGNsb3Nlc3RQb2ludDtcblx0dmFyIGNsb3Nlc3ROb2RlO1xuXHR2YXIgY2xvc2VzdE9mZnNldFg7XG5cdHZhciBjbG9zZXN0T2Zmc2V0WTtcblxuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gJHBvaW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJyUG9pbnQgPSAkcG9pbnRzW2ldO1xuXHRcdGZvciAodmFyIGsgPSAwLCBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDsgayA8IG5vZGVzTGVuZ3RoOyBrICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJOb2RlID0gbm9kZXNba107XG5cdFx0XHR2YXIgb2Zmc2V0WCA9IGN1cnJQb2ludFswXSAtIGN1cnJOb2RlLm9YO1xuXHRcdFx0dmFyIG9mZnNldFkgPSBjdXJyUG9pbnRbMV0gLSBjdXJyTm9kZS5vWTtcblx0XHRcdHZhciBjWCA9IE1hdGguYWJzKG9mZnNldFgpO1xuXHRcdFx0dmFyIGNZID0gTWF0aC5hYnMob2Zmc2V0WSk7XG5cdFx0XHR2YXIgZGlzdCA9IE1hdGguc3FydChjWCAqIGNYICsgY1kgKiBjWSk7XG5cdFx0XHRpZiAoZGlzdCA8IGNsb3Nlc3REaXN0KVxuXHRcdFx0e1xuXHRcdFx0XHRjbG9zZXN0Tm9kZSA9IGN1cnJOb2RlO1xuXHRcdFx0XHRjbG9zZXN0UG9pbnQgPSBjdXJyUG9pbnQ7XG5cdFx0XHRcdGNsb3Nlc3REaXN0ID0gZGlzdDtcblx0XHRcdFx0Y2xvc2VzdE9mZnNldFggPSBvZmZzZXRYO1xuXHRcdFx0XHRjbG9zZXN0T2Zmc2V0WSA9IG9mZnNldFk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNsb3Nlc3RQb2ludDtcbn07XG5cblNWSmVsbHlHcm91cC5wcm90b3R5cGUuZ2V0Q2xvc2VzdE5vZGUgPSBmdW5jdGlvbiAoJGNvb3JkLCAkbm9kZXMpXG57XG5cdHZhciBub2RlcyA9ICRub2RlcyB8fCB0aGlzLm5vZGVzO1xuXHR2YXIgY2xvc2VzdERpc3QgPSBJbmZpbml0eTtcblx0dmFyIGNsb3Nlc3Q7XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBub2Rlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBub2RlID0gbm9kZXNbaV07XG5cdFx0dmFyIG9mZnNldFggPSAkY29vcmRbMF0gLSBub2RlLm9YO1xuXHRcdHZhciBvZmZzZXRZID0gJGNvb3JkWzFdIC0gbm9kZS5vWTtcblx0XHR2YXIgY1ggPSBNYXRoLmFicyhvZmZzZXRYKTtcblx0XHR2YXIgY1kgPSBNYXRoLmFicyhvZmZzZXRZKTtcblx0XHR2YXIgZGlzdCA9IE1hdGguc3FydChjWCAqIGNYICsgY1kgKiBjWSk7XG5cdFx0aWYgKGRpc3QgPCBjbG9zZXN0RGlzdClcblx0XHR7XG5cdFx0XHRjbG9zZXN0ID0gbm9kZTtcblx0XHRcdGNsb3Nlc3REaXN0ID0gZGlzdDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGNsb3Nlc3Q7XG59O1xuXG5TVkplbGx5R3JvdXAucHJvdG90eXBlLmdldE5vZGVzSW5zaWRlID0gZnVuY3Rpb24gKCRwb2ludHMpXG57XG5cdHZhciBQb2x5Z29uID0gcmVxdWlyZSgnLi9Qb2x5Z29uJyk7XG5cdHZhciB0b1JldHVybiA9IFtdO1xuXHR2YXIgcG9seWdvbiA9IFBvbHlnb24uaW5pdCgkcG9pbnRzKTtcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMubm9kZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgbm9kZSA9IHRoaXMubm9kZXNbaV07XG5cdFx0aWYgKHBvbHlnb24uaXNJbnNpZGUoW25vZGUub1gsIG5vZGUub1ldKSlcblx0XHR7XG5cdFx0XHR0b1JldHVybi5wdXNoKG5vZGUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdG9SZXR1cm47XG59O1xuXG5TVkplbGx5R3JvdXAucHJvdG90eXBlLmNyZWF0ZUpvaW50ID0gZnVuY3Rpb24gKCRub2RlQSwgJG5vZGVCLCAkdHlwZSlcbntcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmpvaW50cy5sZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJySm9pbnQgPSB0aGlzLmpvaW50c1tpXTtcblx0XHRpZiAoKGN1cnJKb2ludC5ub2RlQSA9PT0gJG5vZGVBICYmIGN1cnJKb2ludC5ub2RlQiA9PT0gJG5vZGVCKSB8fCAoY3VyckpvaW50Lm5vZGVCID09PSAkbm9kZUEgJiYgY3VyckpvaW50Lm5vZGVBID09PSAkbm9kZUIpKVxuXHRcdHtcblx0XHRcdC8vcmV0dXJuO1xuXHRcdFx0dGhpcy5qb2ludHMuc3BsaWNlKGksIDEpO1xuXHRcdFx0aSA9IGkgLSAxO1xuXHRcdH1cblx0fVxuXHR2YXIgam9pbnQgPSBuZXcgU1ZKZWxseUpvaW50KCRub2RlQSwgJG5vZGVCLCAkdHlwZSk7XG5cdHRoaXMuam9pbnRzLnB1c2goam9pbnQpO1xuXG5cdC8vdGhpcy5waHlzaWNzTWFuYWdlci5hZGRKb2ludFRvV29ybGQoam9pbnQpO1xufTtcblxuU1ZKZWxseUdyb3VwLnByb3RvdHlwZS5hZGROb2Rlc1RvV29ybGQgPSBmdW5jdGlvbiAoKVxue1xuXHR0aGlzLnBoeXNpY3NNYW5hZ2VyLmFkZE5vZGVzVG9Xb3JsZCgpO1xufTtcblxuU1ZKZWxseUdyb3VwLnByb3RvdHlwZS5hZGRKb2ludHNUb1dvcmxkID0gZnVuY3Rpb24gKClcbntcblx0dGhpcy5waHlzaWNzTWFuYWdlci5hZGRKb2ludHNUb1dvcmxkKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWSmVsbHlHcm91cDtcblxuIiwidmFyIFNWSmVsbHlKb2ludCA9IGZ1bmN0aW9uICgkbm9kZUEsICRub2RlQiwgJHR5cGUpXG57XG5cdHRoaXMubm9kZUEgPSAkbm9kZUE7XG5cdHRoaXMubm9kZUIgPSAkbm9kZUI7XG5cdHRoaXMudHlwZSA9ICR0eXBlIHx8ICdkZWZhdWx0Jztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZKZWxseUpvaW50O1xuXG4iLCJ2YXIgU1ZKZWxseU5vZGUgPSBmdW5jdGlvbiAoJG9YLCAkb1ksICRvcHRpb25zKVxue1xuXHR0aGlzLmpvaW50c0FycmF5ID0gW107XG5cdHRoaXMub1ggPSAkb1g7XG5cdHRoaXMub1kgPSAkb1k7XG5cdHRoaXMuZml4ZWQgPSBmYWxzZTtcblx0dGhpcy5kcmF3aW5nID0gdW5kZWZpbmVkO1xuXHR0aGlzLnNldE9wdGlvbnMoJG9wdGlvbnMpO1xufTtcblxuLy9yYWNjb3VyY2lcblNWSmVsbHlOb2RlLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKCRvcHRpb25zKVxue1xuXHRpZiAoJG9wdGlvbnMpXG5cdHtcblx0XHQvLyB2YXIgPSAkID09PSB1bmRlZmluZWQgPyB7fSA6ICRvcHRpb25zO1xuXHRcdGlmICgkb3B0aW9ucy5maXhlZCAhPT0gdW5kZWZpbmVkKSB7IHRoaXMuZml4ZWQgPSAkb3B0aW9ucy5maXhlZDsgfVxuXHR9XG59O1xuXG5TVkplbGx5Tm9kZS5wcm90b3R5cGUuc2V0Rml4ZWQgPSBmdW5jdGlvbiAoJGZpeGVkKVxue1xuXHR0aGlzLmZpeGVkID0gJGZpeGVkO1xuXHR0aGlzLnBoeXNpY3NNYW5hZ2VyLnNldEZpeGVkKCRmaXhlZCk7XG59O1xuXG5TVkplbGx5Tm9kZS5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLnBoeXNpY3NNYW5hZ2VyLmdldFgoKTtcbn07XG5cbi8vcmFjY291cmNpXG5TVkplbGx5Tm9kZS5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLnBoeXNpY3NNYW5hZ2VyLmdldFkoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZKZWxseU5vZGU7XG5cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRleHRlbmQ6IGZ1bmN0aW9uICgkdG9FeHRlbmQsICRleHRlbnNpb24pXG5cdHtcblx0XHR2YXIgcmVjdXIgPSBmdW5jdGlvbiAoJG9iamVjdCwgJGV4dGVuZClcblx0XHR7XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluICRleHRlbmQpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0eXBlb2YgJGV4dGVuZFtuYW1lXSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoJGV4dGVuZFtuYW1lXSkgJiYgJGV4dGVuZFtuYW1lXSAhPT0gbnVsbClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmICgkb2JqZWN0W25hbWVdID09PSB1bmRlZmluZWQgfHwgJG9iamVjdFtuYW1lXSA9PT0gbnVsbCkgeyAkb2JqZWN0W25hbWVdID0ge307IH1cblx0XHRcdFx0XHRyZWN1cigkb2JqZWN0W25hbWVdLCAkZXh0ZW5kW25hbWVdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQkb2JqZWN0W25hbWVdID0gJGV4dGVuZFtuYW1lXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmVjdXIoJHRvRXh0ZW5kLCAkZXh0ZW5zaW9uKTtcblxuXHRcdHJldHVybiAkdG9FeHRlbmQ7XG5cdH1cbn07XG5cbiIsInZhciBTVkplbGx5R3JvdXAgPSByZXF1aXJlKCcuL1NWSmVsbHlHcm91cCcpO1xudmFyIFN0cnVjdHVyZSA9IHJlcXVpcmUoJy4vU3RydWN0dXJlJyk7XG5cbnZhciBTVkplbGx5V29ybGQgPSBmdW5jdGlvbiAoJHBoeXNpY3NNYW5hZ2VyLCAkY29uZilcbntcblx0dGhpcy5waHlzaWNzTWFuYWdlciA9ICRwaHlzaWNzTWFuYWdlcjtcblx0dGhpcy5ncm91cHMgPSBbXTtcblx0dGhpcy5kcmF3aW5ncyA9IFtdO1xuXHR0aGlzLmNvbmYgPSAkY29uZjtcblx0dGhpcy53b3JsZE5vZGVzID0gW107XG5cdHRoaXMuZ3JvdXBDb25zdHJhaW50cyA9IFtdO1xuXHR0aGlzLndvcmxkV2lkdGggPSB0aGlzLnBoeXNpY3NNYW5hZ2VyLndvcmxkV2lkdGggPSAkY29uZi53b3JsZFdpZHRoO1xufTtcblxuU1ZKZWxseVdvcmxkLnByb3RvdHlwZS5hZGREcmF3aW5nID0gZnVuY3Rpb24gKCRkcmF3aW5nKVxue1xuXHR0aGlzLmRyYXdpbmdzLnB1c2goJGRyYXdpbmcpO1xufTtcblxuU1ZKZWxseVdvcmxkLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoJGhlaWdodClcbntcblx0dGhpcy53b3JsZEhlaWdodCA9IHRoaXMucGh5c2ljc01hbmFnZXIud29ybGRIZWlnaHQgPSAkaGVpZ2h0O1xufTtcblxuU1ZKZWxseVdvcmxkLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLndvcmxkV2lkdGg7XG59O1xuXG5TVkplbGx5V29ybGQucHJvdG90eXBlLmdldEdyb3VwQnlJRCA9IGZ1bmN0aW9uICgkSUQpXG57XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLmdyb3Vwcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJyR3JvdXAgPSB0aGlzLmdyb3Vwc1tpXTtcblx0XHRpZiAoY3Vyckdyb3VwLklEID09PSAkSUQpIHsgcmV0dXJuIGN1cnJHcm91cDsgfVxuXHR9XG59O1xuXG5TVkplbGx5V29ybGQucHJvdG90eXBlLmNyZWF0ZUdyb3VwID0gZnVuY3Rpb24gKCR0eXBlLCAkSUQpXG57XG5cdHZhciBjb25mID0gdGhpcy5jb25mLmdyb3Vwc1skdHlwZV0gfHwgdGhpcy5jb25mLmdyb3Vwcy5kZWZhdWx0O1xuXHR2YXIgZ3JvdXAgPSBuZXcgU1ZKZWxseUdyb3VwKCR0eXBlLCBjb25mLCAkSUQpO1xuXHRncm91cC5waHlzaWNzTWFuYWdlciA9IHRoaXMucGh5c2ljc01hbmFnZXIuZ2V0R3JvdXBQaHlzaWNzTWFuYWdlcihncm91cCk7XG5cdGdyb3VwLnN0cnVjdHVyZSA9IG5ldyBTdHJ1Y3R1cmUoZ3JvdXAsIHRoaXMpO1xuXHR0aGlzLmdyb3Vwcy5wdXNoKGdyb3VwKTtcblx0cmV0dXJuIGdyb3VwO1xufTtcblxuLy9tYXliZSBzcGxpdCB0aGlzIGludG8gdHdvIGRpZmZlcmVudCBmZWF0dXJlcywgc3R1ZmYgZm9yIG1ha2luZyBib2RpZXMgZml4ZWQsIGFuZCBjb25zdHJhaW50c1xuU1ZKZWxseVdvcmxkLnByb3RvdHlwZS5jb25zdHJhaW5Hcm91cHMgPSBmdW5jdGlvbiAoJGdyb3VwQSwgJGdyb3VwQiwgJHBvaW50cywgJHR5cGUpXG57XG5cdHZhciBwb2ludHMgPSAkcG9pbnRzO1xuXHR2YXIgZ3JvdXBBID0gJGdyb3VwQTtcblx0dmFyIGdyb3VwQiA9ICRncm91cEI7XG5cblx0aWYgKHBvaW50cy5sZW5ndGggPCAzKVxuXHR7XG5cdFx0dmFyIGFuY2hvckEgPSBncm91cEEucGh5c2ljc01hbmFnZXIuY3JlYXRlQW5jaG9yRnJvbUxpbmUocG9pbnRzKTtcblx0XHRwb2ludHMuc3BsaWNlKHBvaW50cy5pbmRleE9mKGFuY2hvckEucG9pbnQpLCAxKTtcblx0XHR2YXIgYW5jaG9yQiA9IGdyb3VwQiA/IGdyb3VwQi5waHlzaWNzTWFuYWdlci5jcmVhdGVBbmNob3JGcm9tUG9pbnQocG9pbnRzWzBdKSA6IHRoaXMucGh5c2ljc01hbmFnZXIuY3JlYXRlR2hvc3RBbmNob3JGcm9tUG9pbnQocG9pbnRzWzBdKTtcblx0XHR0aGlzLmdyb3VwQ29uc3RyYWludHMucHVzaCh7IGFuY2hvckE6IGFuY2hvckEsIGFuY2hvckI6IGFuY2hvckIsIHR5cGU6ICR0eXBlIH0pO1xuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdHZhciBhbmNob3JzQSA9IGdyb3VwQS5waHlzaWNzTWFuYWdlci5jcmVhdGVBbmNob3JzKHBvaW50cyk7XG5cdFx0dmFyIGFuY2hvcnNCID0gZ3JvdXBCID8gZ3JvdXBCLnBoeXNpY3NNYW5hZ2VyLmNyZWF0ZUFuY2hvcnMocG9pbnRzKSA6IFtdO1xuXHRcdC8vY29uc29sZS5sb2coJ0EnLCBncm91cEEuSUQsIGFuY2hvcnNBLmxlbmd0aCwgJ0InLCBncm91cEIgPyBncm91cEIuSUQgOiBncm91cEIpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBub2Rlc0xlbmd0aCA9IGFuY2hvcnNBLmxlbmd0aDsgaSA8IG5vZGVzTGVuZ3RoOyBpICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJBbmNob3JBID0gYW5jaG9yc0FbaV07XG5cdFx0XHRpZiAoIWdyb3VwQilcblx0XHRcdHtcblx0XHRcdFx0aWYgKCR0eXBlID09PSAnZGVmYXVsdCcpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjdXJyQW5jaG9yQS5zZXRGaXhlZCh0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgZ2hvc3RBbmNob3IgPSB0aGlzLnBoeXNpY3NNYW5hZ2VyLmNyZWF0ZUdob3N0QW5jaG9yRnJvbVBvaW50cyhwb2ludHMpO1xuXHRcdFx0XHRcdHRoaXMuZ3JvdXBDb25zdHJhaW50cy5wdXNoKHsgYW5jaG9yQTogY3VyckFuY2hvckEsIGFuY2hvckI6IGdob3N0QW5jaG9yLCB0eXBlOiAkdHlwZSB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKHZhciBrID0gMCwgYW5jaG9yc0JMZW5ndGggPSBhbmNob3JzQi5sZW5ndGg7IGsgPCBhbmNob3JzQkxlbmd0aDsgayArPSAxKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFyIGN1cnJBbmNob3JCID0gYW5jaG9yc0Jba107XG5cdFx0XHRcdFx0dGhpcy5ncm91cENvbnN0cmFpbnRzLnB1c2goeyBhbmNob3JBOiBjdXJyQW5jaG9yQSwgYW5jaG9yQjogY3VyckFuY2hvckIsIHR5cGU6ICR0eXBlIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5TVkplbGx5V29ybGQucHJvdG90eXBlLmFkZEdyb3Vwc1RvV29ybGQgPSBmdW5jdGlvbiAoKVxue1xuXHRmb3IgKHZhciBpID0gMCwgZ3JvdXBzTGVuZ3RoID0gdGhpcy5ncm91cHMubGVuZ3RoOyBpIDwgZ3JvdXBzTGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3Vyckdyb3VwID0gdGhpcy5ncm91cHNbaV07XG5cdFx0Y3Vyckdyb3VwLmFkZE5vZGVzVG9Xb3JsZCgpO1xuXHRcdGN1cnJHcm91cC5hZGRKb2ludHNUb1dvcmxkKCk7XG5cdFx0dGhpcy53b3JsZE5vZGVzID0gdGhpcy53b3JsZE5vZGVzLmNvbmNhdChjdXJyR3JvdXAubm9kZXMpO1xuXHR9XG5cblx0dmFyIHRvQ29uc3RyYWluTGVuZ3RoID0gdGhpcy5ncm91cENvbnN0cmFpbnRzLmxlbmd0aDtcblx0Zm9yIChpID0gMDsgaSA8IHRvQ29uc3RyYWluTGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3VyclRvQ29uc3RyYWluID0gdGhpcy5ncm91cENvbnN0cmFpbnRzW2ldO1xuXHRcdHRoaXMucGh5c2ljc01hbmFnZXIuY29uc3RyYWluR3JvdXBzKGN1cnJUb0NvbnN0cmFpbi5hbmNob3JBLCBjdXJyVG9Db25zdHJhaW4uYW5jaG9yQiwgY3VyclRvQ29uc3RyYWluLnR5cGUpO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWSmVsbHlXb3JsZDtcblxuIiwidmFyIFRyaWFuZ3VsYXRvciA9IHJlcXVpcmUoJy4vVHJpYW5ndWxhdG9yJyk7XG52YXIgUG9seWdvbiA9IHJlcXVpcmUoJy4vUG9seWdvbicpO1xudmFyIEdyaWQgPSByZXF1aXJlKCcuL0dyaWQnKTtcblxudmFyIFN0cnVjdHVyZSA9IGZ1bmN0aW9uICgkZ3JvdXAsICR3b3JsZClcbntcblx0dGhpcy53b3JsZCA9ICR3b3JsZDtcblx0dGhpcy5ncm91cCA9ICRncm91cDtcblx0dGhpcy5pbm5lclN0cnVjdHVyZSA9IHVuZGVmaW5lZDtcbn07XG5cblN0cnVjdHVyZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCRkcmF3aW5nQ29tbWFuZHMpXG57XG5cdHRoaXMucG9pbnRzID0gdGhpcy5nZXRQb2ludHMoJGRyYXdpbmdDb21tYW5kcyk7XG5cdHRoaXMuZHJhd2luZ0NvbW1hbmRzID0gJGRyYXdpbmdDb21tYW5kcztcblx0dGhpcy5ub2RlUHJvcGVydGllcyA9IFtdO1xuXG5cdHRoaXMuZW52ZWxvcGUgPSB1bmRlZmluZWQ7XG5cdHRoaXMuZmlsbE5vZGVzID0gdW5kZWZpbmVkO1xuXG5cdC8vIGNvbnNvbGUubG9nKCdwb2ludHMnLCBwb2ludHMubGVuZ3RoLCB0aGlzLmdyb3VwLmNvbmYuc3RydWN0dXJlKTtcblxuXHR0aGlzLmFyZWEgPSB0aGlzLmNhbGN1bGF0ZUFyZWEodGhpcy5wb2ludHMsICRkcmF3aW5nQ29tbWFuZHMpO1xuXHR0aGlzLnJhZGl1c1ggPSAkZHJhd2luZ0NvbW1hbmRzLnJhZGl1c1g7XG5cdHRoaXMucmFkaXVzWSA9ICRkcmF3aW5nQ29tbWFuZHMucmFkaXVzWTtcblxuXHRzd2l0Y2ggKHRoaXMuZ3JvdXAuY29uZi5zdHJ1Y3R1cmUpXG5cdHtcblx0XHRjYXNlICd0cmlhbmd1bGF0ZSc6XG5cdFx0XHR0aGlzLnJlbW92ZUR1cGxpY2F0ZXModGhpcy5kcmF3aW5nQ29tbWFuZHMpO1xuXHRcdFx0dmFyIHRyaVBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKHRoaXMuZHJhd2luZ0NvbW1hbmRzKTtcblx0XHRcdHRoaXMuZW52ZWxvcGUgPSB0aGlzLmNyZWF0ZU5vZGVzRnJvbVBvaW50cyh0cmlQb2ludHMpO1xuXHRcdFx0dGhpcy5zZXROb2RlRHJhd2luZ0NvbW1hbmRzKHRoaXMuZW52ZWxvcGUpO1xuXHRcdFx0dGhpcy5jcmVhdGVKb2ludHNGcm9tVHJpYW5nbGVzKHRyaVBvaW50cyk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsaW5lJzpcblx0XHRcdHRoaXMuZW52ZWxvcGUgPSB0aGlzLmNyZWF0ZU5vZGVzRnJvbVBvaW50cyh0aGlzLnBvaW50cyk7XG5cdFx0XHR0aGlzLnNldE5vZGVEcmF3aW5nQ29tbWFuZHModGhpcy5lbnZlbG9wZSk7XG5cdFx0XHR0aGlzLmNyZWF0ZUpvaW50c0Zyb21Qb2ludHModGhpcy5wb2ludHMsIHRydWUpO1xuXHRcdFx0Ly9lbnZlbG9wZVswXS5maXhlZCA9IHRydWU7Ly90byByZW1vdmUgbGF0ZXIgbWF5YmUgP1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAncHJlY2lzZUhleGFGaWxsJzpcblx0XHRcdHRoaXMuZW52ZWxvcGUgPSB0aGlzLmNyZWF0ZVByZWNpc2VIZXhhRmlsbFN0cnVjdHVyZSh0aGlzLnBvaW50cyk7XG5cdFx0XHQvLyBzdHJ1Y3R1cmVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uICgkZWxlbWVudCkgeyAkZWxlbWVudC5kcmF3aW5nID0geyBub3RUb0RyYXc6IHRydWUgfTsgfSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdoZXhhRmlsbCc6XG5cdFx0XHR0aGlzLmVudmVsb3BlID0gdGhpcy5jcmVhdGVIZXhhRmlsbFN0cnVjdHVyZSh0aGlzLnBvaW50cyk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdzaW1wbGUnOlxuXHRcdFx0dGhpcy5lbnZlbG9wZSA9IHRoaXMuY3JlYXRlTm9kZXNGcm9tUG9pbnRzKHRoaXMucG9pbnRzKTtcblx0XHRcdHRoaXMuY3JlYXRlSm9pbnRzRnJvbVBvaW50cyh0aGlzLnBvaW50cyk7XG5cdFx0XHR0aGlzLnNldE5vZGVEcmF3aW5nQ29tbWFuZHModGhpcy5lbnZlbG9wZSk7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhpcy5lbnZlbG9wZSA9IHRoaXMuY3JlYXRlTm9kZXNGcm9tUG9pbnRzKHRoaXMucG9pbnRzLCB0cnVlKTtcblx0XHRcdHRoaXMuc2V0Tm9kZURyYXdpbmdDb21tYW5kcyh0aGlzLmVudmVsb3BlKTtcblx0XHRcdGJyZWFrO1xuXHR9XG59O1xuXG5TdHJ1Y3R1cmUucHJvdG90eXBlLmNhbGN1bGF0ZUFyZWEgPSBmdW5jdGlvbiAoJHBvaW50cywgJGRyYXdpbmdDb21tYW5kcylcbntcblx0aWYgKCRkcmF3aW5nQ29tbWFuZHMudHlwZSA9PT0gJ2VsbGlwc2UnKVxuXHR7XG5cdFx0cmV0dXJuIE1hdGgucG93KE1hdGguUEkgKiAkZHJhd2luZ0NvbW1hbmRzLnJhZGl1c1gsIDIpO1xuXHR9XG5cdGlmICh0aGlzLmdyb3VwLmNvbmYuc3RydWN0dXJlICE9PSAnbGluZScpXG5cdHtcblx0XHR2YXIgcG9seWdvbiA9IFBvbHlnb24uaW5pdCgkcG9pbnRzKTtcblx0XHRyZXR1cm4gcG9seWdvbi5nZXRBcmVhKCk7XG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0dmFyIGFyZWEgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAxLCBsZW5ndGggPSAkcG9pbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjdXJyUG9pbnQgPSAkcG9pbnRzW2ldO1xuXHRcdFx0dmFyIGxhc3RQb2ludCA9ICRwb2ludHNbaSAtIDFdO1xuXHRcdFx0dmFyIGRYID0gTWF0aC5hYnMoY3VyclBvaW50WzBdIC0gbGFzdFBvaW50WzBdKTtcblx0XHRcdHZhciBkWSA9IE1hdGguYWJzKGN1cnJQb2ludFsxXSAtIGxhc3RQb2ludFsxXSk7XG5cdFx0XHRhcmVhICs9IE1hdGguc3FydChkWCAqIGRYICsgZFkgKiBkWSk7XG5cdFx0XHRhcmVhID0gYXJlYSAqIDAuNSArIGFyZWEgKiAkZHJhd2luZ0NvbW1hbmRzLnRoaWNrbmVzcyAqIDAuNTtcblx0XHR9XG5cdFx0cmV0dXJuIGFyZWE7XG5cdH1cbn07XG5cblN0cnVjdHVyZS5wcm90b3R5cGUuY3JlYXRlSGV4YUZpbGxTdHJ1Y3R1cmUgPSBmdW5jdGlvbiAoJHBvaW50cylcbntcblx0dGhpcy5maWxsTm9kZXMgPSB0aGlzLmNyZWF0ZUlubmVyU3RydWN0dXJlKCRwb2ludHMpO1xuXHR2YXIgcGF0aCA9IHRoaXMuaW5uZXJTdHJ1Y3R1cmUuZ2V0U2hhcGVQYXRoKCk7XG5cdHZhciBlbnZlbG9wZSA9IFtdO1xuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gcGF0aC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBub2RlID0gdGhpcy5ncm91cC5nZXROb2RlQXRQb2ludChwYXRoW2ldWzBdLCBwYXRoW2ldWzFdKTtcblx0XHRlbnZlbG9wZS5wdXNoKG5vZGUpO1xuXHRcdHRoaXMubm9kZVByb3BlcnRpZXMucHVzaCh7IG5vZGU6IG5vZGUsIGNvbW1hbmRQcm9wZXJ0aWVzOiB1bmRlZmluZWQsIGlzRW52ZWxvcGU6IHRydWUgfSk7XG5cdH1cblx0cmV0dXJuIGVudmVsb3BlO1xufTtcblxuU3RydWN0dXJlLnByb3RvdHlwZS5zZXROb2RlRHJhd2luZ0NvbW1hbmRzID0gZnVuY3Rpb24gKCRub2Rlcylcbntcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9ICRub2Rlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBub2RlID0gJG5vZGVzW2ldO1xuXHRcdHZhciBjb21tYW5kT2JqZWN0ID0gdGhpcy5kcmF3aW5nQ29tbWFuZHMucG9pbnRDb21tYW5kc1tpXTtcblx0XHR0aGlzLm5vZGVQcm9wZXJ0aWVzLnB1c2goeyBub2RlOiBub2RlLCBjb21tYW5kUHJvcGVydGllczogY29tbWFuZE9iamVjdCwgaXNFbnZlbG9wZTogdHJ1ZSB9KTtcblx0fVxufTtcblxuU3RydWN0dXJlLnByb3RvdHlwZS5jcmVhdGVQcmVjaXNlSGV4YUZpbGxTdHJ1Y3R1cmUgPSBmdW5jdGlvbiAoJHBvaW50cylcbntcblx0dmFyIGVudmVsb3BlID0gdGhpcy5jcmVhdGVOb2Rlc0Zyb21Qb2ludHMoJHBvaW50cywgdHJ1ZSk7XG5cdHRoaXMuc2V0Tm9kZURyYXdpbmdDb21tYW5kcyhlbnZlbG9wZSk7XG5cdHRoaXMuZmlsbE5vZGVzID0gdGhpcy5jcmVhdGVJbm5lclN0cnVjdHVyZSgkcG9pbnRzKTtcblxuXHR0aGlzLmNyZWF0ZUpvaW50c0Zyb21Qb2ludHMoJHBvaW50cywgZmFsc2UpO1xuXHR2YXIgaSA9IDA7XG5cdHZhciBsZW5ndGggPSAkcG9pbnRzLmxlbmd0aDtcblx0Zm9yIChpOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3VyclBvaW50ID0gJHBvaW50c1tpXTtcblx0XHR2YXIgY2xvc2VzdCA9IHRoaXMuaW5uZXJTdHJ1Y3R1cmUuZ2V0Q2xvc2VzdChjdXJyUG9pbnRbMF0sIGN1cnJQb2ludFsxXSwgMik7XG5cdFx0Zm9yICh2YXIgayA9IDAsIGNsb3Nlc3RMZW5ndGggPSBjbG9zZXN0Lmxlbmd0aDsgayA8IGNsb3Nlc3RMZW5ndGg7IGsgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgY3VyckNsb3Nlc3QgPSBjbG9zZXN0W2tdO1xuXHRcdFx0dmFyIG4xID0gdGhpcy5ncm91cC5nZXROb2RlQXRQb2ludChjdXJyUG9pbnRbMF0sIGN1cnJQb2ludFsxXSk7XG5cdFx0XHR2YXIgbjIgPSB0aGlzLmdyb3VwLmdldE5vZGVBdFBvaW50KGN1cnJDbG9zZXN0WzBdLCBjdXJyQ2xvc2VzdFsxXSk7XG5cdFx0XHR0aGlzLmdyb3VwLmNyZWF0ZUpvaW50KG4xLCBuMik7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBlbnZlbG9wZTtcbn07XG5cblN0cnVjdHVyZS5wcm90b3R5cGUuY3JlYXRlSm9pbnRzRnJvbVRyaWFuZ2xlcyA9IGZ1bmN0aW9uICgkcG9pbnRzKVxue1xuXHR2YXIgdHJpYW5ndWxhdG9yID0gbmV3IFRyaWFuZ3VsYXRvcigpO1xuXHR2YXIgdHJpYW5nbGVzID0gdHJpYW5ndWxhdG9yLnRyaWFuZ3VsYXRlKCRwb2ludHMpO1xuXG5cdHZhciB0cmlhbmdsZXNMZW5ndGggPSB0cmlhbmdsZXMubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRyaWFuZ2xlc0xlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJUcmlhbmdsZSA9IHRyaWFuZ2xlc1tpXTtcblx0XHR2YXIgbjAgPSB0aGlzLmdyb3VwLmdldE5vZGVBdFBvaW50KGN1cnJUcmlhbmdsZVswXS54LCBjdXJyVHJpYW5nbGVbMF0ueSk7XG5cdFx0dmFyIG4xID0gdGhpcy5ncm91cC5nZXROb2RlQXRQb2ludChjdXJyVHJpYW5nbGVbMV0ueCwgY3VyclRyaWFuZ2xlWzFdLnkpO1xuXHRcdHZhciBuMiA9IHRoaXMuZ3JvdXAuZ2V0Tm9kZUF0UG9pbnQoY3VyclRyaWFuZ2xlWzJdLngsIGN1cnJUcmlhbmdsZVsyXS55KTtcblx0XHR0aGlzLmdyb3VwLmNyZWF0ZUpvaW50KG4wLCBuMSk7XG5cdFx0dGhpcy5ncm91cC5jcmVhdGVKb2ludChuMSwgbjIpO1xuXHRcdHRoaXMuZ3JvdXAuY3JlYXRlSm9pbnQobjIsIG4wKTtcblx0fVxufTtcblxuU3RydWN0dXJlLnByb3RvdHlwZS5nZXRQb2ludHMgPSBmdW5jdGlvbiAoJGRyYXdpbmdDb21tYW5kcylcbntcblx0dmFyIHBvaW50cyA9IFtdO1xuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gJGRyYXdpbmdDb21tYW5kcy5wb2ludENvbW1hbmRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnIgPSAkZHJhd2luZ0NvbW1hbmRzLnBvaW50Q29tbWFuZHNbaV07XG5cdFx0cG9pbnRzLnB1c2goY3Vyci5wb2ludCk7XG5cdH1cblx0cmV0dXJuIHBvaW50cztcbn07XG5cblN0cnVjdHVyZS5wcm90b3R5cGUuY3JlYXRlTm9kZXNGcm9tUG9pbnRzID0gZnVuY3Rpb24gKCRwb2ludHMsICRvdmVyd3JpdGUpXG57XG5cdHZhciBwb2ludHNMZW5ndGggPSAkcG9pbnRzLmxlbmd0aDtcblx0dmFyIHRvUmV0dXJuID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzTGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3VyclBvaW50ID0gJHBvaW50c1tpXTtcblx0XHR2YXIgbm9kZSA9IHRoaXMuZ3JvdXAuY3JlYXRlTm9kZShjdXJyUG9pbnRbMF0sIGN1cnJQb2ludFsxXSwgdW5kZWZpbmVkLCAkb3ZlcndyaXRlKTtcblx0XHR0b1JldHVybi5wdXNoKG5vZGUpO1xuXHR9XG5cdHJldHVybiB0b1JldHVybjtcbn07XG5cblN0cnVjdHVyZS5wcm90b3R5cGUucmVtb3ZlRHVwbGljYXRlcyA9IGZ1bmN0aW9uICgkZHJhd2luZ0NvbW1hbmRzKVxue1xuXHR2YXIgdmlzaXRlZFBvaW50cyA9IFtdO1xuXHR2YXIgY29tbWFuZHMgPSAkZHJhd2luZ0NvbW1hbmRzLnBvaW50Q29tbWFuZHM7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgcG9pbnQgPSBjb21tYW5kc1tpXS5wb2ludDtcblx0XHRmb3IgKHZhciBrID0gMDsgayA8IHZpc2l0ZWRQb2ludHMubGVuZ3RoOyBrICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIHZpc2l0ZWQgPSB2aXNpdGVkUG9pbnRzW2tdO1xuXHRcdFx0aWYgKHZpc2l0ZWRbMF0gPT09IHBvaW50WzBdICYmIHZpc2l0ZWRbMV0gPT09IHBvaW50WzFdKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zb2xlLmxvZyhpLCAnZHVwbGljYXRlIGZvdW5kICEnLCB2aXNpdGVkWzBdLCB2aXNpdGVkWzFdLCBwb2ludFswXSwgcG9pbnRbMV0pO1xuXHRcdFx0XHRjb21tYW5kcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdGkgPSBpIC0gMTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmlzaXRlZFBvaW50cy5wdXNoKHBvaW50KTtcblx0fVxufTtcblxuU3RydWN0dXJlLnByb3RvdHlwZS5jcmVhdGVJbm5lclN0cnVjdHVyZSA9IGZ1bmN0aW9uICgkcG9pbnRzKVxue1xuXHR2YXIgcG9seWdvbiA9IFBvbHlnb24uaW5pdCgkcG9pbnRzKTtcblx0dmFyIGRpYW0gPSB0aGlzLndvcmxkLmdldFdpZHRoKCkgKiB0aGlzLmdyb3VwLmNvbmYuaW5uZXJTdHJ1Y3R1cmVEZWY7Ly93aWR0aCAvIDEwOy8vdGhpcy53b3JsZC5nZXRXaWR0aCgpIC8gMzA7XG5cdHRoaXMuaW5uZXJSYWRpdXMgPSB0aGlzLmdyb3VwLmNvbmYubm9kZVJhZGl1cyB8fCBkaWFtIC8gMjtcblx0dGhpcy5pbm5lclN0cnVjdHVyZSA9IEdyaWQuY3JlYXRlRnJvbVBvbHlnb24ocG9seWdvbiwgZGlhbSwgdHJ1ZSk7XG5cdHRoaXMuc3RydWN0dXJlTm9kZXMgPSB0aGlzLmNyZWF0ZU5vZGVzRnJvbVBvaW50cyh0aGlzLmlubmVyU3RydWN0dXJlLmdldE5vZGVzQXJyYXkoKSk7XG5cblx0dmFyIG5ldHdvcmsgPSB0aGlzLmlubmVyU3RydWN0dXJlLmdldE5ldHdvcmsoKTtcblx0dmFyIGkgPSAwO1xuXHR2YXIgbGVuZ3RoID0gbmV0d29yay5sZW5ndGg7XG5cdGZvciAoaTsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJMaW5rID0gbmV0d29ya1tpXTtcblx0XHR2YXIgbjEgPSB0aGlzLmdyb3VwLmdldE5vZGVBdFBvaW50KGN1cnJMaW5rWzBdWzBdLCBjdXJyTGlua1swXVsxXSk7XG5cdFx0dmFyIG4yID0gdGhpcy5ncm91cC5nZXROb2RlQXRQb2ludChjdXJyTGlua1sxXVswXSwgY3VyckxpbmtbMV1bMV0pO1xuXHRcdHRoaXMuZ3JvdXAuY3JlYXRlSm9pbnQobjEsIG4yKTtcblx0fVxuXHRsZW5ndGggPSB0aGlzLnN0cnVjdHVyZU5vZGVzLmxlbmd0aDtcblx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIG5vZGUgPSB0aGlzLnN0cnVjdHVyZU5vZGVzW2ldO1xuXHRcdHRoaXMubm9kZVByb3BlcnRpZXMucHVzaCh7IG5vZGU6IG5vZGUsIGNvbW1hbmRQcm9wZXJ0aWVzOiB1bmRlZmluZWQsIGlzRW52ZWxvcGU6IGZhbHNlIH0pO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuc3RydWN0dXJlTm9kZXM7XG59O1xuXG5TdHJ1Y3R1cmUucHJvdG90eXBlLmNyZWF0ZUpvaW50c0Zyb21Qb2ludHMgPSBmdW5jdGlvbiAoJHBvaW50cywgJG5vQ2xvc2UpXG57XG5cdHZhciBwb2ludHNMZW5ndGggPSAkcG9pbnRzLmxlbmd0aDtcblx0Zm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHNMZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJyUG9pbnQgPSAkcG9pbnRzW2ldO1xuXHRcdHZhciBsYXN0UG9pbnQgPSAkcG9pbnRzW2kgLSAxXTtcblx0XHR2YXIgbGFzdE5vZGUgPSB0aGlzLmdyb3VwLmdldE5vZGVBdFBvaW50KGxhc3RQb2ludFswXSwgbGFzdFBvaW50WzFdKTtcblx0XHR2YXIgY3Vyck5vZGUgPSB0aGlzLmdyb3VwLmdldE5vZGVBdFBvaW50KGN1cnJQb2ludFswXSwgY3VyclBvaW50WzFdKTtcblx0XHR0aGlzLmdyb3VwLmNyZWF0ZUpvaW50KGxhc3ROb2RlLCBjdXJyTm9kZSk7XG5cdFx0aWYgKGkgPT09IHBvaW50c0xlbmd0aCAtIDEgJiYgJG5vQ2xvc2UgIT09IHRydWUpXG5cdFx0e1xuXHRcdFx0dmFyIGZpcnN0Tm9kZSA9IHRoaXMuZ3JvdXAuZ2V0Tm9kZUF0UG9pbnQoJHBvaW50c1swXVswXSwgJHBvaW50c1swXVsxXSk7XG5cdFx0XHR0aGlzLmdyb3VwLmNyZWF0ZUpvaW50KGN1cnJOb2RlLCBmaXJzdE5vZGUpO1xuXHRcdH1cblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJ1Y3R1cmU7XG5cbiIsInZhciBwb2x5MnRyaSA9IHJlcXVpcmUoJy4uLy4uL2xpYnMvcG9seTJ0cmkvZGlzdC9wb2x5MnRyaScpO1xuXG52YXIgVHJpYW5ndWxhdG9yID0gZnVuY3Rpb24gKClcbntcbn07XG5cblRyaWFuZ3VsYXRvci5wcm90b3R5cGUudHJpYW5ndWxhdGUgPSBmdW5jdGlvbiAoJGNvb3Jkcylcbntcblx0dmFyIHBvbHkydHJpQ29udG91ciA9IFtdO1xuXHQvL2RlYnVnZ2VyO1xuXG5cdGZvciAodmFyIGkgPSAwLCBwb2ludHNMZW5ndGggPSAkY29vcmRzLmxlbmd0aDsgaSA8IHBvaW50c0xlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIHBvaW50ID0gJGNvb3Jkc1tpXTtcblx0XHRwb2x5MnRyaUNvbnRvdXIucHVzaChuZXcgcG9seTJ0cmkuUG9pbnQocG9pbnRbMF0sIHBvaW50WzFdKSk7XG5cdH1cblxuXHR2YXIgc3djdHg7XG5cdHRyeVxuXHR7XG5cdFx0Ly8gcHJlcGFyZSBTd2VlcENvbnRleHRcblx0XHRzd2N0eCA9IG5ldyBwb2x5MnRyaS5Td2VlcENvbnRleHQocG9seTJ0cmlDb250b3VyLCB7IGNsb25lQXJyYXlzOiB0cnVlIH0pO1xuXG5cdFx0Ly8gdHJpYW5ndWxhdGVcblx0XHRzd2N0eC50cmlhbmd1bGF0ZSgpO1xuXHR9XG5cdGNhdGNoIChlKVxuXHR7XG5cdFx0dGhyb3cgZTtcblx0XHQvLyBjb25zb2xlLmxvZyhlKTtcblx0XHQvLyBjb25zb2xlLmxvZyhlLnBvaW50cyk7XG5cdH1cblx0dmFyIHRyaWFuZ2xlcyA9IHN3Y3R4LmdldFRyaWFuZ2xlcygpO1xuXG5cdHZhciBwb2ludHNBcnJheSA9IFtdO1xuXG5cdHZhciB0cmlhbmdsZXNMZW5ndGggPSB0cmlhbmdsZXMubGVuZ3RoO1xuXHRmb3IgKGkgPSAwOyBpIDwgdHJpYW5nbGVzTGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3VyclRyaWFuZ2xlID0gdHJpYW5nbGVzW2ldO1xuXHRcdC8qanNoaW50IGNhbWVsY2FzZTpmYWxzZSovXG5cdFx0Ly9qc2NzOmRpc2FibGUgZGlzYWxsb3dEYW5nbGluZ1VuZGVyc2NvcmVzXG5cdFx0cG9pbnRzQXJyYXkucHVzaChjdXJyVHJpYW5nbGUucG9pbnRzXyk7XG5cdFx0Ly9qc2NzOmVuYWJsZSBkaXNhbGxvd0RhbmdsaW5nVW5kZXJzY29yZXNcblx0XHQvKmpzaGludCBjYW1lbGNhc2U6dHJ1ZSovXG5cdH1cblxuXHRyZXR1cm4gcG9pbnRzQXJyYXk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyaWFuZ3VsYXRvcjtcblxuIiwidmFyIEFuY2hvclAyR2hvc3RQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgkcDIsICRwMldvcmxkLCAkd29ybGRIZWlnaHQpXG57XG5cdHRoaXMucDIgPSAkcDI7XG5cdHRoaXMucDJXb3JsZCA9ICRwMldvcmxkO1xuXHR0aGlzLm9mZnNldCA9IFswLCAwXTtcblx0dGhpcy53b3JsZEhlaWdodCA9ICR3b3JsZEhlaWdodDtcbn07XG5cbkFuY2hvclAyR2hvc3RQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuc2V0RnJvbVBvaW50ID0gZnVuY3Rpb24gKCRwb2ludClcbntcblx0dGhpcy5wb2ludCA9ICRwb2ludDtcbn07XG5cbkFuY2hvclAyR2hvc3RQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuYWRkVG9Xb3JsZCA9IGZ1bmN0aW9uICgpXG57XG5cdHRoaXMuYm9keSA9IG5ldyB0aGlzLnAyLkJvZHkoe1xuXHRcdHBvc2l0aW9uOiBbdGhpcy5wb2ludFswXSwgdGhpcy53b3JsZEhlaWdodCAtIHRoaXMucG9pbnRbMV1dXG5cdH0pO1xuXHR0aGlzLnAyV29ybGQuYWRkQm9keSh0aGlzLmJvZHkpO1xufTtcblxuQW5jaG9yUDJHaG9zdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMuYm9keS5wb3NpdGlvblswXTtcbn07XG5cbkFuY2hvclAyR2hvc3RQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLndvcmxkSGVpZ2h0IC0gdGhpcy5ib2R5LnBvc2l0aW9uWzFdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbmNob3JQMkdob3N0UGh5c2ljc01hbmFnZXI7XG4iLCJ2YXIgQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXIgPSBmdW5jdGlvbiAoJGdyb3VwKSB7IHRoaXMuZ3JvdXAgPSAkZ3JvdXA7IH07XG5cbkFuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5zZXRGcm9tUG9pbnQgPSBmdW5jdGlvbiAoJHBvaW50KVxue1xuXHR0aGlzLnBvaW50ID0gJHBvaW50O1xufTtcblxuQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmFkZFRvV29ybGQgPSBmdW5jdGlvbiAoKVxue1xuXHR0aGlzLmJvZHkgPSB0aGlzLmdyb3VwLnBoeXNpY3NNYW5hZ2VyLmJvZHk7XG5cdHRoaXMud29ybGRIZWlnaHQgPSB0aGlzLmdyb3VwLnBoeXNpY3NNYW5hZ2VyLndvcmxkSGVpZ2h0O1xuXHR0aGlzLm9mZnNldCA9IFt0aGlzLnBvaW50WzBdIC0gdGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzBdLCAodGhpcy53b3JsZEhlaWdodCAtIHRoaXMucG9pbnRbMV0pIC0gdGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzFdXTtcblx0dmFyIGRYID0gdGhpcy5vZmZzZXRbMF07XG5cdHZhciBkWSA9IHRoaXMub2Zmc2V0WzFdO1xuXHR0aGlzLmFuZ2xlID0gTWF0aC5hdGFuMihkWSwgZFgpO1xuXHR0aGlzLmh5cCA9IE1hdGguc3FydChkWCAqIGRYICsgZFkgKiBkWSk7XG59O1xuXG5BbmNob3JQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuc2V0Rml4ZWQgPSBmdW5jdGlvbiAoJGZpeGVkKVxue1xuXHR0aGlzLmdyb3VwLmZpeGVkID0gJGZpeGVkO1xufTtcblxuQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzBdICsgdGhpcy5oeXAgKiBNYXRoLmNvcyh0aGlzLmJvZHkuYW5nbGUgKyB0aGlzLmFuZ2xlKTtcbn07XG5cbkFuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMud29ybGRIZWlnaHQgLSAodGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzFdICsgdGhpcy5oeXAgKiBNYXRoLnNpbih0aGlzLmJvZHkuYW5nbGUgKyB0aGlzLmFuZ2xlKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyO1xuIiwidmFyIEFuY2hvclAyU29mdFBoeXNpY3NNYW5hZ2VyID0gZnVuY3Rpb24gKCRncm91cCkgeyB0aGlzLmdyb3VwID0gJGdyb3VwOyB9O1xuXG5BbmNob3JQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuc2V0RnJvbVBvaW50ID0gZnVuY3Rpb24gKCRwb2ludClcbntcblx0dGhpcy5wb2ludCA9ICRwb2ludDtcblx0dGhpcy5ub2RlID0gdGhpcy5ncm91cC5nZXRDbG9zZXN0Tm9kZSgkcG9pbnQpO1xuXHR0aGlzLndvcmxkSGVpZ2h0ID0gdGhpcy5ncm91cC5waHlzaWNzTWFuYWdlci53b3JsZEhlaWdodDtcblx0dGhpcy5vZmZzZXQgPSBbMCwgMF07XG59O1xuXG5BbmNob3JQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuYWRkVG9Xb3JsZCA9IGZ1bmN0aW9uICgpXG57XG5cdHRoaXMuYm9keSA9IHRoaXMubm9kZS5waHlzaWNzTWFuYWdlci5ib2R5O1xufTtcblxuQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLnNldEZpeGVkID0gZnVuY3Rpb24gKCRmaXhlZClcbntcblx0dGhpcy5ub2RlLmZpeGVkID0gJGZpeGVkO1xufTtcblxuQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzBdO1xufTtcblxuQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy53b3JsZEhlaWdodCAtIHRoaXMuYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblsxXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXI7XG4iLCJ2YXIgSGFyZERlY29yYXRpb25EcmF3aW5nID0gcmVxdWlyZSgnLi9IYXJkRGVjb3JhdGlvbkRyYXdpbmcnKTtcblxudmFyIEdyb3VwR2hvc3RQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgkZ3JvdXApXG57XG5cdHRoaXMuZ3JvdXAgPSAkZ3JvdXA7XG5cdHRoaXMuX2JvdW5kaW5nQm94ID0gdW5kZWZpbmVkO1xuXHR0aGlzLl9wb3NpdGlvbiA9IFtdO1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHRoaXMubm9kZXNBZGRlZFByb21pc2UgPSBuZXcgd2luZG93LlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgc2VsZi5yZXNvbHZlTm9kZXNBZGRlZCA9IHJlc29sdmU7IH0pO1xufTtcblxuR3JvdXBHaG9zdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXROb2RlUGh5c2ljc01hbmFnZXIgPSBmdW5jdGlvbiAoJG5vZGUpXG57XG5cdHZhciBtYW5hZ2VyID0ge307XG5cdHZhciBnZXRYID0gZnVuY3Rpb24gKCRub2RlT1gpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuICRub2RlT1g7IH07IH07XG5cdHZhciBnZXRZID0gZnVuY3Rpb24gKCRub2RlT1kpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuICRub2RlT1k7IH07IH07XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLmdyb3VwLm5vZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0bWFuYWdlci5nZXRYID0gZ2V0WCgkbm9kZS5vWCk7XG5cdFx0bWFuYWdlci5nZXRZID0gZ2V0WSgkbm9kZS5vWSk7XG5cdH1cblx0cmV0dXJuIG1hbmFnZXI7XG59O1xuXG5Hcm91cEdob3N0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldERlY29yYXRpb25EcmF3aW5nID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIEhhcmREZWNvcmF0aW9uRHJhd2luZy5jcmVhdGUodGhpcy5ncm91cCk7XG59O1xuXG5Hcm91cEdob3N0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKClcbntcblx0aWYgKCF0aGlzLl9ib3VuZGluZ0JveClcblx0e1xuXHRcdHZhciBtaW5YID0gSW5maW5pdHk7XG5cdFx0dmFyIG1pblkgPSBJbmZpbml0eTtcblx0XHR2YXIgbWF4WCA9IC1JbmZpbml0eTtcblx0XHR2YXIgbWF4WSA9IC1JbmZpbml0eTtcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5ncm91cC5ub2Rlc0xlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjdXJyTm9kZSA9IHRoaXMuZ3JvdXAubm9kZXNbaV07XG5cdFx0XHRtaW5YID0gTWF0aC5taW4oY3Vyck5vZGUucGh5c2ljc01hbmFnZXIuZ2V0WCgpLCBtaW5YKTtcblx0XHRcdG1pblkgPSBNYXRoLm1pbihjdXJyTm9kZS5waHlzaWNzTWFuYWdlci5nZXRZKCksIG1pblkpO1xuXHRcdFx0bWF4WCA9IE1hdGgubWluKGN1cnJOb2RlLnBoeXNpY3NNYW5hZ2VyLmdldFgoKSwgbWF4WCk7XG5cdFx0XHRtYXhZID0gTWF0aC5taW4oY3Vyck5vZGUucGh5c2ljc01hbmFnZXIuZ2V0WSgpLCBtYXhZKTtcblx0XHR9XG5cdFx0dGhpcy5fYm91bmRpbmdCb3ggPSBbW21pblgsIG1pblldLCBbbWF4WCwgbWF4WV1dO1xuXHR9XG5cdHJldHVybiB0aGlzLl9ib3VuZGluZ0JveDtcbn07XG5cbkdyb3VwR2hvc3RQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuYWRkSm9pbnRzVG9Xb3JsZCA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiBudWxsO1xufTtcblxuR3JvdXBHaG9zdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbmdsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDA7IH07XG5Hcm91cEdob3N0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwOyB9O1xuR3JvdXBHaG9zdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfTtcblxuR3JvdXBHaG9zdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uICgpXG57XG5cdGlmICghdGhpcy5fYm91bmRpbmdCb3gpXG5cdHtcblx0XHR2YXIgbWluWCA9IEluZmluaXR5O1xuXHRcdHZhciBtaW5ZID0gSW5maW5pdHk7XG5cdFx0dmFyIG1heFggPSAtSW5maW5pdHk7XG5cdFx0dmFyIG1heFkgPSAtSW5maW5pdHk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuZ3JvdXAubm9kZXNMZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgY3Vyck5vZGUgPSB0aGlzLmdyb3VwLm5vZGVzW2ldO1xuXHRcdFx0bWluWCA9IE1hdGgubWluKGN1cnJOb2RlLnBoeXNpY3NNYW5hZ2VyLmdldFgoKSwgbWluWCk7XG5cdFx0XHRtaW5ZID0gTWF0aC5taW4oY3Vyck5vZGUucGh5c2ljc01hbmFnZXIuZ2V0WSgpLCBtaW5ZKTtcblx0XHRcdG1heFggPSBNYXRoLm1heChjdXJyTm9kZS5waHlzaWNzTWFuYWdlci5nZXRYKCksIG1heFgpO1xuXHRcdFx0bWF4WSA9IE1hdGgubWF4KGN1cnJOb2RlLnBoeXNpY3NNYW5hZ2VyLmdldFkoKSwgbWF4WSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fYm91bmRpbmdCb3ggPSBbW21pblgsIG1pblldLCBbbWF4WCwgbWF4WV1dO1xuXHR9XG5cdHJldHVybiB0aGlzLl9ib3VuZGluZ0JveDtcbn07XG5cbkdyb3VwR2hvc3RQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuYWRkTm9kZXNUb1dvcmxkID0gZnVuY3Rpb24gKClcbntcblx0dGhpcy5yZXNvbHZlTm9kZXNBZGRlZCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cEdob3N0UGh5c2ljc01hbmFnZXI7XG5cbiIsIi8vIGpzY3M6ZGlzYWJsZSByZXF1aXJlQ2FtZWxDYXNlT3JVcHBlckNhc2VJZGVudGlmaWVyc1xuLypqc2hpbnQgY2FtZWxjYXNlOmZhbHNlKi9cblxudmFyIHAyID0gcmVxdWlyZSgnLi4vLi4vLi4vbGlicy9wMicpO1xudmFyIE5vZGVQMkhhcmRQaHlzaWNzTWFuYWdlciA9IHJlcXVpcmUoJy4vTm9kZVAySGFyZFBoeXNpY3NNYW5hZ2VyJyk7XG52YXIgQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXIgPSByZXF1aXJlKCcuL0FuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyJyk7XG52YXIgSGFyZERlY29yYXRpb25EcmF3aW5nID0gcmVxdWlyZSgnLi9IYXJkRGVjb3JhdGlvbkRyYXdpbmcnKTtcblxudmFyIEdyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXIgPSBmdW5jdGlvbiAoJGdyb3VwLCAkUDJXb3JsZCwgJHdvcmxkSGVpZ2h0LCAkbWF0ZXJpYWxzTGlzdClcbntcblx0dGhpcy5ncm91cCA9ICRncm91cDtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR0aGlzLl9wb3NpdGlvbiA9IFtdO1xuXHR0aGlzLmFkZGVkVG9Xb3JsZCA9IG5ldyB3aW5kb3cuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyBzZWxmLnJlc29sdmVBZGRlZFRvV29ybGQgPSByZXNvbHZlOyB9KTtcblx0dGhpcy5tYXRlcmlhbHNMaXN0ID0gJG1hdGVyaWFsc0xpc3Q7XG5cdHRoaXMud29ybGRIZWlnaHQgPSAkd29ybGRIZWlnaHQ7XG5cdHRoaXMuUDJXb3JsZCA9ICRQMldvcmxkO1xuXHR0aGlzLmNvbmYgPSAkZ3JvdXAuY29uZi5waHlzaWNzO1xuXHR0aGlzLl9ib3VuZGluZ0JveCA9IFtbMCwgMF0sIFswLCAwXV07XG59O1xuXG5Hcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXREZWNvcmF0aW9uRHJhd2luZyA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiBIYXJkRGVjb3JhdGlvbkRyYXdpbmcuY3JlYXRlKHRoaXMuZ3JvdXApO1xufTtcblxuR3JvdXBQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0Tm9kZVBoeXNpY3NNYW5hZ2VyID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIG5ldyBOb2RlUDJIYXJkUGh5c2ljc01hbmFnZXIoKTtcbn07XG5cbkdyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKClcbntcblx0dmFyIEFBQkIgPSB0aGlzLmJvZHkuZ2V0QUFCQigpO1xuXHR0aGlzLl9ib3VuZGluZ0JveFswXVswXSA9IEFBQkIubG93ZXJCb3VuZFswXTtcblx0dGhpcy5fYm91bmRpbmdCb3hbMF1bMV0gPSB0aGlzLndvcmxkSGVpZ2h0IC0gQUFCQi51cHBlckJvdW5kWzFdO1xuXHR0aGlzLl9ib3VuZGluZ0JveFsxXVswXSA9IEFBQkIudXBwZXJCb3VuZFswXTtcblx0dGhpcy5fYm91bmRpbmdCb3hbMV1bMV0gPSB0aGlzLndvcmxkSGVpZ2h0IC0gQUFCQi5sb3dlckJvdW5kWzFdO1xuXHRyZXR1cm4gdGhpcy5fYm91bmRpbmdCb3g7XG59O1xuXG5Hcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzBdOyB9O1xuR3JvdXBQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMud29ybGRIZWlnaHQgLSB0aGlzLmJvZHkuaW50ZXJwb2xhdGVkUG9zaXRpb25bMV07IH07XG5cbkdyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldEFuZ2xlID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMuYm9keS5pbnRlcnBvbGF0ZWRBbmdsZTtcbn07XG5cbkdyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUFuY2hvckZyb21Qb2ludCA9IGZ1bmN0aW9uICgkcG9pbnQpXG57XG5cdHZhciBhbmNob3IgPSBuZXcgQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXIodGhpcy5ncm91cCk7XG5cdGFuY2hvci5zZXRGcm9tUG9pbnQoJHBvaW50KTtcblx0cmV0dXJuIGFuY2hvcjtcbn07XG5cbkdyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUFuY2hvckZyb21MaW5lID0gZnVuY3Rpb24gKCRsaW5lUG9pbnRzKVxue1xuXHR2YXIgY2xvc2VzdFBvaW50ID0gdGhpcy5ncm91cC5nZXRDbG9zZXN0UG9pbnQoJGxpbmVQb2ludHMpO1xuXHR2YXIgYW5jaG9yID0gbmV3IEFuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyKHRoaXMuZ3JvdXApO1xuXHRhbmNob3Iuc2V0RnJvbVBvaW50KGNsb3Nlc3RQb2ludCk7XG5cdHJldHVybiBhbmNob3I7XG59O1xuXG5Hcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVBbmNob3JzID0gZnVuY3Rpb24gKCRwb2ludHMpXG57XG5cdHZhciB0b1JldHVybiA9IFtdO1xuXHR2YXIgbm9kZXMgPSB0aGlzLmdyb3VwLmdldE5vZGVzSW5zaWRlKCRwb2ludHMpO1xuXHRpZiAoIW5vZGVzLmxlbmd0aClcblx0e1xuXHRcdHZhciBkZWZhdWx0QW5jaG9yID0gbmV3IEFuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyKHRoaXMuZ3JvdXApO1xuXHRcdHZhciBQb2x5Z29uID0gcmVxdWlyZSgnLi4vLi4vY29yZS9Qb2x5Z29uJyk7XG5cdFx0dmFyIHBvbHlnb24gPSBQb2x5Z29uLmluaXQoJHBvaW50cyk7XG5cdFx0dmFyIGNlbnRlciA9IHBvbHlnb24uZ2V0Q2VudGVyKCk7XG5cdFx0Ly92YXIgY2xvc2VzdCA9IHRoaXMuZ3JvdXAuZ2V0Q2xvc2VzdFBvaW50KCRwb2ludHMpO1xuXHRcdGRlZmF1bHRBbmNob3Iuc2V0RnJvbVBvaW50KGNlbnRlcik7XG5cdFx0cmV0dXJuIFtkZWZhdWx0QW5jaG9yXTtcblx0fVxuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbm9kZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgbm9kZSA9IG5vZGVzW2ldO1xuXHRcdHZhciBjdXJyQW5jaG9yQSA9IG5ldyBBbmNob3JQMkhhcmRQaHlzaWNzTWFuYWdlcih0aGlzLmdyb3VwKTtcblx0XHRjdXJyQW5jaG9yQS5zZXRGcm9tUG9pbnQoW25vZGUub1gsIG5vZGUub1ldKTtcblx0XHR0b1JldHVybi5wdXNoKGN1cnJBbmNob3JBKTtcblx0fVxuXHRyZXR1cm4gdG9SZXR1cm47XG59O1xuXG5Hcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5hZGRKb2ludHNUb1dvcmxkID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XG5cbkdyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmFkZE5vZGVzVG9Xb3JsZCA9IGZ1bmN0aW9uICgpXG57XG5cdHZhciBwYXRoID0gW107XG5cblx0dmFyIHN0YXJ0WCA9IHRoaXMuZ3JvdXAubm9kZXNbMF0ub1g7XG5cdHZhciBzdGFydFkgPSB0aGlzLmdyb3VwLm5vZGVzWzBdLm9ZO1xuXHR2YXIgaW5pdFggPSBzdGFydFg7XG5cdHZhciBpbml0WSA9IHRoaXMud29ybGRIZWlnaHQgLSBzdGFydFk7XG5cblx0dGhpcy5ib2R5ID0gbmV3IHAyLkJvZHkoe1xuXHRcdG1hc3M6IHRoaXMuZ3JvdXAuZml4ZWQgPyAwIDogMSxcblx0XHRwb3NpdGlvbjogW3N0YXJ0WCwgdGhpcy53b3JsZEhlaWdodCAtIHN0YXJ0WV1cblx0fSk7XG5cdHZhciBub2RlO1xuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5ncm91cC5ub2Rlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdG5vZGUgPSB0aGlzLmdyb3VwLm5vZGVzW2ldO1xuXHRcdHZhciBwb3MgPSBbbm9kZS5vWCAtIHN0YXJ0WCwgLShub2RlLm9ZIC0gc3RhcnRZKV07XG5cdFx0bm9kZS5waHlzaWNzTWFuYWdlci5hZGRUb1dvcmxkKHRoaXMuYm9keSwgcG9zLCB0aGlzLndvcmxkSGVpZ2h0KTtcblx0XHRwYXRoLnB1c2gocG9zKTtcblx0fVxuXG5cdGlmIChsZW5ndGggPiAxKVxuXHR7XG5cdFx0dGhpcy5ib2R5LmZyb21Qb2x5Z29uKHBhdGgpO1xuXHRcdHZhciBvZmZzZXQgPSBbaW5pdFggLSB0aGlzLmJvZHkucG9zaXRpb25bMF0sIHRoaXMuYm9keS5wb3NpdGlvblsxXSAtIGluaXRZXTtcblx0XHRpID0gMDtcblx0XHRmb3IgKGk7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHRub2RlID0gdGhpcy5ncm91cC5ub2Rlc1tpXTtcblx0XHRcdG5vZGUucGh5c2ljc01hbmFnZXIuc2V0T2Zmc2V0KG9mZnNldCk7XG5cdFx0fVxuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdHZhciByYWRpdXMgPSB0aGlzLmdyb3VwLnN0cnVjdHVyZS5yYWRpdXNYO1xuXHRcdHZhciBjaXJjbGVTaGFwZSA9IG5ldyBwMi5DaXJjbGUocmFkaXVzKTtcblx0XHR0aGlzLmJvZHkuYWRkU2hhcGUoY2lyY2xlU2hhcGUpO1xuXHR9XG5cblx0dGhpcy5ib2R5LmdyYXZpdHlTY2FsZSA9IHRoaXMuY29uZi5ncmF2aXR5U2NhbGUgIT09IHVuZGVmaW5lZCA/IHRoaXMuY29uZi5ncmF2aXR5U2NhbGUgOiAxO1xuXHQvLyBjb25zb2xlLmxvZyhzdGFydFgsIHRoaXMud29ybGRIZWlnaHQgLSBzdGFydFksIHRoaXMuYm9keS5wb3NpdGlvblswXSwgdGhpcy5ib2R5LnBvc2l0aW9uWzFdKTtcblx0Ly90aGlzLmJvZHkubWFzcyA9IHRoaXMuY29uZi5tYXNzO1xuXHQvL2lmICh0aGlzLmdyb3VwLmNvbmYuZml4ZWQpIHsgbm9kZS5waHlzaWNzTWFuYWdlci5zZXRGaXhlZCh0aGlzLmdyb3VwLmNvbmYuZml4ZWQpOyB9XG5cdC8vdGhpcy5ib2R5LnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG5cdHZhciBzaGFwZXNMZW5ndGggPSB0aGlzLmJvZHkuc2hhcGVzLmxlbmd0aDtcblx0Zm9yIChpID0gMDsgaSA8IHNoYXBlc0xlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJTaGFwZSA9IHRoaXMuYm9keS5zaGFwZXNbaV07XG5cdFx0Y3VyclNoYXBlLm1hdGVyaWFsID0gdGhpcy5jb25mLm1hdGVyaWFsID8gdGhpcy5tYXRlcmlhbHNMaXN0W3RoaXMuY29uZi5tYXRlcmlhbF0ubWF0ZXJpYWwgOiB0aGlzLm1hdGVyaWFsc0xpc3QuZGVmYXVsdC5tYXRlcmlhbDtcblx0fVxuXHR0aGlzLlAyV29ybGQuYWRkQm9keSh0aGlzLmJvZHkpO1xuXHR0aGlzLmJvZHkubWFzcyA9IHRoaXMuYm9keS5nZXRBcmVhKCkgKiB0aGlzLmNvbmYubWFzcztcblx0dGhpcy5ib2R5LnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG5cdHRoaXMuYm9keS5jb2xsaXNpb25SZXNwb25zZSA9ICF0aGlzLmNvbmYubm9Db2xsaWRlO1xuXG5cdC8vIGlmICh0aGlzLmdyb3VwLklEID09PSAncmVhcldoZWVsJylcblx0Ly8ge1xuXHQvLyBcdGNvbnNvbGUubG9nKHRoaXMuYm9keS5tYXNzKTtcblx0Ly8gfVxuXG5cdHRoaXMuYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblswXSA9IHRoaXMuYm9keS5wb3NpdGlvblswXTtcblx0dGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzFdID0gdGhpcy5ib2R5LnBvc2l0aW9uWzFdO1xuXHQvL25vZGUucGh5c2ljc01hbmFnZXIuc2V0Rml4ZWQodGhpcy5ncm91cC5jb25mLmZpeGVkKTtcblx0Ly8gY29uc29sZS5sb2codGhpcy5ib2R5LnNoYXBlcyk7XG5cdC8vIGRlYnVnZ2VyO1xuXG5cdHRoaXMucmVzb2x2ZUFkZGVkVG9Xb3JsZCgpO1xufTtcblxuR3JvdXBQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuaGl0VGVzdCA9IGZ1bmN0aW9uICgkcG9pbnQpXG57XG5cdHZhciByZXN1bHQgPSB0aGlzLlAyV29ybGQuaGl0VGVzdChbJHBvaW50WzBdLCB0aGlzLndvcmxkSGVpZ2h0IC0gJHBvaW50WzFdXSwgW3RoaXMuYm9keV0pO1xuXHRyZXR1cm4gcmVzdWx0ID8gcmVzdWx0WzBdIDogdW5kZWZpbmVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyO1xuXG4iLCIvLyBqc2NzOmRpc2FibGUgcmVxdWlyZUNhbWVsQ2FzZU9yVXBwZXJDYXNlSWRlbnRpZmllcnNcbi8qanNoaW50IGNhbWVsY2FzZTpmYWxzZSovXG5cbnZhciBwMiA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYnMvcDInKTtcbi8vIHZhciBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vLi4vZXZlbnQvRGlzcGF0Y2hlcicpO1xudmFyIE5vZGVQMlNvZnRQaHlzaWNzTWFuYWdlciA9IHJlcXVpcmUoJy4vTm9kZVAyU29mdFBoeXNpY3NNYW5hZ2VyJyk7XG52YXIgQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXIgPSByZXF1aXJlKCcuL0FuY2hvclAyU29mdFBoeXNpY3NNYW5hZ2VyJyk7XG52YXIgSm9pbnRQMlBoeXNpY3NNYW5hZ2VyID0gcmVxdWlyZSgnLi9Kb2ludFAyUGh5c2ljc01hbmFnZXInKTtcbnZhciBTb2Z0RGVjb3JhdGlvbkRyYXdpbmcgPSByZXF1aXJlKCcuL1NvZnREZWNvcmF0aW9uRHJhd2luZycpO1xuXG52YXIgR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgkZ3JvdXAsICR3b3JsZCwgJHdvcmxkSGVpZ2h0LCAkbWF0ZXJpYWxzTGlzdClcbntcblx0dGhpcy5ncm91cCA9ICRncm91cDtcblx0dGhpcy5fYm91bmRpbmdCb3ggPSBbWzAsIDBdLCBbMCwgMF1dO1xuXHR0aGlzLm1hdGVyaWFsc0xpc3QgPSAkbWF0ZXJpYWxzTGlzdDtcblx0dGhpcy5fcG9zaXRpb24gPSBbXTtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR0aGlzLmFkZGVkVG9Xb3JsZCA9IG5ldyB3aW5kb3cuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyBzZWxmLnJlc29sdmVBZGRlZFRvV29ybGQgPSByZXNvbHZlOyB9KTtcblx0dGhpcy53b3JsZCA9ICR3b3JsZDtcblx0dGhpcy53b3JsZEhlaWdodCA9ICR3b3JsZEhlaWdodDtcblx0dGhpcy5jb25mID0gJGdyb3VwLmNvbmYucGh5c2ljcztcblx0Ly8gdGhpcy5jb25zdHJhaW50cyA9IFtdO1xuXHQvL3RoaXMubm9kZXNEaWFtZXRlciA9IHRoaXMuY29uZi5ub2Rlc0RpYW1ldGVyO1xufTtcblxuR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuYWRkTm9kZXNUb1dvcmxkID0gZnVuY3Rpb24gKClcbntcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuZ3JvdXAubm9kZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHQvLyB0aGlzLmJhc2VCb2R5ID0gbmV3IHAyLkJvZHkoe1xuXHRcdC8vIFx0bWFzczogMVxuXHRcdC8vIH0pO1xuXHRcdHZhciBub2RlID0gdGhpcy5ncm91cC5ub2Rlc1tpXTtcblx0XHQvL3ZhciBmcmFjdGlvbk1hc3MgPSB0aGlzLmNvbmYubWFzcyAvIHRoaXMuZ3JvdXAubm9kZXMubGVuZ3RoO1xuXHRcdHZhciBhcmVhID0gdGhpcy5ncm91cC5zdHJ1Y3R1cmUuYXJlYTtcblx0XHR2YXIgbm9kZU1hc3MgPSBhcmVhICogdGhpcy5jb25mLm1hc3MgLyB0aGlzLmdyb3VwLm5vZGVzLmxlbmd0aDtcblx0XHQvL3ZhciBtYXNzID0gNTAwO1xuXHRcdC8vdmFyIG1hc3MgPSB0aGlzLmNvbmYubWFzczsvL01hdGgucmFuZG9tKCkgKiAxMCArIDE7XG5cdFx0dmFyIGJvZHkgPSBuZXcgcDIuQm9keSh7XG5cdFx0XHRtYXNzOiBub2RlLmZpeGVkID8gMCA6IG5vZGVNYXNzLFxuXHRcdFx0cG9zaXRpb246IFtub2RlLm9YLCB0aGlzLndvcmxkSGVpZ2h0IC0gbm9kZS5vWV1cblx0XHR9KTtcblx0XHRib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzBdID0gYm9keS5wb3NpdGlvblswXTtcblx0XHRib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzFdID0gYm9keS5wb3NpdGlvblsxXTtcblxuXHRcdC8vaWYgKG5vZGUuZml4ZWQpIHsgYm9keS50eXBlID0gcDIuQm9keS5TVEFUSUM7IH1cblx0XHQvL2NvbnNvbGUubG9nKG5vZGUub1gsIG5vZGUub1kpO1xuXHRcdC8vdGhpcy5ib2R5LmZpeGVkUm90YXRpb24gPSB0cnVlO1xuXG5cdFx0Ly8gdmFyIHJhZGl1cyA9IHRoaXMuY29uZi5ub2RlUmFkaXVzO1xuXHRcdC8vIHZhciBjaXJjbGVTaGFwZSA9IG5ldyBwMi5DaXJjbGUocmFkaXVzKTtcblx0XHQvLyBib2R5LmFkZFNoYXBlKGNpcmNsZVNoYXBlKTtcblxuXHRcdHZhciByYWRpdXMgPSB0aGlzLmdyb3VwLnN0cnVjdHVyZS5pbm5lclJhZGl1cyB8fCB0aGlzLmdyb3VwLmNvbmYubm9kZVJhZGl1cyB8fCAwLjE7XG5cdFx0dmFyIHNoYXBlID0gbmV3IHAyLkNpcmNsZShyYWRpdXMpO1xuXHRcdGJvZHkuYWRkU2hhcGUoc2hhcGUpO1xuXHRcdHNoYXBlLm1hdGVyaWFsID0gdGhpcy5jb25mLm1hdGVyaWFsID8gdGhpcy5tYXRlcmlhbHNMaXN0W3RoaXMuY29uZi5tYXRlcmlhbF0ubWF0ZXJpYWwgOiB0aGlzLm1hdGVyaWFsc0xpc3QuZGVmYXVsdC5tYXRlcmlhbDtcblxuXHRcdC8vY29uc29sZS5sb2codGhpcy5ib2R5LmdldEFyZWEoKSk7XG5cblx0XHQvL3RoaXMuYm9keS5zZXREZW5zaXR5KG5vZGUudHlwZSA9PT0gJ2xpbmUnID8gMSA6IDUwMDApO1xuXG5cdFx0Ly9ib2R5LmRhbXBpbmcgPSAxO1xuXHRcdC8vYm9keS5tYXNzID0gbWFzcztcblx0XHRub2RlLnBoeXNpY3NNYW5hZ2VyLmFkZFRvV29ybGQocDIsIGJvZHksIHRoaXMud29ybGRIZWlnaHQpO1xuXHRcdG5vZGUucGh5c2ljc01hbmFnZXIucmFkaXVzID0gcmFkaXVzO1xuXHRcdC8vbm9kZS5waHlzaWNzTWFuYWdlci5zZXRGaXhlZChub2RlLmZpeGVkKTtcblx0XHQvL2JvZHkuc2V0RGVuc2l0eSgwLjEpO1xuXHRcdHRoaXMud29ybGQuYWRkQm9keShib2R5KTtcblxuXHRcdC8vYm9keS5tYXNzID0gYm9keS5nZXRBcmVhKCkgKiB0aGlzLmNvbmYubWFzcztcblx0XHQvL2JvZHkuZ3Jhdml0eVNjYWxlID0gMC4xO1xuXHRcdC8vYm9keS51cGRhdGVNYXNzUHJvcGVydGllcygpO1xuXHRcdC8vIGJvZHkubWFzcyA9IDA7XG5cdFx0Ly8gYm9keS5zZXREZW5zaXR5KDApO1xuXHRcdC8vbm9kZS5waHlzaWNzTWFuYWdlci5hcHBseUZvcmNlKFswLCAwXSk7XG5cdFx0Ly8gYm9keS5tYXNzID0gMTA7XG5cdFx0dmFyIG1hc3NWYXJpYW5jZSA9IHRoaXMuY29uZi5tYXNzVmFyaWFuY2UgfHwgMDtcblx0XHR2YXIgcmFuZG9tID0gLW1hc3NWYXJpYW5jZSArIE1hdGgucmFuZG9tKCkgKiBtYXNzVmFyaWFuY2UgKiAyO1xuXHRcdGJvZHkubWFzcyA9IGJvZHkubWFzcyArIGJvZHkubWFzcyAqIHJhbmRvbTtcblx0XHQvL2JvZHkubWFzcyA9IGJvZHkubWFzcztcblx0XHRib2R5Lmludk1hc3MgPSAxIC8gYm9keS5tYXNzO1xuXHRcdGJvZHkuaW5lcnRpYSA9IGJvZHkubWFzcyAqIDAuNTtcblx0XHRib2R5LmludkluZXJ0aWEgPSAxIC8gYm9keS5pbmVydGlhO1xuXHRcdGJvZHkuY29sbGlzaW9uUmVzcG9uc2UgPSAhdGhpcy5jb25mLm5vQ29sbGlkZTtcblxuXHRcdGJvZHkuYW5ndWxhckRhbXBpbmcgPSB0aGlzLmNvbmYuYW5ndWxhckRhbXBpbmcgfHwgYm9keS5hbmd1bGFyRGFtcGluZztcblx0XHRib2R5LmRhbXBpbmcgPSB0aGlzLmNvbmYuZGFtcGluZyB8fCBib2R5LmRhbXBpbmc7XG5cblx0XHRib2R5LmdyYXZpdHlTY2FsZSA9IHRoaXMuY29uZi5ncmF2aXR5U2NhbGUgIT09IHVuZGVmaW5lZCA/IHRoaXMuY29uZi5ncmF2aXR5U2NhbGUgOiAxO1xuXHR9XG5cblx0dmFyIFBvbHlnb24gPSByZXF1aXJlKCcuLi8uLi9jb3JlL1BvbHlnb24nKTtcblx0dmFyIHBvaW50cyA9IFtdO1xuXHR2YXIgZW52ZWxvcGUgPSB0aGlzLmdyb3VwLnN0cnVjdHVyZS5lbnZlbG9wZTtcblx0dmFyIGVudmVsb3BlTGVuZ3RoID0gdGhpcy5ncm91cC5zdHJ1Y3R1cmUuZW52ZWxvcGUubGVuZ3RoO1xuXHRmb3IgKGkgPSAwOyBpIDwgZW52ZWxvcGVMZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHBvaW50cy5wdXNoKGVudmVsb3BlW2ldLnBoeXNpY3NNYW5hZ2VyLmJvZHkuaW50ZXJwb2xhdGVkUG9zaXRpb24pO1xuXHR9XG5cdHRoaXMucG9seWdvbiA9IFBvbHlnb24uaW5pdChwb2ludHMpO1xuXHQvL2RlYnVnZ2VyO1xuXG5cdGlmICh0aGlzLmNvbmYuc3RydWN0dXJhbE1hc3NEZWNheSkgeyB0aGlzLnNldE5vZGVzTWFzc0Zyb21Kb2ludHMoKTsgfVxuXG5cdHRoaXMucmVzb2x2ZUFkZGVkVG9Xb3JsZCgpO1xuXG5cdGlmICh0aGlzLmdyb3VwLklEID09PSAnc21pbGV5Jylcblx0e1xuXHRcdGNvbnNvbGUubG9nKHRoaXMuZ3JvdXAuc3RydWN0dXJlLmFyZWEgKiB0aGlzLmNvbmYubWFzcywgdGhpcy5nZXRNYXNzKCkpO1xuXHR9XG59O1xuXG5Hcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXREZWNvcmF0aW9uRHJhd2luZyA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiBTb2Z0RGVjb3JhdGlvbkRyYXdpbmcuY3JlYXRlKHRoaXMuZ3JvdXApO1xufTtcblxuR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0Tm9kZVBoeXNpY3NNYW5hZ2VyID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIG5ldyBOb2RlUDJTb2Z0UGh5c2ljc01hbmFnZXIoKTtcbn07XG5cbkdyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKClcbntcblx0dmFyIG1pblggPSBJbmZpbml0eTtcblx0dmFyIG1pblkgPSBJbmZpbml0eTtcblx0dmFyIG1heFggPSAtSW5maW5pdHk7XG5cdHZhciBtYXhZID0gLUluZmluaXR5O1xuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5ncm91cC5ub2Rlc0xlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJOb2RlID0gdGhpcy5ncm91cC5ub2Rlc1tpXTtcblx0XHRtaW5YID0gTWF0aC5taW4oY3Vyck5vZGUucGh5c2ljc01hbmFnZXIuZ2V0WCgpLCBtaW5YKTtcblx0XHRtaW5ZID0gTWF0aC5taW4oY3Vyck5vZGUucGh5c2ljc01hbmFnZXIuZ2V0WSgpLCBtaW5ZKTtcblx0XHRtYXhYID0gTWF0aC5tYXgoY3Vyck5vZGUucGh5c2ljc01hbmFnZXIuZ2V0WCgpLCBtYXhYKTtcblx0XHRtYXhZID0gTWF0aC5tYXgoY3Vyck5vZGUucGh5c2ljc01hbmFnZXIuZ2V0WSgpLCBtYXhZKTtcblx0fVxuXG5cdHRoaXMuX2JvdW5kaW5nQm94WzBdWzBdID0gbWluWDtcblx0dGhpcy5fYm91bmRpbmdCb3hbMF1bMV0gPSBtaW5ZO1xuXHR0aGlzLl9ib3VuZGluZ0JveFsxXVswXSA9IG1heFg7XG5cdHRoaXMuX2JvdW5kaW5nQm94WzFdWzFdID0gbWF4WTtcblxuXHRyZXR1cm4gdGhpcy5fYm91bmRpbmdCb3g7XG59O1xuXG5Hcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVBbmNob3JGcm9tUG9pbnQgPSBmdW5jdGlvbiAoJHBvaW50KVxue1xuXHR2YXIgYW5jaG9yID0gbmV3IEFuY2hvclAyU29mdFBoeXNpY3NNYW5hZ2VyKHRoaXMuZ3JvdXApO1xuXHRhbmNob3Iuc2V0RnJvbVBvaW50KCRwb2ludCk7XG5cdHJldHVybiBhbmNob3I7XG59O1xuXG5Hcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVBbmNob3JGcm9tTGluZSA9IGZ1bmN0aW9uICgkbGluZVBvaW50cylcbntcblx0dmFyIGNsb3Nlc3RQb2ludCA9IHRoaXMuZ3JvdXAuZ2V0Q2xvc2VzdFBvaW50KCRsaW5lUG9pbnRzKTtcblx0dmFyIGFuY2hvciA9IG5ldyBBbmNob3JQMlNvZnRQaHlzaWNzTWFuYWdlcih0aGlzLmdyb3VwKTtcblx0YW5jaG9yLnNldEZyb21Qb2ludChjbG9zZXN0UG9pbnQpO1xuXHRyZXR1cm4gYW5jaG9yO1xufTtcblxuR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlQW5jaG9ycyA9IGZ1bmN0aW9uICgkcG9pbnRzKVxue1xuXHR2YXIgdG9SZXR1cm4gPSBbXTtcblx0dmFyIG5vZGVzID0gdGhpcy5ncm91cC5nZXROb2Rlc0luc2lkZSgkcG9pbnRzKTtcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIG5vZGUgPSBub2Rlc1tpXTtcblx0XHR2YXIgY3VyckFuY2hvckEgPSBuZXcgQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXIodGhpcy5ncm91cCk7XG5cdFx0Y3VyckFuY2hvckEuc2V0RnJvbVBvaW50KFtub2RlLm9YLCBub2RlLm9ZXSk7XG5cdFx0dG9SZXR1cm4ucHVzaChjdXJyQW5jaG9yQSk7XG5cdH1cblx0cmV0dXJuIHRvUmV0dXJuO1xufTtcblxuR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuYWRkSm9pbnRzVG9Xb3JsZCA9IGZ1bmN0aW9uICgpXG57XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLmdyb3VwLmpvaW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBqb2ludCA9IHRoaXMuZ3JvdXAuam9pbnRzW2ldO1xuXHRcdGpvaW50LnBoeXNpY3NNYW5hZ2VyID0gbmV3IEpvaW50UDJQaHlzaWNzTWFuYWdlcihqb2ludCwgdGhpcy53b3JsZCwgdGhpcy5jb25mKTtcblx0fVxufTtcblxuR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuc2V0Tm9kZXNNYXNzRnJvbUpvaW50cyA9IGZ1bmN0aW9uICgpXG57XG5cdHZhciBOb2RlR3JhcGggPSByZXF1aXJlKCcuLi8uLi9jb3JlL05vZGVHcmFwaCcpO1xuXHR2YXIgbm9kZUdyYXBoID0gbmV3IE5vZGVHcmFwaCgpO1xuXHR2YXIgaTtcblx0dmFyIHN0YXJ0aW5nVmVydGljZXMgPSBbXTtcblx0dmFyIG5vZGVzTGVuZ3RoID0gdGhpcy5ncm91cC5ub2Rlcy5sZW5ndGg7XG5cdHZhciBqb2ludHNMZW5ndGggPSB0aGlzLmdyb3VwLmpvaW50cy5sZW5ndGg7XG5cdGZvciAoaSA9IDA7IGkgPCBqb2ludHNMZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJySm9pbnQgPSB0aGlzLmdyb3VwLmpvaW50c1tpXTtcblx0XHRub2RlR3JhcGguY29ubmVjdChjdXJySm9pbnQubm9kZUEsIGN1cnJKb2ludC5ub2RlQik7XG5cdH1cblx0Zm9yIChpID0gMDsgaSA8IG5vZGVzTGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgbm9kZSA9IHRoaXMuZ3JvdXAubm9kZXNbaV07XG5cdFx0aWYgKG5vZGUuZml4ZWQpXG5cdFx0e1xuXHRcdFx0c3RhcnRpbmdWZXJ0aWNlcy5wdXNoKG5vZGVHcmFwaC5nZXRWZXJ0ZXgobm9kZSkpO1xuXHRcdH1cblx0fVxuXHRpZiAoc3RhcnRpbmdWZXJ0aWNlcy5sZW5ndGggPT09IDApXG5cdHtcblx0XHRyZXR1cm47XG5cdH1cblx0bm9kZUdyYXBoLnRyYXZlcnNlKHN0YXJ0aW5nVmVydGljZXMpO1xuXHR2YXIgdmVydGljZXNMZW5ndGggPSBub2RlR3JhcGgudmVydGljZXMubGVuZ3RoO1xuXHRmb3IgKGkgPSAwOyBpIDwgdmVydGljZXNMZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciB2ZXJ0ZXggPSBub2RlR3JhcGgudmVydGljZXNbaV07XG5cdFx0dmFyIGRlY2F5ID0gTnVtYmVyKHRoaXMuZ3JvdXAuY29uZi5waHlzaWNzLnN0cnVjdHVyYWxNYXNzRGVjYXkpO1xuXHRcdHZhciB2YWx1ZSA9IE1hdGgucG93KGRlY2F5LCB2ZXJ0ZXgubWFwVmFsdWUgLyA1KTsvL01hdGgucG93KDIsIHZlcnRleC5tYXBWYWx1ZSAvIDcuMzMpO1xuXHRcdHZhciBib2R5ID0gdmVydGV4Lm5vZGUucGh5c2ljc01hbmFnZXIuYm9keTtcblx0XHRpZiAoIXZlcnRleC5ub2RlLmZpeGVkKVxuXHRcdHtcblx0XHRcdC8vYm9keS5tYXNzID0gdGhpcy5jb25mLm1hc3MgLyB0aGlzLmdyb3VwLm5vZGVzLmxlbmd0aCAvIHZhbHVlICogYm9keS5nZXRBcmVhKCk7XG5cdFx0XHQvL3ZlcnRleC5ub2RlLmRlYnVnVGV4dCA9IGJvZHkubWFzcztcblx0XHRcdC8vYm9keS51cGRhdGVNYXNzUHJvcGVydGllcygpO1xuXHRcdFx0dmFyIG1hc3NWYXJpYW5jZSA9IHRoaXMuY29uZi5tYXNzVmFyaWFuY2UgfHwgMDtcblx0XHRcdHZhciByYW5kb20gPSAtbWFzc1ZhcmlhbmNlICsgTWF0aC5yYW5kb20oKSAqIG1hc3NWYXJpYW5jZSAqIDI7XG5cdFx0XHR2YXIgYmFzZU1hc3MgPSB0aGlzLmdyb3VwLnN0cnVjdHVyZS5hcmVhICogdGhpcy5jb25mLm1hc3M7XG5cdFx0XHR2YXIgbWFzcyA9IGJhc2VNYXNzICsgYmFzZU1hc3MgKiByYW5kb207XG5cdFx0XHRib2R5Lm1hc3MgPSBtYXNzIC8gdmFsdWU7XG5cdFx0XHRib2R5Lmludk1hc3MgPSAxIC8gYm9keS5tYXNzO1xuXHRcdFx0Ym9keS5pbmVydGlhID0gYm9keS5tYXNzIC8gMjtcblx0XHRcdGJvZHkuaW52SW5lcnRpYSA9IDEgLyBib2R5LmluZXJ0aWE7XG5cdFx0fVxuXHR9XG59O1xuXG5Hcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5hcHBseUFuZ3VsYXJGb3JjZSA9IGZ1bmN0aW9uICgkdmFsdWUpXG57XG5cdC8vdGhpcy5ncm91cC5ub2Rlc1swXS5waHlzaWNzTWFuYWdlci5ib2R5LmFuZ3VsYXJGb3JjZSArPSAkdmFsdWU7XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLmdyb3VwLm5vZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJQaHlzID0gdGhpcy5ncm91cC5ub2Rlc1tpXS5waHlzaWNzTWFuYWdlcjtcblx0XHRjdXJyUGh5cy5ib2R5LmFuZ3VsYXJGb3JjZSArPSAkdmFsdWU7XG5cdH1cbn07XG5cbkdyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbiAoJHZlY3Rvcilcbntcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuZ3JvdXAubm9kZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3VyclBoeXMgPSB0aGlzLmdyb3VwLm5vZGVzW2ldLnBoeXNpY3NNYW5hZ2VyO1xuXHRcdGN1cnJQaHlzLmJvZHkuZm9yY2UgPSBbXG5cdFx0XHRjdXJyUGh5cy5ib2R5LmZvcmNlWzBdICsgJHZlY3RvclswXSxcblx0XHRcdGN1cnJQaHlzLmJvZHkuZm9yY2VbMV0gKyAkdmVjdG9yWzFdXG5cdFx0XTtcblx0fVxufTtcblxuR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0TWFzcyA9IGZ1bmN0aW9uICgpXG57XG5cdHZhciBtYXNzID0gMDtcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuZ3JvdXAubm9kZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgbm9kZSA9IHRoaXMuZ3JvdXAubm9kZXNbaV07XG5cdFx0bWFzcyArPSBub2RlLnBoeXNpY3NNYW5hZ2VyLmJvZHkubWFzcztcblx0fVxuXG5cdHJldHVybiBtYXNzO1xufTtcblxuR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JvdXAubm9kZXNbMF0ucGh5c2ljc01hbmFnZXIuYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblswXTsgfTtcbkdyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLndvcmxkSGVpZ2h0IC0gdGhpcy5ncm91cC5ub2Rlc1swXS5waHlzaWNzTWFuYWdlci5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzFdOyB9O1xuXG5Hcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbmdsZSA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLmdyb3VwLm5vZGVzWzBdLnBoeXNpY3NNYW5hZ2VyLmJvZHkuaW50ZXJwb2xhdGVkQW5nbGU7XG59O1xuXG5Hcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5oaXRUZXN0ID0gZnVuY3Rpb24gKCRwb2ludCwgJHByZWNpc2lvbilcbntcblx0JHBvaW50WzFdID0gdGhpcy53b3JsZEhlaWdodCAtICRwb2ludFsxXTtcblx0dmFyIGR4O1xuXHR2YXIgZHk7XG5cdHZhciBub2Rlc0xlbmd0aCA9IHRoaXMuZ3JvdXAubm9kZXMubGVuZ3RoO1xuXG5cdGZvciAodmFyIG0gPSAwOyBtIDwgbm9kZXNMZW5ndGg7IG0gKz0gMSlcblx0e1xuXHRcdHZhciBib2R5ID0gdGhpcy5ncm91cC5ub2Rlc1ttXS5waHlzaWNzTWFuYWdlci5ib2R5O1xuXHRcdGR4ID0gTWF0aC5hYnMoYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblswXSAtICRwb2ludFswXSk7XG5cdFx0ZHkgPSBNYXRoLmFicyhib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzFdIC0gJHBvaW50WzFdKTtcblx0XHRpZiAoZHggPCAkcHJlY2lzaW9uICYmIGR5IDwgJHByZWNpc2lvbilcblx0XHR7XG5cdFx0XHRyZXR1cm4gYm9keTtcblx0XHR9XG5cdH1cblx0aWYgKHRoaXMucG9seWdvbi5pc0luc2lkZSgkcG9pbnQpKVxuXHR7XG5cdFx0dmFyIGNsb3Nlc3Q7XG5cdFx0dmFyIGNsb3Nlc3RIeXA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMucG9seWdvbi5wb2ludHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJQb2ludCA9IHRoaXMucG9seWdvbi5wb2ludHNbaV07XG5cdFx0XHRkeCA9IE1hdGguYWJzKCRwb2ludFswXSAtIGN1cnJQb2ludFswXSk7XG5cdFx0XHRkeSA9IE1hdGguYWJzKCRwb2ludFsxXSAtIGN1cnJQb2ludFsxXSk7XG5cdFx0XHR2YXIgaHlwID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHRcdGlmIChjbG9zZXN0SHlwID09PSB1bmRlZmluZWQgfHwgaHlwIDwgY2xvc2VzdEh5cClcblx0XHRcdHtcblx0XHRcdFx0Y2xvc2VzdCA9IGN1cnJQb2ludDtcblx0XHRcdFx0Y2xvc2VzdEh5cCA9IGh5cDtcblx0XHRcdH1cblx0XHR9XG5cdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBub2Rlc0xlbmd0aDsgayArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjdXJyTm9kZSA9IHRoaXMuZ3JvdXAubm9kZXNba107XG5cdFx0XHRpZiAoY3Vyck5vZGUucGh5c2ljc01hbmFnZXIuYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblswXSA9PT0gY2xvc2VzdFswXSAmJlxuXHRcdFx0XHRjdXJyTm9kZS5waHlzaWNzTWFuYWdlci5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzFdID09PSBjbG9zZXN0WzFdKVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gY3Vyck5vZGUucGh5c2ljc01hbmFnZXIuYm9keTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNsb3Nlc3Q7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlcjtcblxuIiwidmFyIERlY29yYXRpb25EcmF3aW5nQ29tbWFuZCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvRGVjb3JhdGlvbkRyYXdpbmdDb21tYW5kJyk7XG52YXIgRGVjb3JhdGlvbkRyYXdpbmcgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0RlY29yYXRpb25EcmF3aW5nJyk7XG5cbnZhciBIYXJkRGVjb3JhdGlvbkRyYXdpbmcgPSBPYmplY3QuY3JlYXRlKERlY29yYXRpb25EcmF3aW5nKTtcbkhhcmREZWNvcmF0aW9uRHJhd2luZy5jcmVhdGUgPSBmdW5jdGlvbiAoJGdyb3VwKVxue1xuXHR2YXIgaW5zdCA9IE9iamVjdC5jcmVhdGUoSGFyZERlY29yYXRpb25EcmF3aW5nKTtcblx0aW5zdC5ncm91cCA9ICRncm91cDtcblx0aW5zdC5jb21tYW5kcyA9IFtdO1xuXG5cdGluc3QucHJvcGVydGllcyA9IHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gaW5zdDtcbn07XG5cbkhhcmREZWNvcmF0aW9uRHJhd2luZy5zZXREcmF3aW5nQ29tbWFuZHMgPSBmdW5jdGlvbiAoJGRyYXdpbmdDb21tYW5kcylcbntcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9ICRkcmF3aW5nQ29tbWFuZHMucG9pbnRDb21tYW5kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJyID0gJGRyYXdpbmdDb21tYW5kcy5wb2ludENvbW1hbmRzW2ldO1xuXHRcdHRoaXMuY29tbWFuZHMucHVzaChuZXcgRGVjb3JhdGlvbkRyYXdpbmdDb21tYW5kKGN1cnIsIHRoaXMuZ3JvdXAucGh5c2ljc01hbmFnZXIpKTtcblx0fVxuXHR0aGlzLmNvbW1hbmRzTGVuZ3RoID0gdGhpcy5jb21tYW5kcy5sZW5ndGg7XG59O1xuXG5IYXJkRGVjb3JhdGlvbkRyYXdpbmcuc2V0UHJvcGVydGllcyA9IGZ1bmN0aW9uICgkcHJvcGVydGllcylcbntcblx0dGhpcy5wcm9wZXJ0aWVzID0gJHByb3BlcnRpZXM7XG5cdHRoaXMudXNlRHluYW1pY0dyYWRpZW50ID0gZmFsc2U7XG59O1xuXG5IYXJkRGVjb3JhdGlvbkRyYXdpbmcuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5ncm91cC5waHlzaWNzTWFuYWdlci5nZXRCb3VuZGluZ0JveCgpO1xufTtcblxuSGFyZERlY29yYXRpb25EcmF3aW5nLmlzU3RhdGljID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMuZ3JvdXAuY29uZi5maXhlZCA9PT0gdHJ1ZTtcbn07XG5cbkhhcmREZWNvcmF0aW9uRHJhd2luZy53aWxsTm90SW50ZXJzZWN0ID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIGZhbHNlO1xufTtcblxuSGFyZERlY29yYXRpb25EcmF3aW5nLmlzU2ltcGxlRHJhd2luZyA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSGFyZERlY29yYXRpb25EcmF3aW5nO1xuIiwiLy92YXIgcDIgPSByZXF1aXJlKCcuLi8uLi8uLi9saWJzL3AyJyk7XG52YXIgUDJVdGlscyA9IHJlcXVpcmUoJy4vUDJVdGlscycpO1xuXG52YXIgSm9pbnRQMlBoeXNpY3NNYW5hZ2VyID0gZnVuY3Rpb24gKCRqb2ludCwgJHdvcmxkLCAkY29uZilcbntcblx0dmFyIGpvaW50Q29uZiA9ICRjb25mLmpvaW50c1skam9pbnQudHlwZV07XG5cdHZhciBib2R5QSA9ICRqb2ludC5ub2RlQS5waHlzaWNzTWFuYWdlci5ib2R5O1xuXHR2YXIgYm9keUIgPSAkam9pbnQubm9kZUIucGh5c2ljc01hbmFnZXIuYm9keTtcblx0dGhpcy5jb25zdHJhaW50cyA9IFAyVXRpbHMuY3JlYXRlQ29uc3RyYWludHMoJHdvcmxkLCBib2R5QSwgYm9keUIsIGpvaW50Q29uZik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpvaW50UDJQaHlzaWNzTWFuYWdlcjtcbiIsIi8vIGpzY3M6ZGlzYWJsZSByZXF1aXJlQ2FtZWxDYXNlT3JVcHBlckNhc2VJZGVudGlmaWVyc1xuLypqc2hpbnQgY2FtZWxjYXNlOmZhbHNlKi9cbnZhciBwMiA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYnMvcDInKTtcblxudmFyIE5vZGVQMkhhcmRQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgpXG57XG5cdHRoaXMuZ2V0WCA9IHRoaXMuZ2V0WFNpbXBsZTtcblx0dGhpcy5nZXRZID0gdGhpcy5nZXRZU2ltcGxlO1xufTtcblxuTm9kZVAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5hZGRUb1dvcmxkID0gZnVuY3Rpb24gKCRib2R5LCAkcG9zaXRpb24sICR3b3JsZEhlaWdodClcbntcblx0dGhpcy5ib2R5ID0gJGJvZHk7XG5cdHRoaXMucG9zaXRpb24gPSAkcG9zaXRpb247XG5cdHRoaXMud29ybGRIZWlnaHQgPSAkd29ybGRIZWlnaHQ7XG5cdHRoaXMub2Zmc2V0ID0gWzAsIDBdO1xufTtcblxuTm9kZVAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5zZXRGaXhlZCA9IGZ1bmN0aW9uICgkZml4ZWQpXG57XG5cdGlmICgkZml4ZWQpXG5cdHtcblx0XHR0aGlzLmJvZHkudHlwZSA9IHAyLkJvZHkuU1RBVElDO1xuXHRcdHRoaXMuYm9keS51cGRhdGVNYXNzUHJvcGVydGllcygpO1xuXHR9XG59O1xuXG5Ob2RlUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLnNldE9mZnNldCA9IGZ1bmN0aW9uICgkb2Zmc2V0KVxue1xuXHR2YXIgZFggPSB0aGlzLnBvc2l0aW9uWzBdICsgJG9mZnNldFswXTtcblx0dmFyIGRZID0gdGhpcy5wb3NpdGlvblsxXSAtICRvZmZzZXRbMV07XG5cdHRoaXMuYW5nbGUgPSBNYXRoLmF0YW4yKGRZLCBkWCk7XG5cdHRoaXMuaHlwID0gTWF0aC5zcXJ0KGRYICogZFggKyBkWSAqIGRZKTtcblx0dGhpcy5nZXRYID0gdGhpcy5nZXRYT2Zmc2V0O1xuXHR0aGlzLmdldFkgPSB0aGlzLmdldFlPZmZzZXQ7XG59O1xuXG5Ob2RlUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFhTaW1wbGUgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzBdO1xufTtcblxuTm9kZVAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRZU2ltcGxlID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMud29ybGRIZWlnaHQgLSB0aGlzLmJvZHkuaW50ZXJwb2xhdGVkUG9zaXRpb25bMV07XG59O1xuXG5Ob2RlUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFhPZmZzZXQgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzBdICsgdGhpcy5oeXAgKiBNYXRoLmNvcyh0aGlzLmJvZHkuaW50ZXJwb2xhdGVkQW5nbGUgKyB0aGlzLmFuZ2xlKTtcbn07XG5cbk5vZGVQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0WU9mZnNldCA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLndvcmxkSGVpZ2h0IC0gKHRoaXMuYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblsxXSArIHRoaXMuaHlwICogTWF0aC5zaW4odGhpcy5ib2R5LmludGVycG9sYXRlZEFuZ2xlICsgdGhpcy5hbmdsZSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlUDJIYXJkUGh5c2ljc01hbmFnZXI7XG5cbiIsIi8vIGpzY3M6ZGlzYWJsZSByZXF1aXJlQ2FtZWxDYXNlT3JVcHBlckNhc2VJZGVudGlmaWVyc1xuLypqc2hpbnQgY2FtZWxjYXNlOmZhbHNlKi9cblxudmFyIE5vZGVQMlNvZnRQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgpXG57XG5cdHZhciBzZWxmID0gdGhpcztcblx0dGhpcy5hZGRlZFRvV29ybGQgPSBuZXcgd2luZG93LlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgc2VsZi5yZXNvbHZlQWRkZWRUb1dvcmxkID0gcmVzb2x2ZTsgfSk7XG59O1xuXG5Ob2RlUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmFkZFRvV29ybGQgPSBmdW5jdGlvbiAoJHAyLCAkYm9keSwgJHdvcmxkSGVpZ2h0KVxue1xuXHR0aGlzLnAyID0gJHAyO1xuXHR0aGlzLmJvZHkgPSAkYm9keTtcblx0dGhpcy53b3JsZEhlaWdodCA9ICR3b3JsZEhlaWdodDtcblx0dGhpcy5yZXNvbHZlQWRkZWRUb1dvcmxkKCk7XG59O1xuXG5Ob2RlUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbiAoJHZlYylcbntcblx0Ly9jb25zb2xlLmxvZygnbm9wJywgdGhpcy5ib2R5LmFwcGx5Rm9yY2VMb2NhbCwgJHZlYyk7XG5cdHZhciBsb2MgPSBbXTtcblx0dGhpcy5ib2R5LnRvV29ybGRGcmFtZShsb2MsIFswLCAwXSk7XG5cdHRoaXMuYm9keS5hcHBseUZvcmNlKCR2ZWMsIGxvYyk7XG59O1xuXG5Ob2RlUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLnNldEZpeGVkID0gZnVuY3Rpb24gKCRmaXhlZClcbntcblx0aWYgKCRmaXhlZClcblx0e1xuXHRcdHRoaXMuYm9keS50eXBlID0gdGhpcy5wMi5Cb2R5LlNUQVRJQztcblx0fVxufTtcblxuTm9kZVAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbmdsZSA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLmJvZHkuaW50ZXJwb2xhdGVkQW5nbGU7XG59O1xuXG5Ob2RlUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKVxue1xuXHQvL2NvbnNvbGUubG9nKHRoaXMuYm9keS5HZXRXb3JsZENlbnRlcigpLmdldF94KCkpO1xuXHRyZXR1cm4gdGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzBdO1xufTtcblxuTm9kZVAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMud29ybGRIZWlnaHQgLSB0aGlzLmJvZHkuaW50ZXJwb2xhdGVkUG9zaXRpb25bMV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVQMlNvZnRQaHlzaWNzTWFuYWdlcjtcblxuIiwidmFyIHAyID0gcmVxdWlyZSgnLi4vLi4vLi4vbGlicy9wMicpO1xuXG52YXIgUDJNb3VzZUNvbnRyb2xzID0gZnVuY3Rpb24gKCR3b3JsZCwgJHAyV29ybGQsICRyZW5kZXJlcilcbntcblx0dGhpcy5yZW5kZXJlciA9ICRyZW5kZXJlcjtcblx0dGhpcy53b3JsZCA9ICR3b3JsZDtcblx0dGhpcy5wMldvcmxkID0gJHAyV29ybGQ7XG5cdHRoaXMudG91Y2hDb25zdHJhaW50cyA9IHt9O1xufTtcblxuUDJNb3VzZUNvbnRyb2xzLnByb3RvdHlwZS5hZGRCYXNpY01vdXNlQ29udHJvbHMgPSBmdW5jdGlvbiAoJHN0aWZmbmVzcywgJHJlbGF4YXRpb24pXG57XG5cdHZhciBwMldvcmxkID0gdGhpcy5wMldvcmxkO1xuXHR2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuXHR2YXIgY29udGFpbmVyID0gdGhpcy5yZW5kZXJlci5jb250YWluZXI7XG5cdHZhciB0b3VjaENvbnN0cmFpbnRzID0gdGhpcy50b3VjaENvbnN0cmFpbnRzO1xuXG5cdC8vcHJldmVudCBkZWZhdWx0IHNjcm9sbGluZ1xuXHRkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdH0sIGZhbHNlKTtcblxuXHR2YXIgd29ybGRXaWR0aCA9IHRoaXMud29ybGQud29ybGRXaWR0aDtcblx0dmFyIHdvcmxkSGVpZ2h0ID0gdGhpcy53b3JsZC5waHlzaWNzTWFuYWdlci53b3JsZEhlaWdodDtcblx0Ly92YXIgYm9kaWVzID0gdGhpcy5wMldvcmxkLmJvZGllcy5jb25jYXQoKTtcblx0dmFyIGdyb3VwcyA9IHRoaXMud29ybGQuZ3JvdXBzO1xuXG5cdHZhciBnZXRQaHlzaWNzQ29vcmQgPSBmdW5jdGlvbiAoJGNvbnRhY3QpXG5cdHtcblx0XHR2YXIgdHJndCA9IGV2ZW50LnRhcmdldDtcblx0XHR2YXIgcG9zID0gdHJndC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdHZhciB4ID0gKCRjb250YWN0LmNsaWVudFggLSBwb3MubGVmdCkgLyAocG9zLnJpZ2h0IC0gcG9zLmxlZnQpO1xuXHRcdHZhciB5ID0gKCRjb250YWN0LmNsaWVudFkgLSBwb3MudG9wKSAvIChwb3MuYm90dG9tIC0gcG9zLnRvcCk7XG5cdFx0eCA9IHJlbmRlcmVyLnZpZXdDZW50ZXJbMF0gKyAoeCAtIDAuNSkgKiByZW5kZXJlci52aWV3V2lkdGg7XG5cdFx0eSA9IHJlbmRlcmVyLnZpZXdDZW50ZXJbMV0gKyAoeSAtIDAuNSkgKiByZW5kZXJlci52aWV3SGVpZ2h0O1xuXG5cdFx0cmV0dXJuIFt4LCB5XTtcblx0fTtcblxuXHR2YXIgY29uc3RyYWluID0gZnVuY3Rpb24gKCRjb250YWN0LCAkaWRlbnRpZmllcilcblx0e1xuXHRcdHZhciBib2R5O1xuXHRcdHZhciBwb3NpdGlvbiA9IGdldFBoeXNpY3NDb29yZCgkY29udGFjdCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgY3Vyckdyb3VwID0gZ3JvdXBzW2ldO1xuXHRcdFx0aWYgKGN1cnJHcm91cC5waHlzaWNzTWFuYWdlci5oaXRUZXN0KVxuXHRcdFx0e1xuXHRcdFx0XHRib2R5ID0gY3Vyckdyb3VwLnBoeXNpY3NNYW5hZ2VyLmhpdFRlc3QocG9zaXRpb24sIHdvcmxkV2lkdGggLyA1MCk7XG5cdFx0XHRcdGlmIChib2R5KSB7IGJyZWFrOyB9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGJvZHkpXG5cdFx0e1xuXHRcdFx0dmFyIHRvdWNoQm9keSA9IG5ldyBwMi5Cb2R5KCk7XG5cdFx0XHRwMldvcmxkLmFkZEJvZHkodG91Y2hCb2R5KTtcblxuXHRcdFx0dG91Y2hCb2R5LnBvc2l0aW9uWzBdID0gcG9zaXRpb25bMF07XG5cdFx0XHR0b3VjaEJvZHkucG9zaXRpb25bMV0gPSB3b3JsZEhlaWdodCAtIHBvc2l0aW9uWzFdO1xuXG5cdFx0XHR2YXIgdG91Y2hDb25zdHJhaW50ID0gbmV3IHAyLkxvY2tDb25zdHJhaW50KHRvdWNoQm9keSwgYm9keSxcblx0XHRcdHtcblx0XHRcdFx0Ly93b3JsZFBpdm90OiBwb3NpdGlvbixcblx0XHRcdFx0Y29sbGlkZUNvbm5lY3RlZDogZmFsc2Vcblx0XHRcdH0pO1xuXHRcdFx0Ly90b3VjaENvbnN0cmFpbnQuc2V0TGltaXRzKDAsIDApO1xuXG5cdFx0XHR0b3VjaENvbnN0cmFpbnQuc2V0U3RpZmZuZXNzKCRzdGlmZm5lc3MgfHwgMjAwKTtcblx0XHRcdHRvdWNoQ29uc3RyYWludC5zZXRSZWxheGF0aW9uKCRyZWxheGF0aW9uIHx8IDEpO1xuXG5cdFx0XHRwMldvcmxkLmFkZENvbnN0cmFpbnQodG91Y2hDb25zdHJhaW50KTtcblx0XHRcdHRvdWNoQ29uc3RyYWludHNbJGlkZW50aWZpZXJdID0gdG91Y2hDb25zdHJhaW50O1xuXHRcdH1cblx0fTtcblxuXHR2YXIgdG91Y2hNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KVxuXHR7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdHZhciB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMgfHwgW2V2ZW50XTtcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdG91Y2hlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgdG91Y2ggPSB0b3VjaGVzW2ldO1xuXHRcdFx0dmFyIGlkZW50aWZpZXIgPSB0b3VjaC5pZGVudGlmaWVyIHx8ICdtb3VzZSc7XG5cdFx0XHRpZiAodG91Y2hDb25zdHJhaW50c1tpZGVudGlmaWVyXSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UGh5c2ljc0Nvb3JkKHRvdWNoKTtcblx0XHRcdFx0dG91Y2hDb25zdHJhaW50c1tpZGVudGlmaWVyXS5ib2R5QS5wb3NpdGlvblswXSA9IHBvc2l0aW9uWzBdO1xuXHRcdFx0XHR0b3VjaENvbnN0cmFpbnRzW2lkZW50aWZpZXJdLmJvZHlBLnBvc2l0aW9uWzFdID0gd29ybGRIZWlnaHQgLSBwb3NpdGlvblsxXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0dmFyIHRvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpXG5cdHtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0dmFyIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyB8fCBbZXZlbnRdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0b3VjaGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHZhciB0b3VjaCA9IHRvdWNoZXNbaV07XG5cdFx0XHR2YXIgaWRlbnRpZmllciA9IHRvdWNoLmlkZW50aWZpZXIgfHwgJ21vdXNlJztcblx0XHRcdGlmICghdG91Y2hDb25zdHJhaW50c1tpZGVudGlmaWVyXSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3RyYWluKHRvdWNoLCBpZGVudGlmaWVyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRvdWNoTW92ZSk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0b3VjaEVuZCk7XG5cdH07XG5cblx0dmFyIHRvdWNoRW5kID0gZnVuY3Rpb24gKGV2ZW50KVxuXHR7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR2YXIgY2hhbmdlZFRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyB8fCBbZXZlbnRdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBjaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgaWRlbnRpZmllciA9IGNoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXIgfHwgJ21vdXNlJztcblx0XHRcdHZhciBjb25zdHJhaW50ID0gdG91Y2hDb25zdHJhaW50c1tpZGVudGlmaWVyXTtcblx0XHRcdGlmICh0b3VjaENvbnN0cmFpbnRzW2lkZW50aWZpZXJdKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgdG91Y2hCb2R5ID0gY29uc3RyYWludC5ib2R5QTtcblx0XHRcdFx0cDJXb3JsZC5yZW1vdmVDb25zdHJhaW50KGNvbnN0cmFpbnQpO1xuXHRcdFx0XHRwMldvcmxkLnJlbW92ZUJvZHkodG91Y2hCb2R5KTtcblx0XHRcdFx0dG91Y2hDb25zdHJhaW50c1tpZGVudGlmaWVyXSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRvdWNoTW92ZSk7XG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0b3VjaEVuZCk7XG5cdH07XG5cblx0dGhpcy5yZW1vdmVCYXNpY01vdXNlQ29udHJvbHMgPSBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0Y29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRvdWNoTW92ZSk7XG5cdFx0Y29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRvdWNoU3RhcnQpO1xuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdG91Y2hFbmQpO1xuXHRcdGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdG91Y2hTdGFydCk7XG5cdFx0Y29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hFbmQpO1xuXHRcdGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaE1vdmUpO1xuXHR9O1xuXG5cdGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0b3VjaFN0YXJ0KTtcblx0Y29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0b3VjaFN0YXJ0KTtcblx0Y29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNoTW92ZSk7XG5cdGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoRW5kKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUDJNb3VzZUNvbnRyb2xzO1xuXG4iLCIvLyBqc2NzOmRpc2FibGUgcmVxdWlyZUNhbWVsQ2FzZU9yVXBwZXJDYXNlSWRlbnRpZmllcnNcbi8qanNoaW50IGNhbWVsY2FzZTpmYWxzZSovXG5cbnZhciBwMiA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYnMvcDInKTtcbnZhciBQMlV0aWxzID0gcmVxdWlyZSgnLi9QMlV0aWxzJyk7XG52YXIgR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlciA9IHJlcXVpcmUoJy4vR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlcicpO1xudmFyIEdyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXIgPSByZXF1aXJlKCcuL0dyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXInKTtcbnZhciBHcm91cEdob3N0UGh5c2ljc01hbmFnZXIgPSByZXF1aXJlKCcuL0dyb3VwR2hvc3RQaHlzaWNzTWFuYWdlcicpO1xudmFyIEFuY2hvclAyR2hvc3RQaHlzaWNzTWFuYWdlciA9IHJlcXVpcmUoJy4vQW5jaG9yUDJHaG9zdFBoeXNpY3NNYW5hZ2VyJyk7XG5cbnZhciBQMlBoeXNpY3NNYW5hZ2VyID0gZnVuY3Rpb24gKCRjb25mLCAkcDJXb3JsZClcbntcblx0dGhpcy5wMldvcmxkID0gJHAyV29ybGQgfHwgbmV3IHAyLldvcmxkKCRjb25mKTtcblx0dGhpcy5wMiA9IHAyO1xuXHR0aGlzLmNvbmYgPSAkY29uZjtcblx0dGhpcy53b3JsZFdpZHRoID0gdW5kZWZpbmVkO1xuXHR0aGlzLndvcmxkSGVpZ2h0ID0gdW5kZWZpbmVkO1xuXHR0aGlzLm5ld1RpbWUgPSB1bmRlZmluZWQ7XG5cdHRoaXMubGFzdFRpbWUgPSB1bmRlZmluZWQ7XG5cdHRoaXMubWF0ZXJpYWxzTGlzdCA9IFtdO1xuXG5cdC8vdGhpcy5wMldvcmxkLmdyYXZpdHkgPSB0aGlzLmNvbmYuZ3Jhdml0eTtcblxuXHR0aGlzLnNldE1hdGVyaWFscygpO1xufTtcblxuUDJQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uICgkdGltZSlcbntcblx0dGhpcy5uZXdUaW1lID0gJHRpbWUgLSB0aGlzLmxhc3RUaW1lIHx8IDA7XG5cdHRoaXMubGFzdFRpbWUgPSAkdGltZTtcblx0dGhpcy5wMldvcmxkLnN0ZXAoMSAvIDYwLCB0aGlzLm5ld1RpbWUgLyAxMDAwLCA1KTtcbn07XG5cblAyUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmNvbnN0cmFpbkdyb3VwcyA9IGZ1bmN0aW9uICgkYW5jaG9yQSwgJGFuY2hvckIsICR0eXBlKVxue1xuXHQkYW5jaG9yQS5hZGRUb1dvcmxkKCk7XG5cdCRhbmNob3JCLmFkZFRvV29ybGQoKTtcblxuXHR2YXIgY29uc3RyYWludENvbmZpZyA9IHRoaXMuY29uZi5jb25zdHJhaW50c1skdHlwZV07XG5cblx0UDJVdGlscy5jcmVhdGVDb25zdHJhaW50cyh0aGlzLnAyV29ybGQsICRhbmNob3JBLmJvZHksICRhbmNob3JCLmJvZHksIGNvbnN0cmFpbnRDb25maWcsIFskYW5jaG9yQS5vZmZzZXQsICRhbmNob3JCLm9mZnNldF0pO1xufTtcblxuUDJQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlR2hvc3RBbmNob3JGcm9tUG9pbnRzID0gZnVuY3Rpb24gKCRwb2ludHMpXG57XG5cdHZhciBQb2x5Z29uID0gcmVxdWlyZSgnLi4vLi4vY29yZS9Qb2x5Z29uJyk7XG5cdHZhciBwb2x5Z29uID0gUG9seWdvbi5pbml0KCRwb2ludHMpO1xuXHR2YXIgY2VudGVyID0gcG9seWdvbi5nZXRDZW50ZXIoKTtcblx0cmV0dXJuIHRoaXMuY3JlYXRlR2hvc3RBbmNob3JGcm9tUG9pbnQoY2VudGVyKTtcbn07XG5cblAyUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUdob3N0QW5jaG9yRnJvbVBvaW50ID0gZnVuY3Rpb24gKCRwb2ludClcbntcblx0dmFyIGFuY2hvciA9IG5ldyBBbmNob3JQMkdob3N0UGh5c2ljc01hbmFnZXIodGhpcy5wMiwgdGhpcy5wMldvcmxkLCB0aGlzLndvcmxkSGVpZ2h0KTtcblx0YW5jaG9yLnNldEZyb21Qb2ludCgkcG9pbnQpO1xuXHRyZXR1cm4gYW5jaG9yO1xufTtcblxuUDJQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0R3JvdXBQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgkZ3JvdXApXG57XG5cdHN3aXRjaCAoJGdyb3VwLmNvbmYucGh5c2ljcy5ib2R5VHlwZSlcblx0e1xuXHRcdGNhc2UgJ2dob3N0JzogcmV0dXJuIG5ldyBHcm91cEdob3N0UGh5c2ljc01hbmFnZXIoJGdyb3VwKTtcblx0XHRjYXNlICdoYXJkJzogcmV0dXJuIG5ldyBHcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyKCRncm91cCwgdGhpcy5wMldvcmxkLCB0aGlzLndvcmxkSGVpZ2h0LCB0aGlzLm1hdGVyaWFsc0xpc3QpO1xuXHRcdGNhc2UgJ3NvZnQnOiByZXR1cm4gbmV3IEdyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXIoJGdyb3VwLCB0aGlzLnAyV29ybGQsIHRoaXMud29ybGRIZWlnaHQsIHRoaXMubWF0ZXJpYWxzTGlzdCk7XG5cdH1cbn07XG5cblAyUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLnNldE1hdGVyaWFscyA9IGZ1bmN0aW9uICgpXG57XG5cdHZhciBtYXRlcmlhbE5hbWU7XG5cdGZvciAobWF0ZXJpYWxOYW1lIGluIHRoaXMuY29uZi5tYXRlcmlhbHMpXG5cdHtcblx0XHR2YXIgbWF0ZXJpYWxDb25mID0gdGhpcy5jb25mLm1hdGVyaWFsc1ttYXRlcmlhbE5hbWVdO1xuXHRcdHZhciBjdXJyTWF0ZXJpYWwgPSBuZXcgcDIuTWF0ZXJpYWwoKTtcblx0XHR2YXIgY3VyciA9IHRoaXMubWF0ZXJpYWxzTGlzdFttYXRlcmlhbE5hbWVdID0geyBtYXRlcmlhbDogY3Vyck1hdGVyaWFsLCBtYXRlcmlhbENvbmZpZzogbWF0ZXJpYWxDb25mIH07XG5cdFx0Zm9yICh2YXIgb3RoZXJOYW1lIGluIHRoaXMubWF0ZXJpYWxzTGlzdClcblx0XHR7XG5cdFx0XHR2YXIgb3RoZXIgPSB0aGlzLm1hdGVyaWFsc0xpc3Rbb3RoZXJOYW1lXTtcblx0XHRcdHZhciBjb250YWN0TWF0ZXJpYWwgPSBuZXcgcDIuQ29udGFjdE1hdGVyaWFsKGN1cnIubWF0ZXJpYWwsIG90aGVyLm1hdGVyaWFsLCB7XG5cdFx0XHRcdGZyaWN0aW9uOiBjdXJyLm1hdGVyaWFsQ29uZmlnLmZyaWN0aW9uICsgKG90aGVyLm1hdGVyaWFsQ29uZmlnLmZyaWN0aW9uIC0gY3Vyci5tYXRlcmlhbENvbmZpZy5mcmljdGlvbikgLyAyLFxuXHRcdFx0XHRyZWxheGF0aW9uOiBjdXJyLm1hdGVyaWFsQ29uZmlnLmJvdW5jaW5lc3MgKyAob3RoZXIubWF0ZXJpYWxDb25maWcuYm91bmNpbmVzcyAtIGN1cnIubWF0ZXJpYWxDb25maWcuYm91bmNpbmVzcykgLyAyXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMucDJXb3JsZC5hZGRDb250YWN0TWF0ZXJpYWwoY29udGFjdE1hdGVyaWFsKTtcblx0XHR9XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUDJQaHlzaWNzTWFuYWdlcjtcblxuIiwidmFyIHAyID0gcmVxdWlyZSgnLi4vLi4vLi4vbGlicy9wMicpO1xudmFyIFAyVXRpbHMgPSB7fTtcblxuUDJVdGlscy5jcmVhdGVDb25zdHJhaW50cyA9IGZ1bmN0aW9uICgkd29ybGQsICRib2R5QSwgJGJvZHlCLCAkY29uZmlnLCAkb3B0aW9ucylcbntcblx0aWYgKCEkY29uZmlnKSB7IHJldHVybjsgfVxuXG5cdHZhciBsb2NrID0gJGNvbmZpZy5sb2NrQ29uc3RyYWludDtcblx0dmFyIGRpc3RhbmNlID0gJGNvbmZpZy5kaXN0YW5jZUNvbnN0cmFpbnQ7XG5cdHZhciByZXZvbHV0ZSA9ICRjb25maWcucmV2b2x1dGVDb25zdHJhaW50O1xuXHR2YXIgbGluZWFyU3ByaW5nID0gJGNvbmZpZy5saW5lYXJTcHJpbmc7XG5cdHZhciBwcmlzbWF0aWNDb25zdHJhaW50ID0gJGNvbmZpZy5wcmlzbWF0aWNDb25zdHJhaW50O1xuXHR2YXIgcm90YXRpb25hbFNwcmluZyA9ICRjb25maWcucm90YXRpb25hbFNwcmluZztcblx0dmFyIGNvbnN0cmFpbnRzID0gW107XG5cdHZhciBjb25zdHJhaW50O1xuXG5cdGlmIChyZXZvbHV0ZSlcblx0e1xuXHRcdHZhciB2ZWNXb3JsZEEgPSBwMi52ZWMyLmNyZWF0ZSgpO1xuXHRcdHZhciB2ZWNXb3JsZEIgPSBwMi52ZWMyLmNyZWF0ZSgpO1xuXHRcdHZhciB2ZWNMb2NBID0gcDIudmVjMi5jcmVhdGUoKTtcblx0XHR2YXIgdmVjTG9jQiA9IHAyLnZlYzIuY3JlYXRlKCk7XG5cdFx0JGJvZHlBLnRvV29ybGRGcmFtZSh2ZWNXb3JsZEEsIFswLCAwXSk7XG5cdFx0JGJvZHlCLnRvV29ybGRGcmFtZSh2ZWNXb3JsZEIsIFswLCAwXSk7XG5cdFx0JGJvZHlBLnRvTG9jYWxGcmFtZSh2ZWNMb2NBLCAkYm9keUIuaW50ZXJwb2xhdGVkUG9zaXRpb24pO1xuXHRcdCRib2R5Qi50b0xvY2FsRnJhbWUodmVjTG9jQiwgJGJvZHlBLmludGVycG9sYXRlZFBvc2l0aW9uKTtcblxuXHRcdC8vIGNvbnNvbGUubG9nKHJldm9sdXRlLmF1dG9QaXZvdCk7XG5cdFx0aWYgKCEkb3B0aW9ucyB8fCAhJG9wdGlvbnNbMF0gfHwgISRvcHRpb25zWzFdKSB7IHJldm9sdXRlLmF1dG9QaXZvdCA9IHRydWU7IH1cblx0XHR2YXIgbG9jYWxQaXZvdEEgPSByZXZvbHV0ZS5hdXRvUGl2b3QgPyB1bmRlZmluZWQgOiAkb3B0aW9uc1swXTtcblx0XHR2YXIgbG9jYWxQaXZvdEIgPSByZXZvbHV0ZS5hdXRvUGl2b3QgPyB1bmRlZmluZWQgOiAkb3B0aW9uc1sxXTtcblx0XHR2YXIgd29ybGRQaXZvdCA9IHJldm9sdXRlLmF1dG9QaXZvdCA/ICRib2R5QS5pbnRlcnBvbGF0ZWRQb3NpdGlvbiA6IHVuZGVmaW5lZDtcblx0XHRjb25zdHJhaW50ID0gbmV3IHAyLlJldm9sdXRlQ29uc3RyYWludCgkYm9keUEsICRib2R5Qixcblx0XHR7XG5cdFx0XHR3b3JsZFBpdm90OiB3b3JsZFBpdm90LFxuXHRcdFx0bG9jYWxQaXZvdEE6IGxvY2FsUGl2b3RBLFxuXHRcdFx0bG9jYWxQaXZvdEI6IGxvY2FsUGl2b3RCXG5cdFx0fSk7XG5cdFx0aWYgKCFyZXZvbHV0ZS5tb3Rvcilcblx0XHR7XG5cdFx0XHQvL2NvbnN0cmFpbnQuc2V0TGltaXRzKDAsIDApO1xuXHRcdFx0aWYgKHJldm9sdXRlLmNvbGxpZGVDb25uZWN0ZWQgIT09IHVuZGVmaW5lZCkgeyBjb25zdHJhaW50LmNvbGxpZGVDb25uZWN0ZWQgPSByZXZvbHV0ZS5jb2xsaWRlQ29ubmVjdGVkOyB9XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRjb25zdHJhaW50LmVuYWJsZU1vdG9yKCk7XG5cdFx0XHRjb25zdHJhaW50LnNldE1vdG9yU3BlZWQoLTEpO1xuXHRcdFx0Y29uc3RyYWludC5jb2xsaWRlQ29ubmVjdGVkID0gZmFsc2U7XG5cdFx0fVxuXHRcdGlmIChyZXZvbHV0ZS5ub1JvdGF0aW9uKSB7IGNvbnN0cmFpbnQuc2V0TGltaXRzKDAsIDApOyB9XG5cdFx0aWYgKHJldm9sdXRlLnN0aWZmbmVzcyAhPT0gdW5kZWZpbmVkKSB7IGNvbnN0cmFpbnQuc2V0U3RpZmZuZXNzKHJldm9sdXRlLnN0aWZmbmVzcyk7IH0gLy9kZWZhdWx0IDIwXG5cdFx0aWYgKHJldm9sdXRlLnJlbGF4YXRpb24gIT09IHVuZGVmaW5lZCkgeyBjb25zdHJhaW50LnNldFJlbGF4YXRpb24ocmV2b2x1dGUucmVsYXhhdGlvbik7IH1cblx0XHQkd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcblx0XHRjb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xuXHR9XG5cdGlmIChwcmlzbWF0aWNDb25zdHJhaW50KVxuXHR7XG5cdFx0dmFyIGF4aXNWZWMgPSBwMi52ZWMyLmNyZWF0ZSgpO1xuXHRcdHZhciB3b3JsZE9mZnNldEIgPSBwMi52ZWMyLmNyZWF0ZSgpO1xuXHRcdCRib2R5Qi50b1dvcmxkRnJhbWUod29ybGRPZmZzZXRCLCAkb3B0aW9uc1sxXSk7XG5cdFx0JGJvZHlBLnRvTG9jYWxGcmFtZShheGlzVmVjLCB3b3JsZE9mZnNldEIpOy8vWyRib2R5Qi5pbnRlcnBvbGF0ZWRQb3NpdGlvblswXSArICRvcHRpb25zWzFdWzBdIC0gKCRib2R5QS5pbnRlcnBvbGF0ZWRQb3NpdGlvblswXSArICRvcHRpb25zWzBdWzBdKSwgJGJvZHlCLmludGVycG9sYXRlZFBvc2l0aW9uWzFdIC0gJGJvZHlBLmludGVycG9sYXRlZFBvc2l0aW9uWzFdXTtcblx0XHR2YXIgc3ggPSBheGlzVmVjWzBdIC0gJG9wdGlvbnNbMF1bMF07XG5cdFx0dmFyIHN5ID0gYXhpc1ZlY1sxXSAtICRvcHRpb25zWzBdWzFdO1xuXHRcdC8vIHZhciBjeCA9IE1hdGguYWJzKHN4KTtcblx0XHQvLyB2YXIgY3kgPSBNYXRoLmFicyhzeSk7XG5cdFx0Ly8gdmFyIGRpc3QgPSBNYXRoLnNxcnQoY3ggKiBjeCArIGN5ICogY3kpO1xuXHRcdC8vY29uc29sZS5sb2coYXhpc1ZlYywgJG9wdGlvbnNbMF0pO1xuXHRcdC8vZGVidWdnZXI7XG5cdFx0Y29uc3RyYWludCA9IG5ldyBwMi5QcmlzbWF0aWNDb25zdHJhaW50KCRib2R5QSwgJGJvZHlCLCB7XG5cdFx0XHRsb2NhbEFuY2hvckE6ICRvcHRpb25zWzBdLFxuXHRcdFx0bG9jYWxBbmNob3JCOiAkb3B0aW9uc1sxXSxcblx0XHRcdGxvY2FsQXhpc0E6IFtzeCwgc3ldLFxuXHRcdFx0dXBwZXJMaW1pdDogMSxcblx0XHRcdGxvd2VyTGltaXQ6IDAsXG5cdFx0XHRkaXNhYmxlUm90YXRpb25hbExvY2s6IHByaXNtYXRpY0NvbnN0cmFpbnQuY2FuUm90YXRlID09PSB0cnVlID8gdHJ1ZSA6IGZhbHNlXG5cdFx0fSk7XG5cdFx0JHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XG5cdFx0Y29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcblx0fVxuXHRpZiAobG9jaylcblx0e1xuXHRcdGNvbnN0cmFpbnQgPSBuZXcgcDIuTG9ja0NvbnN0cmFpbnQoJGJvZHlBLCAkYm9keUIpO1xuXHRcdC8vaWYgKCRvcHRpb25zICYmICRvcHRpb25zWzBdKSB7IGNvbnN0cmFpbnQubG9jYWxPZmZzZXRCID0gJG9wdGlvbnNbMF07IH1cblx0XHRpZiAobG9jay5jb2xsaWRlQ29ubmVjdGVkICE9PSB1bmRlZmluZWQpIHsgY29uc3RyYWludC5jb2xsaWRlQ29ubmVjdGVkID0gbG9jay5jb2xsaWRlQ29ubmVjdGVkOyB9XG5cdFx0aWYgKGxvY2suc3RpZmZuZXNzKSB7IGNvbnN0cmFpbnQuc2V0U3RpZmZuZXNzKGxvY2suc3RpZmZuZXNzKTsgfSAvL2RlZmF1bHQgMjBcblx0XHRpZiAobG9jay5yZWxheGF0aW9uKSB7IGNvbnN0cmFpbnQuc2V0UmVsYXhhdGlvbihsb2NrLnJlbGF4YXRpb24pOyB9XG5cdFx0JHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XG5cdFx0Y29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcblx0fVxuXHRpZiAobGluZWFyU3ByaW5nKVxuXHR7XG5cdFx0Y29uc3RyYWludCA9IG5ldyBwMi5MaW5lYXJTcHJpbmcoJGJvZHlBLCAkYm9keUIsIHtcblx0XHRcdGxvY2FsQW5jaG9yQTogJG9wdGlvbnMgJiYgJG9wdGlvbnNbMF0gPyAkb3B0aW9uc1swXSA6IHVuZGVmaW5lZCxcblx0XHRcdGxvY2FsQW5jaG9yQjogJG9wdGlvbnMgJiYgJG9wdGlvbnNbMV0gPyAkb3B0aW9uc1sxXSA6IHVuZGVmaW5lZFxuXHRcdH0pO1xuXHRcdGlmIChsaW5lYXJTcHJpbmcuc3RpZmZuZXNzKSB7IGNvbnN0cmFpbnQuc3RpZmZuZXNzID0gbGluZWFyU3ByaW5nLnN0aWZmbmVzczsgfVxuXHRcdGlmIChsaW5lYXJTcHJpbmcuZGFtcGluZykgeyBjb25zdHJhaW50LmRhbXBpbmcgPSBsaW5lYXJTcHJpbmcuZGFtcGluZzsgfVxuXHRcdCR3b3JsZC5hZGRTcHJpbmcoY29uc3RyYWludCk7XG5cdFx0Y29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcblx0fVxuXHRpZiAocm90YXRpb25hbFNwcmluZylcblx0e1xuXHRcdGNvbnN0cmFpbnQgPSBuZXcgcDIuUm90YXRpb25hbFNwcmluZygkYm9keUEsICRib2R5Qik7XG5cdFx0aWYgKHJvdGF0aW9uYWxTcHJpbmcuc3RpZmZuZXNzKSB7IGNvbnN0cmFpbnQuc3RpZmZuZXNzID0gcm90YXRpb25hbFNwcmluZy5zdGlmZm5lc3M7IH1cblx0XHRpZiAocm90YXRpb25hbFNwcmluZy5kYW1waW5nKSB7IGNvbnN0cmFpbnQuZGFtcGluZyA9IHJvdGF0aW9uYWxTcHJpbmcuZGFtcGluZzsgfVxuXHRcdGNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XG5cdFx0JHdvcmxkLmFkZFNwcmluZyhjb25zdHJhaW50KTtcblx0fVxuXHRpZiAoZGlzdGFuY2UpXG5cdHtcblx0XHRjb25zdHJhaW50ID0gbmV3IHAyLkRpc3RhbmNlQ29uc3RyYWludCgkYm9keUEsICRib2R5Qik7XG5cdFx0aWYgKCRvcHRpb25zICYmICRvcHRpb25zWzBdKSB7IGNvbnN0cmFpbnQubG9jYWxBbmNob3JBID0gJG9wdGlvbnNbMF07IH1cblx0XHRpZiAoJG9wdGlvbnMgJiYgJG9wdGlvbnNbMV0pIHsgY29uc3RyYWludC5sb2NhbEFuY2hvckIgPSAkb3B0aW9uc1sxXTsgfVxuXHRcdGlmIChkaXN0YW5jZSAmJiBkaXN0YW5jZS5zdGlmZm5lc3MpIHsgY29uc3RyYWludC5zZXRTdGlmZm5lc3MoZGlzdGFuY2Uuc3RpZmZuZXNzKTsgfSAvLyBkZWZhdWx0IDUwMFxuXHRcdGlmIChkaXN0YW5jZSAmJiBkaXN0YW5jZS5yZWxheGF0aW9uKSB7IGNvbnN0cmFpbnQuc2V0UmVsYXhhdGlvbihkaXN0YW5jZS5yZWxheGF0aW9uKTsgfS8vIGRlZmF1bHQgMC4xXG5cdFx0JHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XG5cdFx0Y29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcblx0fVxuXG5cdHJldHVybiBjb25zdHJhaW50cztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUDJVdGlscztcbiIsInZhciBEZWNvcmF0aW9uRHJhd2luZ0NvbW1hbmQgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0RlY29yYXRpb25EcmF3aW5nQ29tbWFuZCcpO1xudmFyIERlY29yYXRpb25EcmF3aW5nID0gcmVxdWlyZSgnLi4vLi4vY29yZS9EZWNvcmF0aW9uRHJhd2luZycpO1xuXG52YXIgU29mdERlY29yYXRpb25EcmF3aW5nID0gT2JqZWN0LmNyZWF0ZShEZWNvcmF0aW9uRHJhd2luZyk7XG5Tb2Z0RGVjb3JhdGlvbkRyYXdpbmcuY3JlYXRlID0gZnVuY3Rpb24gKCRncm91cClcbntcblx0dmFyIGluc3QgPSBPYmplY3QuY3JlYXRlKFNvZnREZWNvcmF0aW9uRHJhd2luZyk7XG5cdGluc3QuZ3JvdXAgPSAkZ3JvdXA7XG5cdGluc3QuY29tbWFuZHMgPSBbXTtcblxuXHRpbnN0LnByb3BlcnRpZXMgPSB1bmRlZmluZWQ7XG5cblx0cmV0dXJuIGluc3Q7XG59O1xuXG5Tb2Z0RGVjb3JhdGlvbkRyYXdpbmcuc2V0RHJhd2luZ0NvbW1hbmRzID0gZnVuY3Rpb24gKCRkcmF3aW5nQ29tbWFuZHMpXG57XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSAkZHJhd2luZ0NvbW1hbmRzLnBvaW50Q29tbWFuZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3VyciA9ICRkcmF3aW5nQ29tbWFuZHMucG9pbnRDb21tYW5kc1tpXTtcblx0XHR2YXIgY2xvc2VzdE5vZGUgPSB0aGlzLmdyb3VwLmdldENsb3Nlc3ROb2RlKGN1cnIucG9pbnQpO1xuXHRcdGNvbnNvbGUubG9nKGNsb3Nlc3ROb2RlLklEKTtcblx0XHR0aGlzLmNvbW1hbmRzLnB1c2gobmV3IERlY29yYXRpb25EcmF3aW5nQ29tbWFuZChjdXJyLCBjbG9zZXN0Tm9kZS5waHlzaWNzTWFuYWdlcikpO1xuXHR9XG5cdHRoaXMuY29tbWFuZHNMZW5ndGggPSB0aGlzLmNvbW1hbmRzLmxlbmd0aDtcbn07XG5cblNvZnREZWNvcmF0aW9uRHJhd2luZy5zZXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCRwcm9wZXJ0aWVzKVxue1xuXHR0aGlzLnByb3BlcnRpZXMgPSAkcHJvcGVydGllcztcblx0dGhpcy51c2VEeW5hbWljR3JhZGllbnQgPSBmYWxzZTtcbn07XG5cblNvZnREZWNvcmF0aW9uRHJhd2luZy5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLmdyb3VwLnBoeXNpY3NNYW5hZ2VyLmdldEJvdW5kaW5nQm94KCk7XG59O1xuXG5Tb2Z0RGVjb3JhdGlvbkRyYXdpbmcuaXNTdGF0aWMgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5ncm91cC5jb25mLmZpeGVkID09PSB0cnVlO1xufTtcblxuU29mdERlY29yYXRpb25EcmF3aW5nLndpbGxOb3RJbnRlcnNlY3QgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5Tb2Z0RGVjb3JhdGlvbkRyYXdpbmcuaXNTaW1wbGVEcmF3aW5nID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2Z0RGVjb3JhdGlvbkRyYXdpbmc7XG4iLCJ2YXIgQ29tbWFuZHMgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0NvbW1hbmRzJyk7XG52YXIgQ0lSQ0xFID0gQ29tbWFuZHMuQ0lSQ0xFO1xudmFyIExJTkVfVE8gPSBDb21tYW5kcy5MSU5FX1RPO1xudmFyIE1PVkVfVE8gPSBDb21tYW5kcy5NT1ZFX1RPO1xudmFyIEJFWklFUl9UTyA9IENvbW1hbmRzLkJFWklFUl9UTztcbnZhciBRVUFEUkFfVE8gPSBDb21tYW5kcy5RVUFEUkFfVE87XG52YXIgRUxMSVBTRSA9IENvbW1hbmRzLkVMTElQU0U7XG52YXIgU1ZKZWxseVV0aWxzID0gcmVxdWlyZSgnLi4vLi4vY29yZS9TVkplbGx5VXRpbHMnKTtcbnZhciB0d29QSVMgPSBNYXRoLlBJICogMjtcblxudmFyIFNWSmVsbHlSZW5kZXJlciA9Ly9mdW5jdGlvbiAoJHdvcmxkLCAkY2FudmFzKVxue1xuXHRjcmVhdGU6IGZ1bmN0aW9uICgkd29ybGQsICRjb250YWluZXIpXG5cdHtcblx0XHQvL2NydWRlIHBvbHlmaWxsXG5cdFx0aWYgKENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZWxsaXBzZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmVsbGlwc2UgPSBmdW5jdGlvbiAoeCwgeSwgcngsIHJ5LCByb3RhdGlvbiwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuYXJjKHgsIHksIHJ4LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHR2YXIgaW5zdCA9IE9iamVjdC5jcmVhdGUoU1ZKZWxseVJlbmRlcmVyKTtcblxuXHRcdGluc3QuY29udGFpbmVyID0gaW5zdC5tYWluQ2FudmFzID0gJGNvbnRhaW5lcjtcblx0XHRpbnN0LndvcmxkID0gJHdvcmxkO1xuXHRcdGluc3QubXVsdGlDYW52YXMgPSAkd29ybGQuY29uZi5tdWx0aUNhbnZhcztcblx0XHRpbnN0LmRlYnVnID0gJHdvcmxkLmNvbmYuZGVidWc7XG5cblx0XHQvL2luc3Quc2V0U2l6ZSgkd2lkdGgsICRoZWlnaHQpO1xuXG5cdFx0aWYgKCFpbnN0Lm11bHRpQ2FudmFzKSB7IGluc3QuY29udGFpbmVyID0gaW5zdC5tYWluQ2FudmFzOyB9XG5cblx0XHRyZXR1cm4gaW5zdDtcblx0fSxcblxuXHRzZXRTaXplOiBmdW5jdGlvbiAoJHdpZHRoLCAkaGVpZ2h0KVxuXHR7XG5cdFx0d2hpbGUgKHRoaXMuY29udGFpbmVyLmZpcnN0Q2hpbGQpXG5cdFx0e1xuXHRcdFx0dGhpcy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5jb250YWluZXIuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdGF0aWNDYW52YXMgPSBbXTtcblx0XHR0aGlzLmR5bmFtaWNDYW52YXMgPSBbXTtcblx0XHR0aGlzLmNhbnZhc2VzID0gW107XG5cdFx0dGhpcy5sYXllcnMgPSBbXTtcblx0XHR0aGlzLmNhbnZhc2VzTGVuZ3RoID0gMDtcblx0XHR0aGlzLmNhY2hlZEhhcmQgPSBbXTtcblx0XHR0aGlzLmR5bmFtaWNHcm91cHMgPSBbXTtcblx0XHR0aGlzLnN0YXRpY0dyb3VwcyA9IFtdO1xuXHRcdHRoaXMuZHluYW1pY0dyb3Vwc0xlbmd0aCA9IHVuZGVmaW5lZDtcblxuXHRcdHRoaXMud2lkdGggPSAkd2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSAkaGVpZ2h0O1xuXG5cdFx0dGhpcy5yYXRpbyA9IHRoaXMud2lkdGggLyB0aGlzLndvcmxkLnBoeXNpY3NNYW5hZ2VyLndvcmxkV2lkdGg7XG5cblx0XHR0aGlzLnByZXZpb3VzVmlld0NlbnRlciA9IFtudWxsLCBudWxsXTtcblx0XHR0aGlzLnZpZXdDZW50ZXIgPSBbMCwgMF07XG5cdFx0dGhpcy52aWV3cG9ydFNjYWxlID0gMTtcblx0XHR0aGlzLnByZXZpb3VzVmlld3BvcnRTY2FsZSA9IHVuZGVmaW5lZDtcblxuXHRcdHRoaXMuc2NhbGVYID0gdGhpcy5zY2FsZVkgPSAxMDA7XG5cblx0XHQvL2NyZWF0aW5nIGRyYXdpbmcgZ3JvdXBzXG5cdFx0dGhpcy5kcmF3aW5nR3JvdXBzID0gW107XG5cdFx0dmFyIGsgPSAwO1xuXHRcdHZhciBpO1xuXHRcdGZvciAodmFyIGdyb3Vwc0xlbmd0aCA9IHRoaXMud29ybGQuZHJhd2luZ3MubGVuZ3RoOyBrIDwgZ3JvdXBzTGVuZ3RoOyBrICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJEcmF3aW5nID0gdGhpcy53b3JsZC5kcmF3aW5nc1trXTtcblx0XHRcdGN1cnJEcmF3aW5nLnNldFNjYWxlKHRoaXMuc2NhbGVYLCB0aGlzLnNjYWxlWSk7XG5cdFx0XHR0aGlzLmNyZWF0ZURyYXdpbmdHcm91cChjdXJyRHJhd2luZyk7XG5cdFx0fVxuXHRcdHRoaXMuZHJhd2luZ0dyb3Vwc0xlbmd0aCA9IHRoaXMuZHJhd2luZ0dyb3Vwcy5sZW5ndGg7XG5cblx0XHR2YXIgZHJhd2luZ0dyb3VwO1xuXG5cdFx0Ly9jcmVhdGluZyBjYW52YXMgYW5kIGNhY2hpbmcgbm9uIG1vdmluZyBncm91cHNcblx0XHRpID0gMDtcblx0XHR2YXIgY2FudmFzO1xuXHRcdHZhciBsYXllcjtcblx0XHRmb3IgKGk7IGkgPCB0aGlzLmRyYXdpbmdHcm91cHNMZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHRkcmF3aW5nR3JvdXAgPSB0aGlzLmRyYXdpbmdHcm91cHNbaV07XG5cdFx0XHRpZiAoZHJhd2luZ0dyb3VwLmlzU3RhdGljKVxuXHRcdFx0e1xuXHRcdFx0XHQvL2lmIHNvbWUgc3RhdGljIGxheWVycyBhcmUgb24gdG9wIG9mIGVhY2ggb3RoZXIsIG5vIG5lZWQgdG8gY3JlYXRlXG5cdFx0XHRcdC8vYSBuZXcgY2FudmFzLCB5b3UgY2FuIGp1c3QgZHJhdyB0aGUgbGF5ZXJzIG9uIHRoZSBzYW1lIG9uZVxuXHRcdFx0XHRpZiAoIXRoaXMuc3RhdGljQ2FudmFzW2kgLSAxXSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNhbnZhcyA9IHRoaXMuY3JlYXRlQ2FudmFzKCk7XG5cdFx0XHRcdFx0bGF5ZXIgPSB0aGlzLmNyZWF0ZUNhbnZhcygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNhbnZhcyA9IHRoaXMuZHJhd2luZ0dyb3Vwc1tpIC0gMV0uY2FudmFzO1xuXHRcdFx0XHRcdGxheWVyID0gdGhpcy5kcmF3aW5nR3JvdXBzW2kgLSAxXS5sYXllcjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL2NhbnZhcyA9IHRoaXMuc3RhdGljQ2FudmFzW2kgLSAxXSB8fCB0aGlzLmNyZWF0ZUNhbnZhcygpO1xuXHRcdFx0XHR0aGlzLnN0YXRpY0NhbnZhc1tpXSA9IGNhbnZhcztcblx0XHRcdFx0dGhpcy5zdGF0aWNHcm91cHMucHVzaChkcmF3aW5nR3JvdXApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRjYW52YXMgPSB0aGlzLmR5bmFtaWNDYW52YXNbaSAtIDFdIHx8IHRoaXMuY3JlYXRlQ2FudmFzKCk7XG5cdFx0XHRcdGxheWVyID0gY2FudmFzO1xuXHRcdFx0XHR0aGlzLmR5bmFtaWNDYW52YXNbaV0gPSBjYW52YXM7XG5cdFx0XHRcdHRoaXMuZHluYW1pY0dyb3Vwcy5wdXNoKGRyYXdpbmdHcm91cCk7XG5cdFx0XHR9XG5cdFx0XHRkcmF3aW5nR3JvdXAuY2FudmFzID0gY2FudmFzO1xuXHRcdFx0ZHJhd2luZ0dyb3VwLmxheWVyID0gbGF5ZXI7XG5cdFx0XHRkcmF3aW5nR3JvdXAuY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdH1cblx0XHR0aGlzLmR5bmFtaWNHcm91cHNMZW5ndGggPSB0aGlzLmR5bmFtaWNHcm91cHMubGVuZ3RoO1xuXHRcdHRoaXMuc3RhdGljR3JvdXBzTGVuZ3RoID0gdGhpcy5zdGF0aWNHcm91cHMubGVuZ3RoO1xuXHRcdC8vXG5cblx0XHQvL2NhY2hpbmcgZ3JhZGllbnRzIGFuZCBwcmVjYWxjdWxhdGluZ1xuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLmRyYXdpbmdHcm91cHNMZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHRkcmF3aW5nR3JvdXAgPSB0aGlzLmRyYXdpbmdHcm91cHNbaV07XG5cdFx0XHR0aGlzLnByZWNhbGN1bGF0aW5nKGRyYXdpbmdHcm91cCk7XG5cdFx0XHRkcmF3aW5nR3JvdXAub2JqZWN0RHJhd2luZ3NMZW5ndGggPSBkcmF3aW5nR3JvdXAub2JqZWN0RHJhd2luZ3MubGVuZ3RoO1xuXHRcdFx0Ly9cblx0XHRcdGlmIChkcmF3aW5nR3JvdXAucHJvcGVydGllcy5zdHJva2VHcmFkaWVudClcblx0XHRcdHtcblx0XHRcdFx0ZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMuc3Ryb2tlID0gdGhpcy5jcmVhdGVHcmFkaWVudChkcmF3aW5nR3JvdXAuY29udGV4dCwgZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMuc3Ryb2tlR3JhZGllbnQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLmZpbGxHcmFkaWVudClcblx0XHRcdHtcblx0XHRcdFx0ZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMuZmlsbCA9IHRoaXMuY3JlYXRlR3JhZGllbnQoZHJhd2luZ0dyb3VwLmNvbnRleHQsIGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLmZpbGxHcmFkaWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gbXVsdGkgY2FudmFzXG5cdFx0aWYgKHRoaXMubXVsdGlDYW52YXMpXG5cdFx0e1xuXHRcdFx0dGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5kcmF3aW5nR3JvdXBzTGVuZ3RoOyBpICs9IDEpXG5cdFx0XHR7XG5cdFx0XHRcdGRyYXdpbmdHcm91cCA9IHRoaXMuZHJhd2luZ0dyb3Vwc1tpXTtcblx0XHRcdFx0bGF5ZXIgPSBkcmF3aW5nR3JvdXAubGF5ZXI7XG5cdFx0XHRcdHRoaXMuYWRkTGF5ZXIodGhpcy5jb250YWluZXIsIGxheWVyLCAhZHJhd2luZ0dyb3VwLmlzU3RhdGljKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5kcmF3ID0gdGhpcy5tdWx0aUNhbnZhcyA/IHRoaXMuZHJhd011bHRpQ2FudmFzIDogdGhpcy5kcmF3U2luZ2xlQ2FudmFzO1xuXG5cdFx0dGhpcy5zZXRWaWV3Q2VudGVyKFt0aGlzLndvcmxkLnBoeXNpY3NNYW5hZ2VyLndvcmxkV2lkdGggKiAwLjUsIHRoaXMud29ybGQucGh5c2ljc01hbmFnZXIud29ybGRIZWlnaHQgKiAwLjVdLCB0aGlzLnJhdGlvIC8gdGhpcy5zY2FsZVgpO1xuXHRcdC8vdGhpcy5zZXRWaWV3Q2VudGVyKFt0aGlzLndpZHRoICogMC41LCB0aGlzLmhlaWdodCAqIDAuNV0sIDEpO1xuXG5cdFx0aWYgKHRoaXMuZGVidWcpXG5cdFx0e1xuXHRcdFx0dGhpcy5kZWJ1Z0NhbnZhcyA9IHRoaXMuY3JlYXRlQ2FudmFzKCk7XG5cdFx0XHR0aGlzLmRlYnVnQ29udGV4dCA9IHRoaXMuZGVidWdDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRcdHRoaXMuYWRkTGF5ZXIodGhpcy5tdWx0aUNhbnZhcyA/IHRoaXMuY29udGFpbmVyIDogdGhpcy5tYWluQ2FudmFzLnBhcmVudE5vZGUsIHRoaXMuZGVidWdDYW52YXMsIGZhbHNlKTtcblx0XHR9XG5cdH0sXG5cblx0c2V0Vmlld0NlbnRlcjogZnVuY3Rpb24gKCR2YywgJHNjYWxlKVxuXHR7XG5cdFx0dGhpcy52aWV3Q2VudGVyWzBdID0gTWF0aC5yb3VuZCgkdmNbMF0gKiAxMCkgLyAxMDtcblx0XHR0aGlzLnZpZXdDZW50ZXJbMV0gPSBNYXRoLnJvdW5kKCR2Y1sxXSAqIDEwKSAvIDEwO1xuXHRcdHRoaXMudmlld3BvcnRTY2FsZSA9ICRzY2FsZSB8fCB0aGlzLnZpZXdwb3J0U2NhbGU7XG5cdH0sXG5cblx0c2V0U2NhbGU6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHRjb25zb2xlLmxvZygnc2V0c2NhbGUnKTtcblx0XHR2YXIgcHJldmlvdXNTdGF0aWM7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0YXRpY0dyb3Vwc0xlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBzdGF0aWNHcm91cCA9IHRoaXMuc3RhdGljR3JvdXBzW2ldO1xuXHRcdFx0aWYgKHN0YXRpY0dyb3VwLmNhbnZhcyAhPT0gcHJldmlvdXNTdGF0aWMpXG5cdFx0XHR7XG5cdFx0XHRcdHN0YXRpY0dyb3VwLmNhbnZhcy53aWR0aCA9IHRoaXMud29ybGQucGh5c2ljc01hbmFnZXIud29ybGRXaWR0aCAqIHRoaXMuc2NhbGVYICogdGhpcy52aWV3cG9ydFNjYWxlO1xuXHRcdFx0XHRzdGF0aWNHcm91cC5jYW52YXMuaGVpZ2h0ID0gdGhpcy53b3JsZC5waHlzaWNzTWFuYWdlci53b3JsZEhlaWdodCAqIHRoaXMuc2NhbGVZICogdGhpcy52aWV3cG9ydFNjYWxlO1xuXHRcdFx0XHRzdGF0aWNHcm91cC5jb250ZXh0LnNjYWxlKHRoaXMudmlld3BvcnRTY2FsZSwgdGhpcy52aWV3cG9ydFNjYWxlKTsvL3RoaXMuY29udGV4dFNjYWxlLCB0aGlzLmNvbnRleHRTY2FsZSk7XG5cdFx0XHRcdC8vIHN0YXRpY0dyb3VwLmNvbnRleHQuc2NhbGUoMSwgMSk7XG5cdFx0XHRcdC8vc3RhdGljR3JvdXAuY2FudmFzLndpZHRoID0gdGhpcy53aWR0aDtcblx0XHRcdFx0Ly9zdGF0aWNHcm91cC5jYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cdFx0XHRcdHByZXZpb3VzU3RhdGljID0gc3RhdGljR3JvdXAuY2FudmFzO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5kcmF3R3JvdXAoc3RhdGljR3JvdXAsIHN0YXRpY0dyb3VwLmNvbnRleHQsIHRydWUpO1xuXHRcdH1cblx0XHR0aGlzLnVwZGF0ZVN0YXRpY0xheWVycygpO1xuXHRcdHRoaXMudXBkYXRlRHluYW1pY0xheWVycygpO1xuXHR9LFxuXG5cdHNldFRyYW5zbGF0ZTogZnVuY3Rpb24gKClcblx0e1xuXHRcdHRoaXMudXBkYXRlU3RhdGljTGF5ZXJzKCk7XG5cdFx0dGhpcy51cGRhdGVEeW5hbWljTGF5ZXJzKCk7XG5cdH0sXG5cblx0dXBkYXRlU3RhdGljTGF5ZXJzOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0dmFyIHByZXZpb3VzO1xuXHRcdHZhciBjb250ZXh0O1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0YXRpY0dyb3Vwc0xlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBkcmF3aW5nR3JvdXAgPSB0aGlzLnN0YXRpY0dyb3Vwc1tpXTtcblx0XHRcdHZhciBsYXllciA9IGRyYXdpbmdHcm91cC5sYXllcjtcblx0XHRcdC8vaWYgKGxheWVyID09PSBwcmV2aW91cykgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRjb250ZXh0ID0gbGF5ZXIuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRcdGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0XHRcdHZhciBzeCA9IHRoaXMudmlld0NlbnRlclswXSAqIHRoaXMuc2NhbGVYICogdGhpcy52aWV3cG9ydFNjYWxlIC0gdGhpcy53aWR0aCAqIDAuNTtcblx0XHRcdHZhciBzeSA9IHRoaXMudmlld0NlbnRlclsxXSAqIHRoaXMuc2NhbGVYICogdGhpcy52aWV3cG9ydFNjYWxlIC0gdGhpcy5oZWlnaHQgKiAwLjU7XG5cdFx0XHRjb250ZXh0LmRyYXdJbWFnZShkcmF3aW5nR3JvdXAuY2FudmFzLCBzeCwgc3ksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdFx0XHQvL2NvbnRleHQuZHJhd0ltYWdlKGRyYXdpbmdHcm91cC5jYW52YXMsIDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdFx0XHRwcmV2aW91cyA9IGxheWVyO1xuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVEeW5hbWljTGF5ZXJzOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0dmFyIHByZXZpb3VzRHluYW1pYztcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZHluYW1pY0dyb3Vwc0xlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBkeW5hbWljR3JvdXAgPSB0aGlzLmR5bmFtaWNHcm91cHNbaV07XG5cdFx0XHRpZiAoZHluYW1pY0dyb3VwLmNhbnZhcyA9PT0gcHJldmlvdXNEeW5hbWljKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHQvL2R5bmFtaWNHcm91cC5jb250ZXh0LnNjYWxlKHRoaXMudmlld3BvcnRTY2FsZSwgdGhpcy52aWV3cG9ydFNjYWxlKTtcblx0XHRcdC8vZHluYW1pY0dyb3VwLmNvbnRleHQuc2V0VHJhbnNmb3JtKHRoaXMudmlld3BvcnRTY2FsZSwgMCwgMCwgdGhpcy52aWV3cG9ydFNjYWxlLCAtdGhpcy52aWV3Q2VudGVyWzBdICogdGhpcy52aWV3cG9ydFNjYWxlLCAtdGhpcy52aWV3WSAqIHRoaXMudmlld3BvcnRTY2FsZSk7XG5cdFx0XHRkeW5hbWljR3JvdXAuY29udGV4dC5zZXRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFNjYWxlLCAwLCAwLCB0aGlzLnZpZXdwb3J0U2NhbGUsIC10aGlzLnZpZXdDZW50ZXJbMF0gKiB0aGlzLnNjYWxlWCAqIHRoaXMudmlld3BvcnRTY2FsZSArIHRoaXMud2lkdGggKiAwLjUsIC10aGlzLnZpZXdDZW50ZXJbMV0gKiB0aGlzLnNjYWxlWCAqIHRoaXMudmlld3BvcnRTY2FsZSArIHRoaXMuaGVpZ2h0ICogMC41KTtcblx0XHRcdHByZXZpb3VzRHluYW1pYyA9IGR5bmFtaWNHcm91cC5jYW52YXM7XG5cdFx0fVxuXHR9LFxuXG5cdGNoZWNrVmlld3BvcnQ6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHRpZiAodGhpcy52aWV3Q2VudGVyWzBdICE9PSB0aGlzLnByZXZpb3VzVmlld0NlbnRlclswXSB8fFxuXHRcdFx0dGhpcy52aWV3Q2VudGVyWzFdICE9PSB0aGlzLnByZXZpb3VzVmlld0NlbnRlclsxXSB8fFxuXHRcdFx0dGhpcy52aWV3cG9ydFNjYWxlICE9PSB0aGlzLnByZXZpb3VzVmlld3BvcnRTY2FsZSlcblx0XHR7XG5cdFx0XHR0aGlzLnZpZXdIZWlnaHQgPSB0aGlzLmhlaWdodCAvIHRoaXMuc2NhbGVYIC8gdGhpcy52aWV3cG9ydFNjYWxlO1xuXHRcdFx0dGhpcy52aWV3V2lkdGggPSB0aGlzLndpZHRoIC8gdGhpcy5zY2FsZVggLyB0aGlzLnZpZXdwb3J0U2NhbGU7XG5cblx0XHRcdGlmICh0aGlzLnZpZXdwb3J0U2NhbGUgIT09IHRoaXMucHJldmlvdXNWaWV3cG9ydFNjYWxlKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLnNldFNjYWxlKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuc2V0VHJhbnNsYXRlKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnByZXZpb3VzVmlld0NlbnRlclswXSA9IHRoaXMudmlld0NlbnRlclswXTtcblx0XHRcdHRoaXMucHJldmlvdXNWaWV3Q2VudGVyWzFdID0gdGhpcy52aWV3Q2VudGVyWzFdO1xuXHRcdFx0dGhpcy5wcmV2aW91c1ZpZXdwb3J0U2NhbGUgPSB0aGlzLnZpZXdwb3J0U2NhbGU7XG5cdFx0fVxuXHRcdC8vIGlmICh0aGlzLnZpZXdwb3J0WzBdWzBdICE9PSB0aGlzLnByZXZpb3VzVmlld3BvcnRbMF1bMF0gfHxcblx0XHQvLyBcdHRoaXMudmlld3BvcnRbMF1bMV0gIT09IHRoaXMucHJldmlvdXNWaWV3cG9ydFswXVsxXSB8fFxuXHRcdC8vIFx0dGhpcy52aWV3cG9ydFsxXVswXSAhPT0gdGhpcy5wcmV2aW91c1ZpZXdwb3J0WzFdWzBdIHx8XG5cdFx0Ly8gXHR0aGlzLnZpZXdwb3J0WzFdWzFdICE9PSB0aGlzLnByZXZpb3VzVmlld3BvcnRbMV1bMV0pXG5cdFx0Ly8ge1xuXHRcdC8vIFx0dmFyIGxhc3RTY2FsZSA9IHRoaXMudmlld3BvcnRTY2FsZTtcblx0XHQvLyBcdHRoaXMudmlld3BvcnRTY2FsZSA9ICh0aGlzLndpZHRoIC8gKHRoaXMudmlld3BvcnRbMV1bMF0gLSB0aGlzLnZpZXdwb3J0WzBdWzBdKSk7XG5cblx0XHQvLyBcdGlmIChsYXN0U2NhbGUgPT09IHRoaXMudmlld3BvcnRTY2FsZSlcblx0XHQvLyBcdHtcblx0XHQvLyBcdFx0dGhpcy5zZXRUcmFuc2xhdGUoKTtcblx0XHQvLyBcdH1cblx0XHQvLyBcdGVsc2Vcblx0XHQvLyBcdHtcblx0XHQvLyBcdFx0dGhpcy5zZXRTY2FsZSgpO1xuXHRcdC8vIFx0fVxuXHRcdC8vIFx0dGhpcy5wcmV2aW91c1ZpZXdwb3J0WzBdWzBdID0gdGhpcy52aWV3cG9ydFswXVswXTtcblx0XHQvLyBcdHRoaXMucHJldmlvdXNWaWV3cG9ydFswXVsxXSA9IHRoaXMudmlld3BvcnRbMF1bMV07XG5cdFx0Ly8gXHR0aGlzLnByZXZpb3VzVmlld3BvcnRbMV1bMF0gPSB0aGlzLnZpZXdwb3J0WzFdWzBdO1xuXHRcdC8vIFx0dGhpcy5wcmV2aW91c1ZpZXdwb3J0WzFdWzFdID0gdGhpcy52aWV3cG9ydFsxXVsxXTtcblx0XHQvLyB9XG5cdH0sXG5cblx0ZHJhd011bHRpQ2FudmFzOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0Ly90aGlzLm1haW5Db250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdFx0dGhpcy5jaGVja1ZpZXdwb3J0KCk7XG5cdFx0dmFyIHByZXZpb3VzO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5keW5hbWljR3JvdXBzTGVuZ3RoOyBpICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGRyYXdpbmdHcm91cCA9IHRoaXMuZHluYW1pY0dyb3Vwc1tpXTtcblx0XHRcdGlmIChwcmV2aW91cyAhPT0gZHJhd2luZ0dyb3VwLmNvbnRleHQpXG5cdFx0XHR7XG5cdFx0XHRcdGRyYXdpbmdHcm91cC5jb250ZXh0LnNhdmUoKTtcblx0XHRcdFx0ZHJhd2luZ0dyb3VwLmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdFx0XHRkcmF3aW5nR3JvdXAuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHRcdFx0XHRkcmF3aW5nR3JvdXAuY29udGV4dC5yZXN0b3JlKCk7XG5cdFx0XHR9XG5cdFx0XHQvL2RyYXdpbmdHcm91cC5jb250ZXh0LnNjYWxlKHRoaXMuY29udGV4dFNjYWxlWCwgdGhpcy5jb250ZXh0U2NhbGVZKTtcblx0XHRcdHByZXZpb3VzID0gZHJhd2luZ0dyb3VwLmNvbnRleHQ7XG5cdFx0XHR0aGlzLmRyYXdHcm91cChkcmF3aW5nR3JvdXAsIGRyYXdpbmdHcm91cC5jb250ZXh0KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5kZWJ1ZykgeyB0aGlzLmRlYnVnRHJhdyh0cnVlKTsgfVxuXHR9LFxuXG5cdGRyYXdTaW5nbGVDYW52YXM6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR0aGlzLm1haW5Db250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdFx0Ly90aGlzLmNvbnRleHQubWl0ZXJMaW1pdCA9IDE7XG5cdFx0dmFyIHByZXZpb3VzQ2FjaGVkO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kcmF3aW5nR3JvdXBzTGVuZ3RoOyBpICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGRyYXdpbmdHcm91cCA9IHRoaXMuZHJhd2luZ0dyb3Vwc1tpXTtcblx0XHRcdGlmICh0aGlzLnN0YXRpY0NhbnZhc1tpXSlcblx0XHRcdHtcblx0XHRcdFx0aWYgKHRoaXMuc3RhdGljQ2FudmFzW2ldID09PSBwcmV2aW91c0NhY2hlZCkgeyBjb250aW51ZTsgfVxuXHRcdFx0XHR0aGlzLm1haW5Db250ZXh0LmRyYXdJbWFnZSh0aGlzLnN0YXRpY0NhbnZhc1tpXSwgMCwgMCk7XG5cdFx0XHRcdHByZXZpb3VzQ2FjaGVkID0gdGhpcy5zdGF0aWNDYW52YXNbaV07XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuZHJhd0dyb3VwKGRyYXdpbmdHcm91cCwgdGhpcy5tYWluQ29udGV4dCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuZGVidWcpIHsgdGhpcy5kZWJ1Z0RyYXcodHJ1ZSk7IH1cblx0fSxcblxuXHRkcmF3R3JvdXA6IGZ1bmN0aW9uIChkcmF3aW5nR3JvdXAsIGNvbnRleHQsIGZvcmNlKVxuXHR7XG5cdFx0Y29udGV4dC5iZWdpblBhdGgoKTtcblxuXHRcdGlmIChjb250ZXh0LmZpbGxTdHlsZSAhPT0gZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMuZmlsbCkgeyBjb250ZXh0LmZpbGxTdHlsZSA9IGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLmZpbGw7IH1cblx0XHRpZiAoY29udGV4dC5zdHJva2VTdHlsZSAhPT0gZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMuc3Ryb2tlKSB7IGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBkcmF3aW5nR3JvdXAucHJvcGVydGllcy5zdHJva2U7IH1cblx0XHRpZiAoY29udGV4dC5saW5lV2lkdGggIT09IGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLmxpbmVXaWR0aCkgeyBjb250ZXh0LmxpbmVXaWR0aCA9IGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLmxpbmVXaWR0aDsgfVxuXHRcdGlmIChjb250ZXh0LmxpbmVDYXAgIT09IGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLmxpbmVDYXApIHsgY29udGV4dC5saW5lQ2FwID0gZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMubGluZUNhcDsgfVxuXHRcdGlmIChjb250ZXh0LmxpbmVKb2luICE9PSBkcmF3aW5nR3JvdXAucHJvcGVydGllcy5saW5lSm9pbikgeyBjb250ZXh0LmxpbmVKb2luID0gZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMubGluZUpvaW47IH1cblx0XHRpZiAoY29udGV4dC5nbG9iYWxBbHBoYSAhPT0gZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMub3BhY2l0eSkgeyBjb250ZXh0Lmdsb2JhbEFscGhhID0gZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMub3BhY2l0eTsgfVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGRyYXdpbmdHcm91cC5vYmplY3REcmF3aW5nc0xlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjdXJyT2JqZWN0RHJhd2luZyA9IGRyYXdpbmdHcm91cC5vYmplY3REcmF3aW5nc1tpXTtcblx0XHRcdHRoaXMuZHJhd09iamVjdChjdXJyT2JqZWN0RHJhd2luZywgZHJhd2luZ0dyb3VwLCBjb250ZXh0LCBmb3JjZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLmNsb3NlUGF0aCkgeyBjb250ZXh0LmNsb3NlUGF0aCgpOyB9XG5cdFx0aWYgKGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLmZpbGwgIT09ICdub25lJykgeyBjb250ZXh0LmZpbGwoKTsgfVxuXHRcdGlmIChkcmF3aW5nR3JvdXAucHJvcGVydGllcy5zdHJva2UgIT09ICdub25lJykgeyBjb250ZXh0LnN0cm9rZSgpOyB9XG5cdFx0aWYgKGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLm9wYWNpdHkgIT09IDEpIHsgY29udGV4dC5nbG9iYWxBbHBoYSA9IDE7IH1cblx0fSxcblxuXHRkcmF3T2JqZWN0OiBmdW5jdGlvbiAob2JqZWN0RHJhd2luZywgZHJhd2luZ0dyb3VwLCBjb250ZXh0LCBmb3JjZSlcblx0e1xuXHRcdGlmICghZm9yY2UpXG5cdFx0e1xuXHRcdFx0dmFyIHRvdG8gPSAndHV0Jztcblx0XHRcdHRvdG8gKz0gMTtcblx0XHRcdC8vIHZhciBib3VuZGluZ0JveCA9IG9iamVjdERyYXdpbmcuZ2V0Qm91bmRpbmdCb3goKTtcblx0XHRcdC8vIGlmIChib3VuZGluZ0JveFsxXVswXSAqIHRoaXMuc2NhbGVYIDwgdGhpcy52aWV3WCkgeyByZXR1cm47IH1cblx0XHRcdC8vIGlmIChib3VuZGluZ0JveFsxXVsxXSAqIHRoaXMuc2NhbGVZIDwgdGhpcy52aWV3WSkgeyByZXR1cm47IH1cblx0XHRcdC8vIGlmIChib3VuZGluZ0JveFswXVswXSAqIHRoaXMuc2NhbGVYID4gdGhpcy52aWV3WCArIHRoaXMudmlld1dpZHRoKSB7IHJldHVybjsgfVxuXHRcdFx0Ly8gaWYgKGJvdW5kaW5nQm94WzBdWzFdICogdGhpcy5zY2FsZVkgPiB0aGlzLnZpZXdZICsgdGhpcy52aWV3SGVpZ2h0KSB7IHJldHVybjsgfVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgb2JqZWN0RHJhd2luZy5jb21tYW5kc0xlbmd0aDsgayArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjdXJyQ29tbWFuZCA9IG9iamVjdERyYXdpbmcuY29tbWFuZHNba107XG5cdFx0XHR2YXIgcG9pbnQgPSBbY3VyckNvbW1hbmQuZ2V0WCgpLCBjdXJyQ29tbWFuZC5nZXRZKCldO1xuXG5cdFx0XHRpZiAoY3VyckNvbW1hbmQubmFtZSA9PT0gTU9WRV9UTylcblx0XHRcdHtcblx0XHRcdFx0Y29udGV4dC5tb3ZlVG8ocG9pbnRbMF0sIHBvaW50WzFdKTtcblxuXHRcdFx0XHQvL3NwZWNpYWwgY2FzZSBmb3IgbGluZXMgd2l0aCBuaWNlIGR5bmFtaWMgZ3JhZGllbnRzXG5cdFx0XHRcdGlmIChvYmplY3REcmF3aW5nLnVzZUR5bmFtaWNHcmFkaWVudClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhciB4MSA9IGN1cnJDb21tYW5kLmdldFgoKTtcblx0XHRcdFx0XHR2YXIgeTEgPSBjdXJyQ29tbWFuZC5nZXRZKCk7XG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZyhjdXJyQ29tbWFuZC5lbmRDb21tYW5kLCBjdXJyQ29tbWFuZC5lbmRDb21tYW5kLmdldFgoKSwgY3VyckNvbW1hbmQuZW5kQ29tbWFuZC5nZXRZKCkpO1xuXHRcdFx0XHRcdHZhciB4MiA9IGN1cnJDb21tYW5kLmVuZENvbW1hbmQuZ2V0WCgpO1xuXHRcdFx0XHRcdHZhciB5MiA9IGN1cnJDb21tYW5kLmVuZENvbW1hbmQuZ2V0WSgpO1xuXHRcdFx0XHRcdHZhciBncmFkaWVudCA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoeDEsIHkxLCB4MiwgeTIpO1xuXHRcdFx0XHRcdGZvciAodmFyIHN0b3BOID0gMCwgc3RvcExlbmd0aCA9IG9iamVjdERyYXdpbmcucHJvcGVydGllcy5zdHJva2VHcmFkaWVudC5zdG9wcy5sZW5ndGg7IHN0b3BOIDwgc3RvcExlbmd0aDsgc3RvcE4gKz0gMSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRncmFkaWVudC5hZGRDb2xvclN0b3AoMSAtIG9iamVjdERyYXdpbmcucHJvcGVydGllcy5zdHJva2VHcmFkaWVudC5zdG9wc1tzdG9wTl0ub2Zmc2V0LCBvYmplY3REcmF3aW5nLnByb3BlcnRpZXMuc3Ryb2tlR3JhZGllbnQuc3RvcHNbc3RvcE5dLmNvbG9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29udGV4dC5zdHJva2VTdHlsZSA9IGdyYWRpZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChjdXJyQ29tbWFuZC5uYW1lID09PSBMSU5FX1RPKVxuXHRcdFx0e1xuXHRcdFx0XHRjb250ZXh0LmxpbmVUbyhwb2ludFswXSwgcG9pbnRbMV0pO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGN1cnJDb21tYW5kLm5hbWUgPT09IENJUkNMRSlcblx0XHRcdHtcblx0XHRcdFx0Y29udGV4dC5tb3ZlVG8ocG9pbnRbMF0gKyBjdXJyQ29tbWFuZC5yYWRpdXMsIHBvaW50WzFdKTtcblx0XHRcdFx0Y29udGV4dC5hcmMocG9pbnRbMF0sIHBvaW50WzFdLCBjdXJyQ29tbWFuZC5yYWRpdXMsIDAsIHR3b1BJUyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWRyYXdpbmdHcm91cC5pc1NpbXBsZURyYXdpbmcpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBjcDE7XG5cblx0XHRcdFx0aWYgKGN1cnJDb21tYW5kLm5hbWUgPT09IEJFWklFUl9UTyB8fCBjdXJyQ29tbWFuZC5uYW1lID09PSBRVUFEUkFfVE8pXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjcDEgPSBjdXJyQ29tbWFuZC5nZXRDUDEoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyQ29tbWFuZC5uYW1lID09PSBCRVpJRVJfVE8pXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgY3AyID0gY3VyckNvbW1hbmQuZ2V0Q1AyKCk7XG5cdFx0XHRcdFx0Y29udGV4dC5iZXppZXJDdXJ2ZVRvKGNwMVswXSwgY3AxWzFdLCBjcDJbMF0sIGNwMlsxXSwgcG9pbnRbMF0sIHBvaW50WzFdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChjdXJyQ29tbWFuZC5uYW1lID09PSBRVUFEUkFfVE8pXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY3AxWzBdLCBjcDFbMV0sIHBvaW50WzBdLCBwb2ludFsxXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoY3VyckNvbW1hbmQubmFtZSA9PT0gRUxMSVBTRSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnRleHQubW92ZVRvKHBvaW50WzBdLCBwb2ludFsxXSk7XG5cdFx0XHRcdFx0Y29udGV4dC5lbGxpcHNlKHBvaW50WzBdLCBwb2ludFsxXSwgY3VyckNvbW1hbmQucmFkaXVzLCBjdXJyQ29tbWFuZC5yYWRpdXNCLCBjdXJyQ29tbWFuZC5nZXRSb3RhdGlvbigpLCAwLCB0d29QSVMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByZWNhbGN1bGF0aW5nOiBmdW5jdGlvbiAoJGRyYXdpbmdHcm91cClcblx0e1xuXHRcdC8vcHJlY2FsY3VsYXRpbmcgc29tZSBpbnN0cnVjdGlvbnNcblx0XHQkZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMubGluZVdpZHRoID0gJGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLmxpbmVXaWR0aCAqIHRoaXMuc2NhbGVYO1xuXHRcdCRkcmF3aW5nR3JvdXAucHJvcGVydGllcy5yYWRpdXNYID0gJGRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLnJhZGl1c1ggKiB0aGlzLnNjYWxlWDtcblx0XHQkZHJhd2luZ0dyb3VwLnByb3BlcnRpZXMucmFkaXVzWSA9ICRkcmF3aW5nR3JvdXAucHJvcGVydGllcy5yYWRpdXNZICogdGhpcy5zY2FsZVk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIG9iamVjRHJhd2luZ3NMZW5ndGggPSAkZHJhd2luZ0dyb3VwLm9iamVjdERyYXdpbmdzLmxlbmd0aDsgaSA8IG9iamVjRHJhd2luZ3NMZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgY3Vyck9iamVjdERyYXdpbmcgPSAkZHJhd2luZ0dyb3VwLm9iamVjdERyYXdpbmdzW2ldO1xuXHRcdFx0dmFyIGNvbW1hbmRzTGVuZ3RoID0gY3Vyck9iamVjdERyYXdpbmcuY29tbWFuZHNMZW5ndGg7XG5cdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGNvbW1hbmRzTGVuZ3RoOyBrICs9IDEpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBjb21tYW5kID0gY3Vyck9iamVjdERyYXdpbmcuY29tbWFuZHNba107XG5cdFx0XHRcdGlmICgkZHJhd2luZ0dyb3VwLmlzU2ltcGxlRHJhd2luZyAmJiAoY29tbWFuZC5uYW1lID09PSBCRVpJRVJfVE8gfHwgY29tbWFuZC5uYW1lID09PSBRVUFEUkFfVE8pKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZC5uYW1lID0gTElORV9UTztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoJGRyYXdpbmdHcm91cC5pc1NpbXBsZURyYXdpbmcgJiYgKGNvbW1hbmQubmFtZSA9PT0gRUxMSVBTRSkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kLm5hbWUgPSBDSVJDTEU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0YWRkTGF5ZXI6IGZ1bmN0aW9uICgkcGFyZW50LCAkY2FudmFzLCAkcG9pbnRlckV2ZW50cylcblx0e1xuXHRcdGlmICgkcGFyZW50LmNvbnRhaW5zKCRjYW52YXMpKSB7IHJldHVybjsgfVxuXHRcdCRwYXJlbnQuYXBwZW5kQ2hpbGQoJGNhbnZhcyk7XG5cdFx0JGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdFx0JGNhbnZhcy5zdHlsZS5wb2ludGVyRXZlbnRzID0gJHBvaW50ZXJFdmVudHMgPyAnYXV0bycgOiAnbm9uZSc7XG5cdH0sXG5cdGNyZWF0ZUNhbnZhczogZnVuY3Rpb24gKClcblx0e1xuXHRcdHZhciBjYW52YXMgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdFx0Y2FudmFzLndpZHRoID0gdGhpcy53aWR0aDtcblx0XHRjYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cdFx0dGhpcy5jYW52YXNlcy5wdXNoKGNhbnZhcyk7XG5cdFx0dGhpcy5jYW52YXNlc0xlbmd0aCArPSAxO1xuXHRcdHJldHVybiBjYW52YXM7XG5cdH0sXG5cblx0Y3JlYXRlR3JhZGllbnQ6IGZ1bmN0aW9uICgkY29udGV4dCwgJHByb3BlcnRpZXMpXG5cdHtcblx0XHR2YXIgeDEgPSAkcHJvcGVydGllcy54MSAqIHRoaXMuc2NhbGVYO1xuXHRcdHZhciB5MSA9ICRwcm9wZXJ0aWVzLnkxICogdGhpcy5zY2FsZVk7XG5cdFx0dmFyIHgyID0gJHByb3BlcnRpZXMueDIgKiB0aGlzLnNjYWxlWDtcblx0XHR2YXIgeTIgPSAkcHJvcGVydGllcy55MiAqIHRoaXMuc2NhbGVZO1xuXG5cdFx0dmFyIGN4ID0gJHByb3BlcnRpZXMuY3ggKiB0aGlzLnNjYWxlWDtcblx0XHR2YXIgY3kgPSAkcHJvcGVydGllcy5jeSAqIHRoaXMuc2NhbGVZO1xuXHRcdHZhciBmeCA9ICRwcm9wZXJ0aWVzLmZ4ICogdGhpcy5zY2FsZVggfHwgY3g7XG5cdFx0dmFyIGZ5ID0gJHByb3BlcnRpZXMuZnkgKiB0aGlzLnNjYWxlWSB8fCBjeTtcblx0XHR2YXIgciA9ICRwcm9wZXJ0aWVzLnIgKiB0aGlzLnNjYWxlWDtcblxuXHRcdHZhciBncmFkaWVudCA9ICRwcm9wZXJ0aWVzLnR5cGUgPT09ICdsaW5lYXJHcmFkaWVudCcgPyAkY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgyLCB5MikgOiAkY29udGV4dC5jcmVhdGVSYWRpYWxHcmFkaWVudChjeCwgY3ksIDAsIGZ4LCBmeSwgcik7XG5cblx0XHRmb3IgKHZhciBzdG9wTiA9IDAsIHN0b3BMZW5ndGggPSAkcHJvcGVydGllcy5zdG9wcy5sZW5ndGg7IHN0b3BOIDwgc3RvcExlbmd0aDsgc3RvcE4gKz0gMSlcblx0XHR7XG5cdFx0XHRncmFkaWVudC5hZGRDb2xvclN0b3AoJHByb3BlcnRpZXMuc3RvcHNbc3RvcE5dLm9mZnNldCwgJHByb3BlcnRpZXMuc3RvcHNbc3RvcE5dLmNvbG9yKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZ3JhZGllbnQ7XG5cdH0sXG5cblx0Y3JlYXRlRHJhd2luZ0dyb3VwOiBmdW5jdGlvbiAoJG9iamVjdERyYXdpbmcpXG5cdHtcblx0XHR2YXIgZHJhd2luZ0dyb3VwO1xuXHRcdGlmICgkb2JqZWN0RHJhd2luZy5wcm9wZXJ0aWVzLm9wYWNpdHkgPT09IDApIHsgcmV0dXJuOyB9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5kcmF3aW5nR3JvdXBzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjdXJyRHJhd2luZ0dyb3VwID0gdGhpcy5kcmF3aW5nR3JvdXBzW2ldO1xuXHRcdFx0aWYgKHRoaXMuY29tcGFyZVByb3BlcnRpZXMoY3VyckRyYXdpbmdHcm91cC5wcm9wZXJ0aWVzLCAkb2JqZWN0RHJhd2luZy5wcm9wZXJ0aWVzKSAmJlxuXHRcdFx0XHQoY3VyckRyYXdpbmdHcm91cC53aWxsTm90SW50ZXJzZWN0IHx8ICRvYmplY3REcmF3aW5nLndpbGxOb3RJbnRlcnNlY3QoKSkgJiZcblx0XHRcdFx0KCRvYmplY3REcmF3aW5nLmlzU3RhdGljKCkgPT09IGZhbHNlICYmIGN1cnJEcmF3aW5nR3JvdXAuaXNTdGF0aWMgPT09IGZhbHNlKSAmJlxuXHRcdFx0XHRjdXJyRHJhd2luZ0dyb3VwLmlzU2ltcGxlRHJhd2luZyA9PT0gJG9iamVjdERyYXdpbmcuaXNTaW1wbGVEcmF3aW5nKCkgJiZcblx0XHRcdFx0JG9iamVjdERyYXdpbmcucHJvcGVydGllcy5vcGFjaXR5ID09PSAxKVxuXHRcdFx0e1xuXHRcdFx0XHRkcmF3aW5nR3JvdXAgPSBjdXJyRHJhd2luZ0dyb3VwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIWRyYXdpbmdHcm91cClcblx0XHR7XG5cdFx0XHRkcmF3aW5nR3JvdXAgPVxuXHRcdFx0e1xuXHRcdFx0XHRwcm9wZXJ0aWVzOiBTVkplbGx5VXRpbHMuZXh0ZW5kKHt9LCAkb2JqZWN0RHJhd2luZy5wcm9wZXJ0aWVzKSxcblx0XHRcdFx0aXNTdGF0aWM6ICRvYmplY3REcmF3aW5nLmlzU3RhdGljKCksXG5cdFx0XHRcdHdpbGxOb3RJbnRlcnNlY3Q6ICRvYmplY3REcmF3aW5nLndpbGxOb3RJbnRlcnNlY3QoKSxcblx0XHRcdFx0aXNTaW1wbGVEcmF3aW5nOiAkb2JqZWN0RHJhd2luZy5pc1NpbXBsZURyYXdpbmcoKSxcblx0XHRcdFx0b2JqZWN0RHJhd2luZ3M6IFtdXG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5kcmF3aW5nR3JvdXBzLnB1c2goZHJhd2luZ0dyb3VwKTtcblx0XHR9XG5cdFx0ZHJhd2luZ0dyb3VwLm9iamVjdERyYXdpbmdzLnB1c2goJG9iamVjdERyYXdpbmcpO1xuXHRcdC8vIGRyYXdpbmdHcm91cC5ub2RlcyA9IGRyYXdpbmdHcm91cC5ub2Rlcy5jb25jYXQoJGdyb3VwLmRyYXdpbmcubm9kZXMpO1xuXHRcdHJldHVybiBkcmF3aW5nR3JvdXA7XG5cdH0sXG5cblx0Y29tcGFyZVByb3BlcnRpZXM6IGZ1bmN0aW9uICgkb25lLCAkdHdvKVxuXHR7XG5cdFx0dmFyIGNvbXBhcmlzb24gPSB0cnVlO1xuXHRcdGZvciAodmFyIG5hbWUgaW4gJHR3bylcblx0XHR7XG5cdFx0XHRpZiAoJG9uZVtuYW1lXSAhPT0gJHR3b1tuYW1lXSkgeyBjb21wYXJpc29uID0gZmFsc2U7IH1cblx0XHR9XG5cdFx0cmV0dXJuIGNvbXBhcmlzb247XG5cdH0sXG5cblx0ZGVidWdEcmF3OiBmdW5jdGlvbiAoJGNsZWFyKVxuXHR7XG5cdFx0dGhpcy5kZWJ1Z0NvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdGlmICgkY2xlYXIgIT09IHVuZGVmaW5lZCkgeyB0aGlzLmRlYnVnQ29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpOyB9XG5cblx0XHR0aGlzLmRlYnVnQ29udGV4dC5zZXRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFNjYWxlLCAwLCAwLCB0aGlzLnZpZXdwb3J0U2NhbGUsIC10aGlzLnZpZXdDZW50ZXJbMF0gKiB0aGlzLnNjYWxlWCAqIHRoaXMudmlld3BvcnRTY2FsZSArIHRoaXMud2lkdGggKiAwLjUsIC10aGlzLnZpZXdDZW50ZXJbMV0gKiB0aGlzLnNjYWxlWCAgKiB0aGlzLnZpZXdwb3J0U2NhbGUgKyB0aGlzLmhlaWdodCAqIDAuNSk7XG5cblx0XHR0aGlzLmRlYnVnQ29udGV4dC5zdHJva2VTdHlsZSA9ICd5ZWxsb3cnO1xuXHRcdHRoaXMuZGVidWdDb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7XG5cdFx0dGhpcy5kZWJ1Z0NvbnRleHQubGluZUpvaW4gPSAnbWl0ZXInO1xuXHRcdHRoaXMuZGVidWdDb250ZXh0LmxpbmVXaWR0aCA9IDEgLyB0aGlzLnZpZXdwb3J0U2NhbGU7XG5cdFx0dGhpcy5kZWJ1Z0NvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFx0dmFyIGN1cnJHcm91cDtcblx0XHR2YXIgaTtcblx0XHR2YXIgaztcblx0XHR2YXIgZ3JvdXBzTGVuZ3RoID0gdGhpcy53b3JsZC5ncm91cHMubGVuZ3RoO1xuXHRcdHZhciBub2Rlc0xlbmd0aDtcblx0XHRmb3IgKGsgPSAwOyBrIDwgZ3JvdXBzTGVuZ3RoOyBrICs9IDEpXG5cdFx0e1xuXHRcdFx0Y3Vyckdyb3VwID0gdGhpcy53b3JsZC5ncm91cHNba107XG5cblx0XHRcdG5vZGVzTGVuZ3RoID0gY3Vyckdyb3VwLm5vZGVzLmxlbmd0aDtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBub2Rlc0xlbmd0aDsgaSArPSAxKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgY3Vyck5vZGUgPSBjdXJyR3JvdXAubm9kZXNbaV07XG5cdFx0XHRcdHZhciB4UG9zID0gY3Vyck5vZGUuZ2V0WCgpICogdGhpcy5zY2FsZVg7XG5cdFx0XHRcdHZhciB5UG9zID0gY3Vyck5vZGUuZ2V0WSgpICogdGhpcy5zY2FsZVk7XG5cdFx0XHRcdHZhciByYWRpdXMgPSBjdXJyTm9kZS5waHlzaWNzTWFuYWdlci5yYWRpdXMgfHwgY3Vyckdyb3VwLnN0cnVjdHVyZS5yYWRpdXNYIHx8IDAuMDE7XG5cdFx0XHRcdHJhZGl1cyAqPSB0aGlzLnNjYWxlWDtcblx0XHRcdFx0cmFkaXVzID0gTWF0aC5tYXgocmFkaXVzLCAxKTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coY3Vyckdyb3VwLnN0cnVjdHVyZS5pbm5lclJhZGl1cywgY3Vyckdyb3VwLmNvbmYubm9kZVJhZGl1cywgY3Vyckdyb3VwLnN0cnVjdHVyZS5yYWRpdXNYKTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cocmFkaXVzKTtcblx0XHRcdFx0Ly8gZGVidWdnZXI7XG5cdFx0XHRcdHRoaXMuZGVidWdDb250ZXh0Lm1vdmVUbyh4UG9zICsgcmFkaXVzLCB5UG9zKTtcblx0XHRcdFx0dGhpcy5kZWJ1Z0NvbnRleHQuYXJjKHhQb3MsIHlQb3MsIHJhZGl1cywgMCwgdHdvUElTKTtcblx0XHRcdFx0aWYgKGN1cnJOb2RlLnBoeXNpY3NNYW5hZ2VyLmJvZHkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLmRlYnVnQ29udGV4dC5tb3ZlVG8oeFBvcywgeVBvcyk7XG5cdFx0XHRcdFx0dmFyIGFuZ2xlID0gdHdvUElTIC0gY3Vyck5vZGUucGh5c2ljc01hbmFnZXIuYm9keS5hbmdsZTtcblx0XHRcdFx0XHR0aGlzLmRlYnVnQ29udGV4dC5saW5lVG8oeFBvcyArIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cywgeVBvcyArIE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5kZWJ1Z0NvbnRleHQuc3Ryb2tlKCk7XG5cblx0XHR0aGlzLmRlYnVnQ29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwxLDEsMSknO1xuXHRcdHRoaXMuZGVidWdDb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRcdGZvciAoayA9IDA7IGsgPCBncm91cHNMZW5ndGg7IGsgKz0gMSlcblx0XHR7XG5cdFx0XHRjdXJyR3JvdXAgPSB0aGlzLndvcmxkLmdyb3Vwc1trXTtcblx0XHRcdHZhciBqb2ludHNMZW5ndGggPSBjdXJyR3JvdXAuam9pbnRzLmxlbmd0aDtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGpvaW50c0xlbmd0aDsgaSArPSAxKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgY3VyckpvaW50ID0gY3Vyckdyb3VwLmpvaW50c1tpXTtcblx0XHRcdFx0dGhpcy5kZWJ1Z0NvbnRleHQubW92ZVRvKGN1cnJKb2ludC5ub2RlQS5nZXRYKCkgKiB0aGlzLnNjYWxlWCwgY3VyckpvaW50Lm5vZGVBLmdldFkoKSAqIHRoaXMuc2NhbGVZKTtcblx0XHRcdFx0dGhpcy5kZWJ1Z0NvbnRleHQubGluZVRvKGN1cnJKb2ludC5ub2RlQi5nZXRYKCkgKiB0aGlzLnNjYWxlWCwgY3VyckpvaW50Lm5vZGVCLmdldFkoKSAqIHRoaXMuc2NhbGVZKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5kZWJ1Z0NvbnRleHQuc3Ryb2tlKCk7XG5cblx0XHR0aGlzLmRlYnVnQ29udGV4dC5zdHJva2VTdHlsZSA9ICdibHVlJztcblx0XHR0aGlzLmRlYnVnQ29udGV4dC5iZWdpblBhdGgoKTtcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy53b3JsZC5ncm91cENvbnN0cmFpbnRzLmxlbmd0aDtcblx0XHRmb3IgKGsgPSAwOyBrIDwgbGVuZ3RoOyBrICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJMb2NrID0gdGhpcy53b3JsZC5ncm91cENvbnN0cmFpbnRzW2tdO1xuXHRcdFx0dGhpcy5kZWJ1Z0NvbnRleHQubW92ZVRvKGN1cnJMb2NrLmFuY2hvckEuZ2V0WCgpICogdGhpcy5zY2FsZVgsIGN1cnJMb2NrLmFuY2hvckEuZ2V0WSgpICogdGhpcy5zY2FsZVkpO1xuXHRcdFx0dGhpcy5kZWJ1Z0NvbnRleHQubGluZVRvKGN1cnJMb2NrLmFuY2hvckIuZ2V0WCgpICogdGhpcy5zY2FsZVgsIGN1cnJMb2NrLmFuY2hvckIuZ2V0WSgpICogdGhpcy5zY2FsZVkpO1xuXHRcdH1cblx0XHR0aGlzLmRlYnVnQ29udGV4dC5zdHJva2UoKTtcblxuXHRcdHRoaXMuZGVidWdDb250ZXh0LmZpbGxTdHlsZSA9ICdibGFjayc7XG5cdFx0Zm9yIChrID0gMDsgayA8IGdyb3Vwc0xlbmd0aDsgayArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBncm91cCA9IHRoaXMud29ybGQuZ3JvdXBzW2tdO1xuXHRcdFx0bm9kZXNMZW5ndGggPSBncm91cC5ub2Rlcy5sZW5ndGg7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkgKz0gMSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIG5vZGUgPSBncm91cC5ub2Rlc1tpXTtcblx0XHRcdFx0aWYgKG5vZGUuZGVidWdUZXh0KSB7IHRoaXMuZGVidWdDb250ZXh0LmZpbGxUZXh0KG5vZGUuZGVidWdUZXh0LCBub2RlLmdldFgoKSAqIHRoaXMuc2NhbGVYLCBub2RlLmdldFkoKSAqIHRoaXMuc2NhbGVZKTsgfVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkplbGx5UmVuZGVyZXI7XG5cbiIsInZhciBTVkplbGx5V29ybGQgPSByZXF1aXJlKCcuL2NvcmUvU1ZKZWxseVdvcmxkJyk7XG52YXIgU1ZKZWxseVJlbmRlcmVyID0gcmVxdWlyZSgnLi9yZW5kZXJlci9zdmplbGx5L1NWSmVsbHlSZW5kZXJlcicpO1xudmFyIFNWR1BhcnNlciA9IHJlcXVpcmUoJy4vY29yZS9TVkdQYXJzZXInKTtcbnZhciBQMlBoeXNpY3NNYW5hZ2VyID0gcmVxdWlyZSgnLi9waHlzaWNzL3AycGh5c2ljcy9QMlBoeXNpY3NNYW5hZ2VyJyk7XG52YXIgUDJNb3VzZUNvbnRyb2xzID0gcmVxdWlyZSgnLi9waHlzaWNzL3AycGh5c2ljcy9QMk1vdXNlQ29udHJvbHMnKTtcbnZhciBTVkplbGx5VXRpbHMgPSByZXF1aXJlKCcuL2NvcmUvU1ZKZWxseVV0aWxzJyk7XG52YXIgY29uZk9iamVjdCA9IHJlcXVpcmUoJy4vY29yZS9Db25mT2JqZWN0Jyk7XG5cbnZhciByZXF1ZXN0QW5pbUZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0XHRcdFx0d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0XHRcdFx0d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZTtcblxudmFyIGNhbmNlbEFuaW1GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0XHRcdFx0d2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHRcdFx0XHR3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cbi8vVE9ETyBwcm9taXNlIHBvbHlmaWxsXG52YXIgU1ZKZWxseU1ha2VyID1cbntcblx0Y3JlYXRlOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0dmFyIHN2amVsbHlNYWtlciA9IE9iamVjdC5jcmVhdGUoU1ZKZWxseU1ha2VyKTtcblx0XHRzdmplbGx5TWFrZXIuaW5pdGlhdGVkID0gbmV3IHdpbmRvdy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHN2amVsbHlNYWtlci5pbml0aWF0ZWRSZXNvbHZlID0gcmVzb2x2ZTsgfSk7XG5cdFx0cmV0dXJuIHN2amVsbHlNYWtlcjtcblx0fSxcblxuXHRjcmVhdGVGcm9tVVJMOiBmdW5jdGlvbiAoJGNvbnRhaW5lciwgJFVSTCwgJHdpZHRoLCAkaGVpZ2h0LCAkc2NhbGVNb2RlKVxuXHR7XG5cdFx0dmFyIHN2amVsbHlNYWtlciA9IFNWSmVsbHlNYWtlci5jcmVhdGUoKTtcblx0XHRzdmplbGx5TWFrZXIubG9hZEZpbGUoJFVSTCwgZnVuY3Rpb24gKCRTVkcpXG5cdFx0e1xuXHRcdFx0c3ZqZWxseU1ha2VyLmluaXQoJGNvbnRhaW5lciwgJFNWRywgJHdpZHRoLCAkaGVpZ2h0LCAkc2NhbGVNb2RlKTtcblx0XHR9LCB0cnVlKTtcblx0XHRyZXR1cm4gc3ZqZWxseU1ha2VyO1xuXHR9LFxuXHRjcmVhdGVGcm9tQ29uZmlnOiBmdW5jdGlvbiAoJGNvbnRhaW5lciwgJGNvbmZpZ1VSTCwgJHdpZHRoLCAkaGVpZ2h0LCAkc2NhbGVNb2RlKVxuXHR7XG5cdFx0dmFyIHN2amVsbHlNYWtlciA9IFNWSmVsbHlNYWtlci5jcmVhdGUoKTtcblx0XHR2YXIgbG9hZENvbmZpZ0NvbXBsZXRlID0gZnVuY3Rpb24gKCRjb25maWdEYXRhKVxuXHRcdHtcblx0XHRcdHZhciBKU09OQ29uZmlnID0gSlNPTi5wYXJzZSgkY29uZmlnRGF0YSk7XG5cdFx0XHRzdmplbGx5TWFrZXIuY29uZiA9IFNWSmVsbHlVdGlscy5leHRlbmQoY29uZk9iamVjdCwgSlNPTkNvbmZpZyk7XG5cblx0XHRcdFNWSmVsbHlNYWtlci5sb2FkRmlsZShzdmplbGx5TWFrZXIuY29uZi5zb3VyY2UsIGZ1bmN0aW9uICgkU1ZHKVxuXHRcdFx0e1xuXHRcdFx0XHRzdmplbGx5TWFrZXIuaW5pdCgkY29udGFpbmVyLCAkU1ZHLCAkd2lkdGgsICRoZWlnaHQsICRzY2FsZU1vZGUpO1xuXHRcdFx0fSwgdHJ1ZSk7XG5cdFx0fTtcblx0XHRTVkplbGx5TWFrZXIubG9hZEZpbGUoJGNvbmZpZ1VSTCwgbG9hZENvbmZpZ0NvbXBsZXRlKTtcblxuXHRcdHJldHVybiBzdmplbGx5TWFrZXI7XG5cdH0sXG5cdGNyZWF0ZUZyb21TdHJpbmc6IGZ1bmN0aW9uICgkY29udGFpbmVyLCAkc3RyaW5nLCAkd2lkdGgsICRoZWlnaHQsICRzY2FsZU1vZGUpXG5cdHtcblx0XHR2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuXHRcdHZhciBkb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKCRzdHJpbmcsICdpbWFnZS9zdmcreG1sJyk7XG5cdFx0dmFyIHN2amVsbHlNYWtlciA9IFNWSmVsbHlNYWtlci5jcmVhdGUoKTtcblx0XHRzdmplbGx5TWFrZXIuaW5pdCgkY29udGFpbmVyLCBkb2MsICR3aWR0aCwgJGhlaWdodCwgJHNjYWxlTW9kZSk7XG5cdFx0cmV0dXJuIHN2amVsbHlNYWtlcjtcblx0fSxcblx0Y3JlYXRlRnJvbVBhZ2VTVkc6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXIgc3ZqZWxsaWVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc3ZqZWxseV0nKTtcblxuXHRcdHZhciBjcmVhdGVWaWV3ZXIgPSBmdW5jdGlvbiAoJGVsZW1lbnQpXG5cdFx0e1xuXHRcdFx0dmFyIHN2amVsbHlNYWtlciA9IFNWSmVsbHlNYWtlci5jcmVhdGUoKTtcblx0XHRcdHZhciBjdXJyU1ZHID0gJGVsZW1lbnQ7XG5cdFx0XHR2YXIgYXBwZW5kQ2FudmFzID0gZnVuY3Rpb24gKCRjb25maWcpXG5cdFx0XHR7XG5cdFx0XHRcdHN2amVsbHlNYWtlci5jb25mID0gJGNvbmZpZztcblx0XHRcdFx0dmFyIGNvbnRhaW5lcjtcblx0XHRcdFx0aWYgKHN2amVsbHlNYWtlci5jb25mLm11bHRpQ2FudmFzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRcdFx0Y29udGFpbmVyLnN0eWxlLndpZHRoID0gY3VyclNWRy5jbGllbnRXaWR0aCArICdweCc7XG5cdFx0XHRcdFx0Y29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGN1cnJTVkcuY2xpZW50SGVpZ2h0ICsgJ3B4Jztcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRcdFx0XHRjb250YWluZXIud2lkdGggPSBjdXJyU1ZHLmNsaWVudFdpZHRoO1xuXHRcdFx0XHRcdGNvbnRhaW5lci5oZWlnaHQgPSBjdXJyU1ZHLmNsaWVudEhlaWdodDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN1cnJTVkcucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBjdXJyU1ZHKTtcblx0XHRcdFx0Y3VyclNWRy5yZW1vdmUoKTtcblx0XHRcdFx0c3ZqZWxseU1ha2VyLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblx0XHRcdFx0dmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdFx0d3JhcHBlci5hcHBlbmRDaGlsZChjdXJyU1ZHKTtcblx0XHRcdFx0c3ZqZWxseU1ha2VyLmluaXQoY29udGFpbmVyLCB3cmFwcGVyLCBjb250YWluZXIuY2xpZW50V2lkdGgsIGNvbnRhaW5lci5jbGllbnRIZWlnaHQpO1xuXHRcdFx0fTtcblx0XHRcdHZhciBjb25maWdVUkwgPSBjdXJyU1ZHLmdldEF0dHJpYnV0ZSgnZGF0YS1zdmplbGx5Jyk7XG5cdFx0XHRpZiAoY29uZmlnVVJMKVxuXHRcdFx0e1xuXHRcdFx0XHRTVkplbGx5TWFrZXIubG9hZEZpbGUoY29uZmlnVVJMLCBmdW5jdGlvbiAoJGNvbmZpZ0RhdGEpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgSlNPTkNvbmZpZyA9IEpTT04ucGFyc2UoJGNvbmZpZ0RhdGEpO1xuXHRcdFx0XHRcdGFwcGVuZENhbnZhcyhTVkplbGx5VXRpbHMuZXh0ZW5kKGNvbmZPYmplY3QsIEpTT05Db25maWcpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGFwcGVuZENhbnZhcygpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3ZqZWxsaWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjdXJyU1ZHID0gc3ZqZWxsaWVzW2ldO1xuXHRcdFx0Y3JlYXRlVmlld2VyKGN1cnJTVkcpO1xuXHRcdH1cblx0fSxcblxuXHRpbml0OiBmdW5jdGlvbiAoJGNvbnRhaW5lciwgJFNWRywgJHdpZHRoLCAkaGVpZ2h0LCAkc2NhbGVNb2RlKVxuXHR7XG5cdFx0dmFyIGNvbmYgPSB0aGlzLmNvbmYgfHwgY29uZk9iamVjdDtcblx0XHR0aGlzLmNvbnRhaW5lciA9ICRjb250YWluZXI7XG5cblx0XHR0aGlzLnBoeXNpY3NNYW5hZ2VyID0gdGhpcy5waHlzaWNzTWFuYWdlciB8fCBuZXcgUDJQaHlzaWNzTWFuYWdlcihjb25mKTtcblx0XHR2YXIgc3ZqZWxseVdvcmxkID0gdGhpcy5zdmplbGx5V29ybGQgPSBuZXcgU1ZKZWxseVdvcmxkKHRoaXMucGh5c2ljc01hbmFnZXIsIGNvbmYpO1xuXG5cdFx0dmFyIGNhbnZhc0RlZmluaXRpb24gPSBjb25mLmRlZmluaXRpb24gfHwgMTtcblx0XHR2YXIgc3ZnRGVmID0gJFNWRy5xdWVyeVNlbGVjdG9yKCdzdmcnKTtcblx0XHR2YXIgcGFyc2VyID0gbmV3IFNWR1BhcnNlcigpO1xuXHRcdHBhcnNlci5wYXJzZShzdmplbGx5V29ybGQsIHN2Z0RlZik7XG5cblx0XHR2YXIgd2lkdGggPSAkd2lkdGggfHwgdGhpcy5jb250YWluZXIuY2xpZW50V2lkdGg7XG5cdFx0dmFyIGhlaWdodCA9ICRoZWlnaHQgfHwgdGhpcy5jb250YWluZXIuY2xpZW50SGVpZ2h0O1xuXG5cdFx0dmFyIHJhdGlvQ2FudmFzID0gaGVpZ2h0IC8gd2lkdGg7XG5cdFx0dmFyIHJhdGlvU1ZHID0gcGFyc2VyLnZpZXdCb3hIZWlnaHQgLyBwYXJzZXIudmlld0JveFdpZHRoO1xuXHRcdHZhciBjYW52YXNXaWR0aDtcblx0XHR2YXIgY2FudmFzSGVpZ2h0O1xuXG5cdFx0aWYgKChyYXRpb1NWRyA8IHJhdGlvQ2FudmFzICYmICRzY2FsZU1vZGUgIT09ICdtYXgnKSB8fCAocmF0aW9TVkcgPiByYXRpb0NhbnZhcyAmJiAkc2NhbGVNb2RlID09PSAnbWF4JykpXG5cdFx0e1xuXHRcdFx0Y2FudmFzV2lkdGggPSB3aWR0aCAqIGNhbnZhc0RlZmluaXRpb247XG5cdFx0XHRjYW52YXNIZWlnaHQgPSBjYW52YXNXaWR0aCAqIHJhdGlvU1ZHO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0Y2FudmFzSGVpZ2h0ID0gaGVpZ2h0ICogY2FudmFzRGVmaW5pdGlvbjtcblx0XHRcdGNhbnZhc1dpZHRoID0gY2FudmFzSGVpZ2h0IC8gcmF0aW9TVkc7XG5cdFx0fVxuXG5cdFx0Ly8gdGhpcy5jb250YWluZXIud2lkdGggPSBjYW52YXNXaWR0aDtcblx0XHQvLyB0aGlzLmNvbnRhaW5lci5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG5cblx0XHRjb25zb2xlLmxvZyh0aGlzLlJlbmRlcmVyID09PSB0cnVlKTtcblx0XHR0aGlzLnJlbmRlcmVyID0gdGhpcy5SZW5kZXJlciA/IHRoaXMuUmVuZGVyZXIuY3JlYXRlKHN2amVsbHlXb3JsZCwgdGhpcy5jb250YWluZXIpIDogU1ZKZWxseVJlbmRlcmVyLmNyZWF0ZShzdmplbGx5V29ybGQsIHRoaXMuY29udGFpbmVyKTtcblx0XHR0aGlzLnJlbmRlcmVyLnNldFNpemUoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG5cblx0XHRpZiAoY2FudmFzRGVmaW5pdGlvbiAhPT0gMSlcblx0XHR7XG5cdFx0XHR0aGlzLmNvbnRhaW5lci5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAwJztcblx0XHRcdHRoaXMuY29udGFpbmVyLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgnICsgMSAvIGNhbnZhc0RlZmluaXRpb24gKyAnKSc7XG5cdFx0fVxuXG5cdFx0dmFyIHJlcXVlc3RJRCA9ICcnO1xuXHRcdHZhciBsYXN0UmVuZGVyID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdHZhciBkaWZmUmVuZGVyO1xuXHRcdHZhciByZW5kZXJUYXJnZXRGUFMgPSAwO1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoJG5vdylcblx0XHR7XG5cdFx0XHRpZiAoc2VsZi51cGRhdGVDYWxsYmFjaykgeyBzZWxmLnVwZGF0ZUNhbGxiYWNrKCRub3cpOyB9XG5cblx0XHRcdGRpZmZSZW5kZXIgPSAkbm93IC0gbGFzdFJlbmRlcjtcblxuXHRcdFx0c2VsZi5zdmplbGx5V29ybGQucGh5c2ljc01hbmFnZXIuc3RlcCgkbm93KTtcblx0XHRcdGlmIChkaWZmUmVuZGVyID49IHJlbmRlclRhcmdldEZQUylcblx0XHRcdHtcblx0XHRcdFx0c2VsZi5yZW5kZXJlci5kcmF3KCk7XG5cdFx0XHRcdGxhc3RSZW5kZXIgPSAkbm93O1xuXHRcdFx0fVxuXHRcdFx0cmVxdWVzdElEID0gcmVxdWVzdEFuaW1GcmFtZSh1cGRhdGUpO1xuXHRcdH07XG5cblx0XHR2YXIgYWRkQW5pbVJlcXVlc3QgPSBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdGNhbmNlbEFuaW1GcmFtZShyZXF1ZXN0SUQpO1xuXHRcdFx0cmVxdWVzdElEID0gcmVxdWVzdEFuaW1GcmFtZSh1cGRhdGUpO1xuXHRcdH07XG5cdFx0dmFyIGNhbmNlbEFuaW1SZXF1ZXN0ID0gZnVuY3Rpb24gKClcblx0XHR7XG5cdFx0XHRjYW5jZWxBbmltRnJhbWUocmVxdWVzdElEKTtcblx0XHR9O1xuXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgYWRkQW5pbVJlcXVlc3QpO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgY2FuY2VsQW5pbVJlcXVlc3QpO1xuXHRcdGFkZEFuaW1SZXF1ZXN0KCk7XG5cblx0XHR0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0Y2FuY2VsQW5pbVJlcXVlc3QoKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIGFkZEFuaW1SZXF1ZXN0KTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgY2FuY2VsQW5pbVJlcXVlc3QpO1xuXHRcdH07XG5cblx0XHR0aGlzLmluaXRpYXRlZFJlc29sdmUoKTtcblx0fSxcblxuXHRsb2FkRmlsZTogZnVuY3Rpb24gKCRVUkwsICRzdWNjZXNzQ2FsbGJhY2ssICRYTUwpXG5cdHtcblx0XHR2YXIgZXJyb3IgPSBmdW5jdGlvbiAoKVxuXHRcdHtcblx0XHRcdGNvbnNvbGUubG9nKCdlcnJvcicsICRVUkwpO1xuXHRcdH07XG5cblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uICgpXG5cdFx0e1xuXHRcdFx0JHN1Y2Nlc3NDYWxsYmFjaygkWE1MID8gdGhpcy5yZXNwb25zZVhNTCA6IHRoaXMucmVzcG9uc2VUZXh0KTtcblx0XHR9O1xuXG5cdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBoYW5kbGVyKTtcblx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuXHRcdHJlcXVlc3Qub3BlbignZ2V0JywgJFVSTCwgdHJ1ZSk7XG5cdFx0cmVxdWVzdC5zZW5kKCk7XG5cdH0sXG5cblx0YWRkQmFzaWNNb3VzZUNvbnRyb2xzOiBmdW5jdGlvbiAoJHN0aWZmbmVzcywgJHJlbGF4YXRpb24pXG5cdHtcblx0XHR2YXIgd29ybGQgPSB0aGlzLnN2amVsbHlXb3JsZDtcblx0XHR2YXIgcDJXb3JsZCA9IHdvcmxkLnBoeXNpY3NNYW5hZ2VyLnAyV29ybGQ7XG5cdFx0aWYgKHRoaXMubW91c2VDb250cm9scykgeyB0aGlzLm1vdXNlQ29udHJvbHMucmVtb3ZlQmFzaWNNb3VzZUNvbnRyb2xzKCk7IH1cblx0XHR0aGlzLm1vdXNlQ29udHJvbHMgPSBuZXcgUDJNb3VzZUNvbnRyb2xzKHdvcmxkLCBwMldvcmxkLCB0aGlzLnJlbmRlcmVyKTtcblx0XHR0aGlzLm1vdXNlQ29udHJvbHMuYWRkQmFzaWNNb3VzZUNvbnRyb2xzKCRzdGlmZm5lc3MsICRyZWxheGF0aW9uKTtcblx0fSxcblxuXHRyZW1vdmVCYXNpY01vdXNlQ29udHJvbHM6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR0aGlzLm1vdXNlQ29udHJvbHMucmVtb3ZlQmFzaWNNb3VzZUNvbnRyb2xzKCk7XG5cdH1cbn07XG5cbmlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zdmplbGx5LWF1dG9dJykpXG57XG5cdHZhciB3aW5kb3dMb2FkSGFuZGxlciA9IGZ1bmN0aW9uICgpXG5cdHtcblx0XHRTVkplbGx5TWFrZXIuY3JlYXRlRnJvbVBhZ2VTVkcoKTtcblx0fTtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB3aW5kb3dMb2FkSGFuZGxlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZKZWxseU1ha2VyO1xuIl19
