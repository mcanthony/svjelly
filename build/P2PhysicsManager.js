(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.SVJellyP2PhysicsManager = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/Lau/www/svjelly/libs/p2.js":[function(require,module,exports){
(function (global){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 p2.js authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&false)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.p2=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
var Scalar = _dereq_('./Scalar');

module.exports = Line;

/**
 * Container for line-related functions
 * @class Line
 */
function Line(){};

/**
 * Compute the intersection between two lines.
 * @static
 * @method lineInt
 * @param  {Array}  l1          Line vector 1
 * @param  {Array}  l2          Line vector 2
 * @param  {Number} precision   Precision to use when checking if the lines are parallel
 * @return {Array}              The intersection point.
 */
Line.lineInt = function(l1,l2,precision){
    precision = precision || 0;
    var i = [0,0]; // point
    var a1, b1, c1, a2, b2, c2, det; // scalars
    a1 = l1[1][1] - l1[0][1];
    b1 = l1[0][0] - l1[1][0];
    c1 = a1 * l1[0][0] + b1 * l1[0][1];
    a2 = l2[1][1] - l2[0][1];
    b2 = l2[0][0] - l2[1][0];
    c2 = a2 * l2[0][0] + b2 * l2[0][1];
    det = a1 * b2 - a2*b1;
    if (!Scalar.eq(det, 0, precision)) { // lines are not parallel
        i[0] = (b2 * c1 - b1 * c2) / det;
        i[1] = (a1 * c2 - a2 * c1) / det;
    }
    return i;
};

/**
 * Checks if two line segments intersects.
 * @method segmentsIntersect
 * @param {Array} p1 The start vertex of the first line segment.
 * @param {Array} p2 The end vertex of the first line segment.
 * @param {Array} q1 The start vertex of the second line segment.
 * @param {Array} q2 The end vertex of the second line segment.
 * @return {Boolean} True if the two line segments intersect
 */
Line.segmentsIntersect = function(p1, p2, q1, q2){
   var dx = p2[0] - p1[0];
   var dy = p2[1] - p1[1];
   var da = q2[0] - q1[0];
   var db = q2[1] - q1[1];

   // segments are parallel
   if(da*dy - db*dx == 0)
      return false;

   var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx)
   var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy)

   return (s>=0 && s<=1 && t>=0 && t<=1);
};


},{"./Scalar":4}],2:[function(_dereq_,module,exports){
module.exports = Point;

/**
 * Point related functions
 * @class Point
 */
function Point(){};

/**
 * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.
 * @static
 * @method area
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return {Number}
 */
Point.area = function(a,b,c){
    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));
};

Point.left = function(a,b,c){
    return Point.area(a,b,c) > 0;
};

Point.leftOn = function(a,b,c) {
    return Point.area(a, b, c) >= 0;
};

Point.right = function(a,b,c) {
    return Point.area(a, b, c) < 0;
};

Point.rightOn = function(a,b,c) {
    return Point.area(a, b, c) <= 0;
};

var tmpPoint1 = [],
    tmpPoint2 = [];

/**
 * Check if three points are collinear
 * @method collinear
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.
 * @return {Boolean}
 */
Point.collinear = function(a,b,c,thresholdAngle) {
    if(!thresholdAngle)
        return Point.area(a, b, c) == 0;
    else {
        var ab = tmpPoint1,
            bc = tmpPoint2;

        ab[0] = b[0]-a[0];
        ab[1] = b[1]-a[1];
        bc[0] = c[0]-b[0];
        bc[1] = c[1]-b[1];

        var dot = ab[0]*bc[0] + ab[1]*bc[1],
            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),
            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),
            angle = Math.acos(dot/(magA*magB));
        return angle < thresholdAngle;
    }
};

Point.sqdist = function(a,b){
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    return dx * dx + dy * dy;
};

},{}],3:[function(_dereq_,module,exports){
var Line = _dereq_("./Line")
,   Point = _dereq_("./Point")
,   Scalar = _dereq_("./Scalar")

module.exports = Polygon;

/**
 * Polygon class.
 * @class Polygon
 * @constructor
 */
function Polygon(){

    /**
     * Vertices that this polygon consists of. An array of array of numbers, example: [[0,0],[1,0],..]
     * @property vertices
     * @type {Array}
     */
    this.vertices = [];
}

/**
 * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.
 * @method at
 * @param  {Number} i
 * @return {Array}
 */
Polygon.prototype.at = function(i){
    var v = this.vertices,
        s = v.length;
    return v[i < 0 ? i % s + s : i % s];
};

/**
 * Get first vertex
 * @method first
 * @return {Array}
 */
Polygon.prototype.first = function(){
    return this.vertices[0];
};

/**
 * Get last vertex
 * @method last
 * @return {Array}
 */
Polygon.prototype.last = function(){
    return this.vertices[this.vertices.length-1];
};

/**
 * Clear the polygon data
 * @method clear
 * @return {Array}
 */
Polygon.prototype.clear = function(){
    this.vertices.length = 0;
};

/**
 * Append points "from" to "to"-1 from an other polygon "poly" onto this one.
 * @method append
 * @param {Polygon} poly The polygon to get points from.
 * @param {Number}  from The vertex index in "poly".
 * @param {Number}  to The end vertex index in "poly". Note that this vertex is NOT included when appending.
 * @return {Array}
 */
Polygon.prototype.append = function(poly,from,to){
    if(typeof(from) == "undefined") throw new Error("From is not given!");
    if(typeof(to) == "undefined")   throw new Error("To is not given!");

    if(to-1 < from)                 throw new Error("lol1");
    if(to > poly.vertices.length)   throw new Error("lol2");
    if(from < 0)                    throw new Error("lol3");

    for(var i=from; i<to; i++){
        this.vertices.push(poly.vertices[i]);
    }
};

/**
 * Make sure that the polygon vertices are ordered counter-clockwise.
 * @method makeCCW
 */
Polygon.prototype.makeCCW = function(){
    var br = 0,
        v = this.vertices;

    // find bottom right point
    for (var i = 1; i < this.vertices.length; ++i) {
        if (v[i][1] < v[br][1] || (v[i][1] == v[br][1] && v[i][0] > v[br][0])) {
            br = i;
        }
    }

    // reverse poly if clockwise
    if (!Point.left(this.at(br - 1), this.at(br), this.at(br + 1))) {
        this.reverse();
    }
};

/**
 * Reverse the vertices in the polygon
 * @method reverse
 */
Polygon.prototype.reverse = function(){
    var tmp = [];
    for(var i=0, N=this.vertices.length; i!==N; i++){
        tmp.push(this.vertices.pop());
    }
    this.vertices = tmp;
};

/**
 * Check if a point in the polygon is a reflex point
 * @method isReflex
 * @param  {Number}  i
 * @return {Boolean}
 */
Polygon.prototype.isReflex = function(i){
    return Point.right(this.at(i - 1), this.at(i), this.at(i + 1));
};

var tmpLine1=[],
    tmpLine2=[];

/**
 * Check if two vertices in the polygon can see each other
 * @method canSee
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */
Polygon.prototype.canSee = function(a,b) {
    var p, dist, l1=tmpLine1, l2=tmpLine2;

    if (Point.leftOn(this.at(a + 1), this.at(a), this.at(b)) && Point.rightOn(this.at(a - 1), this.at(a), this.at(b))) {
        return false;
    }
    dist = Point.sqdist(this.at(a), this.at(b));
    for (var i = 0; i !== this.vertices.length; ++i) { // for each edge
        if ((i + 1) % this.vertices.length === a || i === a) // ignore incident edges
            continue;
        if (Point.leftOn(this.at(a), this.at(b), this.at(i + 1)) && Point.rightOn(this.at(a), this.at(b), this.at(i))) { // if diag intersects an edge
            l1[0] = this.at(a);
            l1[1] = this.at(b);
            l2[0] = this.at(i);
            l2[1] = this.at(i + 1);
            p = Line.lineInt(l1,l2);
            if (Point.sqdist(this.at(a), p) < dist) { // if edge is blocking visibility to b
                return false;
            }
        }
    }

    return true;
};

/**
 * Copy the polygon from vertex i to vertex j.
 * @method copy
 * @param  {Number} i
 * @param  {Number} j
 * @param  {Polygon} [targetPoly]   Optional target polygon to save in.
 * @return {Polygon}                The resulting copy.
 */
Polygon.prototype.copy = function(i,j,targetPoly){
    var p = targetPoly || new Polygon();
    p.clear();
    if (i < j) {
        // Insert all vertices from i to j
        for(var k=i; k<=j; k++)
            p.vertices.push(this.vertices[k]);

    } else {

        // Insert vertices 0 to j
        for(var k=0; k<=j; k++)
            p.vertices.push(this.vertices[k]);

        // Insert vertices i to end
        for(var k=i; k<this.vertices.length; k++)
            p.vertices.push(this.vertices[k]);
    }

    return p;
};

/**
 * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.
 * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.
 * @method getCutEdges
 * @return {Array}
 */
Polygon.prototype.getCutEdges = function() {
    var min=[], tmp1=[], tmp2=[], tmpPoly = new Polygon();
    var nDiags = Number.MAX_VALUE;

    for (var i = 0; i < this.vertices.length; ++i) {
        if (this.isReflex(i)) {
            for (var j = 0; j < this.vertices.length; ++j) {
                if (this.canSee(i, j)) {
                    tmp1 = this.copy(i, j, tmpPoly).getCutEdges();
                    tmp2 = this.copy(j, i, tmpPoly).getCutEdges();

                    for(var k=0; k<tmp2.length; k++)
                        tmp1.push(tmp2[k]);

                    if (tmp1.length < nDiags) {
                        min = tmp1;
                        nDiags = tmp1.length;
                        min.push([this.at(i), this.at(j)]);
                    }
                }
            }
        }
    }

    return min;
};

/**
 * Decomposes the polygon into one or more convex sub-Polygons.
 * @method decomp
 * @return {Array} An array or Polygon objects.
 */
Polygon.prototype.decomp = function(){
    var edges = this.getCutEdges();
    if(edges.length > 0)
        return this.slice(edges);
    else
        return [this];
};

/**
 * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.
 * @method slice
 * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()
 * @return {Array}
 */
Polygon.prototype.slice = function(cutEdges){
    if(cutEdges.length == 0) return [this];
    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length==2 && cutEdges[0][0] instanceof Array){

        var polys = [this];

        for(var i=0; i<cutEdges.length; i++){
            var cutEdge = cutEdges[i];
            // Cut all polys
            for(var j=0; j<polys.length; j++){
                var poly = polys[j];
                var result = poly.slice(cutEdge);
                if(result){
                    // Found poly! Cut and quit
                    polys.splice(j,1);
                    polys.push(result[0],result[1]);
                    break;
                }
            }
        }

        return polys;
    } else {

        // Was given one edge
        var cutEdge = cutEdges;
        var i = this.vertices.indexOf(cutEdge[0]);
        var j = this.vertices.indexOf(cutEdge[1]);

        if(i != -1 && j != -1){
            return [this.copy(i,j),
                    this.copy(j,i)];
        } else {
            return false;
        }
    }
};

/**
 * Checks that the line segments of this polygon do not intersect each other.
 * @method isSimple
 * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]
 * @return {Boolean}
 * @todo Should it check all segments with all others?
 */
Polygon.prototype.isSimple = function(){
    var path = this.vertices;
    // Check
    for(var i=0; i<path.length-1; i++){
        for(var j=0; j<i-1; j++){
            if(Line.segmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){
                return false;
            }
        }
    }

    // Check the segment between the last and the first point to all others
    for(var i=1; i<path.length-2; i++){
        if(Line.segmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){
            return false;
        }
    }

    return true;
};

function getIntersectionPoint(p1, p2, q1, q2, delta){
    delta = delta || 0;
   var a1 = p2[1] - p1[1];
   var b1 = p1[0] - p2[0];
   var c1 = (a1 * p1[0]) + (b1 * p1[1]);
   var a2 = q2[1] - q1[1];
   var b2 = q1[0] - q2[0];
   var c2 = (a2 * q1[0]) + (b2 * q1[1]);
   var det = (a1 * b2) - (a2 * b1);

   if(!Scalar.eq(det,0,delta))
      return [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det]
   else
      return [0,0]
}

/**
 * Quickly decompose the Polygon into convex sub-polygons.
 * @method quickDecomp
 * @param  {Array} result
 * @param  {Array} [reflexVertices]
 * @param  {Array} [steinerPoints]
 * @param  {Number} [delta]
 * @param  {Number} [maxlevel]
 * @param  {Number} [level]
 * @return {Array}
 */
Polygon.prototype.quickDecomp = function(result,reflexVertices,steinerPoints,delta,maxlevel,level){
    maxlevel = maxlevel || 100;
    level = level || 0;
    delta = delta || 25;
    result = typeof(result)!="undefined" ? result : [];
    reflexVertices = reflexVertices || [];
    steinerPoints = steinerPoints || [];

    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points
    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars
    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers
    var lowerPoly=new Polygon(), upperPoly=new Polygon(); // polygons
    var poly = this,
        v = this.vertices;

    if(v.length < 3) return result;

    level++;
    if(level > maxlevel){
        console.warn("quickDecomp: max level ("+maxlevel+") reached.");
        return result;
    }

    for (var i = 0; i < this.vertices.length; ++i) {
        if (poly.isReflex(i)) {
            reflexVertices.push(poly.vertices[i]);
            upperDist = lowerDist = Number.MAX_VALUE;


            for (var j = 0; j < this.vertices.length; ++j) {
                if (Point.left(poly.at(i - 1), poly.at(i), poly.at(j))
                        && Point.rightOn(poly.at(i - 1), poly.at(i), poly.at(j - 1))) { // if line intersects with an edge
                    p = getIntersectionPoint(poly.at(i - 1), poly.at(i), poly.at(j), poly.at(j - 1)); // find the point of intersection
                    if (Point.right(poly.at(i + 1), poly.at(i), p)) { // make sure it's inside the poly
                        d = Point.sqdist(poly.vertices[i], p);
                        if (d < lowerDist) { // keep only the closest intersection
                            lowerDist = d;
                            lowerInt = p;
                            lowerIndex = j;
                        }
                    }
                }
                if (Point.left(poly.at(i + 1), poly.at(i), poly.at(j + 1))
                        && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                    p = getIntersectionPoint(poly.at(i + 1), poly.at(i), poly.at(j), poly.at(j + 1));
                    if (Point.left(poly.at(i - 1), poly.at(i), p)) {
                        d = Point.sqdist(poly.vertices[i], p);
                        if (d < upperDist) {
                            upperDist = d;
                            upperInt = p;
                            upperIndex = j;
                        }
                    }
                }
            }

            // if there are no vertices to connect to, choose a point in the middle
            if (lowerIndex == (upperIndex + 1) % this.vertices.length) {
                //console.log("Case 1: Vertex("+i+"), lowerIndex("+lowerIndex+"), upperIndex("+upperIndex+"), poly.size("+this.vertices.length+")");
                p[0] = (lowerInt[0] + upperInt[0]) / 2;
                p[1] = (lowerInt[1] + upperInt[1]) / 2;
                steinerPoints.push(p);

                if (i < upperIndex) {
                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);
                    lowerPoly.append(poly, i, upperIndex+1);
                    lowerPoly.vertices.push(p);
                    upperPoly.vertices.push(p);
                    if (lowerIndex != 0){
                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());
                        upperPoly.append(poly,lowerIndex,poly.vertices.length);
                    }
                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);
                    upperPoly.append(poly,0,i+1);
                } else {
                    if (i != 0){
                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());
                        lowerPoly.append(poly,i,poly.vertices.length);
                    }
                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);
                    lowerPoly.append(poly,0,upperIndex+1);
                    lowerPoly.vertices.push(p);
                    upperPoly.vertices.push(p);
                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);
                    upperPoly.append(poly,lowerIndex,i+1);
                }
            } else {
                // connect to the closest point within the triangle
                //console.log("Case 2: Vertex("+i+"), closestIndex("+closestIndex+"), poly.size("+this.vertices.length+")\n");

                if (lowerIndex > upperIndex) {
                    upperIndex += this.vertices.length;
                }
                closestDist = Number.MAX_VALUE;

                if(upperIndex < lowerIndex){
                    return result;
                }

                for (var j = lowerIndex; j <= upperIndex; ++j) {
                    if (Point.leftOn(poly.at(i - 1), poly.at(i), poly.at(j))
                            && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                        d = Point.sqdist(poly.at(i), poly.at(j));
                        if (d < closestDist) {
                            closestDist = d;
                            closestIndex = j % this.vertices.length;
                        }
                    }
                }

                if (i < closestIndex) {
                    lowerPoly.append(poly,i,closestIndex+1);
                    if (closestIndex != 0){
                        upperPoly.append(poly,closestIndex,v.length);
                    }
                    upperPoly.append(poly,0,i+1);
                } else {
                    if (i != 0){
                        lowerPoly.append(poly,i,v.length);
                    }
                    lowerPoly.append(poly,0,closestIndex+1);
                    upperPoly.append(poly,closestIndex,i+1);
                }
            }

            // solve smallest poly first
            if (lowerPoly.vertices.length < upperPoly.vertices.length) {
                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
            } else {
                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
            }

            return result;
        }
    }
    result.push(this);

    return result;
};

/**
 * Remove collinear points in the polygon.
 * @method removeCollinearPoints
 * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.
 * @return {Number}           The number of points removed
 */
Polygon.prototype.removeCollinearPoints = function(precision){
    var num = 0;
    for(var i=this.vertices.length-1; this.vertices.length>3 && i>=0; --i){
        if(Point.collinear(this.at(i-1),this.at(i),this.at(i+1),precision)){
            // Remove the middle point
            this.vertices.splice(i%this.vertices.length,1);
            i--; // Jump one point forward. Otherwise we may get a chain removal
            num++;
        }
    }
    return num;
};

},{"./Line":1,"./Point":2,"./Scalar":4}],4:[function(_dereq_,module,exports){
module.exports = Scalar;

/**
 * Scalar functions
 * @class Scalar
 */
function Scalar(){}

/**
 * Check if two scalars are equal
 * @static
 * @method eq
 * @param  {Number} a
 * @param  {Number} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */
Scalar.eq = function(a,b,precision){
    precision = precision || 0;
    return Math.abs(a-b) < precision;
};

},{}],5:[function(_dereq_,module,exports){
module.exports = {
    Polygon : _dereq_("./Polygon"),
    Point : _dereq_("./Point"),
};

},{"./Point":2,"./Polygon":3}],6:[function(_dereq_,module,exports){
module.exports={
  "name": "p2",
  "version": "0.6.1",
  "description": "A JavaScript 2D physics engine.",
  "author": "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
  "keywords": [
    "p2.js",
    "p2",
    "physics",
    "engine",
    "2d"
  ],
  "main": "./src/p2.js",
  "engines": {
    "node": "*"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/schteppe/p2.js.git"
  },
  "bugs": {
    "url": "https://github.com/schteppe/p2.js/issues"
  },
  "licenses": [
    {
      "type": "MIT"
    }
  ],
  "devDependencies": {
    "grunt": "~0.4.0",
    "grunt-contrib-jshint": "~0.9.2",
    "grunt-contrib-nodeunit": "~0.1.2",
    "grunt-contrib-uglify": "~0.4.0",
    "grunt-contrib-watch": "~0.5.0",
    "grunt-browserify": "~2.0.1",
    "grunt-contrib-concat": "^0.4.0"
  },
  "dependencies": {
    "poly-decomp": "0.1.0"
  }
}

},{}],7:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Utils = _dereq_('../utils/Utils');

module.exports = AABB;

/**
 * Axis aligned bounding box class.
 * @class AABB
 * @constructor
 * @param {Object}  [options]
 * @param {Array}   [options.upperBound]
 * @param {Array}   [options.lowerBound]
 */
function AABB(options){

    /**
     * The lower bound of the bounding box.
     * @property lowerBound
     * @type {Array}
     */
    this.lowerBound = vec2.create();
    if(options && options.lowerBound){
        vec2.copy(this.lowerBound, options.lowerBound);
    }

    /**
     * The upper bound of the bounding box.
     * @property upperBound
     * @type {Array}
     */
    this.upperBound = vec2.create();
    if(options && options.upperBound){
        vec2.copy(this.upperBound, options.upperBound);
    }
}

var tmp = vec2.create();

/**
 * Set the AABB bounds from a set of points.
 * @method setFromPoints
 * @param {Array} points An array of vec2's.
 */
AABB.prototype.setFromPoints = function(points, position, angle, skinSize){
    var l = this.lowerBound,
        u = this.upperBound;

    if(typeof(angle) !== "number"){
        angle = 0;
    }

    // Set to the first point
    if(angle !== 0){
        vec2.rotate(l, points[0], angle);
    } else {
        vec2.copy(l, points[0]);
    }
    vec2.copy(u, l);

    // Compute cosines and sines just once
    var cosAngle = Math.cos(angle),
        sinAngle = Math.sin(angle);
    for(var i = 1; i<points.length; i++){
        var p = points[i];

        if(angle !== 0){
            var x = p[0],
                y = p[1];
            tmp[0] = cosAngle * x -sinAngle * y;
            tmp[1] = sinAngle * x +cosAngle * y;
            p = tmp;
        }

        for(var j=0; j<2; j++){
            if(p[j] > u[j]){
                u[j] = p[j];
            }
            if(p[j] < l[j]){
                l[j] = p[j];
            }
        }
    }

    // Add offset
    if(position){
        vec2.add(this.lowerBound, this.lowerBound, position);
        vec2.add(this.upperBound, this.upperBound, position);
    }

    if(skinSize){
        this.lowerBound[0] -= skinSize;
        this.lowerBound[1] -= skinSize;
        this.upperBound[0] += skinSize;
        this.upperBound[1] += skinSize;
    }
};

/**
 * Copy bounds from an AABB to this AABB
 * @method copy
 * @param  {AABB} aabb
 */
AABB.prototype.copy = function(aabb){
    vec2.copy(this.lowerBound, aabb.lowerBound);
    vec2.copy(this.upperBound, aabb.upperBound);
};

/**
 * Extend this AABB so that it covers the given AABB too.
 * @method extend
 * @param  {AABB} aabb
 */
AABB.prototype.extend = function(aabb){
    // Loop over x and y
    var i = 2;
    while(i--){
        // Extend lower bound
        var l = aabb.lowerBound[i];
        if(this.lowerBound[i] > l){
            this.lowerBound[i] = l;
        }

        // Upper
        var u = aabb.upperBound[i];
        if(this.upperBound[i] < u){
            this.upperBound[i] = u;
        }
    }
};

/**
 * Returns true if the given AABB overlaps this AABB.
 * @method overlaps
 * @param  {AABB} aabb
 * @return {Boolean}
 */
AABB.prototype.overlaps = function(aabb){
    var l1 = this.lowerBound,
        u1 = this.upperBound,
        l2 = aabb.lowerBound,
        u2 = aabb.upperBound;

    //      l2        u2
    //      |---------|
    // |--------|
    // l1       u1

    return ((l2[0] <= u1[0] && u1[0] <= u2[0]) || (l1[0] <= u2[0] && u2[0] <= u1[0])) &&
           ((l2[1] <= u1[1] && u1[1] <= u2[1]) || (l1[1] <= u2[1] && u2[1] <= u1[1]));
};

},{"../math/vec2":31,"../utils/Utils":50}],8:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Body = _dereq_('../objects/Body');

module.exports = Broadphase;

/**
 * Base class for broadphase implementations.
 * @class Broadphase
 * @constructor
 */
function Broadphase(type){

    this.type = type;

    /**
     * The resulting overlapping pairs. Will be filled with results during .getCollisionPairs().
     * @property result
     * @type {Array}
     */
    this.result = [];

    /**
     * The world to search for collision pairs in. To change it, use .setWorld()
     * @property world
     * @type {World}
     * @readOnly
     */
    this.world = null;

    /**
     * The bounding volume type to use in the broadphase algorithms.
     * @property {Number} boundingVolumeType
     */
    this.boundingVolumeType = Broadphase.AABB;
}

/**
 * Axis aligned bounding box type.
 * @static
 * @property {Number} AABB
 */
Broadphase.AABB = 1;

/**
 * Bounding circle type.
 * @static
 * @property {Number} BOUNDING_CIRCLE
 */
Broadphase.BOUNDING_CIRCLE = 2;

/**
 * Set the world that we are searching for collision pairs in
 * @method setWorld
 * @param  {World} world
 */
Broadphase.prototype.setWorld = function(world){
    this.world = world;
};

/**
 * Get all potential intersecting body pairs.
 * @method getCollisionPairs
 * @param  {World} world The world to search in.
 * @return {Array} An array of the bodies, ordered in pairs. Example: A result of [a,b,c,d] means that the potential pairs are: (a,b), (c,d).
 */
Broadphase.prototype.getCollisionPairs = function(world){
    throw new Error("getCollisionPairs must be implemented in a subclass!");
};

var dist = vec2.create();

/**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.boundingRadiusCheck = function(bodyA, bodyB){
    vec2.sub(dist, bodyA.position, bodyB.position);
    var d2 = vec2.squaredLength(dist),
        r = bodyA.boundingRadius + bodyB.boundingRadius;
    return d2 <= r*r;
};

/**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.aabbCheck = function(bodyA, bodyB){
    return bodyA.getAABB().overlaps(bodyB.getAABB());
};

/**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.prototype.boundingVolumeCheck = function(bodyA, bodyB){
    var result;

    switch(this.boundingVolumeType){
    case Broadphase.BOUNDING_CIRCLE:
        result =  Broadphase.boundingRadiusCheck(bodyA,bodyB);
        break;
    case Broadphase.AABB:
        result = Broadphase.aabbCheck(bodyA,bodyB);
        break;
    default:
        throw new Error('Bounding volume type not recognized: '+this.boundingVolumeType);
    }
    return result;
};

/**
 * Check whether two bodies are allowed to collide at all.
 * @method  canCollide
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.canCollide = function(bodyA, bodyB){

    // Cannot collide static bodies
    if(bodyA.type === Body.STATIC && bodyB.type === Body.STATIC){
        return false;
    }

    // Cannot collide static vs kinematic bodies
    if( (bodyA.type === Body.KINEMATIC && bodyB.type === Body.STATIC) ||
        (bodyA.type === Body.STATIC    && bodyB.type === Body.KINEMATIC)){
        return false;
    }

    // Cannot collide kinematic vs kinematic
    if(bodyA.type === Body.KINEMATIC && bodyB.type === Body.KINEMATIC){
        return false;
    }

    // Cannot collide both sleeping bodies
    if(bodyA.sleepState === Body.SLEEPING && bodyB.sleepState === Body.SLEEPING){
        return false;
    }

    // Cannot collide if one is static and the other is sleeping
    if( (bodyA.sleepState === Body.SLEEPING && bodyB.type === Body.STATIC) ||
        (bodyB.sleepState === Body.SLEEPING && bodyA.type === Body.STATIC)){
        return false;
    }

    return true;
};

Broadphase.NAIVE = 1;
Broadphase.SAP = 2;

},{"../math/vec2":31,"../objects/Body":32}],9:[function(_dereq_,module,exports){
var Circle = _dereq_('../shapes/Circle')
,   Plane = _dereq_('../shapes/Plane')
,   Particle = _dereq_('../shapes/Particle')
,   Broadphase = _dereq_('../collision/Broadphase')
,   vec2 = _dereq_('../math/vec2')
,   Utils = _dereq_('../utils/Utils');

module.exports = GridBroadphase;

/**
 * Broadphase that uses axis-aligned bins.
 * @class GridBroadphase
 * @constructor
 * @extends Broadphase
 * @param {object} [options]
 * @param {number} [options.xmin]   Lower x bound of the grid
 * @param {number} [options.xmax]   Upper x bound
 * @param {number} [options.ymin]   Lower y bound
 * @param {number} [options.ymax]   Upper y bound
 * @param {number} [options.nx]     Number of bins along x axis
 * @param {number} [options.ny]     Number of bins along y axis
 * @todo Should have an option for dynamic scene size
 */
function GridBroadphase(options){
    Broadphase.apply(this);

    options = Utils.defaults(options,{
        xmin:   -100,
        xmax:   100,
        ymin:   -100,
        ymax:   100,
        nx:     10,
        ny:     10
    });

    this.xmin = options.xmin;
    this.ymin = options.ymin;
    this.xmax = options.xmax;
    this.ymax = options.ymax;
    this.nx = options.nx;
    this.ny = options.ny;

    this.binsizeX = (this.xmax-this.xmin) / this.nx;
    this.binsizeY = (this.ymax-this.ymin) / this.ny;
}
GridBroadphase.prototype = new Broadphase();
GridBroadphase.prototype.constructor = GridBroadphase;

/**
 * Get collision pairs.
 * @method getCollisionPairs
 * @param  {World} world
 * @return {Array}
 */
GridBroadphase.prototype.getCollisionPairs = function(world){
    var result = [],
        bodies = world.bodies,
        Ncolliding = bodies.length,
        binsizeX = this.binsizeX,
        binsizeY = this.binsizeY,
        nx = this.nx,
        ny = this.ny,
        xmin = this.xmin,
        ymin = this.ymin,
        xmax = this.xmax,
        ymax = this.ymax;

    // Todo: make garbage free
    var bins=[], Nbins=nx*ny;
    for(var i=0; i<Nbins; i++){
        bins.push([]);
    }

    var xmult = nx / (xmax-xmin);
    var ymult = ny / (ymax-ymin);

    // Put all bodies into bins
    for(var i=0; i!==Ncolliding; i++){
        var bi = bodies[i];
        var aabb = bi.aabb;
        var lowerX = Math.max(aabb.lowerBound[0], xmin);
        var lowerY = Math.max(aabb.lowerBound[1], ymin);
        var upperX = Math.min(aabb.upperBound[0], xmax);
        var upperY = Math.min(aabb.upperBound[1], ymax);
        var xi1 = Math.floor(xmult * (lowerX - xmin));
        var yi1 = Math.floor(ymult * (lowerY - ymin));
        var xi2 = Math.floor(xmult * (upperX - xmin));
        var yi2 = Math.floor(ymult * (upperY - ymin));

        // Put in bin
        for(var j=xi1; j<=xi2; j++){
            for(var k=yi1; k<=yi2; k++){
                var xi = j;
                var yi = k;
                var idx = xi*(ny-1) + yi;
                if(idx >= 0 && idx < Nbins){
                    bins[ idx ].push(bi);
                }
            }
        }
    }

    // Check each bin
    for(var i=0; i!==Nbins; i++){
        var bin = bins[i];

        for(var j=0, NbodiesInBin=bin.length; j!==NbodiesInBin; j++){
            var bi = bin[j];
            for(var k=0; k!==j; k++){
                var bj = bin[k];
                if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){
                    result.push(bi,bj);
                }
            }
        }
    }
    return result;
};

},{"../collision/Broadphase":8,"../math/vec2":31,"../shapes/Circle":38,"../shapes/Particle":42,"../shapes/Plane":43,"../utils/Utils":50}],10:[function(_dereq_,module,exports){
var Circle = _dereq_('../shapes/Circle'),
    Plane = _dereq_('../shapes/Plane'),
    Shape = _dereq_('../shapes/Shape'),
    Particle = _dereq_('../shapes/Particle'),
    Broadphase = _dereq_('../collision/Broadphase'),
    vec2 = _dereq_('../math/vec2');

module.exports = NaiveBroadphase;

/**
 * Naive broadphase implementation. Does N^2 tests.
 *
 * @class NaiveBroadphase
 * @constructor
 * @extends Broadphase
 */
function NaiveBroadphase(){
    Broadphase.call(this, Broadphase.NAIVE);
}
NaiveBroadphase.prototype = new Broadphase();
NaiveBroadphase.prototype.constructor = NaiveBroadphase;

/**
 * Get the colliding pairs
 * @method getCollisionPairs
 * @param  {World} world
 * @return {Array}
 */
NaiveBroadphase.prototype.getCollisionPairs = function(world){
    var bodies = world.bodies,
        result = this.result;

    result.length = 0;

    for(var i=0, Ncolliding=bodies.length; i!==Ncolliding; i++){
        var bi = bodies[i];

        for(var j=0; j<i; j++){
            var bj = bodies[j];

            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){
                result.push(bi,bj);
            }
        }
    }

    return result;
};

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
NaiveBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    var bodies = world.bodies;
    for(var i = 0; i < bodies.length; i++){
        var b = bodies[i];

        if(b.aabbNeedsUpdate){
            b.updateAABB();
        }

        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"../collision/Broadphase":8,"../math/vec2":31,"../shapes/Circle":38,"../shapes/Particle":42,"../shapes/Plane":43,"../shapes/Shape":45}],11:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   sub = vec2.sub
,   add = vec2.add
,   dot = vec2.dot
,   Utils = _dereq_('../utils/Utils')
,   TupleDictionary = _dereq_('../utils/TupleDictionary')
,   Equation = _dereq_('../equations/Equation')
,   ContactEquation = _dereq_('../equations/ContactEquation')
,   FrictionEquation = _dereq_('../equations/FrictionEquation')
,   Circle = _dereq_('../shapes/Circle')
,   Convex = _dereq_('../shapes/Convex')
,   Shape = _dereq_('../shapes/Shape')
,   Body = _dereq_('../objects/Body')
,   Rectangle = _dereq_('../shapes/Rectangle');

module.exports = Narrowphase;

// Temp things
var yAxis = vec2.fromValues(0,1);

var tmp1 = vec2.fromValues(0,0)
,   tmp2 = vec2.fromValues(0,0)
,   tmp3 = vec2.fromValues(0,0)
,   tmp4 = vec2.fromValues(0,0)
,   tmp5 = vec2.fromValues(0,0)
,   tmp6 = vec2.fromValues(0,0)
,   tmp7 = vec2.fromValues(0,0)
,   tmp8 = vec2.fromValues(0,0)
,   tmp9 = vec2.fromValues(0,0)
,   tmp10 = vec2.fromValues(0,0)
,   tmp11 = vec2.fromValues(0,0)
,   tmp12 = vec2.fromValues(0,0)
,   tmp13 = vec2.fromValues(0,0)
,   tmp14 = vec2.fromValues(0,0)
,   tmp15 = vec2.fromValues(0,0)
,   tmp16 = vec2.fromValues(0,0)
,   tmp17 = vec2.fromValues(0,0)
,   tmp18 = vec2.fromValues(0,0)
,   tmpArray = [];

/**
 * Narrowphase. Creates contacts and friction given shapes and transforms.
 * @class Narrowphase
 * @constructor
 */
function Narrowphase(){

    /**
     * @property contactEquations
     * @type {Array}
     */
    this.contactEquations = [];

    /**
     * @property frictionEquations
     * @type {Array}
     */
    this.frictionEquations = [];

    /**
     * Whether to make friction equations in the upcoming contacts.
     * @property enableFriction
     * @type {Boolean}
     */
    this.enableFriction = true;

    /**
     * Whether to make equations enabled in upcoming contacts.
     * @property enabledEquations
     * @type {Boolean}
     */
    this.enabledEquations = true;

    /**
     * The friction slip force to use when creating friction equations.
     * @property slipForce
     * @type {Number}
     */
    this.slipForce = 10.0;

    /**
     * The friction value to use in the upcoming friction equations.
     * @property frictionCoefficient
     * @type {Number}
     */
    this.frictionCoefficient = 0.3;

    /**
     * Will be the .relativeVelocity in each produced FrictionEquation.
     * @property {Number} surfaceVelocity
     */
    this.surfaceVelocity = 0;

    this.reuseObjects = true;
    this.reusableContactEquations = [];
    this.reusableFrictionEquations = [];

    /**
     * The restitution value to use in the next contact equations.
     * @property restitution
     * @type {Number}
     */
    this.restitution = 0;

    /**
     * The stiffness value to use in the next contact equations.
     * @property {Number} stiffness
     */
    this.stiffness = Equation.DEFAULT_STIFFNESS;

    /**
     * The stiffness value to use in the next contact equations.
     * @property {Number} stiffness
     */
    this.relaxation = Equation.DEFAULT_RELAXATION;

    /**
     * The stiffness value to use in the next friction equations.
     * @property frictionStiffness
     * @type {Number}
     */
    this.frictionStiffness = Equation.DEFAULT_STIFFNESS;

    /**
     * The relaxation value to use in the next friction equations.
     * @property frictionRelaxation
     * @type {Number}
     */
    this.frictionRelaxation = Equation.DEFAULT_RELAXATION;

    /**
     * Enable reduction of friction equations. If disabled, a box on a plane will generate 2 contact equations and 2 friction equations. If enabled, there will be only one friction equation. Same kind of simplifications are made  for all collision types.
     * @property enableFrictionReduction
     * @type {Boolean}
     * @deprecated This flag will be removed when the feature is stable enough.
     * @default true
     */
    this.enableFrictionReduction = true;

    /**
     * Keeps track of the colliding bodies last step.
     * @private
     * @property collidingBodiesLastStep
     * @type {TupleDictionary}
     */
    this.collidingBodiesLastStep = new TupleDictionary();

    /**
     * Contact skin size value to use in the next contact equations.
     * @property {Number} contactSkinSize
     * @default 0.01
     */
    this.contactSkinSize = 0.01;
}

var bodiesOverlap_shapePositionA = vec2.create();
var bodiesOverlap_shapePositionB = vec2.create();

/**
 * @method bodiesOverlap
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Narrowphase.prototype.bodiesOverlap = function(bodyA, bodyB){
    var shapePositionA = bodiesOverlap_shapePositionA;
    var shapePositionB = bodiesOverlap_shapePositionB;

    // Loop over all shapes of bodyA
    for(var k=0, Nshapesi=bodyA.shapes.length; k!==Nshapesi; k++){
        var shapeA = bodyA.shapes[k],
            positionA = bodyA.shapeOffsets[k],
            angleA = bodyA.shapeAngles[k];

        bodyA.toWorldFrame(shapePositionA, positionA);

        // All shapes of body j
        for(var l=0, Nshapesj=bodyB.shapes.length; l!==Nshapesj; l++){
            var shapeB = bodyB.shapes[l],
                positionB = bodyB.shapeOffsets[l],
                angleB = bodyB.shapeAngles[l];

            bodyB.toWorldFrame(shapePositionB, positionB);

            if(this[shapeA.type | shapeB.type](
                bodyA,
                shapeA,
                shapePositionA,
                shapeA.angle + bodyA.angle,
                bodyB,
                shapeB,
                shapePositionB,
                shapeB.angle + bodyB.angle,
                true
            )){
                return true;
            }
        }
    }

    return false;
};

/**
 * Check if the bodies were in contact since the last reset().
 * @method collidedLastStep
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Narrowphase.prototype.collidedLastStep = function(bodyA, bodyB){
    var id1 = bodyA.id|0,
        id2 = bodyB.id|0;
    return !!this.collidingBodiesLastStep.get(id1, id2);
};

/**
 * Throws away the old equations and gets ready to create new
 * @method reset
 */
Narrowphase.prototype.reset = function(){
    this.collidingBodiesLastStep.reset();

    var eqs = this.contactEquations;
    var l = eqs.length;
    while(l--){
        var eq = eqs[l],
            id1 = eq.bodyA.id,
            id2 = eq.bodyB.id;
        this.collidingBodiesLastStep.set(id1, id2, true);
    }

    if(this.reuseObjects){
        var ce = this.contactEquations,
            fe = this.frictionEquations,
            rfe = this.reusableFrictionEquations,
            rce = this.reusableContactEquations;
        Utils.appendArray(rce,ce);
        Utils.appendArray(rfe,fe);
    }

    // Reset
    this.contactEquations.length = this.frictionEquations.length = 0;
};

/**
 * Creates a ContactEquation, either by reusing an existing object or creating a new one.
 * @method createContactEquation
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {ContactEquation}
 */
Narrowphase.prototype.createContactEquation = function(bodyA, bodyB, shapeA, shapeB){
    var c = this.reusableContactEquations.length ? this.reusableContactEquations.pop() : new ContactEquation(bodyA,bodyB);
    c.bodyA = bodyA;
    c.bodyB = bodyB;
    c.shapeA = shapeA;
    c.shapeB = shapeB;
    c.restitution = this.restitution;
    c.firstImpact = !this.collidedLastStep(bodyA,bodyB);
    c.stiffness = this.stiffness;
    c.relaxation = this.relaxation;
    c.needsUpdate = true;
    c.enabled = this.enabledEquations;
    c.offset = this.contactSkinSize;

    return c;
};

/**
 * Creates a FrictionEquation, either by reusing an existing object or creating a new one.
 * @method createFrictionEquation
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {FrictionEquation}
 */
Narrowphase.prototype.createFrictionEquation = function(bodyA, bodyB, shapeA, shapeB){
    var c = this.reusableFrictionEquations.length ? this.reusableFrictionEquations.pop() : new FrictionEquation(bodyA,bodyB);
    c.bodyA = bodyA;
    c.bodyB = bodyB;
    c.shapeA = shapeA;
    c.shapeB = shapeB;
    c.setSlipForce(this.slipForce);
    c.frictionCoefficient = this.frictionCoefficient;
    c.relativeVelocity = this.surfaceVelocity;
    c.enabled = this.enabledEquations;
    c.needsUpdate = true;
    c.stiffness = this.frictionStiffness;
    c.relaxation = this.frictionRelaxation;
    c.contactEquations.length = 0;
    return c;
};

/**
 * Creates a FrictionEquation given the data in the ContactEquation. Uses same offset vectors ri and rj, but the tangent vector will be constructed from the collision normal.
 * @method createFrictionFromContact
 * @param  {ContactEquation} contactEquation
 * @return {FrictionEquation}
 */
Narrowphase.prototype.createFrictionFromContact = function(c){
    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
    vec2.copy(eq.contactPointA, c.contactPointA);
    vec2.copy(eq.contactPointB, c.contactPointB);
    vec2.rotate90cw(eq.t, c.normalA);
    eq.contactEquations.push(c);
    return eq;
};

// Take the average N latest contact point on the plane.
Narrowphase.prototype.createFrictionFromAverage = function(numContacts){
    var c = this.contactEquations[this.contactEquations.length - 1];
    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    vec2.set(eq.contactPointA, 0, 0);
    vec2.set(eq.contactPointB, 0, 0);
    vec2.set(eq.t, 0, 0);
    for(var i=0; i!==numContacts; i++){
        c = this.contactEquations[this.contactEquations.length - 1 - i];
        if(c.bodyA === bodyA){
            vec2.add(eq.t, eq.t, c.normalA);
            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointB);
        } else {
            vec2.sub(eq.t, eq.t, c.normalA);
            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointB);
            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointA);
        }
        eq.contactEquations.push(c);
    }

    var invNumContacts = 1/numContacts;
    vec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);
    vec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);
    vec2.normalize(eq.t, eq.t);
    vec2.rotate90cw(eq.t, eq.t);
    return eq;
};

/**
 * Convex/line narrowphase
 * @method convexLine
 * @param  {Body}       convexBody
 * @param  {Convex}     convexShape
 * @param  {Array}      convexOffset
 * @param  {Number}     convexAngle
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      lineOffset
 * @param  {Number}     lineAngle
 * @param {boolean}     justTest
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.LINE | Shape.CONVEX] =
Narrowphase.prototype.convexLine = function(
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

/**
 * Line/rectangle narrowphase
 * @method lineRectangle
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      lineOffset
 * @param  {Number}     lineAngle
 * @param  {Body}       rectangleBody
 * @param  {Rectangle}  rectangleShape
 * @param  {Array}      rectangleOffset
 * @param  {Number}     rectangleAngle
 * @param  {Boolean}    justTest
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.LINE | Shape.RECTANGLE] =
Narrowphase.prototype.lineRectangle = function(
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    rectangleBody,
    rectangleShape,
    rectangleOffset,
    rectangleAngle,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

function setConvexToCapsuleShapeMiddle(convexShape, capsuleShape){
    vec2.set(convexShape.vertices[0], -capsuleShape.length * 0.5, -capsuleShape.radius);
    vec2.set(convexShape.vertices[1],  capsuleShape.length * 0.5, -capsuleShape.radius);
    vec2.set(convexShape.vertices[2],  capsuleShape.length * 0.5,  capsuleShape.radius);
    vec2.set(convexShape.vertices[3], -capsuleShape.length * 0.5,  capsuleShape.radius);
}

var convexCapsule_tempRect = new Rectangle(1,1),
    convexCapsule_tempVec = vec2.create();

/**
 * Convex/capsule narrowphase
 * @method convexCapsule
 * @param  {Body}       convexBody
 * @param  {Convex}     convexShape
 * @param  {Array}      convexPosition
 * @param  {Number}     convexAngle
 * @param  {Body}       capsuleBody
 * @param  {Capsule}    capsuleShape
 * @param  {Array}      capsulePosition
 * @param  {Number}     capsuleAngle
 */
Narrowphase.prototype[Shape.CAPSULE | Shape.CONVEX] =
Narrowphase.prototype[Shape.CAPSULE | Shape.RECTANGLE] =
Narrowphase.prototype.convexCapsule = function(
    convexBody,
    convexShape,
    convexPosition,
    convexAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
){

    // Check the circles
    // Add offsets!
    var circlePos = convexCapsule_tempVec;
    vec2.set(circlePos, capsuleShape.length/2,0);
    vec2.rotate(circlePos,circlePos,capsuleAngle);
    vec2.add(circlePos,circlePos,capsulePosition);
    var result1 = this.circleConvex(capsuleBody,capsuleShape,circlePos,capsuleAngle, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);

    vec2.set(circlePos,-capsuleShape.length/2, 0);
    vec2.rotate(circlePos,circlePos,capsuleAngle);
    vec2.add(circlePos,circlePos,capsulePosition);
    var result2 = this.circleConvex(capsuleBody,capsuleShape,circlePos,capsuleAngle, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);

    if(justTest && (result1 || result2)){
        return true;
    }

    // Check center rect
    var r = convexCapsule_tempRect;
    setConvexToCapsuleShapeMiddle(r,capsuleShape);
    var result = this.convexConvex(convexBody,convexShape,convexPosition,convexAngle, capsuleBody,r,capsulePosition,capsuleAngle, justTest);

    return result + result1 + result2;
};

/**
 * Capsule/line narrowphase
 * @method lineCapsule
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      linePosition
 * @param  {Number}     lineAngle
 * @param  {Body}       capsuleBody
 * @param  {Capsule}    capsuleShape
 * @param  {Array}      capsulePosition
 * @param  {Number}     capsuleAngle
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.CAPSULE | Shape.LINE] =
Narrowphase.prototype.lineCapsule = function(
    lineBody,
    lineShape,
    linePosition,
    lineAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

var capsuleCapsule_tempVec1 = vec2.create();
var capsuleCapsule_tempVec2 = vec2.create();
var capsuleCapsule_tempRect1 = new Rectangle(1,1);

/**
 * Capsule/capsule narrowphase
 * @method capsuleCapsule
 * @param  {Body}       bi
 * @param  {Capsule}    si
 * @param  {Array}      xi
 * @param  {Number}     ai
 * @param  {Body}       bj
 * @param  {Capsule}    sj
 * @param  {Array}      xj
 * @param  {Number}     aj
 */
Narrowphase.prototype[Shape.CAPSULE | Shape.CAPSULE] =
Narrowphase.prototype.capsuleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){

    var enableFrictionBefore;

    // Check the circles
    // Add offsets!
    var circlePosi = capsuleCapsule_tempVec1,
        circlePosj = capsuleCapsule_tempVec2;

    var numContacts = 0;


    // Need 4 circle checks, between all
    for(var i=0; i<2; i++){

        vec2.set(circlePosi,(i===0?-1:1)*si.length/2,0);
        vec2.rotate(circlePosi,circlePosi,ai);
        vec2.add(circlePosi,circlePosi,xi);

        for(var j=0; j<2; j++){

            vec2.set(circlePosj,(j===0?-1:1)*sj.length/2, 0);
            vec2.rotate(circlePosj,circlePosj,aj);
            vec2.add(circlePosj,circlePosj,xj);

            // Temporarily turn off friction
            if(this.enableFrictionReduction){
                enableFrictionBefore = this.enableFriction;
                this.enableFriction = false;
            }

            var result = this.circleCircle(bi,si,circlePosi,ai, bj,sj,circlePosj,aj, justTest, si.radius, sj.radius);

            if(this.enableFrictionReduction){
                this.enableFriction = enableFrictionBefore;
            }

            if(justTest && result){
                return true;
            }

            numContacts += result;
        }
    }

    if(this.enableFrictionReduction){
        // Temporarily turn off friction
        enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
    }

    // Check circles against the center rectangles
    var rect = capsuleCapsule_tempRect1;
    setConvexToCapsuleShapeMiddle(rect,si);
    var result1 = this.convexCapsule(bi,rect,xi,ai, bj,sj,xj,aj, justTest);

    if(this.enableFrictionReduction){
        this.enableFriction = enableFrictionBefore;
    }

    if(justTest && result1){
        return true;
    }
    numContacts += result1;

    if(this.enableFrictionReduction){
        // Temporarily turn off friction
        var enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
    }

    setConvexToCapsuleShapeMiddle(rect,sj);
    var result2 = this.convexCapsule(bj,rect,xj,aj, bi,si,xi,ai, justTest);

    if(this.enableFrictionReduction){
        this.enableFriction = enableFrictionBefore;
    }

    if(justTest && result2){
        return true;
    }
    numContacts += result2;

    if(this.enableFrictionReduction){
        if(numContacts && this.enableFriction){
            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        }
    }

    return numContacts;
};

/**
 * Line/line narrowphase
 * @method lineLine
 * @param  {Body}       bodyA
 * @param  {Line}       shapeA
 * @param  {Array}      positionA
 * @param  {Number}     angleA
 * @param  {Body}       bodyB
 * @param  {Line}       shapeB
 * @param  {Array}      positionB
 * @param  {Number}     angleB
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.LINE | Shape.LINE] =
Narrowphase.prototype.lineLine = function(
    bodyA,
    shapeA,
    positionA,
    angleA,
    bodyB,
    shapeB,
    positionB,
    angleB,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

/**
 * Plane/line Narrowphase
 * @method planeLine
 * @param  {Body}   planeBody
 * @param  {Plane}  planeShape
 * @param  {Array}  planeOffset
 * @param  {Number} planeAngle
 * @param  {Body}   lineBody
 * @param  {Line}   lineShape
 * @param  {Array}  lineOffset
 * @param  {Number} lineAngle
 */
Narrowphase.prototype[Shape.PLANE | Shape.LINE] =
Narrowphase.prototype.planeLine = function(planeBody, planeShape, planeOffset, planeAngle,
                                           lineBody,  lineShape,  lineOffset,  lineAngle, justTest){
    var worldVertex0 = tmp1,
        worldVertex1 = tmp2,
        worldVertex01 = tmp3,
        worldVertex11 = tmp4,
        worldEdge = tmp5,
        worldEdgeUnit = tmp6,
        dist = tmp7,
        worldNormal = tmp8,
        worldTangent = tmp9,
        verts = tmpArray,
        numContacts = 0;

    // Get start and end points
    vec2.set(worldVertex0, -lineShape.length/2, 0);
    vec2.set(worldVertex1,  lineShape.length/2, 0);

    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
    vec2.rotate(worldVertex01, worldVertex0, lineAngle);
    vec2.rotate(worldVertex11, worldVertex1, lineAngle);

    add(worldVertex01, worldVertex01, lineOffset);
    add(worldVertex11, worldVertex11, lineOffset);

    vec2.copy(worldVertex0,worldVertex01);
    vec2.copy(worldVertex1,worldVertex11);

    // Get vector along the line
    sub(worldEdge, worldVertex1, worldVertex0);
    vec2.normalize(worldEdgeUnit, worldEdge);

    // Get tangent to the edge.
    vec2.rotate90cw(worldTangent, worldEdgeUnit);

    vec2.rotate(worldNormal, yAxis, planeAngle);

    // Check line ends
    verts[0] = worldVertex0;
    verts[1] = worldVertex1;
    for(var i=0; i<verts.length; i++){
        var v = verts[i];

        sub(dist, v, planeOffset);

        var d = dot(dist,worldNormal);

        if(d < 0){

            if(justTest){
                return true;
            }

            var c = this.createContactEquation(planeBody,lineBody,planeShape,lineShape);
            numContacts++;

            vec2.copy(c.normalA, worldNormal);
            vec2.normalize(c.normalA,c.normalA);

            // distance vector along plane normal
            vec2.scale(dist, worldNormal, d);

            // Vector from plane center to contact
            sub(c.contactPointA, v, dist);
            sub(c.contactPointA, c.contactPointA, planeBody.position);

            // From line center to contact
            sub(c.contactPointB, v,    lineOffset);
            add(c.contactPointB, c.contactPointB, lineOffset);
            sub(c.contactPointB, c.contactPointB, lineBody.position);

            this.contactEquations.push(c);

            if(!this.enableFrictionReduction){
                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
    }

    if(justTest){
        return false;
    }

    if(!this.enableFrictionReduction){
        if(numContacts && this.enableFriction){
            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        }
    }

    return numContacts;
};

Narrowphase.prototype[Shape.PARTICLE | Shape.CAPSULE] =
Narrowphase.prototype.particleCapsule = function(
    particleBody,
    particleShape,
    particlePosition,
    particleAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
){
    return this.circleLine(particleBody,particleShape,particlePosition,particleAngle, capsuleBody,capsuleShape,capsulePosition,capsuleAngle, justTest, capsuleShape.radius, 0);
};

/**
 * Circle/line Narrowphase
 * @method circleLine
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} lineBody
 * @param  {Line} lineShape
 * @param  {Array} lineOffset
 * @param  {Number} lineAngle
 * @param {Boolean} justTest If set to true, this function will return the result (intersection or not) without adding equations.
 * @param {Number} lineRadius Radius to add to the line. Can be used to test Capsules.
 * @param {Number} circleRadius If set, this value overrides the circle shape radius.
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.LINE] =
Narrowphase.prototype.circleLine = function(
    circleBody,
    circleShape,
    circleOffset,
    circleAngle,
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    justTest,
    lineRadius,
    circleRadius
){
    var lineRadius = lineRadius || 0,
        circleRadius = typeof(circleRadius)!=="undefined" ? circleRadius : circleShape.radius,

        orthoDist = tmp1,
        lineToCircleOrthoUnit = tmp2,
        projectedPoint = tmp3,
        centerDist = tmp4,
        worldTangent = tmp5,
        worldEdge = tmp6,
        worldEdgeUnit = tmp7,
        worldVertex0 = tmp8,
        worldVertex1 = tmp9,
        worldVertex01 = tmp10,
        worldVertex11 = tmp11,
        dist = tmp12,
        lineToCircle = tmp13,
        lineEndToLineRadius = tmp14,

        verts = tmpArray;

    // Get start and end points
    vec2.set(worldVertex0, -lineShape.length/2, 0);
    vec2.set(worldVertex1,  lineShape.length/2, 0);

    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
    vec2.rotate(worldVertex01, worldVertex0, lineAngle);
    vec2.rotate(worldVertex11, worldVertex1, lineAngle);

    add(worldVertex01, worldVertex01, lineOffset);
    add(worldVertex11, worldVertex11, lineOffset);

    vec2.copy(worldVertex0,worldVertex01);
    vec2.copy(worldVertex1,worldVertex11);

    // Get vector along the line
    sub(worldEdge, worldVertex1, worldVertex0);
    vec2.normalize(worldEdgeUnit, worldEdge);

    // Get tangent to the edge.
    vec2.rotate90cw(worldTangent, worldEdgeUnit);

    // Check distance from the plane spanned by the edge vs the circle
    sub(dist, circleOffset, worldVertex0);
    var d = dot(dist, worldTangent); // Distance from center of line to circle center
    sub(centerDist, worldVertex0, lineOffset);

    sub(lineToCircle, circleOffset, lineOffset);

    var radiusSum = circleRadius + lineRadius;

    if(Math.abs(d) < radiusSum){

        // Now project the circle onto the edge
        vec2.scale(orthoDist, worldTangent, d);
        sub(projectedPoint, circleOffset, orthoDist);

        // Add the missing line radius
        vec2.scale(lineToCircleOrthoUnit, worldTangent, dot(worldTangent, lineToCircle));
        vec2.normalize(lineToCircleOrthoUnit,lineToCircleOrthoUnit);
        vec2.scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);
        add(projectedPoint,projectedPoint,lineToCircleOrthoUnit);

        // Check if the point is within the edge span
        var pos =  dot(worldEdgeUnit, projectedPoint);
        var pos0 = dot(worldEdgeUnit, worldVertex0);
        var pos1 = dot(worldEdgeUnit, worldVertex1);

        if(pos > pos0 && pos < pos1){
            // We got contact!

            if(justTest){
                return true;
            }

            var c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);

            vec2.scale(c.normalA, orthoDist, -1);
            vec2.normalize(c.normalA, c.normalA);

            vec2.scale( c.contactPointA, c.normalA,  circleRadius);
            add(c.contactPointA, c.contactPointA, circleOffset);
            sub(c.contactPointA, c.contactPointA, circleBody.position);

            sub(c.contactPointB, projectedPoint, lineOffset);
            add(c.contactPointB, c.contactPointB, lineOffset);
            sub(c.contactPointB, c.contactPointB, lineBody.position);

            this.contactEquations.push(c);

            if(this.enableFriction){
                this.frictionEquations.push(this.createFrictionFromContact(c));
            }

            return 1;
        }
    }

    // Add corner
    verts[0] = worldVertex0;
    verts[1] = worldVertex1;

    for(var i=0; i<verts.length; i++){
        var v = verts[i];

        sub(dist, v, circleOffset);

        if(vec2.squaredLength(dist) < Math.pow(radiusSum, 2)){

            if(justTest){
                return true;
            }

            var c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);

            vec2.copy(c.normalA, dist);
            vec2.normalize(c.normalA,c.normalA);

            // Vector from circle to contact point is the normal times the circle radius
            vec2.scale(c.contactPointA, c.normalA, circleRadius);
            add(c.contactPointA, c.contactPointA, circleOffset);
            sub(c.contactPointA, c.contactPointA, circleBody.position);

            sub(c.contactPointB, v, lineOffset);
            vec2.scale(lineEndToLineRadius, c.normalA, -lineRadius);
            add(c.contactPointB, c.contactPointB, lineEndToLineRadius);
            add(c.contactPointB, c.contactPointB, lineOffset);
            sub(c.contactPointB, c.contactPointB, lineBody.position);

            this.contactEquations.push(c);

            if(this.enableFriction){
                this.frictionEquations.push(this.createFrictionFromContact(c));
            }

            return 1;
        }
    }

    return 0;
};

/**
 * Circle/capsule Narrowphase
 * @method circleCapsule
 * @param  {Body}   bi
 * @param  {Circle} si
 * @param  {Array}  xi
 * @param  {Number} ai
 * @param  {Body}   bj
 * @param  {Line}   sj
 * @param  {Array}  xj
 * @param  {Number} aj
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.CAPSULE] =
Narrowphase.prototype.circleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){
    return this.circleLine(bi,si,xi,ai, bj,sj,xj,aj, justTest, sj.radius);
};

/**
 * Circle/convex Narrowphase.
 * @method circleConvex
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param  {Boolean} justTest
 * @param  {Number} circleRadius
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.CONVEX] =
Narrowphase.prototype[Shape.CIRCLE | Shape.RECTANGLE] =
Narrowphase.prototype.circleConvex = function(
    circleBody,
    circleShape,
    circleOffset,
    circleAngle,
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    justTest,
    circleRadius
){
    var circleRadius = typeof(circleRadius)==="number" ? circleRadius : circleShape.radius;

    var worldVertex0 = tmp1,
        worldVertex1 = tmp2,
        worldEdge = tmp3,
        worldEdgeUnit = tmp4,
        worldNormal = tmp5,
        centerDist = tmp6,
        convexToCircle = tmp7,
        orthoDist = tmp8,
        projectedPoint = tmp9,
        dist = tmp10,
        worldVertex = tmp11,

        closestEdge = -1,
        closestEdgeDistance = null,
        closestEdgeOrthoDist = tmp12,
        closestEdgeProjectedPoint = tmp13,
        candidate = tmp14,
        candidateDist = tmp15,
        minCandidate = tmp16,

        found = false,
        minCandidateDistance = Number.MAX_VALUE;

    var numReported = 0;

    // New algorithm:
    // 1. Check so center of circle is not inside the polygon. If it is, this wont work...
    // 2. For each edge
    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
    // 2. 2. Check if point is inside.

    var verts = convexShape.vertices;

    // Check all edges first
    for(var i=0; i!==verts.length+1; i++){
        var v0 = verts[i%verts.length],
            v1 = verts[(i+1)%verts.length];

        vec2.rotate(worldVertex0, v0, convexAngle);
        vec2.rotate(worldVertex1, v1, convexAngle);
        add(worldVertex0, worldVertex0, convexOffset);
        add(worldVertex1, worldVertex1, convexOffset);
        sub(worldEdge, worldVertex1, worldVertex0);

        vec2.normalize(worldEdgeUnit, worldEdge);

        // Get tangent to the edge. Points out of the Convex
        vec2.rotate90cw(worldNormal, worldEdgeUnit);

        // Get point on circle, closest to the polygon
        vec2.scale(candidate,worldNormal,-circleShape.radius);
        add(candidate,candidate,circleOffset);

        if(pointInConvex(candidate,convexShape,convexOffset,convexAngle)){

            vec2.sub(candidateDist,worldVertex0,candidate);
            var candidateDistance = Math.abs(vec2.dot(candidateDist,worldNormal));

            if(candidateDistance < minCandidateDistance){
                vec2.copy(minCandidate,candidate);
                minCandidateDistance = candidateDistance;
                vec2.scale(closestEdgeProjectedPoint,worldNormal,candidateDistance);
                vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,candidate);
                found = true;
            }
        }
    }

    if(found){

        if(justTest){
            return true;
        }

        var c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);
        vec2.sub(c.normalA, minCandidate, circleOffset);
        vec2.normalize(c.normalA, c.normalA);

        vec2.scale(c.contactPointA,  c.normalA, circleRadius);
        add(c.contactPointA, c.contactPointA, circleOffset);
        sub(c.contactPointA, c.contactPointA, circleBody.position);

        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
        add(c.contactPointB, c.contactPointB, convexOffset);
        sub(c.contactPointB, c.contactPointB, convexBody.position);

        this.contactEquations.push(c);

        if(this.enableFriction){
            this.frictionEquations.push( this.createFrictionFromContact(c) );
        }

        return 1;
    }

    // Check all vertices
    if(circleRadius > 0){
        for(var i=0; i<verts.length; i++){
            var localVertex = verts[i];
            vec2.rotate(worldVertex, localVertex, convexAngle);
            add(worldVertex, worldVertex, convexOffset);

            sub(dist, worldVertex, circleOffset);
            if(vec2.squaredLength(dist) < Math.pow(circleRadius, 2)){

                if(justTest){
                    return true;
                }

                var c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);

                vec2.copy(c.normalA, dist);
                vec2.normalize(c.normalA,c.normalA);

                // Vector from circle to contact point is the normal times the circle radius
                vec2.scale(c.contactPointA, c.normalA, circleRadius);
                add(c.contactPointA, c.contactPointA, circleOffset);
                sub(c.contactPointA, c.contactPointA, circleBody.position);

                sub(c.contactPointB, worldVertex, convexOffset);
                add(c.contactPointB, c.contactPointB, convexOffset);
                sub(c.contactPointB, c.contactPointB, convexBody.position);

                this.contactEquations.push(c);

                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }

                return 1;
            }
        }
    }

    return 0;
};

var pic_worldVertex0 = vec2.create(),
    pic_worldVertex1 = vec2.create(),
    pic_r0 = vec2.create(),
    pic_r1 = vec2.create();

/*
 * Check if a point is in a polygon
 */
function pointInConvex(worldPoint,convexShape,convexOffset,convexAngle){
    var worldVertex0 = pic_worldVertex0,
        worldVertex1 = pic_worldVertex1,
        r0 = pic_r0,
        r1 = pic_r1,
        point = worldPoint,
        verts = convexShape.vertices,
        lastCross = null;
    for(var i=0; i!==verts.length+1; i++){
        var v0 = verts[i%verts.length],
            v1 = verts[(i+1)%verts.length];

        // Transform vertices to world
        // @todo The point should be transformed to local coordinates in the convex, no need to transform each vertex
        vec2.rotate(worldVertex0, v0, convexAngle);
        vec2.rotate(worldVertex1, v1, convexAngle);
        add(worldVertex0, worldVertex0, convexOffset);
        add(worldVertex1, worldVertex1, convexOffset);

        sub(r0, worldVertex0, point);
        sub(r1, worldVertex1, point);
        var cross = vec2.crossLength(r0,r1);

        if(lastCross===null){
            lastCross = cross;
        }

        // If we got a different sign of the distance vector, the point is out of the polygon
        if(cross*lastCross <= 0){
            return false;
        }
        lastCross = cross;
    }
    return true;
}

/**
 * Particle/convex Narrowphase
 * @method particleConvex
 * @param  {Body} particleBody
 * @param  {Particle} particleShape
 * @param  {Array} particleOffset
 * @param  {Number} particleAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param {Boolean} justTest
 * @todo use pointInConvex and code more similar to circleConvex
 * @todo don't transform each vertex, but transform the particle position to convex-local instead
 */
Narrowphase.prototype[Shape.PARTICLE | Shape.CONVEX] =
Narrowphase.prototype[Shape.PARTICLE | Shape.RECTANGLE] =
Narrowphase.prototype.particleConvex = function(
    particleBody,
    particleShape,
    particleOffset,
    particleAngle,
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    justTest
){
    var worldVertex0 = tmp1,
        worldVertex1 = tmp2,
        worldEdge = tmp3,
        worldEdgeUnit = tmp4,
        worldTangent = tmp5,
        centerDist = tmp6,
        convexToparticle = tmp7,
        orthoDist = tmp8,
        projectedPoint = tmp9,
        dist = tmp10,
        worldVertex = tmp11,
        closestEdge = -1,
        closestEdgeDistance = null,
        closestEdgeOrthoDist = tmp12,
        closestEdgeProjectedPoint = tmp13,
        r0 = tmp14, // vector from particle to vertex0
        r1 = tmp15,
        localPoint = tmp16,
        candidateDist = tmp17,
        minEdgeNormal = tmp18,
        minCandidateDistance = Number.MAX_VALUE;

    var numReported = 0,
        found = false,
        verts = convexShape.vertices;

    // Check if the particle is in the polygon at all
    if(!pointInConvex(particleOffset,convexShape,convexOffset,convexAngle)){
        return 0;
    }

    if(justTest){
        return true;
    }

    // Check edges first
    var lastCross = null;
    for(var i=0; i!==verts.length+1; i++){
        var v0 = verts[i%verts.length],
            v1 = verts[(i+1)%verts.length];

        // Transform vertices to world
        vec2.rotate(worldVertex0, v0, convexAngle);
        vec2.rotate(worldVertex1, v1, convexAngle);
        add(worldVertex0, worldVertex0, convexOffset);
        add(worldVertex1, worldVertex1, convexOffset);

        // Get world edge
        sub(worldEdge, worldVertex1, worldVertex0);
        vec2.normalize(worldEdgeUnit, worldEdge);

        // Get tangent to the edge. Points out of the Convex
        vec2.rotate90cw(worldTangent, worldEdgeUnit);

        // Check distance from the infinite line (spanned by the edge) to the particle
        sub(dist, particleOffset, worldVertex0);
        var d = dot(dist, worldTangent);
        sub(centerDist, worldVertex0, convexOffset);

        sub(convexToparticle, particleOffset, convexOffset);

        vec2.sub(candidateDist,worldVertex0,particleOffset);
        var candidateDistance = Math.abs(vec2.dot(candidateDist,worldTangent));

        if(candidateDistance < minCandidateDistance){
            minCandidateDistance = candidateDistance;
            vec2.scale(closestEdgeProjectedPoint,worldTangent,candidateDistance);
            vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,particleOffset);
            vec2.copy(minEdgeNormal,worldTangent);
            found = true;
        }
    }

    if(found){
        var c = this.createContactEquation(particleBody,convexBody,particleShape,convexShape);

        vec2.scale(c.normalA, minEdgeNormal, -1);
        vec2.normalize(c.normalA, c.normalA);

        // Particle has no extent to the contact point
        vec2.set(c.contactPointA,  0, 0);
        add(c.contactPointA, c.contactPointA, particleOffset);
        sub(c.contactPointA, c.contactPointA, particleBody.position);

        // From convex center to point
        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
        add(c.contactPointB, c.contactPointB, convexOffset);
        sub(c.contactPointB, c.contactPointB, convexBody.position);

        this.contactEquations.push(c);

        if(this.enableFriction){
            this.frictionEquations.push( this.createFrictionFromContact(c) );
        }

        return 1;
    }


    return 0;
};

/**
 * Circle/circle Narrowphase
 * @method circleCircle
 * @param  {Body} bodyA
 * @param  {Circle} shapeA
 * @param  {Array} offsetA
 * @param  {Number} angleA
 * @param  {Body} bodyB
 * @param  {Circle} shapeB
 * @param  {Array} offsetB
 * @param  {Number} angleB
 * @param {Boolean} justTest
 * @param {Number} [radiusA] Optional radius to use for shapeA
 * @param {Number} [radiusB] Optional radius to use for shapeB
 */
Narrowphase.prototype[Shape.CIRCLE] =
Narrowphase.prototype.circleCircle = function(
    bodyA,
    shapeA,
    offsetA,
    angleA,
    bodyB,
    shapeB,
    offsetB,
    angleB,
    justTest,
    radiusA,
    radiusB
){

    var dist = tmp1,
        radiusA = radiusA || shapeA.radius,
        radiusB = radiusB || shapeB.radius;

    sub(dist,offsetA,offsetB);
    var r = radiusA + radiusB;
    if(vec2.squaredLength(dist) > Math.pow(r,2)){
        return 0;
    }

    if(justTest){
        return true;
    }

    var c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);
    sub(c.normalA, offsetB, offsetA);
    vec2.normalize(c.normalA,c.normalA);

    vec2.scale( c.contactPointA, c.normalA,  radiusA);
    vec2.scale( c.contactPointB, c.normalA, -radiusB);

    add(c.contactPointA, c.contactPointA, offsetA);
    sub(c.contactPointA, c.contactPointA, bodyA.position);

    add(c.contactPointB, c.contactPointB, offsetB);
    sub(c.contactPointB, c.contactPointB, bodyB.position);

    this.contactEquations.push(c);

    if(this.enableFriction){
        this.frictionEquations.push(this.createFrictionFromContact(c));
    }
    return 1;
};

/**
 * Plane/Convex Narrowphase
 * @method planeConvex
 * @param  {Body} planeBody
 * @param  {Plane} planeShape
 * @param  {Array} planeOffset
 * @param  {Number} planeAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param {Boolean} justTest
 */
Narrowphase.prototype[Shape.PLANE | Shape.CONVEX] =
Narrowphase.prototype[Shape.PLANE | Shape.RECTANGLE] =
Narrowphase.prototype.planeConvex = function(
    planeBody,
    planeShape,
    planeOffset,
    planeAngle,
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    justTest
){
    var worldVertex = tmp1,
        worldNormal = tmp2,
        dist = tmp3;

    var numReported = 0;
    vec2.rotate(worldNormal, yAxis, planeAngle);

    for(var i=0; i!==convexShape.vertices.length; i++){
        var v = convexShape.vertices[i];
        vec2.rotate(worldVertex, v, convexAngle);
        add(worldVertex, worldVertex, convexOffset);

        sub(dist, worldVertex, planeOffset);

        if(dot(dist,worldNormal) <= 0){

            if(justTest){
                return true;
            }

            // Found vertex
            numReported++;

            var c = this.createContactEquation(planeBody,convexBody,planeShape,convexShape);

            sub(dist, worldVertex, planeOffset);

            vec2.copy(c.normalA, worldNormal);

            var d = dot(dist, c.normalA);
            vec2.scale(dist, c.normalA, d);

            // rj is from convex center to contact
            sub(c.contactPointB, worldVertex, convexBody.position);


            // ri is from plane center to contact
            sub( c.contactPointA, worldVertex, dist);
            sub( c.contactPointA, c.contactPointA, planeBody.position);

            this.contactEquations.push(c);

            if(!this.enableFrictionReduction){
                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
    }

    if(this.enableFrictionReduction){
        if(this.enableFriction && numReported){
            this.frictionEquations.push(this.createFrictionFromAverage(numReported));
        }
    }

    return numReported;
};

/**
 * Narrowphase for particle vs plane
 * @method particlePlane
 * @param  {Body}       particleBody
 * @param  {Particle}   particleShape
 * @param  {Array}      particleOffset
 * @param  {Number}     particleAngle
 * @param  {Body}       planeBody
 * @param  {Plane}      planeShape
 * @param  {Array}      planeOffset
 * @param  {Number}     planeAngle
 * @param {Boolean}     justTest
 */
Narrowphase.prototype[Shape.PARTICLE | Shape.PLANE] =
Narrowphase.prototype.particlePlane = function(
    particleBody,
    particleShape,
    particleOffset,
    particleAngle,
    planeBody,
    planeShape,
    planeOffset,
    planeAngle,
    justTest
){
    var dist = tmp1,
        worldNormal = tmp2;

    planeAngle = planeAngle || 0;

    sub(dist, particleOffset, planeOffset);
    vec2.rotate(worldNormal, yAxis, planeAngle);

    var d = dot(dist, worldNormal);

    if(d > 0){
        return 0;
    }
    if(justTest){
        return true;
    }

    var c = this.createContactEquation(planeBody,particleBody,planeShape,particleShape);

    vec2.copy(c.normalA, worldNormal);
    vec2.scale( dist, c.normalA, d );
    // dist is now the distance vector in the normal direction

    // ri is the particle position projected down onto the plane, from the plane center
    sub( c.contactPointA, particleOffset, dist);
    sub( c.contactPointA, c.contactPointA, planeBody.position);

    // rj is from the body center to the particle center
    sub( c.contactPointB, particleOffset, particleBody.position );

    this.contactEquations.push(c);

    if(this.enableFriction){
        this.frictionEquations.push(this.createFrictionFromContact(c));
    }
    return 1;
};

/**
 * Circle/Particle Narrowphase
 * @method circleParticle
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} particleBody
 * @param  {Particle} particleShape
 * @param  {Array} particleOffset
 * @param  {Number} particleAngle
 * @param  {Boolean} justTest
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.PARTICLE] =
Narrowphase.prototype.circleParticle = function(
    circleBody,
    circleShape,
    circleOffset,
    circleAngle,
    particleBody,
    particleShape,
    particleOffset,
    particleAngle,
    justTest
){
    var dist = tmp1;

    sub(dist, particleOffset, circleOffset);
    if(vec2.squaredLength(dist) > Math.pow(circleShape.radius, 2)){
        return 0;
    }
    if(justTest){
        return true;
    }

    var c = this.createContactEquation(circleBody,particleBody,circleShape,particleShape);
    vec2.copy(c.normalA, dist);
    vec2.normalize(c.normalA,c.normalA);

    // Vector from circle to contact point is the normal times the circle radius
    vec2.scale(c.contactPointA, c.normalA, circleShape.radius);
    add(c.contactPointA, c.contactPointA, circleOffset);
    sub(c.contactPointA, c.contactPointA, circleBody.position);

    // Vector from particle center to contact point is zero
    sub(c.contactPointB, particleOffset, particleBody.position);

    this.contactEquations.push(c);

    if(this.enableFriction){
        this.frictionEquations.push(this.createFrictionFromContact(c));
    }

    return 1;
};

var planeCapsule_tmpCircle = new Circle(1),
    planeCapsule_tmp1 = vec2.create(),
    planeCapsule_tmp2 = vec2.create(),
    planeCapsule_tmp3 = vec2.create();

/**
 * @method planeCapsule
 * @param  {Body} planeBody
 * @param  {Circle} planeShape
 * @param  {Array} planeOffset
 * @param  {Number} planeAngle
 * @param  {Body} capsuleBody
 * @param  {Particle} capsuleShape
 * @param  {Array} capsuleOffset
 * @param  {Number} capsuleAngle
 * @param {Boolean} justTest
 */
Narrowphase.prototype[Shape.PLANE | Shape.CAPSULE] =
Narrowphase.prototype.planeCapsule = function(
    planeBody,
    planeShape,
    planeOffset,
    planeAngle,
    capsuleBody,
    capsuleShape,
    capsuleOffset,
    capsuleAngle,
    justTest
){
    var end1 = planeCapsule_tmp1,
        end2 = planeCapsule_tmp2,
        circle = planeCapsule_tmpCircle,
        dst = planeCapsule_tmp3;

    // Compute world end positions
    vec2.set(end1, -capsuleShape.length/2, 0);
    vec2.rotate(end1,end1,capsuleAngle);
    add(end1,end1,capsuleOffset);

    vec2.set(end2,  capsuleShape.length/2, 0);
    vec2.rotate(end2,end2,capsuleAngle);
    add(end2,end2,capsuleOffset);

    circle.radius = capsuleShape.radius;

    var enableFrictionBefore;

    // Temporarily turn off friction
    if(this.enableFrictionReduction){
        enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
    }

    // Do Narrowphase as two circles
    var numContacts1 = this.circlePlane(capsuleBody,circle,end1,0, planeBody,planeShape,planeOffset,planeAngle, justTest),
        numContacts2 = this.circlePlane(capsuleBody,circle,end2,0, planeBody,planeShape,planeOffset,planeAngle, justTest);

    // Restore friction
    if(this.enableFrictionReduction){
        this.enableFriction = enableFrictionBefore;
    }

    if(justTest){
        return numContacts1 || numContacts2;
    } else {
        var numTotal = numContacts1 + numContacts2;
        if(this.enableFrictionReduction){
            if(numTotal){
                this.frictionEquations.push(this.createFrictionFromAverage(numTotal));
            }
        }
        return numTotal;
    }
};

/**
 * Creates ContactEquations and FrictionEquations for a collision.
 * @method circlePlane
 * @param  {Body}    bi     The first body that should be connected to the equations.
 * @param  {Circle}  si     The circle shape participating in the collision.
 * @param  {Array}   xi     Extra offset to take into account for the Shape, in addition to the one in circleBody.position. Will *not* be rotated by circleBody.angle (maybe it should, for sake of homogenity?). Set to null if none.
 * @param  {Body}    bj     The second body that should be connected to the equations.
 * @param  {Plane}   sj     The Plane shape that is participating
 * @param  {Array}   xj     Extra offset for the plane shape.
 * @param  {Number}  aj     Extra angle to apply to the plane
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.PLANE] =
Narrowphase.prototype.circlePlane = function(   bi,si,xi,ai, bj,sj,xj,aj, justTest ){
    var circleBody = bi,
        circleShape = si,
        circleOffset = xi, // Offset from body center, rotated!
        planeBody = bj,
        shapeB = sj,
        planeOffset = xj,
        planeAngle = aj;

    planeAngle = planeAngle || 0;

    // Vector from plane to circle
    var planeToCircle = tmp1,
        worldNormal = tmp2,
        temp = tmp3;

    sub(planeToCircle, circleOffset, planeOffset);

    // World plane normal
    vec2.rotate(worldNormal, yAxis, planeAngle);

    // Normal direction distance
    var d = dot(worldNormal, planeToCircle);

    if(d > circleShape.radius){
        return 0; // No overlap. Abort.
    }

    if(justTest){
        return true;
    }

    // Create contact
    var contact = this.createContactEquation(planeBody,circleBody,sj,si);

    // ni is the plane world normal
    vec2.copy(contact.normalA, worldNormal);

    // rj is the vector from circle center to the contact point
    vec2.scale(contact.contactPointB, contact.normalA, -circleShape.radius);
    add(contact.contactPointB, contact.contactPointB, circleOffset);
    sub(contact.contactPointB, contact.contactPointB, circleBody.position);

    // ri is the distance from plane center to contact.
    vec2.scale(temp, contact.normalA, d);
    sub(contact.contactPointA, planeToCircle, temp ); // Subtract normal distance vector from the distance vector
    add(contact.contactPointA, contact.contactPointA, planeOffset);
    sub(contact.contactPointA, contact.contactPointA, planeBody.position);

    this.contactEquations.push(contact);

    if(this.enableFriction){
        this.frictionEquations.push( this.createFrictionFromContact(contact) );
    }

    return 1;
};

/**
 * Convex/convex Narrowphase.See <a href="http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/">this article</a> for more info.
 * @method convexConvex
 * @param  {Body} bi
 * @param  {Convex} si
 * @param  {Array} xi
 * @param  {Number} ai
 * @param  {Body} bj
 * @param  {Convex} sj
 * @param  {Array} xj
 * @param  {Number} aj
 */
Narrowphase.prototype[Shape.CONVEX] =
Narrowphase.prototype[Shape.CONVEX | Shape.RECTANGLE] =
Narrowphase.prototype[Shape.RECTANGLE] =
Narrowphase.prototype.convexConvex = function(  bi,si,xi,ai, bj,sj,xj,aj, justTest, precision ){
    var sepAxis = tmp1,
        worldPoint = tmp2,
        worldPoint0 = tmp3,
        worldPoint1 = tmp4,
        worldEdge = tmp5,
        projected = tmp6,
        penetrationVec = tmp7,
        dist = tmp8,
        worldNormal = tmp9,
        numContacts = 0,
        precision = typeof(precision) === 'number' ? precision : 0;

    var found = Narrowphase.findSeparatingAxis(si,xi,ai,sj,xj,aj,sepAxis);
    if(!found){
        return 0;
    }

    // Make sure the separating axis is directed from shape i to shape j
    sub(dist,xj,xi);
    if(dot(sepAxis,dist) > 0){
        vec2.scale(sepAxis,sepAxis,-1);
    }

    // Find edges with normals closest to the separating axis
    var closestEdge1 = Narrowphase.getClosestEdge(si,ai,sepAxis,true), // Flipped axis
        closestEdge2 = Narrowphase.getClosestEdge(sj,aj,sepAxis);

    if(closestEdge1 === -1 || closestEdge2 === -1){
        return 0;
    }

    // Loop over the shapes
    for(var k=0; k<2; k++){

        var closestEdgeA = closestEdge1,
            closestEdgeB = closestEdge2,
            shapeA =  si, shapeB =  sj,
            offsetA = xi, offsetB = xj,
            angleA = ai, angleB = aj,
            bodyA = bi, bodyB = bj;

        if(k === 0){
            // Swap!
            var tmp;
            tmp = closestEdgeA;
            closestEdgeA = closestEdgeB;
            closestEdgeB = tmp;

            tmp = shapeA;
            shapeA = shapeB;
            shapeB = tmp;

            tmp = offsetA;
            offsetA = offsetB;
            offsetB = tmp;

            tmp = angleA;
            angleA = angleB;
            angleB = tmp;

            tmp = bodyA;
            bodyA = bodyB;
            bodyB = tmp;
        }

        // Loop over 2 points in convex B
        for(var j=closestEdgeB; j<closestEdgeB+2; j++){

            // Get world point
            var v = shapeB.vertices[(j+shapeB.vertices.length)%shapeB.vertices.length];
            vec2.rotate(worldPoint, v, angleB);
            add(worldPoint, worldPoint, offsetB);

            var insideNumEdges = 0;

            // Loop over the 3 closest edges in convex A
            for(var i=closestEdgeA-1; i<closestEdgeA+2; i++){

                var v0 = shapeA.vertices[(i  +shapeA.vertices.length)%shapeA.vertices.length],
                    v1 = shapeA.vertices[(i+1+shapeA.vertices.length)%shapeA.vertices.length];

                // Construct the edge
                vec2.rotate(worldPoint0, v0, angleA);
                vec2.rotate(worldPoint1, v1, angleA);
                add(worldPoint0, worldPoint0, offsetA);
                add(worldPoint1, worldPoint1, offsetA);

                sub(worldEdge, worldPoint1, worldPoint0);

                vec2.rotate90cw(worldNormal, worldEdge); // Normal points out of convex 1
                vec2.normalize(worldNormal,worldNormal);

                sub(dist, worldPoint, worldPoint0);

                var d = dot(worldNormal,dist);

                if((i === closestEdgeA && d <= precision) || (i !== closestEdgeA && d <= 0)){
                    insideNumEdges++;
                }
            }

            if(insideNumEdges >= 3){

                if(justTest){
                    return true;
                }

                // worldPoint was on the "inside" side of each of the 3 checked edges.
                // Project it to the center edge and use the projection direction as normal

                // Create contact
                var c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);
                numContacts++;

                // Get center edge from body A
                var v0 = shapeA.vertices[(closestEdgeA)   % shapeA.vertices.length],
                    v1 = shapeA.vertices[(closestEdgeA+1) % shapeA.vertices.length];

                // Construct the edge
                vec2.rotate(worldPoint0, v0, angleA);
                vec2.rotate(worldPoint1, v1, angleA);
                add(worldPoint0, worldPoint0, offsetA);
                add(worldPoint1, worldPoint1, offsetA);

                sub(worldEdge, worldPoint1, worldPoint0);

                vec2.rotate90cw(c.normalA, worldEdge); // Normal points out of convex A
                vec2.normalize(c.normalA,c.normalA);

                sub(dist, worldPoint, worldPoint0); // From edge point to the penetrating point
                var d = dot(c.normalA,dist);             // Penetration
                vec2.scale(penetrationVec, c.normalA, d);     // Vector penetration

                sub(c.contactPointA, worldPoint, offsetA);
                sub(c.contactPointA, c.contactPointA, penetrationVec);
                add(c.contactPointA, c.contactPointA, offsetA);
                sub(c.contactPointA, c.contactPointA, bodyA.position);

                sub(c.contactPointB, worldPoint, offsetB);
                add(c.contactPointB, c.contactPointB, offsetB);
                sub(c.contactPointB, c.contactPointB, bodyB.position);

                this.contactEquations.push(c);

                // Todo reduce to 1 friction equation if we have 2 contact points
                if(!this.enableFrictionReduction){
                    if(this.enableFriction){
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                }
            }
        }
    }

    if(this.enableFrictionReduction){
        if(this.enableFriction && numContacts){
            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        }
    }

    return numContacts;
};

// .projectConvex is called by other functions, need local tmp vectors
var pcoa_tmp1 = vec2.fromValues(0,0);

/**
 * Project a Convex onto a world-oriented axis
 * @method projectConvexOntoAxis
 * @static
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param  {Array} worldAxis
 * @param  {Array} result
 */
Narrowphase.projectConvexOntoAxis = function(convexShape, convexOffset, convexAngle, worldAxis, result){
    var max=null,
        min=null,
        v,
        value,
        localAxis = pcoa_tmp1;

    // Convert the axis to local coords of the body
    vec2.rotate(localAxis, worldAxis, -convexAngle);

    // Get projected position of all vertices
    for(var i=0; i<convexShape.vertices.length; i++){
        v = convexShape.vertices[i];
        value = dot(v,localAxis);
        if(max === null || value > max){
            max = value;
        }
        if(min === null || value < min){
            min = value;
        }
    }

    if(min > max){
        var t = min;
        min = max;
        max = t;
    }

    // Project the position of the body onto the axis - need to add this to the result
    var offset = dot(convexOffset, worldAxis);

    vec2.set( result, min + offset, max + offset);
};

// .findSeparatingAxis is called by other functions, need local tmp vectors
var fsa_tmp1 = vec2.fromValues(0,0)
,   fsa_tmp2 = vec2.fromValues(0,0)
,   fsa_tmp3 = vec2.fromValues(0,0)
,   fsa_tmp4 = vec2.fromValues(0,0)
,   fsa_tmp5 = vec2.fromValues(0,0)
,   fsa_tmp6 = vec2.fromValues(0,0);

/**
 * Find a separating axis between the shapes, that maximizes the separating distance between them.
 * @method findSeparatingAxis
 * @static
 * @param  {Convex}     c1
 * @param  {Array}      offset1
 * @param  {Number}     angle1
 * @param  {Convex}     c2
 * @param  {Array}      offset2
 * @param  {Number}     angle2
 * @param  {Array}      sepAxis     The resulting axis
 * @return {Boolean}                Whether the axis could be found.
 */
Narrowphase.findSeparatingAxis = function(c1,offset1,angle1,c2,offset2,angle2,sepAxis){
    var maxDist = null,
        overlap = false,
        found = false,
        edge = fsa_tmp1,
        worldPoint0 = fsa_tmp2,
        worldPoint1 = fsa_tmp3,
        normal = fsa_tmp4,
        span1 = fsa_tmp5,
        span2 = fsa_tmp6;

    if(c1 instanceof Rectangle && c2 instanceof Rectangle){

        for(var j=0; j!==2; j++){
            var c = c1,
                angle = angle1;
            if(j===1){
                c = c2;
                angle = angle2;
            }

            for(var i=0; i!==2; i++){

                // Get the world edge
                if(i === 0){
                    vec2.set(normal, 0, 1);
                } else if(i === 1) {
                    vec2.set(normal, 1, 0);
                }
                if(angle !== 0){
                    vec2.rotate(normal, normal, angle);
                }

                // Project hulls onto that normal
                Narrowphase.projectConvexOntoAxis(c1,offset1,angle1,normal,span1);
                Narrowphase.projectConvexOntoAxis(c2,offset2,angle2,normal,span2);

                // Order by span position
                var a=span1,
                    b=span2,
                    swapped = false;
                if(span1[0] > span2[0]){
                    b=span1;
                    a=span2;
                    swapped = true;
                }

                // Get separating distance
                var dist = b[0] - a[1];
                overlap = (dist <= 0);

                if(maxDist===null || dist > maxDist){
                    vec2.copy(sepAxis, normal);
                    maxDist = dist;
                    found = overlap;
                }
            }
        }

    } else {

        for(var j=0; j!==2; j++){
            var c = c1,
                angle = angle1;
            if(j===1){
                c = c2;
                angle = angle2;
            }

            for(var i=0; i!==c.vertices.length; i++){
                // Get the world edge
                vec2.rotate(worldPoint0, c.vertices[i], angle);
                vec2.rotate(worldPoint1, c.vertices[(i+1)%c.vertices.length], angle);

                sub(edge, worldPoint1, worldPoint0);

                // Get normal - just rotate 90 degrees since vertices are given in CCW
                vec2.rotate90cw(normal, edge);
                vec2.normalize(normal,normal);

                // Project hulls onto that normal
                Narrowphase.projectConvexOntoAxis(c1,offset1,angle1,normal,span1);
                Narrowphase.projectConvexOntoAxis(c2,offset2,angle2,normal,span2);

                // Order by span position
                var a=span1,
                    b=span2,
                    swapped = false;
                if(span1[0] > span2[0]){
                    b=span1;
                    a=span2;
                    swapped = true;
                }

                // Get separating distance
                var dist = b[0] - a[1];
                overlap = (dist <= 0);

                if(maxDist===null || dist > maxDist){
                    vec2.copy(sepAxis, normal);
                    maxDist = dist;
                    found = overlap;
                }
            }
        }
    }


    /*
    // Needs to be tested some more
    for(var j=0; j!==2; j++){
        var c = c1,
            angle = angle1;
        if(j===1){
            c = c2;
            angle = angle2;
        }

        for(var i=0; i!==c.axes.length; i++){

            var normal = c.axes[i];

            // Project hulls onto that normal
            Narrowphase.projectConvexOntoAxis(c1, offset1, angle1, normal, span1);
            Narrowphase.projectConvexOntoAxis(c2, offset2, angle2, normal, span2);

            // Order by span position
            var a=span1,
                b=span2,
                swapped = false;
            if(span1[0] > span2[0]){
                b=span1;
                a=span2;
                swapped = true;
            }

            // Get separating distance
            var dist = b[0] - a[1];
            overlap = (dist <= Narrowphase.convexPrecision);

            if(maxDist===null || dist > maxDist){
                vec2.copy(sepAxis, normal);
                maxDist = dist;
                found = overlap;
            }
        }
    }
    */

    return found;
};

// .getClosestEdge is called by other functions, need local tmp vectors
var gce_tmp1 = vec2.fromValues(0,0)
,   gce_tmp2 = vec2.fromValues(0,0)
,   gce_tmp3 = vec2.fromValues(0,0);

/**
 * Get the edge that has a normal closest to an axis.
 * @method getClosestEdge
 * @static
 * @param  {Convex}     c
 * @param  {Number}     angle
 * @param  {Array}      axis
 * @param  {Boolean}    flip
 * @return {Number}             Index of the edge that is closest. This index and the next spans the resulting edge. Returns -1 if failed.
 */
Narrowphase.getClosestEdge = function(c,angle,axis,flip){
    var localAxis = gce_tmp1,
        edge = gce_tmp2,
        normal = gce_tmp3;

    // Convert the axis to local coords of the body
    vec2.rotate(localAxis, axis, -angle);
    if(flip){
        vec2.scale(localAxis,localAxis,-1);
    }

    var closestEdge = -1,
        N = c.vertices.length,
        maxDot = -1;
    for(var i=0; i!==N; i++){
        // Get the edge
        sub(edge, c.vertices[(i+1)%N], c.vertices[i%N]);

        // Get normal - just rotate 90 degrees since vertices are given in CCW
        vec2.rotate90cw(normal, edge);
        vec2.normalize(normal,normal);

        var d = dot(normal,localAxis);
        if(closestEdge === -1 || d > maxDot){
            closestEdge = i % N;
            maxDot = d;
        }
    }

    return closestEdge;
};

var circleHeightfield_candidate = vec2.create(),
    circleHeightfield_dist = vec2.create(),
    circleHeightfield_v0 = vec2.create(),
    circleHeightfield_v1 = vec2.create(),
    circleHeightfield_minCandidate = vec2.create(),
    circleHeightfield_worldNormal = vec2.create(),
    circleHeightfield_minCandidateNormal = vec2.create();

/**
 * @method circleHeightfield
 * @param  {Body}           bi
 * @param  {Circle}         si
 * @param  {Array}          xi
 * @param  {Body}           bj
 * @param  {Heightfield}    sj
 * @param  {Array}          xj
 * @param  {Number}         aj
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.HEIGHTFIELD] =
Narrowphase.prototype.circleHeightfield = function( circleBody,circleShape,circlePos,circleAngle,
                                                    hfBody,hfShape,hfPos,hfAngle, justTest, radius ){
    var data = hfShape.data,
        radius = radius || circleShape.radius,
        w = hfShape.elementWidth,
        dist = circleHeightfield_dist,
        candidate = circleHeightfield_candidate,
        minCandidate = circleHeightfield_minCandidate,
        minCandidateNormal = circleHeightfield_minCandidateNormal,
        worldNormal = circleHeightfield_worldNormal,
        v0 = circleHeightfield_v0,
        v1 = circleHeightfield_v1;

    // Get the index of the points to test against
    var idxA = Math.floor( (circlePos[0] - radius - hfPos[0]) / w ),
        idxB = Math.ceil(  (circlePos[0] + radius - hfPos[0]) / w );

    /*if(idxB < 0 || idxA >= data.length)
        return justTest ? false : 0;*/

    if(idxA < 0){
        idxA = 0;
    }
    if(idxB >= data.length){
        idxB = data.length-1;
    }

    // Get max and min
    var max = data[idxA],
        min = data[idxB];
    for(var i=idxA; i<idxB; i++){
        if(data[i] < min){
            min = data[i];
        }
        if(data[i] > max){
            max = data[i];
        }
    }

    if(circlePos[1]-radius > max){
        return justTest ? false : 0;
    }

    /*
    if(circlePos[1]+radius < min){
        // Below the minimum point... We can just guess.
        // TODO
    }
    */

    // 1. Check so center of circle is not inside the field. If it is, this wont work...
    // 2. For each edge
    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
    // 2. 2. Check if point is inside.

    var found = false;

    // Check all edges first
    for(var i=idxA; i<idxB; i++){

        // Get points
        vec2.set(v0,     i*w, data[i]  );
        vec2.set(v1, (i+1)*w, data[i+1]);
        vec2.add(v0,v0,hfPos);
        vec2.add(v1,v1,hfPos);

        // Get normal
        vec2.sub(worldNormal, v1, v0);
        vec2.rotate(worldNormal, worldNormal, Math.PI/2);
        vec2.normalize(worldNormal,worldNormal);

        // Get point on circle, closest to the edge
        vec2.scale(candidate,worldNormal,-radius);
        vec2.add(candidate,candidate,circlePos);

        // Distance from v0 to the candidate point
        vec2.sub(dist,candidate,v0);

        // Check if it is in the element "stick"
        var d = vec2.dot(dist,worldNormal);
        if(candidate[0] >= v0[0] && candidate[0] < v1[0] && d <= 0){

            if(justTest){
                return true;
            }

            found = true;

            // Store the candidate point, projected to the edge
            vec2.scale(dist,worldNormal,-d);
            vec2.add(minCandidate,candidate,dist);
            vec2.copy(minCandidateNormal,worldNormal);

            var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);

            // Normal is out of the heightfield
            vec2.copy(c.normalA, minCandidateNormal);

            // Vector from circle to heightfield
            vec2.scale(c.contactPointB,  c.normalA, -radius);
            add(c.contactPointB, c.contactPointB, circlePos);
            sub(c.contactPointB, c.contactPointB, circleBody.position);

            vec2.copy(c.contactPointA, minCandidate);
            vec2.sub(c.contactPointA, c.contactPointA, hfBody.position);

            this.contactEquations.push(c);

            if(this.enableFriction){
                this.frictionEquations.push( this.createFrictionFromContact(c) );
            }
        }
    }

    // Check all vertices
    found = false;
    if(radius > 0){
        for(var i=idxA; i<=idxB; i++){

            // Get point
            vec2.set(v0, i*w, data[i]);
            vec2.add(v0,v0,hfPos);

            vec2.sub(dist, circlePos, v0);

            if(vec2.squaredLength(dist) < Math.pow(radius, 2)){

                if(justTest){
                    return true;
                }

                found = true;

                var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);

                // Construct normal - out of heightfield
                vec2.copy(c.normalA, dist);
                vec2.normalize(c.normalA,c.normalA);

                vec2.scale(c.contactPointB, c.normalA, -radius);
                add(c.contactPointB, c.contactPointB, circlePos);
                sub(c.contactPointB, c.contactPointB, circleBody.position);

                sub(c.contactPointA, v0, hfPos);
                add(c.contactPointA, c.contactPointA, hfPos);
                sub(c.contactPointA, c.contactPointA, hfBody.position);

                this.contactEquations.push(c);

                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
    }

    if(found){
        return 1;
    }

    return 0;

};

var convexHeightfield_v0 = vec2.create(),
    convexHeightfield_v1 = vec2.create(),
    convexHeightfield_tilePos = vec2.create(),
    convexHeightfield_tempConvexShape = new Convex([vec2.create(),vec2.create(),vec2.create(),vec2.create()]);
/**
 * @method circleHeightfield
 * @param  {Body}           bi
 * @param  {Circle}         si
 * @param  {Array}          xi
 * @param  {Body}           bj
 * @param  {Heightfield}    sj
 * @param  {Array}          xj
 * @param  {Number}         aj
 */
Narrowphase.prototype[Shape.RECTANGLE | Shape.HEIGHTFIELD] =
Narrowphase.prototype[Shape.CONVEX | Shape.HEIGHTFIELD] =
Narrowphase.prototype.convexHeightfield = function( convexBody,convexShape,convexPos,convexAngle,
                                                    hfBody,hfShape,hfPos,hfAngle, justTest ){
    var data = hfShape.data,
        w = hfShape.elementWidth,
        v0 = convexHeightfield_v0,
        v1 = convexHeightfield_v1,
        tilePos = convexHeightfield_tilePos,
        tileConvex = convexHeightfield_tempConvexShape;

    // Get the index of the points to test against
    var idxA = Math.floor( (convexBody.aabb.lowerBound[0] - hfPos[0]) / w ),
        idxB = Math.ceil(  (convexBody.aabb.upperBound[0] - hfPos[0]) / w );

    if(idxA < 0){
        idxA = 0;
    }
    if(idxB >= data.length){
        idxB = data.length-1;
    }

    // Get max and min
    var max = data[idxA],
        min = data[idxB];
    for(var i=idxA; i<idxB; i++){
        if(data[i] < min){
            min = data[i];
        }
        if(data[i] > max){
            max = data[i];
        }
    }

    if(convexBody.aabb.lowerBound[1] > max){
        return justTest ? false : 0;
    }

    var found = false;
    var numContacts = 0;

    // Loop over all edges
    // TODO: If possible, construct a convex from several data points (need o check if the points make a convex shape)
    for(var i=idxA; i<idxB; i++){

        // Get points
        vec2.set(v0,     i*w, data[i]  );
        vec2.set(v1, (i+1)*w, data[i+1]);
        vec2.add(v0,v0,hfPos);
        vec2.add(v1,v1,hfPos);

        // Construct a convex
        var tileHeight = 100; // todo
        vec2.set(tilePos, (v1[0] + v0[0])*0.5, (v1[1] + v0[1] - tileHeight)*0.5);

        vec2.sub(tileConvex.vertices[0], v1, tilePos);
        vec2.sub(tileConvex.vertices[1], v0, tilePos);
        vec2.copy(tileConvex.vertices[2], tileConvex.vertices[1]);
        vec2.copy(tileConvex.vertices[3], tileConvex.vertices[0]);
        tileConvex.vertices[2][1] -= tileHeight;
        tileConvex.vertices[3][1] -= tileHeight;

        // Do convex collision
        numContacts += this.convexConvex(   convexBody, convexShape, convexPos, convexAngle,
                                            hfBody, tileConvex, tilePos, 0, justTest);
    }

    return numContacts;
};
},{"../equations/ContactEquation":22,"../equations/Equation":23,"../equations/FrictionEquation":24,"../math/vec2":31,"../objects/Body":32,"../shapes/Circle":38,"../shapes/Convex":39,"../shapes/Rectangle":44,"../shapes/Shape":45,"../utils/TupleDictionary":49,"../utils/Utils":50}],12:[function(_dereq_,module,exports){
module.exports = Ray;

var vec2 = _dereq_('../math/vec2');
var RaycastResult = _dereq_('../collision/RaycastResult');
var Shape = _dereq_('../shapes/Shape');
var AABB = _dereq_('../collision/AABB');

/**
 * A line with a start and end point that is used to intersect shapes.
 * @class Ray
 * @constructor
 */
function Ray(options){
    options = options || {};

    /**
     * @property {array} from
     */
    this.from = options.from ? vec2.fromValues(options.from[0], options.from[1]) : vec2.create();

    /**
     * @property {array} to
     */
    this.to = options.to ? vec2.fromValues(options.to[0], options.to[1]) : vec2.create();

    /**
     * @private
     * @property {array} _direction
     */
    this._direction = vec2.create();

    /**
     * The precision of the ray. Used when checking parallelity etc.
     * @property {Number} precision
     */
    this.precision = 0.0001;

    /**
     * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.
     * @property {Boolean} checkCollisionResponse
     */
    this.checkCollisionResponse = true;

    /**
     * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.
     * @property {Boolean} skipBackfaces
     */
    this.skipBackfaces = false;

    /**
     * @property {number} collisionMask
     * @default -1
     */
    this.collisionMask = -1;

    /**
     * @property {number} collisionGroup
     * @default -1
     */
    this.collisionGroup = -1;

    /**
     * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
     * @property {number} mode
     */
    this.mode = Ray.ANY;

    /**
     * Current result object.
     * @property {RaycastResult} result
     */
    this.result = new RaycastResult();

    /**
     * Will be set to true during intersectWorld() if the ray hit anything.
     * @property {Boolean} hasHit
     */
    this.hasHit = false;

    /**
     * Current, user-provided result callback. Will be used if mode is Ray.ALL.
     * @property {Function} callback
     */
    this.callback = function(result){};
}
Ray.prototype.constructor = Ray;

Ray.CLOSEST = 1;
Ray.ANY = 2;
Ray.ALL = 4;

var tmpAABB = new AABB();
var tmpArray = [];

/**
 * Do itersection against all bodies in the given World.
 * @method intersectWorld
 * @param  {World} world
 * @param  {object} options
 * @return {Boolean} True if the ray hit anything, otherwise false.
 */
Ray.prototype.intersectWorld = function (world, options) {
    this.mode = options.mode || Ray.ANY;
    this.result = options.result || new RaycastResult();
    this.skipBackfaces = !!options.skipBackfaces;
    this.collisionMask = typeof(options.collisionMask) !== 'undefined' ? options.collisionMask : -1;
    this.collisionGroup = typeof(options.collisionGroup) !== 'undefined' ? options.collisionGroup : -1;
    if(options.from){
        vec2.copy(this.from, options.from);
    }
    if(options.to){
        vec2.copy(this.to, options.to);
    }
    this.callback = options.callback || function(){};
    this.hasHit = false;

    this.result.reset();
    this._updateDirection();

    this.getAABB(tmpAABB);
    tmpArray.length = 0;
    world.broadphase.aabbQuery(world, tmpAABB, tmpArray);
    this.intersectBodies(tmpArray);

    return this.hasHit;
};

var v1 = vec2.create(),
    v2 = vec2.create();

var intersectBody_worldPosition = vec2.create();

/**
 * Shoot a ray at a body, get back information about the hit.
 * @method intersectBody
 * @private
 * @param {Body} body
 * @param {RaycastResult} [result] Deprecated - set the result property of the Ray instead.
 */
Ray.prototype.intersectBody = function (body, result) {

    if(result){
        this.result = result;
        this._updateDirection();
    }
    var checkCollisionResponse = this.checkCollisionResponse;

    if(checkCollisionResponse && !body.collisionResponse){
        return;
    }

    // if((this.collisionGroup & body.collisionMask)===0 || (body.collisionGroup & this.collisionMask)===0){
    //     return;
    // }

    var worldPosition = intersectBody_worldPosition;

    for (var i = 0, N = body.shapes.length; i < N; i++) {
        var shape = body.shapes[i];

        if(checkCollisionResponse && !shape.collisionResponse){
            continue; // Skip
        }

        // Get world angle and position of the shape
        vec2.copy(worldPosition, body.shapeOffsets[i]);
        vec2.rotate(worldPosition, worldPosition, body.angle);
        vec2.add(worldPosition, worldPosition, body.position);
        var worldAngle = body.shapeAngles[i] + body.angle;

        this.intersectShape(
            shape,
            worldAngle,
            worldPosition,
            body
        );

        if(this.result._shouldStop){
            break;
        }
    }
};

/**
 * @method intersectBodies
 * @param {Array} bodies An array of Body objects.
 * @param {RaycastResult} [result] Deprecated
 */
Ray.prototype.intersectBodies = function (bodies, result) {
    if(result){
        this.result = result;
        this._updateDirection();
    }

    for ( var i = 0, l = bodies.length; !this.result._shouldStop && i < l; i ++ ) {
        this.intersectBody(bodies[i]);
    }
};

/**
 * Updates the _direction vector.
 * @private
 * @method _updateDirection
 */
Ray.prototype._updateDirection = function(){
    var d = this._direction;
    vec2.sub(d, this.to, this.from); // this.to.vsub(this.from, this._direction);
    vec2.normalize(d, d); // this._direction.normalize();
};

/**
 * @method intersectShape
 * @private
 * @param {Shape} shape
 * @param {number} angle
 * @param {array} position
 * @param {Body} body
 */
Ray.prototype.intersectShape = function(shape, angle, position, body){
    var from = this.from;


    // Checking boundingSphere
    var distance = distanceFromIntersection(from, this._direction, position);
    if ( distance > shape.boundingSphereRadius ) {
        return;
    }

    var method = this[shape.type];
    if(method){
        method.call(this, shape, angle, position, body);
    }
};

var vector = vec2.create();
var normal = vec2.create();
var intersectPoint = vec2.create();

var a = vec2.create();
var b = vec2.create();
var c = vec2.create();
var d = vec2.create();

var tmpRaycastResult = new RaycastResult();
var intersectRectangle_direction = vec2.create();
var intersectRectangle_rayStart = vec2.create();
var intersectRectangle_worldNormalMin = vec2.create();
var intersectRectangle_worldNormalMax = vec2.create();
var intersectRectangle_hitPointWorld = vec2.create();
var intersectRectangle_boxMin = vec2.create();
var intersectRectangle_boxMax = vec2.create();

/**
 * @method intersectRectangle
 * @private
 * @param  {Shape} shape
 * @param  {number} angle
 * @param  {array} position
 * @param  {Body} body
 */
Ray.prototype.intersectRectangle = function(shape, angle, position, body){
    var tmin = -Number.MAX_VALUE;
    var tmax = Number.MAX_VALUE;

    var direction = intersectRectangle_direction;
    var rayStart = intersectRectangle_rayStart;
    var worldNormalMin = intersectRectangle_worldNormalMin;
    var worldNormalMax = intersectRectangle_worldNormalMax;
    var hitPointWorld = intersectRectangle_hitPointWorld;
    var boxMin = intersectRectangle_boxMin;
    var boxMax = intersectRectangle_boxMax;

    vec2.set(boxMin, -shape.width * 0.5, -shape.height * 0.5);
    vec2.set(boxMax, shape.width * 0.5, shape.height * 0.5);

    // Transform the ray direction and start to local space
    vec2.rotate(direction, this._direction, -angle);
    body.toLocalFrame(rayStart, this.from);

    if (direction[0] !== 0) {
        var tx1 = (boxMin[0] - rayStart[0]) / direction[0];
        var tx2 = (boxMax[0] - rayStart[0]) / direction[0];

        var tminOld = tmin;
        tmin = Math.max(tmin, Math.min(tx1, tx2));
        if(tmin !== tminOld){
            vec2.set(worldNormalMin, tx1 > tx2 ? 1 : -1, 0);
        }

        var tmaxOld = tmax;
        tmax = Math.min(tmax, Math.max(tx1, tx2));
        if(tmax !== tmaxOld){
            vec2.set(worldNormalMax, tx1 < tx2 ? 1 : -1, 0);
        }
    }

    if (direction[1] !== 0) {
        var ty1 = (boxMin[1] - rayStart[1]) / direction[1];
        var ty2 = (boxMax[1] - rayStart[1]) / direction[1];

        var tminOld = tmin;
        tmin = Math.max(tmin, Math.min(ty1, ty2));
        if(tmin !== tminOld){
            vec2.set(worldNormalMin, 0, ty1 > ty2 ? 1 : -1);
        }

        var tmaxOld = tmax;
        tmax = Math.min(tmax, Math.max(ty1, ty2));
        if(tmax !== tmaxOld){
            vec2.set(worldNormalMax, 0, ty1 < ty2 ? 1 : -1);
        }
    }

    if(tmax >= tmin){
        // Hit point
        vec2.set(
            hitPointWorld,
            rayStart[0] + direction[0] * tmin,
            rayStart[1] + direction[1] * tmin
        );

        vec2.rotate(worldNormalMin, worldNormalMin, angle);

        body.toWorldFrame(hitPointWorld, hitPointWorld);

        this.reportIntersection(worldNormalMin, hitPointWorld, shape, body, -1);
        if(this._shouldStop){
            return;
        }

        vec2.rotate(worldNormalMax, worldNormalMax, angle);

        // Hit point
        vec2.set(
            hitPointWorld,
            rayStart[0] + direction[0] * tmax,
            rayStart[1] + direction[1] * tmax
        );
        body.toWorldFrame(hitPointWorld, hitPointWorld);

        this.reportIntersection(worldNormalMax, hitPointWorld, shape, body, -1);
    }
};
Ray.prototype[Shape.RECTANGLE] = Ray.prototype.intersectRectangle;

var intersectPlane_planePointToFrom = vec2.create();
var intersectPlane_dir_scaled_with_t = vec2.create();
var intersectPlane_hitPointWorld = vec2.create();
var intersectPlane_worldNormal = vec2.create();
var intersectPlane_len = vec2.create();

/**
 * @method intersectPlane
 * @private
 * @param  {Shape} shape
 * @param  {number} angle
 * @param  {array} position
 * @param  {Body} body
 */
Ray.prototype.intersectPlane = function(shape, angle, position, body){
    var from = this.from;
    var to = this.to;
    var direction = this._direction;

    var planePointToFrom = intersectPlane_planePointToFrom;
    var dir_scaled_with_t = intersectPlane_dir_scaled_with_t;
    var hitPointWorld = intersectPlane_hitPointWorld;
    var worldNormal = intersectPlane_worldNormal;
    var len = intersectPlane_len;

    // Get plane normal
    vec2.set(worldNormal, 0, 1);
    vec2.rotate(worldNormal, worldNormal, angle);

    vec2.sub(len, from, position); //from.vsub(position, len);
    var planeToFrom = vec2.dot(len, worldNormal); // len.dot(worldNormal);
    vec2.sub(len, to, position); // to.vsub(position, len);
    var planeToTo = vec2.dot(len, worldNormal); // len.dot(worldNormal);

    if(planeToFrom * planeToTo > 0){
        // "from" and "to" are on the same side of the plane... bail out
        return;
    }

    if(vec2.distance(from, to) /* from.distanceTo(to) */ < planeToFrom){
        return;
    }

    var n_dot_dir = vec2.dot(worldNormal, direction); // worldNormal.dot(direction);

    // if (Math.abs(n_dot_dir) < this.precision) {
    //     // No intersection
    //     return;
    // }

    vec2.sub(planePointToFrom, from, position); // from.vsub(position, planePointToFrom);
    var t = -vec2.dot(worldNormal, planePointToFrom) / n_dot_dir; // - worldNormal.dot(planePointToFrom) / n_dot_dir;
    vec2.scale(dir_scaled_with_t, direction, t); // direction.scale(t, dir_scaled_with_t);
    vec2.add(hitPointWorld, from, dir_scaled_with_t); // from.vadd(dir_scaled_with_t, hitPointWorld);

    this.reportIntersection(worldNormal, hitPointWorld, shape, body, -1);
};
Ray.prototype[Shape.PLANE] = Ray.prototype.intersectPlane;

var Ray_intersectSphere_intersectionPoint = vec2.create();
var Ray_intersectSphere_normal = vec2.create();
Ray.prototype.intersectCircle = function(shape, angle, position, body){
    var from = this.from,
        to = this.to,
        r = shape.radius;

    var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
    var b = 2 * ((to[0] - from[0]) * (from[0] - position[0]) + (to[1] - from[1]) * (from[1] - position[1]));
    var c = Math.pow(from[0] - position[0], 2) + Math.pow(from[1] - position[1], 2) - Math.pow(r, 2);

    var delta = Math.pow(b, 2) - 4 * a * c;

    var intersectionPoint = Ray_intersectSphere_intersectionPoint;
    var normal = Ray_intersectSphere_normal;

    if(delta < 0){
        // No intersection
        return;

    } else if(delta === 0){
        // single intersection point
        vec2.lerp(intersectionPoint, from, to, delta); // from.lerp(to, delta, intersectionPoint);

        vec2.sub(normal, intersectionPoint, position); // intersectionPoint.vsub(position, normal);
        vec2.normalize(normal,normal); //normal.normalize();

        this.reportIntersection(normal, intersectionPoint, shape, body, -1);

    } else {
        var d1 = (- b - Math.sqrt(delta)) / (2 * a);
        var d2 = (- b + Math.sqrt(delta)) / (2 * a);

        vec2.lerp(intersectionPoint, from, to, d1); // from.lerp(to, d1, intersectionPoint);

        vec2.sub(normal, intersectionPoint, position); // intersectionPoint.vsub(position, normal);
        vec2.normalize(normal,normal); //normal.normalize();

        this.reportIntersection(normal, intersectionPoint, shape, body, -1);

        if(this.result._shouldStop){
            return;
        }

        vec2.lerp(intersectionPoint, from, to, d2); // from.lerp(to, d2, intersectionPoint);

        vec2.sub(normal, intersectionPoint, position); // intersectionPoint.vsub(position, normal);
        vec2.normalize(normal,normal); //normal.normalize();

        this.reportIntersection(normal, intersectionPoint, shape, body, -1);
    }
};
Ray.prototype[Shape.CIRCLE] = Ray.prototype.intersectCircle;

/**
 * Get the AABB of the ray.
 * @method getAABB
 * @param  {AABB} aabb
 */
Ray.prototype.getAABB = function(result){
    var to = this.to;
    var from = this.from;
    result.lowerBound[0] = Math.min(to[0], from[0]);
    result.lowerBound[1] = Math.min(to[1], from[1]);
    result.upperBound[0] = Math.max(to[0], from[0]);
    result.upperBound[1] = Math.max(to[1], from[1]);
};

/**
 * @method reportIntersection
 * @private
 * @param  {array} normal
 * @param  {array} hitPointWorld
 * @param  {Shape} shape
 * @param  {Body} body
 * @return {boolean} True if the intersections should continue
 */
Ray.prototype.reportIntersection = function(normal, hitPointWorld, shape, body, hitFaceIndex){
    var from = this.from;
    var to = this.to;
    var distance = vec2.distance(from, hitPointWorld); // from.distanceTo(hitPointWorld);
    var result = this.result;

    // Skip back faces?
    if(this.skipBackfaces && /* normal.dot(this._direction) */ vec2.dot(normal, this._direction) > 0){
        return;
    }

    result.hitFaceIndex = typeof(hitFaceIndex) !== 'undefined' ? hitFaceIndex : -1;

    switch(this.mode){
    case Ray.ALL:
        this.hasHit = true;
        result.set(
            from,
            to,
            normal,
            hitPointWorld,
            shape,
            body,
            distance
        );
        result.hasHit = true;
        this.callback(result);
        break;

    case Ray.CLOSEST:

        // Store if closer than current closest
        if(distance < result.distance || !result.hasHit){
            this.hasHit = true;
            result.hasHit = true;
            result.set(
                from,
                to,
                normal,
                hitPointWorld,
                shape,
                body,
                distance
            );
        }
        break;

    case Ray.ANY:

        // Report and stop.
        this.hasHit = true;
        result.hasHit = true;
        result.set(
            from,
            to,
            normal,
            hitPointWorld,
            shape,
            body,
            distance
        );
        result._shouldStop = true;
        break;
    }
};

var v0 = vec2.create(),
    intersect = vec2.create();
function distanceFromIntersection(from, direction, position) {

    // v0 is vector from from to position
    vec2.sub(v0, position, from); // position.vsub(from,v0);
    var dot = vec2.dot(v0, direction); // v0.dot(direction);

    // intersect = direction*dot + from
    vec2.scale(intersect, direction, dot); //direction.mult(dot,intersect);
    vec2.add(intersect, intersect, from); // intersect.vadd(from, intersect);

    var distance = vec2.distance(position, intersect); // position.distanceTo(intersect);

    return distance;
}


},{"../collision/AABB":7,"../collision/RaycastResult":13,"../math/vec2":31,"../shapes/Shape":45}],13:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');

module.exports = RaycastResult;

/**
 * Storage for Ray casting data.
 * @class RaycastResult
 * @constructor
 */
function RaycastResult(){

	/**
	 * @property {array} rayFromWorld
	 */
	this.rayFromWorld = vec2.create();

	/**
	 * @property {array} rayToWorld
	 */
	this.rayToWorld = vec2.create();

	/**
	 * @property {array} hitNormalWorld
	 */
	this.hitNormalWorld = vec2.create();

	/**
	 * @property {array} hitPointWorld
	 */
	this.hitPointWorld = vec2.create();

	/**
	 * @property {boolean} hasHit
	 */
	this.hasHit = false;

	/**
	 * The hit shape, or null.
	 * @property {Shape} shape
	 */
	this.shape = null;

	/**
	 * The hit body, or null.
	 * @property {Body} body
	 */
	this.body = null;

	/**
	 * The index of the hit triangle, if the hit shape was a trimesh.
	 * @property {number} hitFaceIndex
	 * @default -1
	 */
	this.hitFaceIndex = -1;

	/**
	 * Distance to the hit. Will be set to -1 if there was no hit.
	 * @property {number} distance
	 * @default -1
	 */
	this.distance = -1;

	/**
	 * If the ray should stop traversing the bodies.
	 * @private
	 * @property {Boolean} _shouldStop
	 * @default false
	 */
	this._shouldStop = false;
}

/**
 * Reset all result data.
 * @method reset
 */
RaycastResult.prototype.reset = function () {
	vec2.set(this.rayFromWorld, 0, 0);
	vec2.set(this.rayToWorld, 0, 0);
	vec2.set(this.hitNormalWorld, 0, 0);
	vec2.set(this.hitPointWorld, 0, 0);
	this.hasHit = false;
	this.shape = null;
	this.body = null;
	this.hitFaceIndex = -1;
	this.distance = -1;
	this._shouldStop = false;
};

/**
 * @method abort
 */
RaycastResult.prototype.abort = function(){
	this._shouldStop = true;
};

/**
 * @method set
 * @param {array} rayFromWorld
 * @param {array} rayToWorld
 * @param {array} hitNormalWorld
 * @param {array} hitPointWorld
 * @param {Shape} shape
 * @param {Body} body
 * @param {number} distance
 */
RaycastResult.prototype.set = function(
	rayFromWorld,
	rayToWorld,
	hitNormalWorld,
	hitPointWorld,
	shape,
	body,
	distance
){
	vec2.copy(this.rayFromWorld, rayFromWorld);
	vec2.copy(this.rayToWorld, rayToWorld);
	vec2.copy(this.hitNormalWorld, hitNormalWorld);
	vec2.copy(this.hitPointWorld, hitPointWorld);
	this.shape = shape;
	this.body = body;
	this.distance = distance;
};
},{"../math/vec2":31}],14:[function(_dereq_,module,exports){
var Utils = _dereq_('../utils/Utils')
,   Broadphase = _dereq_('../collision/Broadphase');

module.exports = SAPBroadphase;

/**
 * Sweep and prune broadphase along one axis.
 *
 * @class SAPBroadphase
 * @constructor
 * @extends Broadphase
 */
function SAPBroadphase(){
    Broadphase.call(this,Broadphase.SAP);

    /**
     * List of bodies currently in the broadphase.
     * @property axisList
     * @type {Array}
     */
    this.axisList = [];

    /**
     * The axis to sort along. 0 means x-axis and 1 y-axis. If your bodies are more spread out over the X axis, set axisIndex to 0, and you will gain some performance.
     * @property axisIndex
     * @type {Number}
     */
    this.axisIndex = 0;

    var that = this;
    this._addBodyHandler = function(e){
        that.axisList.push(e.body);
    };

    this._removeBodyHandler = function(e){
        // Remove from list
        var idx = that.axisList.indexOf(e.body);
        if(idx !== -1){
            that.axisList.splice(idx,1);
        }
    };
}
SAPBroadphase.prototype = new Broadphase();
SAPBroadphase.prototype.constructor = SAPBroadphase;

/**
 * Change the world
 * @method setWorld
 * @param {World} world
 */
SAPBroadphase.prototype.setWorld = function(world){
    // Clear the old axis array
    this.axisList.length = 0;

    // Add all bodies from the new world
    Utils.appendArray(this.axisList, world.bodies);

    // Remove old handlers, if any
    world
        .off("addBody",this._addBodyHandler)
        .off("removeBody",this._removeBodyHandler);

    // Add handlers to update the list of bodies.
    world.on("addBody",this._addBodyHandler).on("removeBody",this._removeBodyHandler);

    this.world = world;
};

/**
 * Sorts bodies along an axis.
 * @method sortAxisList
 * @param {Array} a
 * @param {number} axisIndex
 * @return {Array}
 */
SAPBroadphase.sortAxisList = function(a, axisIndex){
    axisIndex = axisIndex|0;
    for(var i=1,l=a.length; i<l; i++) {
        var v = a[i];
        for(var j=i - 1;j>=0;j--) {
            if(a[j].aabb.lowerBound[axisIndex] <= v.aabb.lowerBound[axisIndex]){
                break;
            }
            a[j+1] = a[j];
        }
        a[j+1] = v;
    }
    return a;
};

SAPBroadphase.prototype.sortList = function(){
    var bodies = this.axisList,
    axisIndex = this.axisIndex;

    // Sort the lists
    SAPBroadphase.sortAxisList(bodies, axisIndex);
};

/**
 * Get the colliding pairs
 * @method getCollisionPairs
 * @param  {World} world
 * @return {Array}
 */
SAPBroadphase.prototype.getCollisionPairs = function(world){
    var bodies = this.axisList,
        result = this.result,
        axisIndex = this.axisIndex;

    result.length = 0;

    // Update all AABBs if needed
    var l = bodies.length;
    while(l--){
        var b = bodies[l];
        if(b.aabbNeedsUpdate){
            b.updateAABB();
        }
    }

    // Sort the lists
    this.sortList();

    // Look through the X list
    for(var i=0, N=bodies.length|0; i!==N; i++){
        var bi = bodies[i];

        for(var j=i+1; j<N; j++){
            var bj = bodies[j];

            // Bounds overlap?
            var overlaps = (bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex]);
            if(!overlaps){
                break;
            }

            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){
                result.push(bi,bj);
            }
        }
    }

    return result;
};

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
SAPBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    this.sortList();

    var axisIndex = this.axisIndex;
    var axis = 'x';
    if(axisIndex === 1){ axis = 'y'; }
    if(axisIndex === 2){ axis = 'z'; }

    var axisList = this.axisList;
    var lower = aabb.lowerBound[axis];
    var upper = aabb.upperBound[axis];
    for(var i = 0; i < axisList.length; i++){
        var b = axisList[i];

        if(b.aabbNeedsUpdate){
            b.updateAABB();
        }

        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"../collision/Broadphase":8,"../utils/Utils":50}],15:[function(_dereq_,module,exports){
module.exports = Constraint;

var Utils = _dereq_('../utils/Utils');

/**
 * Base constraint class.
 *
 * @class Constraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} type
 * @param {Object} [options]
 * @param {Object} [options.collideConnected=true]
 */
function Constraint(bodyA, bodyB, type, options){

    /**
     * The type of constraint. May be one of Constraint.DISTANCE, Constraint.GEAR, Constraint.LOCK, Constraint.PRISMATIC or Constraint.REVOLUTE.
     * @property {number} type
     */
    this.type = type;

    options = Utils.defaults(options,{
        collideConnected : true,
        wakeUpBodies : true,
    });

    /**
     * Equations to be solved in this constraint
     *
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * First body participating in the constraint.
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second body participating in the constraint.
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;

    /**
     * Set to true if you want the connected bodies to collide.
     * @property collideConnected
     * @type {Boolean}
     * @default true
     */
    this.collideConnected = options.collideConnected;

    // Wake up bodies when connected
    if(options.wakeUpBodies){
        if(bodyA){
            bodyA.wakeUp();
        }
        if(bodyB){
            bodyB.wakeUp();
        }
    }
}

/**
 * Updates the internal constraint parameters before solve.
 * @method update
 */
Constraint.prototype.update = function(){
    throw new Error("method update() not implmemented in this Constraint subclass!");
};

/**
 * @static
 * @property {number} DISTANCE
 */
Constraint.DISTANCE = 1;

/**
 * @static
 * @property {number} GEAR
 */
Constraint.GEAR = 2;

/**
 * @static
 * @property {number} LOCK
 */
Constraint.LOCK = 3;

/**
 * @static
 * @property {number} PRISMATIC
 */
Constraint.PRISMATIC = 4;

/**
 * @static
 * @property {number} REVOLUTE
 */
Constraint.REVOLUTE = 5;

/**
 * Set stiffness for this constraint.
 * @method setStiffness
 * @param {Number} stiffness
 */
Constraint.prototype.setStiffness = function(stiffness){
    var eqs = this.equations;
    for(var i=0; i !== eqs.length; i++){
        var eq = eqs[i];
        eq.stiffness = stiffness;
        eq.needsUpdate = true;
    }
};

/**
 * Set relaxation for this constraint.
 * @method setRelaxation
 * @param {Number} relaxation
 */
Constraint.prototype.setRelaxation = function(relaxation){
    var eqs = this.equations;
    for(var i=0; i !== eqs.length; i++){
        var eq = eqs[i];
        eq.relaxation = relaxation;
        eq.needsUpdate = true;
    }
};

},{"../utils/Utils":50}],16:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   Equation = _dereq_('../equations/Equation')
,   vec2 = _dereq_('../math/vec2')
,   Utils = _dereq_('../utils/Utils');

module.exports = DistanceConstraint;

/**
 * Constraint that tries to keep the distance between two bodies constant.
 *
 * @class DistanceConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {number} [options.distance] The distance to keep between the anchor points. Defaults to the current distance between the bodies.
 * @param {Array} [options.localAnchorA] The anchor point for bodyA, defined locally in bodyA frame. Defaults to [0,0].
 * @param {Array} [options.localAnchorB] The anchor point for bodyB, defined locally in bodyB frame. Defaults to [0,0].
 * @param {object} [options.maxForce=Number.MAX_VALUE] Maximum force to apply.
 * @extends Constraint
 *
 * @example
 *     // If distance is not given as an option, then the current distance between the bodies is used.
 *     // In this example, the bodies will be constrained to have a distance of 2 between their centers.
 *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
 *     var bodyB = new Body({ mass: 1, position: [1, 0] });
 *     var constraint = new DistanceConstraint(bodyA, bodyB);
 *
 * @example
 *     var constraint = new DistanceConstraint(bodyA, bodyB, {
 *         distance: 1,          // Distance to keep between the points
 *         localAnchorA: [1, 0], // Point on bodyA
 *         localAnchorB: [-1, 0] // Point on bodyB
 *     });
 */
function DistanceConstraint(bodyA,bodyB,options){
    options = Utils.defaults(options,{
        localAnchorA:[0,0],
        localAnchorB:[0,0]
    });

    Constraint.call(this,bodyA,bodyB,Constraint.DISTANCE,options);

    /**
     * Local anchor in body A.
     * @property localAnchorA
     * @type {Array}
     */
    this.localAnchorA = vec2.fromValues(options.localAnchorA[0], options.localAnchorA[1]);

    /**
     * Local anchor in body B.
     * @property localAnchorB
     * @type {Array}
     */
    this.localAnchorB = vec2.fromValues(options.localAnchorB[0], options.localAnchorB[1]);

    var localAnchorA = this.localAnchorA;
    var localAnchorB = this.localAnchorB;

    /**
     * The distance to keep.
     * @property distance
     * @type {Number}
     */
    this.distance = 0;

    if(typeof(options.distance) === 'number'){
        this.distance = options.distance;
    } else {
        // Use the current world distance between the world anchor points.
        var worldAnchorA = vec2.create(),
            worldAnchorB = vec2.create(),
            r = vec2.create();

        // Transform local anchors to world
        vec2.rotate(worldAnchorA, localAnchorA, bodyA.angle);
        vec2.rotate(worldAnchorB, localAnchorB, bodyB.angle);

        vec2.add(r, bodyB.position, worldAnchorB);
        vec2.sub(r, r, worldAnchorA);
        vec2.sub(r, r, bodyA.position);

        this.distance = vec2.length(r);
    }

    var maxForce;
    if(typeof(options.maxForce)==="undefined" ){
        maxForce = Number.MAX_VALUE;
    } else {
        maxForce = options.maxForce;
    }

    var normal = new Equation(bodyA,bodyB,-maxForce,maxForce); // Just in the normal direction
    this.equations = [ normal ];

    /**
     * Max force to apply.
     * @property {number} maxForce
     */
    this.maxForce = maxForce;

    // g = (xi - xj).dot(n)
    // dg/dt = (vi - vj).dot(n) = G*W = [n 0 -n 0] * [vi wi vj wj]'

    // ...and if we were to include offset points (TODO for now):
    // g =
    //      (xj + rj - xi - ri).dot(n) - distance
    //
    // dg/dt =
    //      (vj + wj x rj - vi - wi x ri).dot(n) =
    //      { term 2 is near zero } =
    //      [-n   -ri x n   n   rj x n] * [vi wi vj wj]' =
    //      G * W
    //
    // => G = [-n -rixn n rjxn]

    var r = vec2.create();
    var ri = vec2.create(); // worldAnchorA
    var rj = vec2.create(); // worldAnchorB
    var that = this;
    normal.computeGq = function(){
        var bodyA = this.bodyA,
            bodyB = this.bodyB,
            xi = bodyA.position,
            xj = bodyB.position;

        // Transform local anchors to world
        vec2.rotate(ri, localAnchorA, bodyA.angle);
        vec2.rotate(rj, localAnchorB, bodyB.angle);

        vec2.add(r, xj, rj);
        vec2.sub(r, r, ri);
        vec2.sub(r, r, xi);

        //vec2.sub(r, bodyB.position, bodyA.position);
        return vec2.length(r) - that.distance;
    };

    // Make the contact constraint bilateral
    this.setMaxForce(maxForce);

    /**
     * If the upper limit is enabled or not.
     * @property {Boolean} upperLimitEnabled
     */
    this.upperLimitEnabled = false;

    /**
     * The upper constraint limit.
     * @property {number} upperLimit
     */
    this.upperLimit = 1;

    /**
     * If the lower limit is enabled or not.
     * @property {Boolean} lowerLimitEnabled
     */
    this.lowerLimitEnabled = false;

    /**
     * The lower constraint limit.
     * @property {number} lowerLimit
     */
    this.lowerLimit = 0;

    /**
     * Current constraint position. This is equal to the current distance between the world anchor points.
     * @property {number} position
     */
    this.position = 0;
}
DistanceConstraint.prototype = new Constraint();
DistanceConstraint.prototype.constructor = DistanceConstraint;

/**
 * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
 * @method update
 */
var n = vec2.create();
var ri = vec2.create(); // worldAnchorA
var rj = vec2.create(); // worldAnchorB
DistanceConstraint.prototype.update = function(){
    var normal = this.equations[0],
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        distance = this.distance,
        xi = bodyA.position,
        xj = bodyB.position,
        normalEquation = this.equations[0],
        G = normal.G;

    // Transform local anchors to world
    vec2.rotate(ri, this.localAnchorA, bodyA.angle);
    vec2.rotate(rj, this.localAnchorB, bodyB.angle);

    // Get world anchor points and normal
    vec2.add(n, xj, rj);
    vec2.sub(n, n, ri);
    vec2.sub(n, n, xi);
    this.position = vec2.length(n);

    var violating = false;
    if(this.upperLimitEnabled){
        if(this.position > this.upperLimit){
            normalEquation.maxForce = 0;
            normalEquation.minForce = -this.maxForce;
            this.distance = this.upperLimit;
            violating = true;
        }
    }

    if(this.lowerLimitEnabled){
        if(this.position < this.lowerLimit){
            normalEquation.maxForce = this.maxForce;
            normalEquation.minForce = 0;
            this.distance = this.lowerLimit;
            violating = true;
        }
    }

    if((this.lowerLimitEnabled || this.upperLimitEnabled) && !violating){
        // No constraint needed.
        normalEquation.enabled = false;
        return;
    }

    normalEquation.enabled = true;

    vec2.normalize(n,n);

    // Caluclate cross products
    var rixn = vec2.crossLength(ri, n),
        rjxn = vec2.crossLength(rj, n);

    // G = [-n -rixn n rjxn]
    G[0] = -n[0];
    G[1] = -n[1];
    G[2] = -rixn;
    G[3] = n[0];
    G[4] = n[1];
    G[5] = rjxn;
};

/**
 * Set the max force to be used
 * @method setMaxForce
 * @param {Number} f
 */
DistanceConstraint.prototype.setMaxForce = function(f){
    var normal = this.equations[0];
    normal.minForce = -f;
    normal.maxForce =  f;
};

/**
 * Get the max force
 * @method getMaxForce
 * @return {Number}
 */
DistanceConstraint.prototype.getMaxForce = function(f){
    var normal = this.equations[0];
    return normal.maxForce;
};

},{"../equations/Equation":23,"../math/vec2":31,"../utils/Utils":50,"./Constraint":15}],17:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   Equation = _dereq_('../equations/Equation')
,   AngleLockEquation = _dereq_('../equations/AngleLockEquation')
,   vec2 = _dereq_('../math/vec2');

module.exports = GearConstraint;

/**
 * Connects two bodies at given offset points, letting them rotate relative to each other around this point.
 * @class GearConstraint
 * @constructor
 * @author schteppe
 * @param {Body}            bodyA
 * @param {Body}            bodyB
 * @param {Object}          [options]
 * @param {Number}          [options.angle=0] Relative angle between the bodies. Will be set to the current angle between the bodies (the gear ratio is accounted for).
 * @param {Number}          [options.ratio=1] Gear ratio.
 * @param {Number}          [options.maxTorque] Maximum torque to apply.
 * @extends Constraint
 * @todo Ability to specify world points
 */
function GearConstraint(bodyA, bodyB, options){
    options = options || {};

    Constraint.call(this, bodyA, bodyB, Constraint.GEAR, options);

    /**
     * The gear ratio.
     * @property ratio
     * @type {Number}
     */
    this.ratio = typeof(options.ratio) === "number" ? options.ratio : 1;

    /**
     * The relative angle
     * @property angle
     * @type {Number}
     */
    this.angle = typeof(options.angle) === "number" ? options.angle : bodyB.angle - this.ratio * bodyA.angle;

    // Send same parameters to the equation
    options.angle = this.angle;
    options.ratio = this.ratio;

    this.equations = [
        new AngleLockEquation(bodyA,bodyB,options),
    ];

    // Set max torque
    if(typeof(options.maxTorque) === "number"){
        this.setMaxTorque(options.maxTorque);
    }
}
GearConstraint.prototype = new Constraint();
GearConstraint.prototype.constructor = GearConstraint;

GearConstraint.prototype.update = function(){
    var eq = this.equations[0];
    if(eq.ratio !== this.ratio){
        eq.setRatio(this.ratio);
    }
    eq.angle = this.angle;
};

/**
 * Set the max torque for the constraint.
 * @method setMaxTorque
 * @param {Number} torque
 */
GearConstraint.prototype.setMaxTorque = function(torque){
    this.equations[0].setMaxTorque(torque);
};

/**
 * Get the max torque for the constraint.
 * @method getMaxTorque
 * @return {Number}
 */
GearConstraint.prototype.getMaxTorque = function(torque){
    return this.equations[0].maxForce;
};
},{"../equations/AngleLockEquation":21,"../equations/Equation":23,"../math/vec2":31,"./Constraint":15}],18:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   vec2 = _dereq_('../math/vec2')
,   Equation = _dereq_('../equations/Equation');

module.exports = LockConstraint;

/**
 * Locks the relative position between two bodies.
 *
 * @class LockConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Array}  [options.localOffsetB] The offset of bodyB in bodyA's frame. If not given the offset is computed from current positions.
 * @param {number} [options.localAngleB] The angle of bodyB in bodyA's frame. If not given, the angle is computed from current angles.
 * @param {number} [options.maxForce]
 * @extends Constraint
 */
function LockConstraint(bodyA, bodyB, options){
    options = options || {};

    Constraint.call(this,bodyA,bodyB,Constraint.LOCK,options);

    var maxForce = ( typeof(options.maxForce)==="undefined" ? Number.MAX_VALUE : options.maxForce );

    var localAngleB = options.localAngleB || 0;

    // Use 3 equations:
    // gx =   (xj - xi - l) * xhat = 0
    // gy =   (xj - xi - l) * yhat = 0
    // gr =   (xi - xj + r) * that = 0
    //
    // ...where:
    //   l is the localOffsetB vector rotated to world in bodyA frame
    //   r is the same vector but reversed and rotated from bodyB frame
    //   xhat, yhat are world axis vectors
    //   that is the tangent of r
    //
    // For the first two constraints, we get
    // G*W = (vj - vi - ldot  ) * xhat
    //     = (vj - vi - wi x l) * xhat
    //
    // Since (wi x l) * xhat = (l x xhat) * wi, we get
    // G*W = [ -1   0   (-l x xhat)  1   0   0] * [vi wi vj wj]
    //
    // The last constraint gives
    // GW = (vi - vj + wj x r) * that
    //    = [  that   0  -that  (r x t) ]

    var x =     new Equation(bodyA,bodyB,-maxForce,maxForce),
        y =     new Equation(bodyA,bodyB,-maxForce,maxForce),
        rot =   new Equation(bodyA,bodyB,-maxForce,maxForce);

    var l = vec2.create(),
        g = vec2.create(),
        that = this;
    x.computeGq = function(){
        vec2.rotate(l, that.localOffsetB, bodyA.angle);
        vec2.sub(g, bodyB.position, bodyA.position);
        vec2.sub(g, g, l);
        return g[0];
    };
    y.computeGq = function(){
        vec2.rotate(l, that.localOffsetB, bodyA.angle);
        vec2.sub(g, bodyB.position, bodyA.position);
        vec2.sub(g, g, l);
        return g[1];
    };
    var r = vec2.create(),
        t = vec2.create();
    rot.computeGq = function(){
        vec2.rotate(r, that.localOffsetB, bodyB.angle - that.localAngleB);
        vec2.scale(r,r,-1);
        vec2.sub(g,bodyA.position,bodyB.position);
        vec2.add(g,g,r);
        vec2.rotate(t,r,-Math.PI/2);
        vec2.normalize(t,t);
        return vec2.dot(g,t);
    };

    /**
     * The offset of bodyB in bodyA's frame.
     * @property {Array} localOffsetB
     */
    this.localOffsetB = vec2.create();
    if(options.localOffsetB){
        vec2.copy(this.localOffsetB, options.localOffsetB);
    } else {
        // Construct from current positions
        vec2.sub(this.localOffsetB, bodyB.position, bodyA.position);
        vec2.rotate(this.localOffsetB, this.localOffsetB, -bodyA.angle);
    }

    /**
     * The offset angle of bodyB in bodyA's frame.
     * @property {Number} localAngleB
     */
    this.localAngleB = 0;
    if(typeof(options.localAngleB) === 'number'){
        this.localAngleB = options.localAngleB;
    } else {
        // Construct
        this.localAngleB = bodyB.angle - bodyA.angle;
    }

    this.equations.push(x, y, rot);
    this.setMaxForce(maxForce);
}
LockConstraint.prototype = new Constraint();
LockConstraint.prototype.constructor = LockConstraint;

/**
 * Set the maximum force to be applied.
 * @method setMaxForce
 * @param {Number} force
 */
LockConstraint.prototype.setMaxForce = function(force){
    var eqs = this.equations;
    for(var i=0; i<this.equations.length; i++){
        eqs[i].maxForce =  force;
        eqs[i].minForce = -force;
    }
};

/**
 * Get the max force.
 * @method getMaxForce
 * @return {Number}
 */
LockConstraint.prototype.getMaxForce = function(){
    return this.equations[0].maxForce;
};

var l = vec2.create();
var r = vec2.create();
var t = vec2.create();
var xAxis = vec2.fromValues(1,0);
var yAxis = vec2.fromValues(0,1);
LockConstraint.prototype.update = function(){
    var x =   this.equations[0],
        y =   this.equations[1],
        rot = this.equations[2],
        bodyA = this.bodyA,
        bodyB = this.bodyB;

    vec2.rotate(l,this.localOffsetB,bodyA.angle);
    vec2.rotate(r,this.localOffsetB,bodyB.angle - this.localAngleB);
    vec2.scale(r,r,-1);

    vec2.rotate(t,r,Math.PI/2);
    vec2.normalize(t,t);

    x.G[0] = -1;
    x.G[1] =  0;
    x.G[2] = -vec2.crossLength(l,xAxis);
    x.G[3] =  1;

    y.G[0] =  0;
    y.G[1] = -1;
    y.G[2] = -vec2.crossLength(l,yAxis);
    y.G[4] =  1;

    rot.G[0] =  -t[0];
    rot.G[1] =  -t[1];
    rot.G[3] =  t[0];
    rot.G[4] =  t[1];
    rot.G[5] =  vec2.crossLength(r,t);
};

},{"../equations/Equation":23,"../math/vec2":31,"./Constraint":15}],19:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   ContactEquation = _dereq_('../equations/ContactEquation')
,   Equation = _dereq_('../equations/Equation')
,   vec2 = _dereq_('../math/vec2')
,   RotationalLockEquation = _dereq_('../equations/RotationalLockEquation');

module.exports = PrismaticConstraint;

/**
 * Constraint that only allows bodies to move along a line, relative to each other. See <a href="http://www.iforce2d.net/b2dtut/joints-prismatic">this tutorial</a>.
 *
 * @class PrismaticConstraint
 * @constructor
 * @extends Constraint
 * @author schteppe
 * @param {Body}    bodyA
 * @param {Body}    bodyB
 * @param {Object}  [options]
 * @param {Number}  [options.maxForce]                Max force to be applied by the constraint
 * @param {Array}   [options.localAnchorA]            Body A's anchor point, defined in its own local frame.
 * @param {Array}   [options.localAnchorB]            Body B's anchor point, defined in its own local frame.
 * @param {Array}   [options.localAxisA]              An axis, defined in body A frame, that body B's anchor point may slide along.
 * @param {Boolean} [options.disableRotationalLock]   If set to true, bodyB will be free to rotate around its anchor point.
 * @param {Number}  [options.upperLimit]
 * @param {Number}  [options.lowerLimit]
 * @todo Ability to create using only a point and a worldAxis
 */
function PrismaticConstraint(bodyA, bodyB, options){
    options = options || {};
    Constraint.call(this,bodyA,bodyB,Constraint.PRISMATIC,options);

    // Get anchors
    var localAnchorA = vec2.fromValues(0,0),
        localAxisA = vec2.fromValues(1,0),
        localAnchorB = vec2.fromValues(0,0);
    if(options.localAnchorA){ vec2.copy(localAnchorA, options.localAnchorA); }
    if(options.localAxisA){ vec2.copy(localAxisA,   options.localAxisA); }
    if(options.localAnchorB){ vec2.copy(localAnchorB, options.localAnchorB); }

    /**
     * @property localAnchorA
     * @type {Array}
     */
    this.localAnchorA = localAnchorA;

    /**
     * @property localAnchorB
     * @type {Array}
     */
    this.localAnchorB = localAnchorB;

    /**
     * @property localAxisA
     * @type {Array}
     */
    this.localAxisA = localAxisA;

    /*

    The constraint violation for the common axis point is

        g = ( xj + rj - xi - ri ) * t   :=  gg*t

    where r are body-local anchor points, and t is a tangent to the constraint axis defined in body i frame.

        gdot =  ( vj + wj x rj - vi - wi x ri ) * t + ( xj + rj - xi - ri ) * ( wi x t )

    Note the use of the chain rule. Now we identify the jacobian

        G*W = [ -t      -ri x t + t x gg     t    rj x t ] * [vi wi vj wj]

    The rotational part is just a rotation lock.

     */

    var maxForce = this.maxForce = typeof(options.maxForce)!=="undefined" ? options.maxForce : Number.MAX_VALUE;

    // Translational part
    var trans = new Equation(bodyA,bodyB,-maxForce,maxForce);
    var ri = new vec2.create(),
        rj = new vec2.create(),
        gg = new vec2.create(),
        t =  new vec2.create();
    trans.computeGq = function(){
        // g = ( xj + rj - xi - ri ) * t
        return vec2.dot(gg,t);
    };
    trans.updateJacobian = function(){
        var G = this.G,
            xi = bodyA.position,
            xj = bodyB.position;
        vec2.rotate(ri,localAnchorA,bodyA.angle);
        vec2.rotate(rj,localAnchorB,bodyB.angle);
        vec2.add(gg,xj,rj);
        vec2.sub(gg,gg,xi);
        vec2.sub(gg,gg,ri);
        vec2.rotate(t,localAxisA,bodyA.angle+Math.PI/2);

        G[0] = -t[0];
        G[1] = -t[1];
        G[2] = -vec2.crossLength(ri,t) + vec2.crossLength(t,gg);
        G[3] = t[0];
        G[4] = t[1];
        G[5] = vec2.crossLength(rj,t);
    };
    this.equations.push(trans);

    // Rotational part
    if(!options.disableRotationalLock){
        var rot = new RotationalLockEquation(bodyA,bodyB,-maxForce,maxForce);
        this.equations.push(rot);
    }

    /**
     * The position of anchor A relative to anchor B, along the constraint axis.
     * @property position
     * @type {Number}
     */
    this.position = 0;

    // Is this one used at all?
    this.velocity = 0;

    /**
     * Set to true to enable lower limit.
     * @property lowerLimitEnabled
     * @type {Boolean}
     */
    this.lowerLimitEnabled = typeof(options.lowerLimit)!=="undefined" ? true : false;

    /**
     * Set to true to enable upper limit.
     * @property upperLimitEnabled
     * @type {Boolean}
     */
    this.upperLimitEnabled = typeof(options.upperLimit)!=="undefined" ? true : false;

    /**
     * Lower constraint limit. The constraint position is forced to be larger than this value.
     * @property lowerLimit
     * @type {Number}
     */
    this.lowerLimit = typeof(options.lowerLimit)!=="undefined" ? options.lowerLimit : 0;

    /**
     * Upper constraint limit. The constraint position is forced to be smaller than this value.
     * @property upperLimit
     * @type {Number}
     */
    this.upperLimit = typeof(options.upperLimit)!=="undefined" ? options.upperLimit : 1;

    // Equations used for limits
    this.upperLimitEquation = new ContactEquation(bodyA,bodyB);
    this.lowerLimitEquation = new ContactEquation(bodyA,bodyB);

    // Set max/min forces
    this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0;
    this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = maxForce;

    /**
     * Equation used for the motor.
     * @property motorEquation
     * @type {Equation}
     */
    this.motorEquation = new Equation(bodyA,bodyB);

    /**
     * The current motor state. Enable or disable the motor using .enableMotor
     * @property motorEnabled
     * @type {Boolean}
     */
    this.motorEnabled = false;

    /**
     * Set the target speed for the motor.
     * @property motorSpeed
     * @type {Number}
     */
    this.motorSpeed = 0;

    var that = this;
    var motorEquation = this.motorEquation;
    var old = motorEquation.computeGW;
    motorEquation.computeGq = function(){ return 0; };
    motorEquation.computeGW = function(){
        var G = this.G,
            bi = this.bodyA,
            bj = this.bodyB,
            vi = bi.velocity,
            vj = bj.velocity,
            wi = bi.angularVelocity,
            wj = bj.angularVelocity;
        return this.gmult(G,vi,wi,vj,wj) + that.motorSpeed;
    };
}

PrismaticConstraint.prototype = new Constraint();
PrismaticConstraint.prototype.constructor = PrismaticConstraint;

var worldAxisA = vec2.create(),
    worldAnchorA = vec2.create(),
    worldAnchorB = vec2.create(),
    orientedAnchorA = vec2.create(),
    orientedAnchorB = vec2.create(),
    tmp = vec2.create();

/**
 * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
 * @method update
 */
PrismaticConstraint.prototype.update = function(){
    var eqs = this.equations,
        trans = eqs[0],
        upperLimit = this.upperLimit,
        lowerLimit = this.lowerLimit,
        upperLimitEquation = this.upperLimitEquation,
        lowerLimitEquation = this.lowerLimitEquation,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        localAxisA = this.localAxisA,
        localAnchorA = this.localAnchorA,
        localAnchorB = this.localAnchorB;

    trans.updateJacobian();

    // Transform local things to world
    vec2.rotate(worldAxisA,      localAxisA,      bodyA.angle);
    vec2.rotate(orientedAnchorA, localAnchorA,    bodyA.angle);
    vec2.add(worldAnchorA,       orientedAnchorA, bodyA.position);
    vec2.rotate(orientedAnchorB, localAnchorB,    bodyB.angle);
    vec2.add(worldAnchorB,       orientedAnchorB, bodyB.position);

    var relPosition = this.position = vec2.dot(worldAnchorB,worldAxisA) - vec2.dot(worldAnchorA,worldAxisA);

    // Motor
    if(this.motorEnabled){
        // G = [ a     a x ri   -a   -a x rj ]
        var G = this.motorEquation.G;
        G[0] = worldAxisA[0];
        G[1] = worldAxisA[1];
        G[2] = vec2.crossLength(worldAxisA,orientedAnchorB);
        G[3] = -worldAxisA[0];
        G[4] = -worldAxisA[1];
        G[5] = -vec2.crossLength(worldAxisA,orientedAnchorA);
    }

    /*
        Limits strategy:
        Add contact equation, with normal along the constraint axis.
        min/maxForce is set so the constraint is repulsive in the correct direction.
        Some offset is added to either equation.contactPointA or .contactPointB to get the correct upper/lower limit.

                 ^
                 |
      upperLimit x
                 |    ------
         anchorB x<---|  B |
                 |    |    |
        ------   |    ------
        |    |   |
        |  A |-->x anchorA
        ------   |
                 x lowerLimit
                 |
                axis
     */


    if(this.upperLimitEnabled && relPosition > upperLimit){
        // Update contact constraint normal, etc
        vec2.scale(upperLimitEquation.normalA, worldAxisA, -1);
        vec2.sub(upperLimitEquation.contactPointA, worldAnchorA, bodyA.position);
        vec2.sub(upperLimitEquation.contactPointB, worldAnchorB, bodyB.position);
        vec2.scale(tmp,worldAxisA,upperLimit);
        vec2.add(upperLimitEquation.contactPointA,upperLimitEquation.contactPointA,tmp);
        if(eqs.indexOf(upperLimitEquation) === -1){
            eqs.push(upperLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(upperLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }

    if(this.lowerLimitEnabled && relPosition < lowerLimit){
        // Update contact constraint normal, etc
        vec2.scale(lowerLimitEquation.normalA, worldAxisA, 1);
        vec2.sub(lowerLimitEquation.contactPointA, worldAnchorA, bodyA.position);
        vec2.sub(lowerLimitEquation.contactPointB, worldAnchorB, bodyB.position);
        vec2.scale(tmp,worldAxisA,lowerLimit);
        vec2.sub(lowerLimitEquation.contactPointB,lowerLimitEquation.contactPointB,tmp);
        if(eqs.indexOf(lowerLimitEquation) === -1){
            eqs.push(lowerLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(lowerLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }
};

/**
 * Enable the motor
 * @method enableMotor
 */
PrismaticConstraint.prototype.enableMotor = function(){
    if(this.motorEnabled){
        return;
    }
    this.equations.push(this.motorEquation);
    this.motorEnabled = true;
};

/**
 * Disable the rotational motor
 * @method disableMotor
 */
PrismaticConstraint.prototype.disableMotor = function(){
    if(!this.motorEnabled){
        return;
    }
    var i = this.equations.indexOf(this.motorEquation);
    this.equations.splice(i,1);
    this.motorEnabled = false;
};

/**
 * Set the constraint limits.
 * @method setLimits
 * @param {number} lower Lower limit.
 * @param {number} upper Upper limit.
 */
PrismaticConstraint.prototype.setLimits = function (lower, upper) {
    if(typeof(lower) === 'number'){
        this.lowerLimit = lower;
        this.lowerLimitEnabled = true;
    } else {
        this.lowerLimit = lower;
        this.lowerLimitEnabled = false;
    }

    if(typeof(upper) === 'number'){
        this.upperLimit = upper;
        this.upperLimitEnabled = true;
    } else {
        this.upperLimit = upper;
        this.upperLimitEnabled = false;
    }
};


},{"../equations/ContactEquation":22,"../equations/Equation":23,"../equations/RotationalLockEquation":25,"../math/vec2":31,"./Constraint":15}],20:[function(_dereq_,module,exports){
var Constraint = _dereq_('./Constraint')
,   Equation = _dereq_('../equations/Equation')
,   RotationalVelocityEquation = _dereq_('../equations/RotationalVelocityEquation')
,   RotationalLockEquation = _dereq_('../equations/RotationalLockEquation')
,   vec2 = _dereq_('../math/vec2');

module.exports = RevoluteConstraint;

var worldPivotA = vec2.create(),
    worldPivotB = vec2.create(),
    xAxis = vec2.fromValues(1,0),
    yAxis = vec2.fromValues(0,1),
    g = vec2.create();

/**
 * Connects two bodies at given offset points, letting them rotate relative to each other around this point.
 * @class RevoluteConstraint
 * @constructor
 * @author schteppe
 * @param {Body}    bodyA
 * @param {Body}    bodyB
 * @param {Object}  [options]
 * @param {Array}   [options.worldPivot] A pivot point given in world coordinates. If specified, localPivotA and localPivotB are automatically computed from this value.
 * @param {Array}   [options.localPivotA] The point relative to the center of mass of bodyA which bodyA is constrained to.
 * @param {Array}   [options.localPivotB] See localPivotA.
 * @param {Number}  [options.maxForce] The maximum force that should be applied to constrain the bodies.
 * @extends Constraint
 *
 * @example
 *     // This will create a revolute constraint between two bodies with pivot point in between them.
 *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
 *     var bodyB = new Body({ mass: 1, position: [1, 0] });
 *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
 *         worldPivot: [0, 0]
 *     });
 *     world.addConstraint(constraint);
 *
 *     // Using body-local pivot points, the constraint could have been constructed like this:
 *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
 *         localPivotA: [1, 0],
 *         localPivotB: [-1, 0]
 *     });
 */
function RevoluteConstraint(bodyA, bodyB, options){
    options = options || {};
    Constraint.call(this,bodyA,bodyB,Constraint.REVOLUTE,options);

    var maxForce = this.maxForce = typeof(options.maxForce) !== "undefined" ? options.maxForce : Number.MAX_VALUE;

    /**
     * @property {Array} pivotA
     */
    this.pivotA = vec2.create();

    /**
     * @property {Array} pivotB
     */
    this.pivotB = vec2.create();

    if(options.worldPivot){
        // Compute pivotA and pivotB
        vec2.sub(this.pivotA, options.worldPivot, bodyA.position);
        vec2.sub(this.pivotB, options.worldPivot, bodyB.position);
        // Rotate to local coordinate system
        vec2.rotate(this.pivotA, this.pivotA, -bodyA.angle);
        vec2.rotate(this.pivotB, this.pivotB, -bodyB.angle);
    } else {
        // Get pivotA and pivotB
        vec2.copy(this.pivotA, options.localPivotA);
        vec2.copy(this.pivotB, options.localPivotB);
    }

    // Equations to be fed to the solver
    var eqs = this.equations = [
        new Equation(bodyA,bodyB,-maxForce,maxForce),
        new Equation(bodyA,bodyB,-maxForce,maxForce),
    ];

    var x = eqs[0];
    var y = eqs[1];
    var that = this;

    x.computeGq = function(){
        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
        vec2.add(g, bodyB.position, worldPivotB);
        vec2.sub(g, g, bodyA.position);
        vec2.sub(g, g, worldPivotA);
        return vec2.dot(g,xAxis);
    };

    y.computeGq = function(){
        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
        vec2.add(g, bodyB.position, worldPivotB);
        vec2.sub(g, g, bodyA.position);
        vec2.sub(g, g, worldPivotA);
        return vec2.dot(g,yAxis);
    };

    y.minForce = x.minForce = -maxForce;
    y.maxForce = x.maxForce =  maxForce;

    this.motorEquation = new RotationalVelocityEquation(bodyA,bodyB);

    /**
     * Indicates whether the motor is enabled. Use .enableMotor() to enable the constraint motor.
     * @property {Boolean} motorEnabled
     * @readOnly
     */
    this.motorEnabled = false;

    /**
     * The constraint position.
     * @property angle
     * @type {Number}
     * @readOnly
     */
    this.angle = 0;

    /**
     * Set to true to enable lower limit
     * @property lowerLimitEnabled
     * @type {Boolean}
     */
    this.lowerLimitEnabled = false;

    /**
     * Set to true to enable upper limit
     * @property upperLimitEnabled
     * @type {Boolean}
     */
    this.upperLimitEnabled = false;

    /**
     * The lower limit on the constraint angle.
     * @property lowerLimit
     * @type {Boolean}
     */
    this.lowerLimit = 0;

    /**
     * The upper limit on the constraint angle.
     * @property upperLimit
     * @type {Boolean}
     */
    this.upperLimit = 0;

    this.upperLimitEquation = new RotationalLockEquation(bodyA,bodyB);
    this.lowerLimitEquation = new RotationalLockEquation(bodyA,bodyB);
    this.upperLimitEquation.minForce = 0;
    this.lowerLimitEquation.maxForce = 0;
}
RevoluteConstraint.prototype = new Constraint();
RevoluteConstraint.prototype.constructor = RevoluteConstraint;

/**
 * Set the constraint angle limits.
 * @method setLimits
 * @param {number} lower Lower angle limit.
 * @param {number} upper Upper angle limit.
 */
RevoluteConstraint.prototype.setLimits = function (lower, upper) {
    if(typeof(lower) === 'number'){
        this.lowerLimit = lower;
        this.lowerLimitEnabled = true;
    } else {
        this.lowerLimit = lower;
        this.lowerLimitEnabled = false;
    }

    if(typeof(upper) === 'number'){
        this.upperLimit = upper;
        this.upperLimitEnabled = true;
    } else {
        this.upperLimit = upper;
        this.upperLimitEnabled = false;
    }
};

RevoluteConstraint.prototype.update = function(){
    var bodyA =  this.bodyA,
        bodyB =  this.bodyB,
        pivotA = this.pivotA,
        pivotB = this.pivotB,
        eqs =    this.equations,
        normal = eqs[0],
        tangent= eqs[1],
        x = eqs[0],
        y = eqs[1],
        upperLimit = this.upperLimit,
        lowerLimit = this.lowerLimit,
        upperLimitEquation = this.upperLimitEquation,
        lowerLimitEquation = this.lowerLimitEquation;

    var relAngle = this.angle = bodyB.angle - bodyA.angle;

    if(this.upperLimitEnabled && relAngle > upperLimit){
        upperLimitEquation.angle = upperLimit;
        if(eqs.indexOf(upperLimitEquation) === -1){
            eqs.push(upperLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(upperLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }

    if(this.lowerLimitEnabled && relAngle < lowerLimit){
        lowerLimitEquation.angle = lowerLimit;
        if(eqs.indexOf(lowerLimitEquation) === -1){
            eqs.push(lowerLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(lowerLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }

    /*

    The constraint violation is

        g = xj + rj - xi - ri

    ...where xi and xj are the body positions and ri and rj world-oriented offset vectors. Differentiate:

        gdot = vj + wj x rj - vi - wi x ri

    We split this into x and y directions. (let x and y be unit vectors along the respective axes)

        gdot * x = ( vj + wj x rj - vi - wi x ri ) * x
                 = ( vj*x + (wj x rj)*x -vi*x -(wi x ri)*x
                 = ( vj*x + (rj x x)*wj -vi*x -(ri x x)*wi
                 = [ -x   -(ri x x)   x   (rj x x)] * [vi wi vj wj]
                 = G*W

    ...and similar for y. We have then identified the jacobian entries for x and y directions:

        Gx = [ x   (rj x x)   -x   -(ri x x)]
        Gy = [ y   (rj x y)   -y   -(ri x y)]

     */

    vec2.rotate(worldPivotA, pivotA, bodyA.angle);
    vec2.rotate(worldPivotB, pivotB, bodyB.angle);

    // todo: these are a bit sparse. We could save some computations on making custom eq.computeGW functions, etc

    x.G[0] = -1;
    x.G[1] =  0;
    x.G[2] = -vec2.crossLength(worldPivotA,xAxis);
    x.G[3] =  1;
    x.G[4] =  0;
    x.G[5] =  vec2.crossLength(worldPivotB,xAxis);

    y.G[0] =  0;
    y.G[1] = -1;
    y.G[2] = -vec2.crossLength(worldPivotA,yAxis);
    y.G[3] =  0;
    y.G[4] =  1;
    y.G[5] =  vec2.crossLength(worldPivotB,yAxis);
};

/**
 * Enable the rotational motor
 * @method enableMotor
 */
RevoluteConstraint.prototype.enableMotor = function(){
    if(this.motorEnabled){
        return;
    }
    this.equations.push(this.motorEquation);
    this.motorEnabled = true;
};

/**
 * Disable the rotational motor
 * @method disableMotor
 */
RevoluteConstraint.prototype.disableMotor = function(){
    if(!this.motorEnabled){
        return;
    }
    var i = this.equations.indexOf(this.motorEquation);
    this.equations.splice(i,1);
    this.motorEnabled = false;
};

/**
 * Check if the motor is enabled.
 * @method motorIsEnabled
 * @deprecated use property motorEnabled instead.
 * @return {Boolean}
 */
RevoluteConstraint.prototype.motorIsEnabled = function(){
    return !!this.motorEnabled;
};

/**
 * Set the speed of the rotational constraint motor
 * @method setMotorSpeed
 * @param  {Number} speed
 */
RevoluteConstraint.prototype.setMotorSpeed = function(speed){
    if(!this.motorEnabled){
        return;
    }
    var i = this.equations.indexOf(this.motorEquation);
    this.equations[i].relativeVelocity = speed;
};

/**
 * Get the speed of the rotational constraint motor
 * @method getMotorSpeed
 * @return {Number} The current speed, or false if the motor is not enabled.
 */
RevoluteConstraint.prototype.getMotorSpeed = function(){
    if(!this.motorEnabled){
        return false;
    }
    return this.motorEquation.relativeVelocity;
};

},{"../equations/Equation":23,"../equations/RotationalLockEquation":25,"../equations/RotationalVelocityEquation":26,"../math/vec2":31,"./Constraint":15}],21:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = AngleLockEquation;

/**
 * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
 *
 * @class AngleLockEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Number} [options.angle] Angle to add to the local vector in body A.
 * @param {Number} [options.ratio] Gear ratio
 */
function AngleLockEquation(bodyA, bodyB, options){
    options = options || {};
    Equation.call(this,bodyA,bodyB,-Number.MAX_VALUE,Number.MAX_VALUE);
    this.angle = options.angle || 0;

    /**
     * The gear ratio.
     * @property {Number} ratio
     * @private
     * @see setRatio
     */
    this.ratio = typeof(options.ratio)==="number" ? options.ratio : 1;

    this.setRatio(this.ratio);
}
AngleLockEquation.prototype = new Equation();
AngleLockEquation.prototype.constructor = AngleLockEquation;

AngleLockEquation.prototype.computeGq = function(){
    return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;
};

/**
 * Set the gear ratio for this equation
 * @method setRatio
 * @param {Number} ratio
 */
AngleLockEquation.prototype.setRatio = function(ratio){
    var G = this.G;
    G[2] =  ratio;
    G[5] = -1;
    this.ratio = ratio;
};

/**
 * Set the max force for the equation.
 * @method setMaxTorque
 * @param {Number} torque
 */
AngleLockEquation.prototype.setMaxTorque = function(torque){
    this.maxForce =  torque;
    this.minForce = -torque;
};

},{"../math/vec2":31,"./Equation":23}],22:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = ContactEquation;

/**
 * Non-penetration constraint equation. Tries to make the contactPointA and contactPointB vectors coincide, while keeping the applied force repulsive.
 *
 * @class ContactEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function ContactEquation(bodyA, bodyB){
    Equation.call(this, bodyA, bodyB, 0, Number.MAX_VALUE);

    /**
     * Vector from body i center of mass to the contact point.
     * @property contactPointA
     * @type {Array}
     */
    this.contactPointA = vec2.create();
    this.penetrationVec = vec2.create();

    /**
     * World-oriented vector from body A center of mass to the contact point.
     * @property contactPointB
     * @type {Array}
     */
    this.contactPointB = vec2.create();

    /**
     * The normal vector, pointing out of body i
     * @property normalA
     * @type {Array}
     */
    this.normalA = vec2.create();

    /**
     * The restitution to use (0=no bounciness, 1=max bounciness).
     * @property restitution
     * @type {Number}
     */
    this.restitution = 0;

    /**
     * This property is set to true if this is the first impact between the bodies (not persistant contact).
     * @property firstImpact
     * @type {Boolean}
     * @readOnly
     */
    this.firstImpact = false;

    /**
     * The shape in body i that triggered this contact.
     * @property shapeA
     * @type {Shape}
     */
    this.shapeA = null;

    /**
     * The shape in body j that triggered this contact.
     * @property shapeB
     * @type {Shape}
     */
    this.shapeB = null;
}
ContactEquation.prototype = new Equation();
ContactEquation.prototype.constructor = ContactEquation;
ContactEquation.prototype.computeB = function(a,b,h){
    var bi = this.bodyA,
        bj = this.bodyB,
        ri = this.contactPointA,
        rj = this.contactPointB,
        xi = bi.position,
        xj = bj.position;

    var penetrationVec = this.penetrationVec,
        n = this.normalA,
        G = this.G;

    // Caluclate cross products
    var rixn = vec2.crossLength(ri,n),
        rjxn = vec2.crossLength(rj,n);

    // G = [-n -rixn n rjxn]
    G[0] = -n[0];
    G[1] = -n[1];
    G[2] = -rixn;
    G[3] = n[0];
    G[4] = n[1];
    G[5] = rjxn;

    // Calculate q = xj+rj -(xi+ri) i.e. the penetration vector
    vec2.add(penetrationVec,xj,rj);
    vec2.sub(penetrationVec,penetrationVec,xi);
    vec2.sub(penetrationVec,penetrationVec,ri);

    // Compute iteration
    var GW, Gq;
    if(this.firstImpact && this.restitution !== 0){
        Gq = 0;
        GW = (1/b)*(1+this.restitution) * this.computeGW();
    } else {
        Gq = vec2.dot(n,penetrationVec) + this.offset;
        GW = this.computeGW();
    }

    var GiMf = this.computeGiMf();
    var B = - Gq * a - GW * b - h*GiMf;

    return B;
};

},{"../math/vec2":31,"./Equation":23}],23:[function(_dereq_,module,exports){
module.exports = Equation;

var vec2 = _dereq_('../math/vec2'),
    Utils = _dereq_('../utils/Utils'),
    Body = _dereq_('../objects/Body');

/**
 * Base class for constraint equations.
 * @class Equation
 * @constructor
 * @param {Body} bodyA First body participating in the equation
 * @param {Body} bodyB Second body participating in the equation
 * @param {number} minForce Minimum force to apply. Default: -Number.MAX_VALUE
 * @param {number} maxForce Maximum force to apply. Default: Number.MAX_VALUE
 */
function Equation(bodyA, bodyB, minForce, maxForce){

    /**
     * Minimum force to apply when solving.
     * @property minForce
     * @type {Number}
     */
    this.minForce = typeof(minForce)==="undefined" ? -Number.MAX_VALUE : minForce;

    /**
     * Max force to apply when solving.
     * @property maxForce
     * @type {Number}
     */
    this.maxForce = typeof(maxForce)==="undefined" ? Number.MAX_VALUE : maxForce;

    /**
     * First body participating in the constraint
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second body participating in the constraint
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;

    /**
     * The stiffness of this equation. Typically chosen to a large number (~1e7), but can be chosen somewhat freely to get a stable simulation.
     * @property stiffness
     * @type {Number}
     */
    this.stiffness = Equation.DEFAULT_STIFFNESS;

    /**
     * The number of time steps needed to stabilize the constraint equation. Typically between 3 and 5 time steps.
     * @property relaxation
     * @type {Number}
     */
    this.relaxation = Equation.DEFAULT_RELAXATION;

    /**
     * The Jacobian entry of this equation. 6 numbers, 3 per body (x,y,angle).
     * @property G
     * @type {Array}
     */
    this.G = new Utils.ARRAY_TYPE(6);
    for(var i=0; i<6; i++){
        this.G[i]=0;
    }

    this.offset = 0;

    this.a = 0;
    this.b = 0;
    this.epsilon = 0;
    this.timeStep = 1/60;

    /**
     * Indicates if stiffness or relaxation was changed.
     * @property {Boolean} needsUpdate
     */
    this.needsUpdate = true;

    /**
     * The resulting constraint multiplier from the last solve. This is mostly equivalent to the force produced by the constraint.
     * @property multiplier
     * @type {Number}
     */
    this.multiplier = 0;

    /**
     * Relative velocity.
     * @property {Number} relativeVelocity
     */
    this.relativeVelocity = 0;

    /**
     * Whether this equation is enabled or not. If true, it will be added to the solver.
     * @property {Boolean} enabled
     */
    this.enabled = true;
}
Equation.prototype.constructor = Equation;

/**
 * The default stiffness when creating a new Equation.
 * @static
 * @property {Number} DEFAULT_STIFFNESS
 * @default 1e6
 */
Equation.DEFAULT_STIFFNESS = 1e6;

/**
 * The default relaxation when creating a new Equation.
 * @static
 * @property {Number} DEFAULT_RELAXATION
 * @default 4
 */
Equation.DEFAULT_RELAXATION = 4;

/**
 * Compute SPOOK parameters .a, .b and .epsilon according to the current parameters. See equations 9, 10 and 11 in the <a href="http://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf">SPOOK notes</a>.
 * @method update
 */
Equation.prototype.update = function(){
    var k = this.stiffness,
        d = this.relaxation,
        h = this.timeStep;

    this.a = 4.0 / (h * (1 + 4 * d));
    this.b = (4.0 * d) / (1 + 4 * d);
    this.epsilon = 4.0 / (h * h * k * (1 + 4 * d));

    this.needsUpdate = false;
};

/**
 * Multiply a jacobian entry with corresponding positions or velocities
 * @method gmult
 * @return {Number}
 */
Equation.prototype.gmult = function(G,vi,wi,vj,wj){
    return  G[0] * vi[0] +
            G[1] * vi[1] +
            G[2] * wi +
            G[3] * vj[0] +
            G[4] * vj[1] +
            G[5] * wj;
};

/**
 * Computes the RHS of the SPOOK equation
 * @method computeB
 * @return {Number}
 */
Equation.prototype.computeB = function(a,b,h){
    var GW = this.computeGW();
    var Gq = this.computeGq();
    var GiMf = this.computeGiMf();
    return - Gq * a - GW * b - GiMf*h;
};

/**
 * Computes G\*q, where q are the generalized body coordinates
 * @method computeGq
 * @return {Number}
 */
var qi = vec2.create(),
    qj = vec2.create();
Equation.prototype.computeGq = function(){
    var G = this.G,
        bi = this.bodyA,
        bj = this.bodyB,
        xi = bi.position,
        xj = bj.position,
        ai = bi.angle,
        aj = bj.angle;

    return this.gmult(G, qi, ai, qj, aj) + this.offset;
};

/**
 * Computes G\*W, where W are the body velocities
 * @method computeGW
 * @return {Number}
 */
Equation.prototype.computeGW = function(){
    var G = this.G,
        bi = this.bodyA,
        bj = this.bodyB,
        vi = bi.velocity,
        vj = bj.velocity,
        wi = bi.angularVelocity,
        wj = bj.angularVelocity;
    return this.gmult(G,vi,wi,vj,wj) + this.relativeVelocity;
};

/**
 * Computes G\*Wlambda, where W are the body velocities
 * @method computeGWlambda
 * @return {Number}
 */
Equation.prototype.computeGWlambda = function(){
    var G = this.G,
        bi = this.bodyA,
        bj = this.bodyB,
        vi = bi.vlambda,
        vj = bj.vlambda,
        wi = bi.wlambda,
        wj = bj.wlambda;
    return this.gmult(G,vi,wi,vj,wj);
};

/**
 * Computes G\*inv(M)\*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
 * @method computeGiMf
 * @return {Number}
 */
var iMfi = vec2.create(),
    iMfj = vec2.create();
Equation.prototype.computeGiMf = function(){
    var bi = this.bodyA,
        bj = this.bodyB,
        fi = bi.force,
        ti = bi.angularForce,
        fj = bj.force,
        tj = bj.angularForce,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaSolve,
        invIj = bj.invInertiaSolve,
        G = this.G;

    vec2.scale(iMfi, fi,invMassi);
    vec2.scale(iMfj, fj,invMassj);

    return this.gmult(G,iMfi,ti*invIi,iMfj,tj*invIj);
};

/**
 * Computes G\*inv(M)\*G'
 * @method computeGiMGt
 * @return {Number}
 */
Equation.prototype.computeGiMGt = function(){
    var bi = this.bodyA,
        bj = this.bodyB,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaSolve,
        invIj = bj.invInertiaSolve,
        G = this.G;

    return  G[0] * G[0] * invMassi +
            G[1] * G[1] * invMassi +
            G[2] * G[2] *    invIi +
            G[3] * G[3] * invMassj +
            G[4] * G[4] * invMassj +
            G[5] * G[5] *    invIj;
};

var addToWlambda_temp = vec2.create(),
    addToWlambda_Gi = vec2.create(),
    addToWlambda_Gj = vec2.create(),
    addToWlambda_ri = vec2.create(),
    addToWlambda_rj = vec2.create(),
    addToWlambda_Mdiag = vec2.create();

/**
 * Add constraint velocity to the bodies.
 * @method addToWlambda
 * @param {Number} deltalambda
 */
Equation.prototype.addToWlambda = function(deltalambda){
    var bi = this.bodyA,
        bj = this.bodyB,
        temp = addToWlambda_temp,
        Gi = addToWlambda_Gi,
        Gj = addToWlambda_Gj,
        ri = addToWlambda_ri,
        rj = addToWlambda_rj,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaSolve,
        invIj = bj.invInertiaSolve,
        Mdiag = addToWlambda_Mdiag,
        G = this.G;

    Gi[0] = G[0];
    Gi[1] = G[1];
    Gj[0] = G[3];
    Gj[1] = G[4];

    // Add to linear velocity
    // v_lambda += inv(M) * delta_lamba * G
    vec2.scale(temp, Gi, invMassi*deltalambda);
    vec2.add( bi.vlambda, bi.vlambda, temp);
    // This impulse is in the offset frame
    // Also add contribution to angular
    //bi.wlambda -= vec2.crossLength(temp,ri);
    bi.wlambda += invIi * G[2] * deltalambda;


    vec2.scale(temp, Gj, invMassj*deltalambda);
    vec2.add( bj.vlambda, bj.vlambda, temp);
    //bj.wlambda -= vec2.crossLength(temp,rj);
    bj.wlambda += invIj * G[5] * deltalambda;
};

/**
 * Compute the denominator part of the SPOOK equation: C = G\*inv(M)\*G' + eps
 * @method computeInvC
 * @param  {Number} eps
 * @return {Number}
 */
Equation.prototype.computeInvC = function(eps){
    return 1.0 / (this.computeGiMGt() + eps);
};

},{"../math/vec2":31,"../objects/Body":32,"../utils/Utils":50}],24:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Equation = _dereq_('./Equation')
,   Utils = _dereq_('../utils/Utils');

module.exports = FrictionEquation;

/**
 * Constrains the slipping in a contact along a tangent
 *
 * @class FrictionEquation
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} slipForce
 * @extends Equation
 */
function FrictionEquation(bodyA, bodyB, slipForce){
    Equation.call(this, bodyA, bodyB, -slipForce, slipForce);

    /**
     * Relative vector from center of body A to the contact point, world oriented.
     * @property contactPointA
     * @type {Array}
     */
    this.contactPointA = vec2.create();

    /**
     * Relative vector from center of body B to the contact point, world oriented.
     * @property contactPointB
     * @type {Array}
     */
    this.contactPointB = vec2.create();

    /**
     * Tangent vector that the friction force will act along. World oriented.
     * @property t
     * @type {Array}
     */
    this.t = vec2.create();

    /**
     * A ContactEquation connected to this friction. The contact equations can be used to rescale the max force for the friction. If more than one contact equation is given, then the max force can be set to the average.
     * @property contactEquations
     * @type {ContactEquation}
     */
    this.contactEquations = [];

    /**
     * The shape in body i that triggered this friction.
     * @property shapeA
     * @type {Shape}
     * @todo Needed? The shape can be looked up via contactEquation.shapeA...
     */
    this.shapeA = null;

    /**
     * The shape in body j that triggered this friction.
     * @property shapeB
     * @type {Shape}
     * @todo Needed? The shape can be looked up via contactEquation.shapeB...
     */
    this.shapeB = null;

    /**
     * The friction coefficient to use.
     * @property frictionCoefficient
     * @type {Number}
     */
    this.frictionCoefficient = 0.3;
}
FrictionEquation.prototype = new Equation();
FrictionEquation.prototype.constructor = FrictionEquation;

/**
 * Set the slipping condition for the constraint. The friction force cannot be
 * larger than this value.
 * @method setSlipForce
 * @param  {Number} slipForce
 */
FrictionEquation.prototype.setSlipForce = function(slipForce){
    this.maxForce = slipForce;
    this.minForce = -slipForce;
};

/**
 * Get the max force for the constraint.
 * @method getSlipForce
 * @return {Number}
 */
FrictionEquation.prototype.getSlipForce = function(){
    return this.maxForce;
};

FrictionEquation.prototype.computeB = function(a,b,h){
    var bi = this.bodyA,
        bj = this.bodyB,
        ri = this.contactPointA,
        rj = this.contactPointB,
        t = this.t,
        G = this.G;

    // G = [-t -rixt t rjxt]
    // And remember, this is a pure velocity constraint, g is always zero!
    G[0] = -t[0];
    G[1] = -t[1];
    G[2] = -vec2.crossLength(ri,t);
    G[3] = t[0];
    G[4] = t[1];
    G[5] = vec2.crossLength(rj,t);

    var GW = this.computeGW(),
        GiMf = this.computeGiMf();

    var B = /* - g * a  */ - GW * b - h*GiMf;

    return B;
};

},{"../math/vec2":31,"../utils/Utils":50,"./Equation":23}],25:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = RotationalLockEquation;

/**
 * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
 *
 * @class RotationalLockEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Number} [options.angle] Angle to add to the local vector in bodyA.
 */
function RotationalLockEquation(bodyA, bodyB, options){
    options = options || {};
    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);

    /**
     * @property {number} angle
     */
    this.angle = options.angle || 0;

    var G = this.G;
    G[2] =  1;
    G[5] = -1;
}
RotationalLockEquation.prototype = new Equation();
RotationalLockEquation.prototype.constructor = RotationalLockEquation;

var worldVectorA = vec2.create(),
    worldVectorB = vec2.create(),
    xAxis = vec2.fromValues(1,0),
    yAxis = vec2.fromValues(0,1);
RotationalLockEquation.prototype.computeGq = function(){
    vec2.rotate(worldVectorA,xAxis,this.bodyA.angle+this.angle);
    vec2.rotate(worldVectorB,yAxis,this.bodyB.angle);
    return vec2.dot(worldVectorA,worldVectorB);
};

},{"../math/vec2":31,"./Equation":23}],26:[function(_dereq_,module,exports){
var Equation = _dereq_("./Equation"),
    vec2 = _dereq_('../math/vec2');

module.exports = RotationalVelocityEquation;

/**
 * Syncs rotational velocity of two bodies, or sets a relative velocity (motor).
 *
 * @class RotationalVelocityEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function RotationalVelocityEquation(bodyA, bodyB){
    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
    this.relativeVelocity = 1;
    this.ratio = 1;
}
RotationalVelocityEquation.prototype = new Equation();
RotationalVelocityEquation.prototype.constructor = RotationalVelocityEquation;
RotationalVelocityEquation.prototype.computeB = function(a,b,h){
    var G = this.G;
    G[2] = -1;
    G[5] = this.ratio;

    var GiMf = this.computeGiMf();
    var GW = this.computeGW();
    var B = - GW * b - h*GiMf;

    return B;
};

},{"../math/vec2":31,"./Equation":23}],27:[function(_dereq_,module,exports){
/**
 * Base class for objects that dispatches events.
 * @class EventEmitter
 * @constructor
 */
var EventEmitter = function () {};

module.exports = EventEmitter;

EventEmitter.prototype = {
    constructor: EventEmitter,

    /**
     * Add an event listener
     * @method on
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     */
    on: function ( type, listener, context ) {
        listener.context = context || this;
        if ( this._listeners === undefined ){
            this._listeners = {};
        }
        var listeners = this._listeners;
        if ( listeners[ type ] === undefined ) {
            listeners[ type ] = [];
        }
        if ( listeners[ type ].indexOf( listener ) === - 1 ) {
            listeners[ type ].push( listener );
        }
        return this;
    },

    /**
     * Check if an event listener is added
     * @method has
     * @param  {String} type
     * @param  {Function} listener
     * @return {Boolean}
     */
    has: function ( type, listener ) {
        if ( this._listeners === undefined ){
            return false;
        }
        var listeners = this._listeners;
        if(listener){
            if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
                return true;
            }
        } else {
            if ( listeners[ type ] !== undefined ) {
                return true;
            }
        }

        return false;
    },

    /**
     * Remove an event listener
     * @method off
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     */
    off: function ( type, listener ) {
        if ( this._listeners === undefined ){
            return this;
        }
        var listeners = this._listeners;
        var index = listeners[ type ].indexOf( listener );
        if ( index !== - 1 ) {
            listeners[ type ].splice( index, 1 );
        }
        return this;
    },

    /**
     * Emit an event.
     * @method emit
     * @param  {Object} event
     * @param  {String} event.type
     * @return {EventEmitter} The self object, for chainability.
     */
    emit: function ( event ) {
        if ( this._listeners === undefined ){
            return this;
        }
        var listeners = this._listeners;
        var listenerArray = listeners[ event.type ];
        if ( listenerArray !== undefined ) {
            event.target = this;
            for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {
                var listener = listenerArray[ i ];
                listener.call( listener.context, event );
            }
        }
        return this;
    }
};

},{}],28:[function(_dereq_,module,exports){
var Material = _dereq_('./Material');
var Equation = _dereq_('../equations/Equation');

module.exports = ContactMaterial;

/**
 * Defines what happens when two materials meet, such as what friction coefficient to use. You can also set other things such as restitution, surface velocity and constraint parameters.
 * @class ContactMaterial
 * @constructor
 * @param {Material} materialA
 * @param {Material} materialB
 * @param {Object}   [options]
 * @param {Number}   [options.friction=0.3]       Friction coefficient.
 * @param {Number}   [options.restitution=0]      Restitution coefficient aka "bounciness".
 * @param {Number}   [options.stiffness]          ContactEquation stiffness.
 * @param {Number}   [options.relaxation]         ContactEquation relaxation.
 * @param {Number}   [options.frictionStiffness]  FrictionEquation stiffness.
 * @param {Number}   [options.frictionRelaxation] FrictionEquation relaxation.
 * @param {Number}   [options.surfaceVelocity=0]  Surface velocity.
 * @author schteppe
 */
function ContactMaterial(materialA, materialB, options){
    options = options || {};

    if(!(materialA instanceof Material) || !(materialB instanceof Material)){
        throw new Error("First two arguments must be Material instances.");
    }

    /**
     * The contact material identifier
     * @property id
     * @type {Number}
     */
    this.id = ContactMaterial.idCounter++;

    /**
     * First material participating in the contact material
     * @property materialA
     * @type {Material}
     */
    this.materialA = materialA;

    /**
     * Second material participating in the contact material
     * @property materialB
     * @type {Material}
     */
    this.materialB = materialB;

    /**
     * Friction to use in the contact of these two materials
     * @property friction
     * @type {Number}
     */
    this.friction    =  typeof(options.friction)    !== "undefined" ?   Number(options.friction)    : 0.3;

    /**
     * Restitution to use in the contact of these two materials
     * @property restitution
     * @type {Number}
     */
    this.restitution =  typeof(options.restitution) !== "undefined" ?   Number(options.restitution) : 0.0;

    /**
     * Stiffness of the resulting ContactEquation that this ContactMaterial generate
     * @property stiffness
     * @type {Number}
     */
    this.stiffness =            typeof(options.stiffness)           !== "undefined" ?   Number(options.stiffness)   : Equation.DEFAULT_STIFFNESS;

    /**
     * Relaxation of the resulting ContactEquation that this ContactMaterial generate
     * @property relaxation
     * @type {Number}
     */
    this.relaxation =           typeof(options.relaxation)          !== "undefined" ?   Number(options.relaxation)  : Equation.DEFAULT_RELAXATION;

    /**
     * Stiffness of the resulting FrictionEquation that this ContactMaterial generate
     * @property frictionStiffness
     * @type {Number}
     */
    this.frictionStiffness =    typeof(options.frictionStiffness)   !== "undefined" ?   Number(options.frictionStiffness)   : Equation.DEFAULT_STIFFNESS;

    /**
     * Relaxation of the resulting FrictionEquation that this ContactMaterial generate
     * @property frictionRelaxation
     * @type {Number}
     */
    this.frictionRelaxation =   typeof(options.frictionRelaxation)  !== "undefined" ?   Number(options.frictionRelaxation)  : Equation.DEFAULT_RELAXATION;

    /**
     * Will add surface velocity to this material. If bodyA rests on top if bodyB, and the surface velocity is positive, bodyA will slide to the right.
     * @property {Number} surfaceVelocity
     */
    this.surfaceVelocity = typeof(options.surfaceVelocity)    !== "undefined" ?   Number(options.surfaceVelocity)    : 0;

    /**
     * Offset to be set on ContactEquations. A positive value will make the bodies penetrate more into each other. Can be useful in scenes where contacts need to be more persistent, for example when stacking. Aka "cure for nervous contacts".
     * @property contactSkinSize
     * @type {Number}
     */
    this.contactSkinSize = 0.005;
}

ContactMaterial.idCounter = 0;

},{"../equations/Equation":23,"./Material":29}],29:[function(_dereq_,module,exports){
module.exports = Material;

/**
 * Defines a physics material.
 * @class Material
 * @constructor
 * @param {number} id Material identifier
 * @author schteppe
 */
function Material(id){
    /**
     * The material identifier
     * @property id
     * @type {Number}
     */
    this.id = id || Material.idCounter++;
}

Material.idCounter = 0;

},{}],30:[function(_dereq_,module,exports){

    /*
        PolyK library
        url: http://polyk.ivank.net
        Released under MIT licence.

        Copyright (c) 2012 Ivan Kuckir

        Permission is hereby granted, free of charge, to any person
        obtaining a copy of this software and associated documentation
        files (the "Software"), to deal in the Software without
        restriction, including without limitation the rights to use,
        copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the
        Software is furnished to do so, subject to the following
        conditions:

        The above copyright notice and this permission notice shall be
        included in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
        OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
        HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
        WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
        FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
        OTHER DEALINGS IN THE SOFTWARE.
    */

    var PolyK = {};

    /*
        Is Polygon self-intersecting?

        O(n^2)
    */
    /*
    PolyK.IsSimple = function(p)
    {
        var n = p.length>>1;
        if(n<4) return true;
        var a1 = new PolyK._P(), a2 = new PolyK._P();
        var b1 = new PolyK._P(), b2 = new PolyK._P();
        var c = new PolyK._P();

        for(var i=0; i<n; i++)
        {
            a1.x = p[2*i  ];
            a1.y = p[2*i+1];
            if(i==n-1)  { a2.x = p[0    ];  a2.y = p[1    ]; }
            else        { a2.x = p[2*i+2];  a2.y = p[2*i+3]; }

            for(var j=0; j<n; j++)
            {
                if(Math.abs(i-j) < 2) continue;
                if(j==n-1 && i==0) continue;
                if(i==n-1 && j==0) continue;

                b1.x = p[2*j  ];
                b1.y = p[2*j+1];
                if(j==n-1)  { b2.x = p[0    ];  b2.y = p[1    ]; }
                else        { b2.x = p[2*j+2];  b2.y = p[2*j+3]; }

                if(PolyK._GetLineIntersection(a1,a2,b1,b2,c) != null) return false;
            }
        }
        return true;
    }

    PolyK.IsConvex = function(p)
    {
        if(p.length<6) return true;
        var l = p.length - 4;
        for(var i=0; i<l; i+=2)
            if(!PolyK._convex(p[i], p[i+1], p[i+2], p[i+3], p[i+4], p[i+5])) return false;
        if(!PolyK._convex(p[l  ], p[l+1], p[l+2], p[l+3], p[0], p[1])) return false;
        if(!PolyK._convex(p[l+2], p[l+3], p[0  ], p[1  ], p[2], p[3])) return false;
        return true;
    }
    */
    PolyK.GetArea = function(p)
    {
        if(p.length <6) return 0;
        var l = p.length - 2;
        var sum = 0;
        for(var i=0; i<l; i+=2)
            sum += (p[i+2]-p[i]) * (p[i+1]+p[i+3]);
        sum += (p[0]-p[l]) * (p[l+1]+p[1]);
        return - sum * 0.5;
    }
    /*
    PolyK.GetAABB = function(p)
    {
        var minx = Infinity;
        var miny = Infinity;
        var maxx = -minx;
        var maxy = -miny;
        for(var i=0; i<p.length; i+=2)
        {
            minx = Math.min(minx, p[i  ]);
            maxx = Math.max(maxx, p[i  ]);
            miny = Math.min(miny, p[i+1]);
            maxy = Math.max(maxy, p[i+1]);
        }
        return {x:minx, y:miny, width:maxx-minx, height:maxy-miny};
    }
    */

    PolyK.Triangulate = function(p)
    {
        var n = p.length>>1;
        if(n<3) return [];
        var tgs = [];
        var avl = [];
        for(var i=0; i<n; i++) avl.push(i);

        var i = 0;
        var al = n;
        while(al > 3)
        {
            var i0 = avl[(i+0)%al];
            var i1 = avl[(i+1)%al];
            var i2 = avl[(i+2)%al];

            var ax = p[2*i0],  ay = p[2*i0+1];
            var bx = p[2*i1],  by = p[2*i1+1];
            var cx = p[2*i2],  cy = p[2*i2+1];

            var earFound = false;
            if(PolyK._convex(ax, ay, bx, by, cx, cy))
            {
                earFound = true;
                for(var j=0; j<al; j++)
                {
                    var vi = avl[j];
                    if(vi==i0 || vi==i1 || vi==i2) continue;
                    if(PolyK._PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy)) {earFound = false; break;}
                }
            }
            if(earFound)
            {
                tgs.push(i0, i1, i2);
                avl.splice((i+1)%al, 1);
                al--;
                i= 0;
            }
            else if(i++ > 3*al) break;      // no convex angles :(
        }
        tgs.push(avl[0], avl[1], avl[2]);
        return tgs;
    }
    /*
    PolyK.ContainsPoint = function(p, px, py)
    {
        var n = p.length>>1;
        var ax, ay, bx = p[2*n-2]-px, by = p[2*n-1]-py;
        var depth = 0;
        for(var i=0; i<n; i++)
        {
            ax = bx;  ay = by;
            bx = p[2*i  ] - px;
            by = p[2*i+1] - py;
            if(ay< 0 && by< 0) continue;    // both "up" or both "donw"
            if(ay>=0 && by>=0) continue;    // both "up" or both "donw"
            if(ax< 0 && bx< 0) continue;

            var lx = ax + (bx-ax)*(-ay)/(by-ay);
            if(lx>0) depth++;
        }
        return (depth & 1) == 1;
    }

    PolyK.Slice = function(p, ax, ay, bx, by)
    {
        if(PolyK.ContainsPoint(p, ax, ay) || PolyK.ContainsPoint(p, bx, by)) return [p.slice(0)];

        var a = new PolyK._P(ax, ay);
        var b = new PolyK._P(bx, by);
        var iscs = [];  // intersections
        var ps = [];    // points
        for(var i=0; i<p.length; i+=2) ps.push(new PolyK._P(p[i], p[i+1]));

        for(var i=0; i<ps.length; i++)
        {
            var isc = new PolyK._P(0,0);
            isc = PolyK._GetLineIntersection(a, b, ps[i], ps[(i+1)%ps.length], isc);

            if(isc)
            {
                isc.flag = true;
                iscs.push(isc);
                ps.splice(i+1,0,isc);
                i++;
            }
        }
        if(iscs.length == 0) return [p.slice(0)];
        var comp = function(u,v) {return PolyK._P.dist(a,u) - PolyK._P.dist(a,v); }
        iscs.sort(comp);

        var pgs = [];
        var dir = 0;
        while(iscs.length > 0)
        {
            var n = ps.length;
            var i0 = iscs[0];
            var i1 = iscs[1];
            var ind0 = ps.indexOf(i0);
            var ind1 = ps.indexOf(i1);
            var solved = false;

            if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;
            else
            {
                i0 = iscs[1];
                i1 = iscs[0];
                ind0 = ps.indexOf(i0);
                ind1 = ps.indexOf(i1);
                if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;
            }
            if(solved)
            {
                dir--;
                var pgn = PolyK._getPoints(ps, ind0, ind1);
                pgs.push(pgn);
                ps = PolyK._getPoints(ps, ind1, ind0);
                i0.flag = i1.flag = false;
                iscs.splice(0,2);
                if(iscs.length == 0) pgs.push(ps);
            }
            else { dir++; iscs.reverse(); }
            if(dir>1) break;
        }
        var result = [];
        for(var i=0; i<pgs.length; i++)
        {
            var pg = pgs[i];
            var npg = [];
            for(var j=0; j<pg.length; j++) npg.push(pg[j].x, pg[j].y);
            result.push(npg);
        }
        return result;
    }

    PolyK.Raycast = function(p, x, y, dx, dy, isc)
    {
        var l = p.length - 2;
        var tp = PolyK._tp;
        var a1 = tp[0], a2 = tp[1],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;
        a2.x = x+dx; a2.y = y+dy;

        if(isc==null) isc = {dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);
            if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, i/2, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);
        if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, p.length/2, isc);

        return (isc.dist != Infinity) ? isc : null;
    }

    PolyK.ClosestEdge = function(p, x, y, isc)
    {
        var l = p.length - 2;
        var tp = PolyK._tp;
        var a1 = tp[0],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;

        if(isc==null) isc = {dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            PolyK._pointLineDist(a1, b1, b2, i>>1, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        PolyK._pointLineDist(a1, b1, b2, l>>1, isc);

        var idst = 1/isc.dist;
        isc.norm.x = (x-isc.point.x)*idst;
        isc.norm.y = (y-isc.point.y)*idst;
        return isc;
    }

    PolyK._pointLineDist = function(p, a, b, edge, isc)
    {
        var x = p.x, y = p.y, x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;

        var A = x - x1;
        var B = y - y1;
        var C = x2 - x1;
        var D = y2 - y1;

        var dot = A * C + B * D;
        var len_sq = C * C + D * D;
        var param = dot / len_sq;

        var xx, yy;

        if (param < 0 || (x1 == x2 && y1 == y2)) {
            xx = x1;
            yy = y1;
        }
        else if (param > 1) {
            xx = x2;
            yy = y2;
        }
        else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        var dx = x - xx;
        var dy = y - yy;
        var dst = Math.sqrt(dx * dx + dy * dy);
        if(dst<isc.dist)
        {
            isc.dist = dst;
            isc.edge = edge;
            isc.point.x = xx;
            isc.point.y = yy;
        }
    }

    PolyK._updateISC = function(dx, dy, a1, b1, b2, c, edge, isc)
    {
        var nrl = PolyK._P.dist(a1, c);
        if(nrl<isc.dist)
        {
            var ibl = 1/PolyK._P.dist(b1, b2);
            var nx = -(b2.y-b1.y)*ibl;
            var ny =  (b2.x-b1.x)*ibl;
            var ddot = 2*(dx*nx+dy*ny);
            isc.dist = nrl;
            isc.norm.x = nx;
            isc.norm.y = ny;
            isc.refl.x = -ddot*nx+dx;
            isc.refl.y = -ddot*ny+dy;
            isc.edge = edge;
        }
    }

    PolyK._getPoints = function(ps, ind0, ind1)
    {
        var n = ps.length;
        var nps = [];
        if(ind1<ind0) ind1 += n;
        for(var i=ind0; i<= ind1; i++) nps.push(ps[i%n]);
        return nps;
    }

    PolyK._firstWithFlag = function(ps, ind)
    {
        var n = ps.length;
        while(true)
        {
            ind = (ind+1)%n;
            if(ps[ind].flag) return ind;
        }
    }
    */
    PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy)
    {
        var v0x = cx-ax;
        var v0y = cy-ay;
        var v1x = bx-ax;
        var v1y = by-ay;
        var v2x = px-ax;
        var v2y = py-ay;

        var dot00 = v0x*v0x+v0y*v0y;
        var dot01 = v0x*v1x+v0y*v1y;
        var dot02 = v0x*v2x+v0y*v2y;
        var dot11 = v1x*v1x+v1y*v1y;
        var dot12 = v1x*v2x+v1y*v2y;

        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

        // Check if point is in triangle
        return (u >= 0) && (v >= 0) && (u + v < 1);
    }
    /*
    PolyK._RayLineIntersection = function(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        var iDen = 1/Den;
        I.x = ( A*dbx - dax*B ) * iDen;
        I.y = ( A*dby - day*B ) * iDen;

        if(!PolyK._InRect(I, b1, b2)) return null;
        if((day>0 && I.y>a1.y) || (day<0 && I.y<a1.y)) return null;
        if((dax>0 && I.x>a1.x) || (dax<0 && I.x<a1.x)) return null;
        return I;
    }

    PolyK._GetLineIntersection = function(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        I.x = ( A*dbx - dax*B ) / Den;
        I.y = ( A*dby - day*B ) / Den;

        if(PolyK._InRect(I, a1, a2) && PolyK._InRect(I, b1, b2)) return I;
        return null;
    }

    PolyK._InRect = function(a, b, c)
    {
        if  (b.x == c.x) return (a.y>=Math.min(b.y, c.y) && a.y<=Math.max(b.y, c.y));
        if  (b.y == c.y) return (a.x>=Math.min(b.x, c.x) && a.x<=Math.max(b.x, c.x));

        if(a.x >= Math.min(b.x, c.x) && a.x <= Math.max(b.x, c.x)
        && a.y >= Math.min(b.y, c.y) && a.y <= Math.max(b.y, c.y))
        return true;
        return false;
    }
    */
    PolyK._convex = function(ax, ay, bx, by, cx, cy)
    {
        return (ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0;
    }
    /*
    PolyK._P = function(x,y)
    {
        this.x = x;
        this.y = y;
        this.flag = false;
    }
    PolyK._P.prototype.toString = function()
    {
        return "Point ["+this.x+", "+this.y+"]";
    }
    PolyK._P.dist = function(a,b)
    {
        var dx = b.x-a.x;
        var dy = b.y-a.y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    PolyK._tp = [];
    for(var i=0; i<10; i++) PolyK._tp.push(new PolyK._P(0,0));
        */

module.exports = PolyK;

},{}],31:[function(_dereq_,module,exports){
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * The vec2 object from glMatrix, with some extensions and some removed methods. See http://glmatrix.net.
 * @class vec2
 */

var vec2 = module.exports = {};

var Utils = _dereq_('../utils/Utils');

/**
 * Make a cross product and only return the z component
 * @method crossLength
 * @static
 * @param  {Array} a
 * @param  {Array} b
 * @return {Number}
 */
vec2.crossLength = function(a,b){
    return a[0] * b[1] - a[1] * b[0];
};

/**
 * Cross product between a vector and the Z component of a vector
 * @method crossVZ
 * @static
 * @param  {Array} out
 * @param  {Array} vec
 * @param  {Number} zcomp
 * @return {Number}
 */
vec2.crossVZ = function(out, vec, zcomp){
    vec2.rotate(out,vec,-Math.PI/2);// Rotate according to the right hand rule
    vec2.scale(out,out,zcomp);      // Scale with z
    return out;
};

/**
 * Cross product between a vector and the Z component of a vector
 * @method crossZV
 * @static
 * @param  {Array} out
 * @param  {Number} zcomp
 * @param  {Array} vec
 * @return {Number}
 */
vec2.crossZV = function(out, zcomp, vec){
    vec2.rotate(out,vec,Math.PI/2); // Rotate according to the right hand rule
    vec2.scale(out,out,zcomp);      // Scale with z
    return out;
};

/**
 * Rotate a vector by an angle
 * @method rotate
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Number} angle
 */
vec2.rotate = function(out,a,angle){
    if(angle !== 0){
        var c = Math.cos(angle),
            s = Math.sin(angle),
            x = a[0],
            y = a[1];
        out[0] = c*x -s*y;
        out[1] = s*x +c*y;
    } else {
        out[0] = a[0];
        out[1] = a[1];
    }
};

/**
 * Rotate a vector 90 degrees clockwise
 * @method rotate90cw
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Number} angle
 */
vec2.rotate90cw = function(out, a) {
    var x = a[0];
    var y = a[1];
    out[0] = y;
    out[1] = -x;
};

/**
 * Transform a point position to local frame.
 * @method toLocalFrame
 * @param  {Array} out
 * @param  {Array} worldPoint
 * @param  {Array} framePosition
 * @param  {Number} frameAngle
 */
vec2.toLocalFrame = function(out, worldPoint, framePosition, frameAngle){
    vec2.copy(out, worldPoint);
    vec2.sub(out, out, framePosition);
    vec2.rotate(out, out, -frameAngle);
};

/**
 * Transform a point position to global frame.
 * @method toGlobalFrame
 * @param  {Array} out
 * @param  {Array} localPoint
 * @param  {Array} framePosition
 * @param  {Number} frameAngle
 */
vec2.toGlobalFrame = function(out, localPoint, framePosition, frameAngle){
    vec2.copy(out, localPoint);
    vec2.rotate(out, out, frameAngle);
    vec2.add(out, out, framePosition);
};

/**
 * Compute centroid of a triangle spanned by vectors a,b,c. See http://easycalculation.com/analytical/learn-centroid.php
 * @method centroid
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return  {Array} The out object
 */
vec2.centroid = function(out, a, b, c){
    vec2.add(out, a, b);
    vec2.add(out, out, c);
    vec2.scale(out, out, 1/3);
    return out;
};

/**
 * Creates a new, empty vec2
 * @static
 * @method create
 * @return {Array} a new 2D vector
 */
vec2.create = function() {
    var out = new Utils.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 * @static
 * @method clone
 * @param {Array} a vector to clone
 * @return {Array} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new Utils.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 * @static
 * @method fromValues
 * @param {Number} x X component
 * @param {Number} y Y component
 * @return {Array} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new Utils.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 * @static
 * @method copy
 * @param {Array} out the receiving vector
 * @param {Array} a the source vector
 * @return {Array} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 * @static
 * @method set
 * @param {Array} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @return {Array} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 * @static
 * @method add
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts two vec2's
 * @static
 * @method subtract
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for vec2.subtract
 * @static
 * @method sub
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 * @static
 * @method multiply
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for vec2.multiply
 * @static
 * @method mul
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 * @static
 * @method divide
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for vec2.divide
 * @static
 * @method div
 */
vec2.div = vec2.divide;

/**
 * Scales a vec2 by a scalar number
 * @static
 * @method scale
 * @param {Array} out the receiving vector
 * @param {Array} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @return {Array} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 * @static
 * @method distance
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for vec2.distance
 * @static
 * @method dist
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 * @static
 * @method squaredDistance
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for vec2.squaredDistance
 * @static
 * @method sqrDist
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 * @static
 * @method length
 * @param {Array} a vector to calculate length of
 * @return {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for vec2.length
 * @method len
 * @static
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 * @static
 * @method squaredLength
 * @param {Array} a vector to calculate squared length of
 * @return {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for vec2.squaredLength
 * @static
 * @method sqrLen
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 * @static
 * @method negate
 * @param {Array} out the receiving vector
 * @param {Array} a vector to negate
 * @return {Array} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Normalize a vec2
 * @static
 * @method normalize
 * @param {Array} out the receiving vector
 * @param {Array} a vector to normalize
 * @return {Array} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 * @static
 * @method dot
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Returns a string representation of a vector
 * @static
 * @method str
 * @param {Array} vec vector to represent as a string
 * @return {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

},{"../utils/Utils":50}],32:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   decomp = _dereq_('poly-decomp')
,   Convex = _dereq_('../shapes/Convex')
,   AABB = _dereq_('../collision/AABB')
,   EventEmitter = _dereq_('../events/EventEmitter');

module.exports = Body;

/**
 * A rigid body. Has got a center of mass, position, velocity and a number of
 * shapes that are used for collisions.
 *
 * @class Body
 * @constructor
 * @extends EventEmitter
 * @param {Object}              [options]
 * @param {Number}              [options.mass=0]    A number >= 0. If zero, the .type will be set to Body.STATIC.
 * @param {Array}               [options.position]
 * @param {Array}               [options.velocity]
 * @param {Number}              [options.angle=0]
 * @param {Number}              [options.angularVelocity=0]
 * @param {Array}               [options.force]
 * @param {Number}              [options.angularForce=0]
 * @param {Number}              [options.fixedRotation=false]
 * @param {Number}              [options.ccdSpeedThreshold=-1]
 * @param {Number}              [options.ccdIterations=10]
 *
 * @example
 *
 *     // Create a typical dynamic body
 *     var body = new Body({
 *         mass: 1,
 *         position: [0, 0],
 *         angle: 0,
 *         velocity: [0, 0],
 *         angularVelocity: 0
 *     });
 *
 *     // Add a circular shape to the body
 *     body.addShape(new Circle(1));
 *
 *     // Add the body to the world
 *     world.addBody(body);
 */
function Body(options){
    options = options || {};

    EventEmitter.call(this);

    /**
     * The body identifyer
     * @property id
     * @type {Number}
     */
    this.id = ++Body._idCounter;

    /**
     * The world that this body is added to. This property is set to NULL if the body is not added to any world.
     * @property world
     * @type {World}
     */
    this.world = null;

    /**
     * The shapes of the body. The local transform of the shape in .shapes[i] is
     * defined by .shapeOffsets[i] and .shapeAngles[i].
     *
     * @property shapes
     * @type {Array}
     */
    this.shapes = [];

    /**
     * The local shape offsets, relative to the body center of mass. This is an
     * array of Array.
     * @property shapeOffsets
     * @type {Array}
     */
    this.shapeOffsets = [];

    /**
     * The body-local shape angle transforms. This is an array of numbers (angles).
     * @property shapeAngles
     * @type {Array}
     */
    this.shapeAngles = [];

    /**
     * The mass of the body.
     * @property mass
     * @type {number}
     */
    this.mass = options.mass || 0;

    /**
     * The inverse mass of the body.
     * @property invMass
     * @type {number}
     */
    this.invMass = 0;

    /**
     * The inertia of the body around the Z axis.
     * @property inertia
     * @type {number}
     */
    this.inertia = 0;

    /**
     * The inverse inertia of the body.
     * @property invInertia
     * @type {number}
     */
    this.invInertia = 0;

    this.invMassSolve = 0;
    this.invInertiaSolve = 0;

    /**
     * Set to true if you want to fix the rotation of the body.
     * @property fixedRotation
     * @type {Boolean}
     */
    this.fixedRotation = !!options.fixedRotation;

    /**
     * The position of the body
     * @property position
     * @type {Array}
     */
    this.position = vec2.fromValues(0,0);
    if(options.position){
        vec2.copy(this.position, options.position);
    }

    /**
     * The interpolated position of the body.
     * @property interpolatedPosition
     * @type {Array}
     */
    this.interpolatedPosition = vec2.fromValues(0,0);

    /**
     * The interpolated angle of the body.
     * @property interpolatedAngle
     * @type {Number}
     */
    this.interpolatedAngle = 0;

    /**
     * The previous position of the body.
     * @property previousPosition
     * @type {Array}
     */
    this.previousPosition = vec2.fromValues(0,0);

    /**
     * The previous angle of the body.
     * @property previousAngle
     * @type {Number}
     */
    this.previousAngle = 0;

    /**
     * The velocity of the body
     * @property velocity
     * @type {Array}
     */
    this.velocity = vec2.fromValues(0,0);
    if(options.velocity){
        vec2.copy(this.velocity, options.velocity);
    }

    /**
     * Constraint velocity that was added to the body during the last step.
     * @property vlambda
     * @type {Array}
     */
    this.vlambda = vec2.fromValues(0,0);

    /**
     * Angular constraint velocity that was added to the body during last step.
     * @property wlambda
     * @type {Array}
     */
    this.wlambda = 0;

    /**
     * The angle of the body, in radians.
     * @property angle
     * @type {number}
     * @example
     *     // The angle property is not normalized to the interval 0 to 2*pi, it can be any value.
     *     // If you need a value between 0 and 2*pi, use the following function to normalize it.
     *     function normalizeAngle(angle){
     *         angle = angle % (2*Math.PI);
     *         if(angle < 0){
     *             angle += (2*Math.PI);
     *         }
     *         return angle;
     *     }
     */
    this.angle = options.angle || 0;

    /**
     * The angular velocity of the body, in radians per second.
     * @property angularVelocity
     * @type {number}
     */
    this.angularVelocity = options.angularVelocity || 0;

    /**
     * The force acting on the body. Since the body force (and {{#crossLink "Body/angularForce:property"}}{{/crossLink}}) will be zeroed after each step, so you need to set the force before each step.
     * @property force
     * @type {Array}
     *
     * @example
     *     // This produces a forcefield of 1 Newton in the positive x direction.
     *     for(var i=0; i<numSteps; i++){
     *         body.force[0] = 1;
     *         world.step(1/60);
     *     }
     *
     * @example
     *     // This will apply a rotational force on the body
     *     for(var i=0; i<numSteps; i++){
     *         body.angularForce = -3;
     *         world.step(1/60);
     *     }
     */
    this.force = vec2.create();
    if(options.force){
        vec2.copy(this.force, options.force);
    }

    /**
     * The angular force acting on the body. See {{#crossLink "Body/force:property"}}{{/crossLink}}.
     * @property angularForce
     * @type {number}
     */
    this.angularForce = options.angularForce || 0;

    /**
     * The linear damping acting on the body in the velocity direction. Should be a value between 0 and 1.
     * @property damping
     * @type {Number}
     * @default 0.1
     */
    this.damping = typeof(options.damping) === "number" ? options.damping : 0.1;

    /**
     * The angular force acting on the body. Should be a value between 0 and 1.
     * @property angularDamping
     * @type {Number}
     * @default 0.1
     */
    this.angularDamping = typeof(options.angularDamping) === "number" ? options.angularDamping : 0.1;

    /**
     * The type of motion this body has. Should be one of: {{#crossLink "Body/STATIC:property"}}Body.STATIC{{/crossLink}}, {{#crossLink "Body/DYNAMIC:property"}}Body.DYNAMIC{{/crossLink}} and {{#crossLink "Body/KINEMATIC:property"}}Body.KINEMATIC{{/crossLink}}.
     *
     * * Static bodies do not move, and they do not respond to forces or collision.
     * * Dynamic bodies body can move and respond to collisions and forces.
     * * Kinematic bodies only moves according to its .velocity, and does not respond to collisions or force.
     *
     * @property type
     * @type {number}
     *
     * @example
     *     // Bodies are static by default. Static bodies will never move.
     *     var body = new Body();
     *     console.log(body.type == Body.STATIC); // true
     *
     * @example
     *     // By setting the mass of a body to a nonzero number, the body
     *     // will become dynamic and will move and interact with other bodies.
     *     var dynamicBody = new Body({
     *         mass : 1
     *     });
     *     console.log(dynamicBody.type == Body.DYNAMIC); // true
     *
     * @example
     *     // Kinematic bodies will only move if you change their velocity.
     *     var kinematicBody = new Body({
     *         type: Body.KINEMATIC // Type can be set via the options object.
     *     });
     */
    this.type = Body.STATIC;

    if(typeof(options.type) !== 'undefined'){
        this.type = options.type;
    } else if(!options.mass){
        this.type = Body.STATIC;
    } else {
        this.type = Body.DYNAMIC;
    }

    /**
     * Bounding circle radius.
     * @property boundingRadius
     * @type {Number}
     */
    this.boundingRadius = 0;

    /**
     * Bounding box of this body.
     * @property aabb
     * @type {AABB}
     */
    this.aabb = new AABB();

    /**
     * Indicates if the AABB needs update. Update it with {{#crossLink "Body/updateAABB:method"}}.updateAABB(){{/crossLink}}.
     * @property aabbNeedsUpdate
     * @type {Boolean}
     * @see updateAABB
     *
     * @example
     *     // Force update the AABB
     *     body.aabbNeedsUpdate = true;
     *     body.updateAABB();
     *     console.log(body.aabbNeedsUpdate); // false
     */
    this.aabbNeedsUpdate = true;

    /**
     * If true, the body will automatically fall to sleep. Note that you need to enable sleeping in the {{#crossLink "World"}}{{/crossLink}} before anything will happen.
     * @property allowSleep
     * @type {Boolean}
     * @default true
     */
    this.allowSleep = true;

    this.wantsToSleep = false;

    /**
     * One of {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}}, {{#crossLink "Body/SLEEPY:property"}}Body.SLEEPY{{/crossLink}} and {{#crossLink "Body/SLEEPING:property"}}Body.SLEEPING{{/crossLink}}.
     *
     * The body is initially Body.AWAKE. If its velocity norm is below .sleepSpeedLimit, the sleepState will become Body.SLEEPY. If the body continues to be Body.SLEEPY for .sleepTimeLimit seconds, it will fall asleep (Body.SLEEPY).
     *
     * @property sleepState
     * @type {Number}
     * @default Body.AWAKE
     */
    this.sleepState = Body.AWAKE;

    /**
     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
     * @property sleepSpeedLimit
     * @type {Number}
     * @default 0.2
     */
    this.sleepSpeedLimit = 0.2;

    /**
     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
     * @property sleepTimeLimit
     * @type {Number}
     * @default 1
     */
    this.sleepTimeLimit = 1;

    /**
     * Gravity scaling factor. If you want the body to ignore gravity, set this to zero. If you want to reverse gravity, set it to -1.
     * @property {Number} gravityScale
     * @default 1
     */
    this.gravityScale = 1;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this body will move through other bodies, but it will still trigger contact events, etc.
     * @property {Boolean} collisionResponse
     */
    this.collisionResponse = true;

    /**
     * How long the body has been sleeping.
     * @property {Number} idleTime
     */
    this.idleTime = 0;

    /**
     * The last time when the body went to SLEEPY state.
     * @property {Number} timeLastSleepy
     * @private
     */
    this.timeLastSleepy = 0;

    /**
     * If the body speed exceeds this threshold, CCD (continuous collision detection) will be enabled. Set it to a negative number to disable CCD completely for this body.
     * @property {number} ccdSpeedThreshold
     * @default -1
     */
    this.ccdSpeedThreshold = options.ccdSpeedThreshold !== undefined ? options.ccdSpeedThreshold : -1;

    /**
     * The number of iterations that should be used when searching for the time of impact during CCD. A larger number will assure that there's a small penetration on CCD collision, but a small number will give more performance.
     * @property {number} ccdIterations
     * @default 10
     */
    this.ccdIterations = options.ccdIterations !== undefined ? options.ccdIterations : 10;

    this.concavePath = null;

    this._wakeUpAfterNarrowphase = false;

    this.updateMassProperties();
}
Body.prototype = new EventEmitter();
Body.prototype.constructor = Body;

Body._idCounter = 0;

Body.prototype.updateSolveMassProperties = function(){
    if(this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC){
        this.invMassSolve = 0;
        this.invInertiaSolve = 0;
    } else {
        this.invMassSolve = this.invMass;
        this.invInertiaSolve = this.invInertia;
    }
};

/**
 * Set the total density of the body
 * @method setDensity
 */
Body.prototype.setDensity = function(density) {
    var totalArea = this.getArea();
    this.mass = totalArea * density;
    this.updateMassProperties();
};

/**
 * Get the total area of all shapes in the body
 * @method getArea
 * @return {Number}
 */
Body.prototype.getArea = function() {
    var totalArea = 0;
    for(var i=0; i<this.shapes.length; i++){
        totalArea += this.shapes[i].area;
    }
    return totalArea;
};

/**
 * Get the AABB from the body. The AABB is updated if necessary.
 * @method getAABB
 */
Body.prototype.getAABB = function(){
    if(this.aabbNeedsUpdate){
        this.updateAABB();
    }
    return this.aabb;
};

var shapeAABB = new AABB(),
    tmp = vec2.create();

/**
 * Updates the AABB of the Body
 * @method updateAABB
 */
Body.prototype.updateAABB = function() {
    var shapes = this.shapes,
        shapeOffsets = this.shapeOffsets,
        shapeAngles = this.shapeAngles,
        N = shapes.length,
        offset = tmp,
        bodyAngle = this.angle;

    for(var i=0; i!==N; i++){
        var shape = shapes[i],
            angle = shapeAngles[i] + bodyAngle;

        // Get shape world offset
        vec2.rotate(offset, shapeOffsets[i], bodyAngle);
        vec2.add(offset, offset, this.position);

        // Get shape AABB
        shape.computeAABB(shapeAABB, offset, angle);

        if(i===0){
            this.aabb.copy(shapeAABB);
        } else {
            this.aabb.extend(shapeAABB);
        }
    }

    this.aabbNeedsUpdate = false;
};

/**
 * Update the bounding radius of the body. Should be done if any of the shapes
 * are changed.
 * @method updateBoundingRadius
 */
Body.prototype.updateBoundingRadius = function(){
    var shapes = this.shapes,
        shapeOffsets = this.shapeOffsets,
        N = shapes.length,
        radius = 0;

    for(var i=0; i!==N; i++){
        var shape = shapes[i],
            offset = vec2.length(shapeOffsets[i]),
            r = shape.boundingRadius;
        if(offset + r > radius){
            radius = offset + r;
        }
    }

    this.boundingRadius = radius;
};

/**
 * Add a shape to the body. You can pass a local transform when adding a shape,
 * so that the shape gets an offset and angle relative to the body center of mass.
 * Will automatically update the mass properties and bounding radius.
 *
 * @method addShape
 * @param  {Shape}              shape
 * @param  {Array} [offset] Local body offset of the shape.
 * @param  {Number}             [angle]  Local body angle.
 *
 * @example
 *     var body = new Body(),
 *         shape = new Circle();
 *
 *     // Add the shape to the body, positioned in the center
 *     body.addShape(shape);
 *
 *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local x-axis.
 *     body.addShape(shape,[1,0]);
 *
 *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local y-axis, and rotated 90 degrees CCW.
 *     body.addShape(shape,[0,1],Math.PI/2);
 */
Body.prototype.addShape = function(shape,offset,angle){
    angle = angle || 0.0;

    // Copy the offset vector
    if(offset){
        offset = vec2.fromValues(offset[0],offset[1]);
    } else {
        offset = vec2.fromValues(0,0);
    }

    this.shapes      .push(shape);
    this.shapeOffsets.push(offset);
    this.shapeAngles .push(angle);
    this.updateMassProperties();
    this.updateBoundingRadius();

    this.aabbNeedsUpdate = true;
};

/**
 * Remove a shape
 * @method removeShape
 * @param  {Shape}  shape
 * @return {Boolean}       True if the shape was found and removed, else false.
 */
Body.prototype.removeShape = function(shape){
    var idx = this.shapes.indexOf(shape);

    if(idx !== -1){
        this.shapes.splice(idx,1);
        this.shapeOffsets.splice(idx,1);
        this.shapeAngles.splice(idx,1);
        this.aabbNeedsUpdate = true;
        return true;
    } else {
        return false;
    }
};

/**
 * Updates .inertia, .invMass, .invInertia for this Body. Should be called when
 * changing the structure or mass of the Body.
 *
 * @method updateMassProperties
 *
 * @example
 *     body.mass += 1;
 *     body.updateMassProperties();
 */
Body.prototype.updateMassProperties = function(){
    if(this.type === Body.STATIC || this.type === Body.KINEMATIC){

        this.mass = Number.MAX_VALUE;
        this.invMass = 0;
        this.inertia = Number.MAX_VALUE;
        this.invInertia = 0;

    } else {

        var shapes = this.shapes,
            N = shapes.length,
            m = this.mass / N,
            I = 0;

        if(!this.fixedRotation){
            for(var i=0; i<N; i++){
                var shape = shapes[i],
                    r2 = vec2.squaredLength(this.shapeOffsets[i]),
                    Icm = shape.computeMomentOfInertia(m);
                I += Icm + m*r2;
            }
            this.inertia = I;
            this.invInertia = I>0 ? 1/I : 0;

        } else {
            this.inertia = Number.MAX_VALUE;
            this.invInertia = 0;
        }

        // Inverse mass properties are easy
        this.invMass = 1/this.mass;// > 0 ? 1/this.mass : 0;
    }
};

var Body_applyForce_r = vec2.create();

/**
 * Apply force to a world point. This could for example be a point on the RigidBody surface. Applying force this way will add to Body.force and Body.angularForce.
 * @method applyForce
 * @param {Array} force The force to add.
 * @param {Array} worldPoint A world point to apply the force on.
 */
Body.prototype.applyForce = function(force,worldPoint){
    // Compute point position relative to the body center
    var r = Body_applyForce_r;
    vec2.sub(r,worldPoint,this.position);

    // Add linear force
    vec2.add(this.force,this.force,force);

    // Compute produced rotational force
    var rotForce = vec2.crossLength(r,force);

    // Add rotational force
    this.angularForce += rotForce;
};

/**
 * Transform a world point to local body frame.
 * @method toLocalFrame
 * @param  {Array} out          The vector to store the result in
 * @param  {Array} worldPoint   The input world vector
 */
Body.prototype.toLocalFrame = function(out, worldPoint){
    vec2.toLocalFrame(out, worldPoint, this.position, this.angle);
};

/**
 * Transform a local point to world frame.
 * @method toWorldFrame
 * @param  {Array} out          The vector to store the result in
 * @param  {Array} localPoint   The input local vector
 */
Body.prototype.toWorldFrame = function(out, localPoint){
    vec2.toGlobalFrame(out, localPoint, this.position, this.angle);
};

/**
 * Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points.
 * @method fromPolygon
 * @param {Array} path An array of 2d vectors, e.g. [[0,0],[0,1],...] that resembles a concave or convex polygon. The shape must be simple and without holes.
 * @param {Object} [options]
 * @param {Boolean} [options.optimalDecomp=false]   Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.
 * @param {Boolean} [options.skipSimpleCheck=false] Set to true if you already know that the path is not intersecting itself.
 * @param {Boolean|Number} [options.removeCollinearPoints=false] Set to a number (angle threshold value) to remove collinear points, or false to keep all points.
 * @return {Boolean} True on success, else false.
 */
Body.prototype.fromPolygon = function(path,options){
    options = options || {};

    // Remove all shapes
    for(var i=this.shapes.length; i>=0; --i){
        this.removeShape(this.shapes[i]);
    }

    var p = new decomp.Polygon();
    p.vertices = path;

    // Make it counter-clockwise
    p.makeCCW();

    if(typeof(options.removeCollinearPoints) === "number"){
        p.removeCollinearPoints(options.removeCollinearPoints);
    }

    // Check if any line segment intersects the path itself
    if(typeof(options.skipSimpleCheck) === "undefined"){
        if(!p.isSimple()){
            return false;
        }
    }

    // Save this path for later
    this.concavePath = p.vertices.slice(0);
    for(var i=0; i<this.concavePath.length; i++){
        var v = [0,0];
        vec2.copy(v,this.concavePath[i]);
        this.concavePath[i] = v;
    }

    // Slow or fast decomp?
    var convexes;
    if(options.optimalDecomp){
        convexes = p.decomp();
    } else {
        convexes = p.quickDecomp();
    }

    var cm = vec2.create();

    // Add convexes
    for(var i=0; i!==convexes.length; i++){
        // Create convex
        var c = new Convex(convexes[i].vertices);

        // Move all vertices so its center of mass is in the local center of the convex
        for(var j=0; j!==c.vertices.length; j++){
            var v = c.vertices[j];
            vec2.sub(v,v,c.centerOfMass);
        }

        vec2.scale(cm,c.centerOfMass,1);
        c.updateTriangles();
        c.updateCenterOfMass();
        c.updateBoundingRadius();

        // Add the shape
        this.addShape(c,cm);
    }

    this.adjustCenterOfMass();

    this.aabbNeedsUpdate = true;

    return true;
};

var adjustCenterOfMass_tmp1 = vec2.fromValues(0,0),
    adjustCenterOfMass_tmp2 = vec2.fromValues(0,0),
    adjustCenterOfMass_tmp3 = vec2.fromValues(0,0),
    adjustCenterOfMass_tmp4 = vec2.fromValues(0,0);

/**
 * Moves the shape offsets so their center of mass becomes the body center of mass.
 * @method adjustCenterOfMass
 */
Body.prototype.adjustCenterOfMass = function(){
    var offset_times_area = adjustCenterOfMass_tmp2,
        sum =               adjustCenterOfMass_tmp3,
        cm =                adjustCenterOfMass_tmp4,
        totalArea =         0;
    vec2.set(sum,0,0);

    for(var i=0; i!==this.shapes.length; i++){
        var s = this.shapes[i],
            offset = this.shapeOffsets[i];
        vec2.scale(offset_times_area,offset,s.area);
        vec2.add(sum,sum,offset_times_area);
        totalArea += s.area;
    }

    vec2.scale(cm,sum,1/totalArea);

    // Now move all shapes
    for(var i=0; i!==this.shapes.length; i++){
        var s = this.shapes[i],
            offset = this.shapeOffsets[i];

        // Offset may be undefined. Fix that.
        if(!offset){
            offset = this.shapeOffsets[i] = vec2.create();
        }

        vec2.sub(offset,offset,cm);
    }

    // Move the body position too
    vec2.add(this.position,this.position,cm);

    // And concave path
    for(var i=0; this.concavePath && i<this.concavePath.length; i++){
        vec2.sub(this.concavePath[i], this.concavePath[i], cm);
    }

    this.updateMassProperties();
    this.updateBoundingRadius();
};

/**
 * Sets the force on the body to zero.
 * @method setZeroForce
 */
Body.prototype.setZeroForce = function(){
    vec2.set(this.force,0.0,0.0);
    this.angularForce = 0.0;
};

Body.prototype.resetConstraintVelocity = function(){
    var b = this,
        vlambda = b.vlambda;
    vec2.set(vlambda,0,0);
    b.wlambda = 0;
};

Body.prototype.addConstraintVelocity = function(){
    var b = this,
        v = b.velocity;
    vec2.add( v, v, b.vlambda);
    b.angularVelocity += b.wlambda;
};

/**
 * Apply damping, see <a href="http://code.google.com/p/bullet/issues/detail?id=74">this</a> for details.
 * @method applyDamping
 * @param  {number} dt Current time step
 */
Body.prototype.applyDamping = function(dt){
    if(this.type === Body.DYNAMIC){ // Only for dynamic bodies
        var v = this.velocity;
        vec2.scale(v, v, Math.pow(1.0 - this.damping,dt));
        this.angularVelocity *= Math.pow(1.0 - this.angularDamping,dt);
    }
};

/**
 * Wake the body up. Normally you should not need this, as the body is automatically awoken at events such as collisions.
 * Sets the sleepState to {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}} and emits the wakeUp event if the body wasn't awake before.
 * @method wakeUp
 */
Body.prototype.wakeUp = function(){
    var s = this.sleepState;
    this.sleepState = Body.AWAKE;
    this.idleTime = 0;
    if(s !== Body.AWAKE){
        this.emit(Body.wakeUpEvent);
    }
};

/**
 * Force body sleep
 * @method sleep
 */
Body.prototype.sleep = function(){
    this.sleepState = Body.SLEEPING;
    this.angularVelocity = 0;
    this.angularForce = 0;
    vec2.set(this.velocity,0,0);
    vec2.set(this.force,0,0);
    this.emit(Body.sleepEvent);
};

/**
 * Called every timestep to update internal sleep timer and change sleep state if needed.
 * @method sleepTick
 * @param {number} time The world time in seconds
 * @param {boolean} dontSleep
 * @param {number} dt
 */
Body.prototype.sleepTick = function(time, dontSleep, dt){
    if(!this.allowSleep || this.type === Body.SLEEPING){
        return;
    }

    this.wantsToSleep = false;

    var sleepState = this.sleepState,
        speedSquared = vec2.squaredLength(this.velocity) + Math.pow(this.angularVelocity,2),
        speedLimitSquared = Math.pow(this.sleepSpeedLimit,2);

    // Add to idle time
    if(speedSquared >= speedLimitSquared){
        this.idleTime = 0;
        this.sleepState = Body.AWAKE;
    } else {
        this.idleTime += dt;
        this.sleepState = Body.SLEEPY;
    }
    if(this.idleTime > this.sleepTimeLimit){
        if(!dontSleep){
            this.sleep();
        } else {
            this.wantsToSleep = true;
        }
    }

    /*
    if(sleepState===Body.AWAKE && speedSquared < speedLimitSquared){
        this.sleepState = Body.SLEEPY; // Sleepy
        this.timeLastSleepy = time;
        this.emit(Body.sleepyEvent);
    } else if(sleepState===Body.SLEEPY && speedSquared >= speedLimitSquared){
        this.wakeUp(); // Wake up
    } else if(sleepState===Body.SLEEPY && (time - this.timeLastSleepy ) > this.sleepTimeLimit){
        this.wantsToSleep = true;
        if(!dontSleep){
            this.sleep();
        }
    }
    */
};

Body.prototype.getVelocityFromPosition = function(store, timeStep){
    store = store || vec2.create();
    vec2.sub(store, this.position, this.previousPosition);
    vec2.scale(store, store, 1/timeStep);
    return store;
};

Body.prototype.getAngularVelocityFromPosition = function(timeStep){
    return (this.angle - this.previousAngle) / timeStep;
};

/**
 * Check if the body is overlapping another body. Note that this method only works if the body was added to a World and if at least one step was taken.
 * @method overlaps
 * @param  {Body} body
 * @return {boolean}
 */
Body.prototype.overlaps = function(body){
    return this.world.overlapKeeper.bodiesAreOverlapping(this, body);
};

var integrate_fhMinv = vec2.create();
var integrate_velodt = vec2.create();

/**
 * Move the body forward in time given its current velocity.
 * @method integrate
 * @param  {Number} dt
 */
Body.prototype.integrate = function(dt){
    var minv = this.invMass,
        f = this.force,
        pos = this.position,
        velo = this.velocity;

    // Save old position
    vec2.copy(this.previousPosition, this.position);
    this.previousAngle = this.angle;

    // Velocity update
    if(!this.fixedRotation){
        this.angularVelocity += this.angularForce * this.invInertia * dt;
    }
    vec2.scale(integrate_fhMinv, f, dt * minv);
    vec2.add(velo, integrate_fhMinv, velo);

    // CCD
    if(!this.integrateToTimeOfImpact(dt)){

        // Regular position update
        vec2.scale(integrate_velodt, velo, dt);
        vec2.add(pos, pos, integrate_velodt);
        if(!this.fixedRotation){
            this.angle += this.angularVelocity * dt;
        }
    }

    this.aabbNeedsUpdate = true;
};

var direction = vec2.create();
var end = vec2.create();
var startToEnd = vec2.create();
var rememberPosition = vec2.create();
Body.prototype.integrateToTimeOfImpact = function(dt){

    if(this.ccdSpeedThreshold < 0 || vec2.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)){
        return false;
    }

    vec2.normalize(direction, this.velocity);

    vec2.scale(end, this.velocity, dt);
    vec2.add(end, end, this.position);

    vec2.sub(startToEnd, end, this.position);
    var startToEndAngle = this.angularVelocity * dt;
    var len = vec2.length(startToEnd);

    var timeOfImpact = 1;

    var hit;
    var that = this;
    this.world.raycastAll(this.position, end, {}, function (result) {
        if(result.body === that){
            return;
        }
        hit = result.body;
        vec2.copy(end, result.hitPointWorld);
        vec2.sub(startToEnd, result.hitPointWorld, that.position);
        timeOfImpact = vec2.length(startToEnd) / len;
        result.abort();
    });

    if(!hit){
        return false;
    }

    var rememberAngle = this.angle;
    vec2.copy(rememberPosition, this.position);

    // Got a start and end point. Approximate time of impact using binary search
    var iter = 0;
    var tmin = 0;
    var tmid = 0;
    var tmax = timeOfImpact;
    while (tmax >= tmin && iter < this.ccdIterations) {
        iter++;

        // calculate the midpoint
        tmid = (tmax - tmin) / 2;

        // Move the body to that point
        vec2.scale(integrate_velodt, startToEnd, timeOfImpact);
        vec2.add(this.position, rememberPosition, integrate_velodt);
        this.angle = rememberAngle + startToEndAngle * timeOfImpact;
        this.updateAABB();

        // check overlap
        var overlaps = this.aabb.overlaps(hit.aabb) && this.world.narrowphase.bodiesOverlap(this, hit);

        if (overlaps) {
            // change min to search upper interval
            tmin = tmid;
        } else {
            // change max to search lower interval
            tmax = tmid;
        }
    }

    timeOfImpact = tmid;

    vec2.copy(this.position, rememberPosition);
    this.angle = rememberAngle;

    // move to TOI
    vec2.scale(integrate_velodt, startToEnd, timeOfImpact);
    vec2.add(this.position, this.position, integrate_velodt);
    if(!this.fixedRotation){
        this.angle += startToEndAngle * timeOfImpact;
    }

    return true;
};

/**
 * @event sleepy
 */
Body.sleepyEvent = {
    type: "sleepy"
};

/**
 * @event sleep
 */
Body.sleepEvent = {
    type: "sleep"
};

/**
 * @event wakeup
 */
Body.wakeUpEvent = {
    type: "wakeup"
};

/**
 * Dynamic body.
 * @property DYNAMIC
 * @type {Number}
 * @static
 */
Body.DYNAMIC = 1;

/**
 * Static body.
 * @property STATIC
 * @type {Number}
 * @static
 */
Body.STATIC = 2;

/**
 * Kinematic body.
 * @property KINEMATIC
 * @type {Number}
 * @static
 */
Body.KINEMATIC = 4;

/**
 * @property AWAKE
 * @type {Number}
 * @static
 */
Body.AWAKE = 0;

/**
 * @property SLEEPY
 * @type {Number}
 * @static
 */
Body.SLEEPY = 1;

/**
 * @property SLEEPING
 * @type {Number}
 * @static
 */
Body.SLEEPING = 2;


},{"../collision/AABB":7,"../events/EventEmitter":27,"../math/vec2":31,"../shapes/Convex":39,"poly-decomp":5}],33:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Spring = _dereq_('./Spring');
var Utils = _dereq_('../utils/Utils');

module.exports = LinearSpring;

/**
 * A spring, connecting two bodies.
 *
 * The Spring explicitly adds force and angularForce to the bodies.
 *
 * @class LinearSpring
 * @extends Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.restLength]   A number > 0. Default is the current distance between the world anchor points.
 * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1]      A number >= 0. Default: 1
 * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
 * @param {Array}  [options.worldAnchorB]
 * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
 * @param {Array}  [options.localAnchorB]
 */
function LinearSpring(bodyA,bodyB,options){
    options = options || {};

    Spring.call(this, bodyA, bodyB, options);

    /**
     * Anchor for bodyA in local bodyA coordinates.
     * @property localAnchorA
     * @type {Array}
     */
    this.localAnchorA = vec2.fromValues(0,0);

    /**
     * Anchor for bodyB in local bodyB coordinates.
     * @property localAnchorB
     * @type {Array}
     */
    this.localAnchorB = vec2.fromValues(0,0);

    if(options.localAnchorA){ vec2.copy(this.localAnchorA, options.localAnchorA); }
    if(options.localAnchorB){ vec2.copy(this.localAnchorB, options.localAnchorB); }
    if(options.worldAnchorA){ this.setWorldAnchorA(options.worldAnchorA); }
    if(options.worldAnchorB){ this.setWorldAnchorB(options.worldAnchorB); }

    var worldAnchorA = vec2.create();
    var worldAnchorB = vec2.create();
    this.getWorldAnchorA(worldAnchorA);
    this.getWorldAnchorB(worldAnchorB);
    var worldDistance = vec2.distance(worldAnchorA, worldAnchorB);

    /**
     * Rest length of the spring.
     * @property restLength
     * @type {number}
     */
    this.restLength = typeof(options.restLength) === "number" ? options.restLength : worldDistance;
}
LinearSpring.prototype = new Spring();
LinearSpring.prototype.constructor = LinearSpring;

/**
 * Set the anchor point on body A, using world coordinates.
 * @method setWorldAnchorA
 * @param {Array} worldAnchorA
 */
LinearSpring.prototype.setWorldAnchorA = function(worldAnchorA){
    this.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA);
};

/**
 * Set the anchor point on body B, using world coordinates.
 * @method setWorldAnchorB
 * @param {Array} worldAnchorB
 */
LinearSpring.prototype.setWorldAnchorB = function(worldAnchorB){
    this.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB);
};

/**
 * Get the anchor point on body A, in world coordinates.
 * @method getWorldAnchorA
 * @param {Array} result The vector to store the result in.
 */
LinearSpring.prototype.getWorldAnchorA = function(result){
    this.bodyA.toWorldFrame(result, this.localAnchorA);
};

/**
 * Get the anchor point on body B, in world coordinates.
 * @method getWorldAnchorB
 * @param {Array} result The vector to store the result in.
 */
LinearSpring.prototype.getWorldAnchorB = function(result){
    this.bodyB.toWorldFrame(result, this.localAnchorB);
};

var applyForce_r =              vec2.create(),
    applyForce_r_unit =         vec2.create(),
    applyForce_u =              vec2.create(),
    applyForce_f =              vec2.create(),
    applyForce_worldAnchorA =   vec2.create(),
    applyForce_worldAnchorB =   vec2.create(),
    applyForce_ri =             vec2.create(),
    applyForce_rj =             vec2.create(),
    applyForce_tmp =            vec2.create();

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
LinearSpring.prototype.applyForce = function(){
    var k = this.stiffness,
        d = this.damping,
        l = this.restLength,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        r = applyForce_r,
        r_unit = applyForce_r_unit,
        u = applyForce_u,
        f = applyForce_f,
        tmp = applyForce_tmp;

    var worldAnchorA = applyForce_worldAnchorA,
        worldAnchorB = applyForce_worldAnchorB,
        ri = applyForce_ri,
        rj = applyForce_rj;

    // Get world anchors
    this.getWorldAnchorA(worldAnchorA);
    this.getWorldAnchorB(worldAnchorB);

    // Get offset points
    vec2.sub(ri, worldAnchorA, bodyA.position);
    vec2.sub(rj, worldAnchorB, bodyB.position);

    // Compute distance vector between world anchor points
    vec2.sub(r, worldAnchorB, worldAnchorA);
    var rlen = vec2.len(r);
    vec2.normalize(r_unit,r);

    //console.log(rlen)
    //console.log("A",vec2.str(worldAnchorA),"B",vec2.str(worldAnchorB))

    // Compute relative velocity of the anchor points, u
    vec2.sub(u, bodyB.velocity, bodyA.velocity);
    vec2.crossZV(tmp, bodyB.angularVelocity, rj);
    vec2.add(u, u, tmp);
    vec2.crossZV(tmp, bodyA.angularVelocity, ri);
    vec2.sub(u, u, tmp);

    // F = - k * ( x - L ) - D * ( u )
    vec2.scale(f, r_unit, -k*(rlen-l) - d*vec2.dot(u,r_unit));

    // Add forces to bodies
    vec2.sub( bodyA.force, bodyA.force, f);
    vec2.add( bodyB.force, bodyB.force, f);

    // Angular force
    var ri_x_f = vec2.crossLength(ri, f);
    var rj_x_f = vec2.crossLength(rj, f);
    bodyA.angularForce -= ri_x_f;
    bodyB.angularForce += rj_x_f;
};

},{"../math/vec2":31,"../utils/Utils":50,"./Spring":35}],34:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Spring = _dereq_('./Spring');

module.exports = RotationalSpring;

/**
 * A rotational spring, connecting two bodies rotation. This spring explicitly adds angularForce (torque) to the bodies.
 *
 * The spring can be combined with a {{#crossLink "RevoluteConstraint"}}{{/crossLink}} to make, for example, a mouse trap.
 *
 * @class RotationalSpring
 * @extends Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.restAngle] The relative angle of bodies at which the spring is at rest. If not given, it's set to the current relative angle between the bodies.
 * @param {number} [options.stiffness=100] Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1] A number >= 0.
 */
function RotationalSpring(bodyA, bodyB, options){
    options = options || {};

    Spring.call(this, bodyA, bodyB, options);

    /**
     * Rest angle of the spring.
     * @property restAngle
     * @type {number}
     */
    this.restAngle = typeof(options.restAngle) === "number" ? options.restAngle : bodyB.angle - bodyA.angle;
}
RotationalSpring.prototype = new Spring();
RotationalSpring.prototype.constructor = RotationalSpring;

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
RotationalSpring.prototype.applyForce = function(){
    var k = this.stiffness,
        d = this.damping,
        l = this.restAngle,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        x = bodyB.angle - bodyA.angle,
        u = bodyB.angularVelocity - bodyA.angularVelocity;

    var torque = - k * (x - l) - d * u * 0;

    bodyA.angularForce -= torque;
    bodyB.angularForce += torque;
};

},{"../math/vec2":31,"./Spring":35}],35:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2');
var Utils = _dereq_('../utils/Utils');

module.exports = Spring;

/**
 * A spring, connecting two bodies. The Spring explicitly adds force and angularForce to the bodies and does therefore not put load on the constraint solver.
 *
 * @class Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1]      A number >= 0. Default: 1
 * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
 * @param {Array}  [options.localAnchorB]
 * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
 * @param {Array}  [options.worldAnchorB]
 */
function Spring(bodyA, bodyB, options){
    options = Utils.defaults(options,{
        stiffness: 100,
        damping: 1,
    });

    /**
     * Stiffness of the spring.
     * @property stiffness
     * @type {number}
     */
    this.stiffness = options.stiffness;

    /**
     * Damping of the spring.
     * @property damping
     * @type {number}
     */
    this.damping = options.damping;

    /**
     * First connected body.
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second connected body.
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;
}

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
Spring.prototype.applyForce = function(){
    // To be implemented by subclasses
};

},{"../math/vec2":31,"../utils/Utils":50}],36:[function(_dereq_,module,exports){
// Export p2 classes
module.exports = {
    AABB :                          _dereq_('./collision/AABB'),
    AngleLockEquation :             _dereq_('./equations/AngleLockEquation'),
    Body :                          _dereq_('./objects/Body'),
    Broadphase :                    _dereq_('./collision/Broadphase'),
    Capsule :                       _dereq_('./shapes/Capsule'),
    Circle :                        _dereq_('./shapes/Circle'),
    Constraint :                    _dereq_('./constraints/Constraint'),
    ContactEquation :               _dereq_('./equations/ContactEquation'),
    ContactMaterial :               _dereq_('./material/ContactMaterial'),
    Convex :                        _dereq_('./shapes/Convex'),
    DistanceConstraint :            _dereq_('./constraints/DistanceConstraint'),
    Equation :                      _dereq_('./equations/Equation'),
    EventEmitter :                  _dereq_('./events/EventEmitter'),
    FrictionEquation :              _dereq_('./equations/FrictionEquation'),
    GearConstraint :                _dereq_('./constraints/GearConstraint'),
    GridBroadphase :                _dereq_('./collision/GridBroadphase'),
    GSSolver :                      _dereq_('./solver/GSSolver'),
    Heightfield :                   _dereq_('./shapes/Heightfield'),
    Line :                          _dereq_('./shapes/Line'),
    LockConstraint :                _dereq_('./constraints/LockConstraint'),
    Material :                      _dereq_('./material/Material'),
    Narrowphase :                   _dereq_('./collision/Narrowphase'),
    NaiveBroadphase :               _dereq_('./collision/NaiveBroadphase'),
    Particle :                      _dereq_('./shapes/Particle'),
    Plane :                         _dereq_('./shapes/Plane'),
    RevoluteConstraint :            _dereq_('./constraints/RevoluteConstraint'),
    PrismaticConstraint :           _dereq_('./constraints/PrismaticConstraint'),
    Ray :                           _dereq_('./collision/Ray'),
    RaycastResult :                 _dereq_('./collision/RaycastResult'),
    Rectangle :                     _dereq_('./shapes/Rectangle'),
    RotationalVelocityEquation :    _dereq_('./equations/RotationalVelocityEquation'),
    SAPBroadphase :                 _dereq_('./collision/SAPBroadphase'),
    Shape :                         _dereq_('./shapes/Shape'),
    Solver :                        _dereq_('./solver/Solver'),
    Spring :                        _dereq_('./objects/Spring'),
    LinearSpring :                  _dereq_('./objects/LinearSpring'),
    RotationalSpring :              _dereq_('./objects/RotationalSpring'),
    Utils :                         _dereq_('./utils/Utils'),
    World :                         _dereq_('./world/World'),
    vec2 :                          _dereq_('./math/vec2'),
    version :                       _dereq_('../package.json').version,
};

},{"../package.json":6,"./collision/AABB":7,"./collision/Broadphase":8,"./collision/GridBroadphase":9,"./collision/NaiveBroadphase":10,"./collision/Narrowphase":11,"./collision/Ray":12,"./collision/RaycastResult":13,"./collision/SAPBroadphase":14,"./constraints/Constraint":15,"./constraints/DistanceConstraint":16,"./constraints/GearConstraint":17,"./constraints/LockConstraint":18,"./constraints/PrismaticConstraint":19,"./constraints/RevoluteConstraint":20,"./equations/AngleLockEquation":21,"./equations/ContactEquation":22,"./equations/Equation":23,"./equations/FrictionEquation":24,"./equations/RotationalVelocityEquation":26,"./events/EventEmitter":27,"./material/ContactMaterial":28,"./material/Material":29,"./math/vec2":31,"./objects/Body":32,"./objects/LinearSpring":33,"./objects/RotationalSpring":34,"./objects/Spring":35,"./shapes/Capsule":37,"./shapes/Circle":38,"./shapes/Convex":39,"./shapes/Heightfield":40,"./shapes/Line":41,"./shapes/Particle":42,"./shapes/Plane":43,"./shapes/Rectangle":44,"./shapes/Shape":45,"./solver/GSSolver":46,"./solver/Solver":47,"./utils/Utils":50,"./world/World":54}],37:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2');

module.exports = Capsule;

/**
 * Capsule shape class.
 * @class Capsule
 * @constructor
 * @extends Shape
 * @param {Number} [length=1] The distance between the end points
 * @param {Number} [radius=1] Radius of the capsule
 * @example
 *     var radius = 1;
 *     var length = 2;
 *     var capsuleShape = new Capsule(length, radius);
 *     body.addShape(capsuleShape);
 */
function Capsule(length, radius){

    /**
     * The distance between the end points.
     * @property {Number} length
     */
    this.length = length || 1;

    /**
     * The radius of the capsule.
     * @property {Number} radius
     */
    this.radius = radius || 1;

    Shape.call(this,Shape.CAPSULE);
}
Capsule.prototype = new Shape();
Capsule.prototype.constructor = Capsule;

/**
 * Compute the mass moment of inertia of the Capsule.
 * @method conputeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 * @todo
 */
Capsule.prototype.computeMomentOfInertia = function(mass){
    // Approximate with rectangle
    var r = this.radius,
        w = this.length + r, // 2*r is too much, 0 is too little
        h = r*2;
    return mass * (h*h + w*w) / 12;
};

/**
 * @method updateBoundingRadius
 */
Capsule.prototype.updateBoundingRadius = function(){
    this.boundingRadius = this.radius + this.length/2;
};

/**
 * @method updateArea
 */
Capsule.prototype.updateArea = function(){
    this.area = Math.PI * this.radius * this.radius + this.radius * 2 * this.length;
};

var r = vec2.create();

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Capsule.prototype.computeAABB = function(out, position, angle){
    var radius = this.radius;

    // Compute center position of one of the the circles, world oriented, but with local offset
    vec2.set(r,this.length / 2,0);
    if(angle !== 0){
        vec2.rotate(r,r,angle);
    }

    // Get bounds
    vec2.set(out.upperBound,  Math.max(r[0]+radius, -r[0]+radius),
                              Math.max(r[1]+radius, -r[1]+radius));
    vec2.set(out.lowerBound,  Math.min(r[0]-radius, -r[0]-radius),
                              Math.min(r[1]-radius, -r[1]-radius));

    // Add offset
    vec2.add(out.lowerBound, out.lowerBound, position);
    vec2.add(out.upperBound, out.upperBound, position);
};

},{"../math/vec2":31,"./Shape":45}],38:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,    vec2 = _dereq_('../math/vec2');

module.exports = Circle;

/**
 * Circle shape class.
 * @class Circle
 * @extends Shape
 * @constructor
 * @param {number} [radius=1] The radius of this circle
 *
 * @example
 *     var radius = 1;
 *     var circleShape = new Circle(radius);
 *     body.addShape(circleShape);
 */
function Circle(radius){

    /**
     * The radius of the circle.
     * @property radius
     * @type {number}
     */
    this.radius = radius || 1;

    Shape.call(this,Shape.CIRCLE);
}
Circle.prototype = new Shape();
Circle.prototype.constructor = Circle;

/**
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */
Circle.prototype.computeMomentOfInertia = function(mass){
    var r = this.radius;
    return mass * r * r / 2;
};

/**
 * @method updateBoundingRadius
 * @return {Number}
 */
Circle.prototype.updateBoundingRadius = function(){
    this.boundingRadius = this.radius;
};

/**
 * @method updateArea
 * @return {Number}
 */
Circle.prototype.updateArea = function(){
    this.area = Math.PI * this.radius * this.radius;
};

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Circle.prototype.computeAABB = function(out, position, angle){
    var r = this.radius;
    vec2.set(out.upperBound,  r,  r);
    vec2.set(out.lowerBound, -r, -r);
    if(position){
        vec2.add(out.lowerBound, out.lowerBound, position);
        vec2.add(out.upperBound, out.upperBound, position);
    }
};

},{"../math/vec2":31,"./Shape":45}],39:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2')
,   polyk = _dereq_('../math/polyk')
,   decomp = _dereq_('poly-decomp');

module.exports = Convex;

/**
 * Convex shape class.
 * @class Convex
 * @constructor
 * @extends Shape
 * @param {Array} vertices An array of vertices that span this shape. Vertices are given in counter-clockwise (CCW) direction.
 * @param {Array} [axes] An array of unit length vectors, representing the symmetry axes in the convex.
 * @example
 *     // Create a box
 *     var vertices = [[-1,-1], [1,-1], [1,1], [-1,1]];
 *     var convexShape = new Convex(vertices);
 *     body.addShape(convexShape);
 */
function Convex(vertices, axes){

    /**
     * Vertices defined in the local frame.
     * @property vertices
     * @type {Array}
     */
    this.vertices = [];

    /**
     * Axes defined in the local frame.
     * @property axes
     * @type {Array}
     */
    this.axes = [];

    // Copy the verts
    for(var i=0; i<vertices.length; i++){
        var v = vec2.create();
        vec2.copy(v,vertices[i]);
        this.vertices.push(v);
    }

    if(axes){
        // Copy the axes
        for(var i=0; i < axes.length; i++){
            var axis = vec2.create();
            vec2.copy(axis, axes[i]);
            this.axes.push(axis);
        }
    } else {
        // Construct axes from the vertex data
        for(var i = 0; i < vertices.length; i++){
            // Get the world edge
            var worldPoint0 = vertices[i];
            var worldPoint1 = vertices[(i+1) % vertices.length];

            var normal = vec2.create();
            vec2.sub(normal, worldPoint1, worldPoint0);

            // Get normal - just rotate 90 degrees since vertices are given in CCW
            vec2.rotate90cw(normal, normal);
            vec2.normalize(normal, normal);

            this.axes.push(normal);
        }
    }

    /**
     * The center of mass of the Convex
     * @property centerOfMass
     * @type {Array}
     */
    this.centerOfMass = vec2.fromValues(0,0);

    /**
     * Triangulated version of this convex. The structure is Array of 3-Arrays, and each subarray contains 3 integers, referencing the vertices.
     * @property triangles
     * @type {Array}
     */
    this.triangles = [];

    if(this.vertices.length){
        this.updateTriangles();
        this.updateCenterOfMass();
    }

    /**
     * The bounding radius of the convex
     * @property boundingRadius
     * @type {Number}
     */
    this.boundingRadius = 0;

    Shape.call(this, Shape.CONVEX);

    this.updateBoundingRadius();
    this.updateArea();
    if(this.area < 0){
        throw new Error("Convex vertices must be given in conter-clockwise winding.");
    }
}
Convex.prototype = new Shape();
Convex.prototype.constructor = Convex;

var tmpVec1 = vec2.create();
var tmpVec2 = vec2.create();

/**
 * Project a Convex onto a world-oriented axis
 * @method projectOntoAxis
 * @static
 * @param  {Array} offset
 * @param  {Array} localAxis
 * @param  {Array} result
 */
Convex.prototype.projectOntoLocalAxis = function(localAxis, result){
    var max=null,
        min=null,
        v,
        value,
        localAxis = tmpVec1;

    // Get projected position of all vertices
    for(var i=0; i<this.vertices.length; i++){
        v = this.vertices[i];
        value = vec2.dot(v, localAxis);
        if(max === null || value > max){
            max = value;
        }
        if(min === null || value < min){
            min = value;
        }
    }

    if(min > max){
        var t = min;
        min = max;
        max = t;
    }

    vec2.set(result, min, max);
};

Convex.prototype.projectOntoWorldAxis = function(localAxis, shapeOffset, shapeAngle, result){
    var worldAxis = tmpVec2;

    this.projectOntoLocalAxis(localAxis, result);

    // Project the position of the body onto the axis - need to add this to the result
    if(shapeAngle !== 0){
        vec2.rotate(worldAxis, localAxis, shapeAngle);
    } else {
        worldAxis = localAxis;
    }
    var offset = vec2.dot(shapeOffset, worldAxis);

    vec2.set(result, result[0] + offset, result[1] + offset);
};


/**
 * Update the .triangles property
 * @method updateTriangles
 */
Convex.prototype.updateTriangles = function(){

    this.triangles.length = 0;

    // Rewrite on polyk notation, array of numbers
    var polykVerts = [];
    for(var i=0; i<this.vertices.length; i++){
        var v = this.vertices[i];
        polykVerts.push(v[0],v[1]);
    }

    // Triangulate
    var triangles = polyk.Triangulate(polykVerts);

    // Loop over all triangles, add their inertia contributions to I
    for(var i=0; i<triangles.length; i+=3){
        var id1 = triangles[i],
            id2 = triangles[i+1],
            id3 = triangles[i+2];

        // Add to triangles
        this.triangles.push([id1,id2,id3]);
    }
};

var updateCenterOfMass_centroid = vec2.create(),
    updateCenterOfMass_centroid_times_mass = vec2.create(),
    updateCenterOfMass_a = vec2.create(),
    updateCenterOfMass_b = vec2.create(),
    updateCenterOfMass_c = vec2.create(),
    updateCenterOfMass_ac = vec2.create(),
    updateCenterOfMass_ca = vec2.create(),
    updateCenterOfMass_cb = vec2.create(),
    updateCenterOfMass_n = vec2.create();

/**
 * Update the .centerOfMass property.
 * @method updateCenterOfMass
 */
Convex.prototype.updateCenterOfMass = function(){
    var triangles = this.triangles,
        verts = this.vertices,
        cm = this.centerOfMass,
        centroid = updateCenterOfMass_centroid,
        n = updateCenterOfMass_n,
        a = updateCenterOfMass_a,
        b = updateCenterOfMass_b,
        c = updateCenterOfMass_c,
        ac = updateCenterOfMass_ac,
        ca = updateCenterOfMass_ca,
        cb = updateCenterOfMass_cb,
        centroid_times_mass = updateCenterOfMass_centroid_times_mass;

    vec2.set(cm,0,0);
    var totalArea = 0;

    for(var i=0; i!==triangles.length; i++){
        var t = triangles[i],
            a = verts[t[0]],
            b = verts[t[1]],
            c = verts[t[2]];

        vec2.centroid(centroid,a,b,c);

        // Get mass for the triangle (density=1 in this case)
        // http://math.stackexchange.com/questions/80198/area-of-triangle-via-vectors
        var m = Convex.triangleArea(a,b,c);
        totalArea += m;

        // Add to center of mass
        vec2.scale(centroid_times_mass, centroid, m);
        vec2.add(cm, cm, centroid_times_mass);
    }

    vec2.scale(cm,cm,1/totalArea);
};

/**
 * Compute the mass moment of inertia of the Convex.
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 * @see http://www.gamedev.net/topic/342822-moment-of-inertia-of-a-polygon-2d/
 */
Convex.prototype.computeMomentOfInertia = function(mass){
    var denom = 0.0,
        numer = 0.0,
        N = this.vertices.length;
    for(var j = N-1, i = 0; i < N; j = i, i ++){
        var p0 = this.vertices[j];
        var p1 = this.vertices[i];
        var a = Math.abs(vec2.crossLength(p0,p1));
        var b = vec2.dot(p1,p1) + vec2.dot(p1,p0) + vec2.dot(p0,p0);
        denom += a * b;
        numer += a;
    }
    return (mass / 6.0) * (denom / numer);
};

/**
 * Updates the .boundingRadius property
 * @method updateBoundingRadius
 */
Convex.prototype.updateBoundingRadius = function(){
    var verts = this.vertices,
        r2 = 0;

    for(var i=0; i!==verts.length; i++){
        var l2 = vec2.squaredLength(verts[i]);
        if(l2 > r2){
            r2 = l2;
        }
    }

    this.boundingRadius = Math.sqrt(r2);
};

/**
 * Get the area of the triangle spanned by the three points a, b, c. The area is positive if the points are given in counter-clockwise order, otherwise negative.
 * @static
 * @method triangleArea
 * @param {Array} a
 * @param {Array} b
 * @param {Array} c
 * @return {Number}
 */
Convex.triangleArea = function(a,b,c){
    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1]))) * 0.5;
};

/**
 * Update the .area
 * @method updateArea
 */
Convex.prototype.updateArea = function(){
    this.updateTriangles();
    this.area = 0;

    var triangles = this.triangles,
        verts = this.vertices;
    for(var i=0; i!==triangles.length; i++){
        var t = triangles[i],
            a = verts[t[0]],
            b = verts[t[1]],
            c = verts[t[2]];

        // Get mass for the triangle (density=1 in this case)
        var m = Convex.triangleArea(a,b,c);
        this.area += m;
    }
};

/**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */
Convex.prototype.computeAABB = function(out, position, angle){
    out.setFromPoints(this.vertices, position, angle, 0);
};

},{"../math/polyk":30,"../math/vec2":31,"./Shape":45,"poly-decomp":5}],40:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,    vec2 = _dereq_('../math/vec2')
,    Utils = _dereq_('../utils/Utils');

module.exports = Heightfield;

/**
 * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a distance "elementWidth".
 * @class Heightfield
 * @extends Shape
 * @constructor
 * @param {Array} data An array of Y values that will be used to construct the terrain.
 * @param {object} options
 * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
 * @param {Number} [options.maxValue] Maximum value.
 * @param {Number} [options.elementWidth=0.1] World spacing between the data points in X direction.
 * @todo Should be possible to use along all axes, not just y
 *
 * @example
 *     // Generate some height data (y-values).
 *     var data = [];
 *     for(var i = 0; i < 1000; i++){
 *         var y = 0.5 * Math.cos(0.2 * i);
 *         data.push(y);
 *     }
 *
 *     // Create the heightfield shape
 *     var heightfieldShape = new Heightfield(data, {
 *         elementWidth: 1 // Distance between the data points in X direction
 *     });
 *     var heightfieldBody = new Body();
 *     heightfieldBody.addShape(heightfieldShape);
 *     world.addBody(heightfieldBody);
 */
function Heightfield(data, options){
    options = Utils.defaults(options, {
        maxValue : null,
        minValue : null,
        elementWidth : 0.1
    });

    if(options.minValue === null || options.maxValue === null){
        options.maxValue = data[0];
        options.minValue = data[0];
        for(var i=0; i !== data.length; i++){
            var v = data[i];
            if(v > options.maxValue){
                options.maxValue = v;
            }
            if(v < options.minValue){
                options.minValue = v;
            }
        }
    }

    /**
     * An array of numbers, or height values, that are spread out along the x axis.
     * @property {array} data
     */
    this.data = data;

    /**
     * Max value of the data
     * @property {number} maxValue
     */
    this.maxValue = options.maxValue;

    /**
     * Max value of the data
     * @property {number} minValue
     */
    this.minValue = options.minValue;

    /**
     * The width of each element
     * @property {number} elementWidth
     */
    this.elementWidth = options.elementWidth;

    Shape.call(this,Shape.HEIGHTFIELD);
}
Heightfield.prototype = new Shape();
Heightfield.prototype.constructor = Heightfield;

/**
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */
Heightfield.prototype.computeMomentOfInertia = function(mass){
    return Number.MAX_VALUE;
};

Heightfield.prototype.updateBoundingRadius = function(){
    this.boundingRadius = Number.MAX_VALUE;
};

Heightfield.prototype.updateArea = function(){
    var data = this.data,
        area = 0;
    for(var i=0; i<data.length-1; i++){
        area += (data[i]+data[i+1]) / 2 * this.elementWidth;
    }
    this.area = area;
};

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Heightfield.prototype.computeAABB = function(out, position, angle){
    // Use the max data rectangle
    out.upperBound[0] = this.elementWidth * this.data.length + position[0];
    out.upperBound[1] = this.maxValue + position[1];
    out.lowerBound[0] = position[0];
    out.lowerBound[1] = -Number.MAX_VALUE; // Infinity
};

},{"../math/vec2":31,"../utils/Utils":50,"./Shape":45}],41:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2');

module.exports = Line;

/**
 * Line shape class. The line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].
 * @class Line
 * @param {Number} [length=1] The total length of the line
 * @extends Shape
 * @constructor
 */
function Line(length){

    /**
     * Length of this line
     * @property length
     * @type {Number}
     */
    this.length = length || 1;

    Shape.call(this,Shape.LINE);
}
Line.prototype = new Shape();
Line.prototype.constructor = Line;

Line.prototype.computeMomentOfInertia = function(mass){
    return mass * Math.pow(this.length,2) / 12;
};

Line.prototype.updateBoundingRadius = function(){
    this.boundingRadius = this.length/2;
};

var points = [vec2.create(),vec2.create()];

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Line.prototype.computeAABB = function(out, position, angle){
    var l2 = this.length / 2;
    vec2.set(points[0], -l2,  0);
    vec2.set(points[1],  l2,  0);
    out.setFromPoints(points,position,angle,0);
};


},{"../math/vec2":31,"./Shape":45}],42:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape')
,   vec2 = _dereq_('../math/vec2');

module.exports = Particle;

/**
 * Particle shape class.
 * @class Particle
 * @constructor
 * @extends Shape
 */
function Particle(){
    Shape.call(this,Shape.PARTICLE);
}
Particle.prototype = new Shape();
Particle.prototype.constructor = Particle;

Particle.prototype.computeMomentOfInertia = function(mass){
    return 0; // Can't rotate a particle
};

Particle.prototype.updateBoundingRadius = function(){
    this.boundingRadius = 0;
};

/**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */
Particle.prototype.computeAABB = function(out, position, angle){
    vec2.copy(out.lowerBound, position);
    vec2.copy(out.upperBound, position);
};

},{"../math/vec2":31,"./Shape":45}],43:[function(_dereq_,module,exports){
var Shape =  _dereq_('./Shape')
,    vec2 =  _dereq_('../math/vec2')
,    Utils = _dereq_('../utils/Utils');

module.exports = Plane;

/**
 * Plane shape class. The plane is facing in the Y direction.
 * @class Plane
 * @extends Shape
 * @constructor
 */
function Plane(){
    Shape.call(this,Shape.PLANE);
}
Plane.prototype = new Shape();
Plane.prototype.constructor = Plane;

/**
 * Compute moment of inertia
 * @method computeMomentOfInertia
 */
Plane.prototype.computeMomentOfInertia = function(mass){
    return 0; // Plane is infinite. The inertia should therefore be infinty but by convention we set 0 here
};

/**
 * Update the bounding radius
 * @method updateBoundingRadius
 */
Plane.prototype.updateBoundingRadius = function(){
    this.boundingRadius = Number.MAX_VALUE;
};

/**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */
Plane.prototype.computeAABB = function(out, position, angle){
    var a = 0,
        set = vec2.set;
    if(typeof(angle) === "number"){
        a = angle % (2*Math.PI);
    }

    if(a === 0){
        // y goes from -inf to 0
        set(out.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);
        set(out.upperBound,  Number.MAX_VALUE,  0);
    } else if(a === Math.PI / 2){
        // x goes from 0 to inf
        set(out.lowerBound, 0, -Number.MAX_VALUE);
        set(out.upperBound,      Number.MAX_VALUE,  Number.MAX_VALUE);
    } else if(a === Math.PI){
        // y goes from 0 to inf
        set(out.lowerBound, -Number.MAX_VALUE, 0);
        set(out.upperBound,  Number.MAX_VALUE, Number.MAX_VALUE);
    } else if(a === 3*Math.PI/2){
        // x goes from -inf to 0
        set(out.lowerBound, -Number.MAX_VALUE,     -Number.MAX_VALUE);
        set(out.upperBound,  0,  Number.MAX_VALUE);
    } else {
        // Set max bounds
        set(out.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);
        set(out.upperBound,  Number.MAX_VALUE,  Number.MAX_VALUE);
    }

    vec2.add(out.lowerBound, out.lowerBound, position);
    vec2.add(out.upperBound, out.upperBound, position);
};

Plane.prototype.updateArea = function(){
    this.area = Number.MAX_VALUE;
};


},{"../math/vec2":31,"../utils/Utils":50,"./Shape":45}],44:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Shape = _dereq_('./Shape')
,   Convex = _dereq_('./Convex');

module.exports = Rectangle;

/**
 * Rectangle shape class.
 * @class Rectangle
 * @constructor
 * @param {Number} [width=1] Width
 * @param {Number} [height=1] Height
 * @extends Convex
 */
function Rectangle(width, height){

    /**
     * Total width of the rectangle
     * @property width
     * @type {Number}
     */
    this.width = width || 1;

    /**
     * Total height of the rectangle
     * @property height
     * @type {Number}
     */
    this.height = height || 1;

    var verts = [   vec2.fromValues(-width/2, -height/2),
                    vec2.fromValues( width/2, -height/2),
                    vec2.fromValues( width/2,  height/2),
                    vec2.fromValues(-width/2,  height/2)];
    var axes = [vec2.fromValues(1, 0), vec2.fromValues(0, 1)];

    Convex.call(this, verts, axes);

    this.type = Shape.RECTANGLE;
}
Rectangle.prototype = new Convex([]);
Rectangle.prototype.constructor = Rectangle;

/**
 * Compute moment of inertia
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */
Rectangle.prototype.computeMomentOfInertia = function(mass){
    var w = this.width,
        h = this.height;
    return mass * (h*h + w*w) / 12;
};

/**
 * Update the bounding radius
 * @method updateBoundingRadius
 */
Rectangle.prototype.updateBoundingRadius = function(){
    var w = this.width,
        h = this.height;
    this.boundingRadius = Math.sqrt(w*w + h*h) / 2;
};

var corner1 = vec2.create(),
    corner2 = vec2.create(),
    corner3 = vec2.create(),
    corner4 = vec2.create();

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Rectangle.prototype.computeAABB = function(out, position, angle){
    out.setFromPoints(this.vertices,position,angle,0);
};

Rectangle.prototype.updateArea = function(){
    this.area = this.width * this.height;
};


},{"../math/vec2":31,"./Convex":39,"./Shape":45}],45:[function(_dereq_,module,exports){
module.exports = Shape;

/**
 * Base class for shapes.
 * @class Shape
 * @constructor
 * @param {Number} type
 */
function Shape(type){

    /**
     * The type of the shape. One of:
     *
     * * {{#crossLink "Shape/CIRCLE:property"}}Shape.CIRCLE{{/crossLink}}
     * * {{#crossLink "Shape/PARTICLE:property"}}Shape.PARTICLE{{/crossLink}}
     * * {{#crossLink "Shape/PLANE:property"}}Shape.PLANE{{/crossLink}}
     * * {{#crossLink "Shape/CONVEX:property"}}Shape.CONVEX{{/crossLink}}
     * * {{#crossLink "Shape/LINE:property"}}Shape.LINE{{/crossLink}}
     * * {{#crossLink "Shape/RECTANGLE:property"}}Shape.RECTANGLE{{/crossLink}}
     * * {{#crossLink "Shape/CAPSULE:property"}}Shape.CAPSULE{{/crossLink}}
     * * {{#crossLink "Shape/HEIGHTFIELD:property"}}Shape.HEIGHTFIELD{{/crossLink}}
     *
     * @property {number} type
     */
    this.type = type;

    /**
     * Shape object identifier.
     * @type {Number}
     * @property id
     */
    this.id = Shape.idCounter++;

    /**
     * Bounding circle radius of this shape
     * @property boundingRadius
     * @type {Number}
     */
    this.boundingRadius = 0;

    /**
     * Collision group that this shape belongs to (bit mask). See <a href="http://www.aurelienribon.com/blog/2011/07/box2d-tutorial-collision-filtering/">this tutorial</a>.
     * @property collisionGroup
     * @type {Number}
     * @example
     *     // Setup bits for each available group
     *     var PLAYER = Math.pow(2,0),
     *         ENEMY =  Math.pow(2,1),
     *         GROUND = Math.pow(2,2)
     *
     *     // Put shapes into their groups
     *     player1Shape.collisionGroup = PLAYER;
     *     player2Shape.collisionGroup = PLAYER;
     *     enemyShape  .collisionGroup = ENEMY;
     *     groundShape .collisionGroup = GROUND;
     *
     *     // Assign groups that each shape collide with.
     *     // Note that the players can collide with ground and enemies, but not with other players.
     *     player1Shape.collisionMask = ENEMY | GROUND;
     *     player2Shape.collisionMask = ENEMY | GROUND;
     *     enemyShape  .collisionMask = PLAYER | GROUND;
     *     groundShape .collisionMask = PLAYER | ENEMY;
     *
     * @example
     *     // How collision check is done
     *     if(shapeA.collisionGroup & shapeB.collisionMask)!=0 && (shapeB.collisionGroup & shapeA.collisionMask)!=0){
     *         // The shapes will collide
     *     }
     */
    this.collisionGroup = 1;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this shape will move through other body shapes, but it will still trigger contact events, etc.
     * @property {Boolean} collisionResponse
     */
    this.collisionResponse = true;

    /**
     * Collision mask of this shape. See .collisionGroup.
     * @property collisionMask
     * @type {Number}
     */
    this.collisionMask =  1;
    if(type){
        this.updateBoundingRadius();
    }

    /**
     * Material to use in collisions for this Shape. If this is set to null, the world will use default material properties instead.
     * @property material
     * @type {Material}
     */
    this.material = null;

    /**
     * Area of this shape.
     * @property area
     * @type {Number}
     */
    this.area = 0;

    /**
     * Set to true if you want this shape to be a sensor. A sensor does not generate contacts, but it still reports contact events. This is good if you want to know if a shape is overlapping another shape, without them generating contacts.
     * @property {Boolean} sensor
     */
    this.sensor = false;

    this.updateArea();
}

Shape.idCounter = 0;

/**
 * @static
 * @property {Number} CIRCLE
 */
Shape.CIRCLE =      1;

/**
 * @static
 * @property {Number} PARTICLE
 */
Shape.PARTICLE =    2;

/**
 * @static
 * @property {Number} PLANE
 */
Shape.PLANE =       4;

/**
 * @static
 * @property {Number} CONVEX
 */
Shape.CONVEX =      8;

/**
 * @static
 * @property {Number} LINE
 */
Shape.LINE =        16;

/**
 * @static
 * @property {Number} RECTANGLE
 */
Shape.RECTANGLE =   32;

/**
 * @static
 * @property {Number} CAPSULE
 */
Shape.CAPSULE =     64;

/**
 * @static
 * @property {Number} HEIGHTFIELD
 */
Shape.HEIGHTFIELD = 128;

/**
 * Should return the moment of inertia around the Z axis of the body given the total mass. See <a href="http://en.wikipedia.org/wiki/List_of_moments_of_inertia">Wikipedia's list of moments of inertia</a>.
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number} If the inertia is infinity or if the object simply isn't possible to rotate, return 0.
 */
Shape.prototype.computeMomentOfInertia = function(mass){
    throw new Error("Shape.computeMomentOfInertia is not implemented in this Shape...");
};

/**
 * Returns the bounding circle radius of this shape.
 * @method updateBoundingRadius
 * @return {Number}
 */
Shape.prototype.updateBoundingRadius = function(){
    throw new Error("Shape.updateBoundingRadius is not implemented in this Shape...");
};

/**
 * Update the .area property of the shape.
 * @method updateArea
 */
Shape.prototype.updateArea = function(){
    // To be implemented in all subclasses
};

/**
 * Compute the world axis-aligned bounding box (AABB) of this shape.
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Shape.prototype.computeAABB = function(out, position, angle){
    // To be implemented in each subclass
};

},{}],46:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Solver = _dereq_('./Solver')
,   Utils = _dereq_('../utils/Utils')
,   FrictionEquation = _dereq_('../equations/FrictionEquation');

module.exports = GSSolver;

/**
 * Iterative Gauss-Seidel constraint equation solver.
 *
 * @class GSSolver
 * @constructor
 * @extends Solver
 * @param {Object} [options]
 * @param {Number} [options.iterations=10]
 * @param {Number} [options.tolerance=0]
 */
function GSSolver(options){
    Solver.call(this,options,Solver.GS);
    options = options || {};

    /**
     * The number of iterations to do when solving. More gives better results, but is more expensive.
     * @property iterations
     * @type {Number}
     */
    this.iterations = options.iterations || 10;

    /**
     * The error tolerance, per constraint. If the total error is below this limit, the solver will stop iterating. Set to zero for as good solution as possible, but to something larger than zero to make computations faster.
     * @property tolerance
     * @type {Number}
     */
    this.tolerance = options.tolerance || 1e-10;

    this.arrayStep = 30;
    this.lambda = new Utils.ARRAY_TYPE(this.arrayStep);
    this.Bs =     new Utils.ARRAY_TYPE(this.arrayStep);
    this.invCs =  new Utils.ARRAY_TYPE(this.arrayStep);

    /**
     * Set to true to set all right hand side terms to zero when solving. Can be handy for a few applications.
     * @property useZeroRHS
     * @type {Boolean}
     */
    this.useZeroRHS = false;

    /**
     * Number of solver iterations that are done to approximate normal forces. When these iterations are done, friction force will be computed from the contact normal forces. These friction forces will override any other friction forces set from the World for example.
     * The solver will use less iterations if the solution is below the .tolerance.
     * @property frictionIterations
     * @type {Number}
     */
    this.frictionIterations = 0;

    /**
     * The number of iterations that were made during the last solve. If .tolerance is zero, this value will always be equal to .iterations, but if .tolerance is larger than zero, and the solver can quit early, then this number will be somewhere between 1 and .iterations.
     * @property {Number} usedIterations
     */
    this.usedIterations = 0;
}
GSSolver.prototype = new Solver();
GSSolver.prototype.constructor = GSSolver;

function setArrayZero(array){
    var l = array.length;
    while(l--){
        array[l] = +0.0;
    }
}

/**
 * Solve the system of equations
 * @method solve
 * @param  {Number}  h       Time step
 * @param  {World}   world    World to solve
 */
GSSolver.prototype.solve = function(h, world){

    this.sortEquations();

    var iter = 0,
        maxIter = this.iterations,
        maxFrictionIter = this.frictionIterations,
        equations = this.equations,
        Neq = equations.length,
        tolSquared = Math.pow(this.tolerance*Neq, 2),
        bodies = world.bodies,
        Nbodies = world.bodies.length,
        add = vec2.add,
        set = vec2.set,
        useZeroRHS = this.useZeroRHS,
        lambda = this.lambda;

    this.usedIterations = 0;

    if(Neq){
        for(var i=0; i!==Nbodies; i++){
            var b = bodies[i];

            // Update solve mass
            b.updateSolveMassProperties();
        }
    }

    // Things that does not change during iteration can be computed once
    if(lambda.length < Neq){
        lambda = this.lambda =  new Utils.ARRAY_TYPE(Neq + this.arrayStep);
        this.Bs =               new Utils.ARRAY_TYPE(Neq + this.arrayStep);
        this.invCs =            new Utils.ARRAY_TYPE(Neq + this.arrayStep);
    }
    setArrayZero(lambda);
    var invCs = this.invCs,
        Bs = this.Bs,
        lambda = this.lambda;

    for(var i=0; i!==equations.length; i++){
        var c = equations[i];
        if(c.timeStep !== h || c.needsUpdate){
            c.timeStep = h;
            c.update();
        }
        Bs[i] =     c.computeB(c.a,c.b,h);
        invCs[i] =  c.computeInvC(c.epsilon);
    }

    var q, B, c, deltalambdaTot,i,j;

    if(Neq !== 0){

        for(i=0; i!==Nbodies; i++){
            var b = bodies[i];

            // Reset vlambda
            b.resetConstraintVelocity();
        }

        if(maxFrictionIter){
            // Iterate over contact equations to get normal forces
            for(iter=0; iter!==maxFrictionIter; iter++){

                // Accumulate the total error for each iteration.
                deltalambdaTot = 0.0;

                for(j=0; j!==Neq; j++){
                    c = equations[j];

                    var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);
                    deltalambdaTot += Math.abs(deltalambda);
                }

                this.usedIterations++;

                // If the total error is small enough - stop iterate
                if(deltalambdaTot*deltalambdaTot <= tolSquared){
                    break;
                }
            }

            GSSolver.updateMultipliers(equations, lambda, 1/h);

            // Set computed friction force
            for(j=0; j!==Neq; j++){
                var eq = equations[j];
                if(eq instanceof FrictionEquation){
                    var f = 0.0;
                    for(var k=0; k!==eq.contactEquations.length; k++){
                        f += eq.contactEquations[k].multiplier;
                    }
                    f *= eq.frictionCoefficient / eq.contactEquations.length;
                    eq.maxForce =  f;
                    eq.minForce = -f;
                }
            }
        }

        // Iterate over all equations
        for(iter=0; iter!==maxIter; iter++){

            // Accumulate the total error for each iteration.
            deltalambdaTot = 0.0;

            for(j=0; j!==Neq; j++){
                c = equations[j];

                var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);
                deltalambdaTot += Math.abs(deltalambda);
            }

            this.usedIterations++;

            // If the total error is small enough - stop iterate
            if(deltalambdaTot*deltalambdaTot <= tolSquared){
                break;
            }
        }

        // Add result to velocity
        for(i=0; i!==Nbodies; i++){
            bodies[i].addConstraintVelocity();
        }

        GSSolver.updateMultipliers(equations, lambda, 1/h);
    }
};

// Sets the .multiplier property of each equation
GSSolver.updateMultipliers = function(equations, lambda, invDt){
    // Set the .multiplier property of each equation
    var l = equations.length;
    while(l--){
        equations[l].multiplier = lambda[l] * invDt;
    }
};

GSSolver.iterateEquation = function(j,eq,eps,Bs,invCs,lambda,useZeroRHS,dt,iter){
    // Compute iteration
    var B = Bs[j],
        invC = invCs[j],
        lambdaj = lambda[j],
        GWlambda = eq.computeGWlambda();

    var maxForce = eq.maxForce,
        minForce = eq.minForce;

    if(useZeroRHS){
        B = 0;
    }

    var deltalambda = invC * ( B - GWlambda - eps * lambdaj );

    // Clamp if we are not within the min/max interval
    var lambdaj_plus_deltalambda = lambdaj + deltalambda;
    if(lambdaj_plus_deltalambda < minForce*dt){
        deltalambda = minForce*dt - lambdaj;
    } else if(lambdaj_plus_deltalambda > maxForce*dt){
        deltalambda = maxForce*dt - lambdaj;
    }
    lambda[j] += deltalambda;
    eq.addToWlambda(deltalambda);

    return deltalambda;
};

},{"../equations/FrictionEquation":24,"../math/vec2":31,"../utils/Utils":50,"./Solver":47}],47:[function(_dereq_,module,exports){
var Utils = _dereq_('../utils/Utils')
,   EventEmitter = _dereq_('../events/EventEmitter');

module.exports = Solver;

/**
 * Base class for constraint solvers.
 * @class Solver
 * @constructor
 * @extends EventEmitter
 */
function Solver(options,type){
    options = options || {};

    EventEmitter.call(this);

    this.type = type;

    /**
     * Current equations in the solver.
     *
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * Function that is used to sort all equations before each solve.
     * @property equationSortFunction
     * @type {function|boolean}
     */
    this.equationSortFunction = options.equationSortFunction || false;
}
Solver.prototype = new EventEmitter();
Solver.prototype.constructor = Solver;

/**
 * Method to be implemented in each subclass
 * @method solve
 * @param  {Number} dt
 * @param  {World} world
 */
Solver.prototype.solve = function(dt,world){
    throw new Error("Solver.solve should be implemented by subclasses!");
};

var mockWorld = {bodies:[]};

/**
 * Solves all constraints in an island.
 * @method solveIsland
 * @param  {Number} dt
 * @param  {Island} island
 */
Solver.prototype.solveIsland = function(dt,island){

    this.removeAllEquations();

    if(island.equations.length){
        // Add equations to solver
        this.addEquations(island.equations);
        mockWorld.bodies.length = 0;
        island.getBodies(mockWorld.bodies);

        // Solve
        if(mockWorld.bodies.length){
            this.solve(dt,mockWorld);
        }
    }
};

/**
 * Sort all equations using the .equationSortFunction. Should be called by subclasses before solving.
 * @method sortEquations
 */
Solver.prototype.sortEquations = function(){
    if(this.equationSortFunction){
        this.equations.sort(this.equationSortFunction);
    }
};

/**
 * Add an equation to be solved.
 *
 * @method addEquation
 * @param {Equation} eq
 */
Solver.prototype.addEquation = function(eq){
    if(eq.enabled){
        this.equations.push(eq);
    }
};

/**
 * Add equations. Same as .addEquation, but this time the argument is an array of Equations
 *
 * @method addEquations
 * @param {Array} eqs
 */
Solver.prototype.addEquations = function(eqs){
    //Utils.appendArray(this.equations,eqs);
    for(var i=0, N=eqs.length; i!==N; i++){
        var eq = eqs[i];
        if(eq.enabled){
            this.equations.push(eq);
        }
    }
};

/**
 * Remove an equation.
 *
 * @method removeEquation
 * @param {Equation} eq
 */
Solver.prototype.removeEquation = function(eq){
    var i = this.equations.indexOf(eq);
    if(i !== -1){
        this.equations.splice(i,1);
    }
};

/**
 * Remove all currently added equations.
 *
 * @method removeAllEquations
 */
Solver.prototype.removeAllEquations = function(){
    this.equations.length=0;
};

Solver.GS = 1;
Solver.ISLAND = 2;

},{"../events/EventEmitter":27,"../utils/Utils":50}],48:[function(_dereq_,module,exports){
var TupleDictionary = _dereq_('./TupleDictionary');
var Utils = _dereq_('./Utils');

module.exports = OverlapKeeper;

/**
 * Keeps track of overlaps in the current state and the last step state.
 * @class OverlapKeeper
 * @constructor
 */
function OverlapKeeper() {
    this.overlappingShapesLastState = new TupleDictionary();
    this.overlappingShapesCurrentState = new TupleDictionary();
    this.recordPool = [];
    this.tmpDict = new TupleDictionary();
    this.tmpArray1 = [];
}

/**
 * Ticks one step forward in time. This will move the current overlap state to the "old" overlap state, and create a new one as current.
 * @method tick
 */
OverlapKeeper.prototype.tick = function() {
    var last = this.overlappingShapesLastState;
    var current = this.overlappingShapesCurrentState;

    // Save old objects into pool
    var l = last.keys.length;
    while(l--){
        var key = last.keys[l];
        var lastObject = last.getByKey(key);
        var currentObject = current.getByKey(key);
        if(lastObject && !currentObject){
            // The record is only used in the "last" dict, and will be removed. We might as well pool it.
            this.recordPool.push(lastObject);
        }
    }

    // Clear last object
    last.reset();

    // Transfer from new object to old
    last.copy(current);

    // Clear current object
    current.reset();
};

/**
 * @method setOverlapping
 * @param {Body} bodyA
 * @param {Body} shapeA
 * @param {Body} bodyB
 * @param {Body} shapeB
 */
OverlapKeeper.prototype.setOverlapping = function(bodyA, shapeA, bodyB, shapeB) {
    var last = this.overlappingShapesLastState;
    var current = this.overlappingShapesCurrentState;

    // Store current contact state
    if(!current.get(shapeA.id, shapeB.id)){

        var data;
        if(this.recordPool.length){
            data = this.recordPool.pop();
            data.set(bodyA, shapeA, bodyB, shapeB);
        } else {
            data = new OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB);
        }

        current.set(shapeA.id, shapeB.id, data);
    }
};

OverlapKeeper.prototype.getNewOverlaps = function(result){
    return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, result);
};

OverlapKeeper.prototype.getEndOverlaps = function(result){
    return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, result);
};

/**
 * Checks if two bodies are currently overlapping.
 * @method bodiesAreOverlapping
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {boolean}
 */
OverlapKeeper.prototype.bodiesAreOverlapping = function(bodyA, bodyB){
    var current = this.overlappingShapesCurrentState;
    var l = current.keys.length;
    while(l--){
        var key = current.keys[l];
        var data = current.data[key];
        if((data.bodyA === bodyA && data.bodyB === bodyB) || data.bodyA === bodyB && data.bodyB === bodyA){
            return true;
        }
    }
    return false;
};

OverlapKeeper.prototype.getDiff = function(dictA, dictB, result){
    var result = result || [];
    var last = dictA;
    var current = dictB;

    result.length = 0;

    var l = current.keys.length;
    while(l--){
        var key = current.keys[l];
        var data = current.data[key];

        if(!data){
            throw new Error('Key '+key+' had no data!');
        }

        var lastData = last.data[key];
        if(!lastData){
            // Not overlapping in last state, but in current.
            result.push(data);
        }
    }

    return result;
};

OverlapKeeper.prototype.isNewOverlap = function(shapeA, shapeB){
    var idA = shapeA.id|0,
        idB = shapeB.id|0;
    var last = this.overlappingShapesLastState;
    var current = this.overlappingShapesCurrentState;
    // Not in last but in new
    return !!!last.get(idA, idB) && !!current.get(idA, idB);
};

OverlapKeeper.prototype.getNewBodyOverlaps = function(result){
    this.tmpArray1.length = 0;
    var overlaps = this.getNewOverlaps(this.tmpArray1);
    return this.getBodyDiff(overlaps, result);
};

OverlapKeeper.prototype.getEndBodyOverlaps = function(result){
    this.tmpArray1.length = 0;
    var overlaps = this.getEndOverlaps(this.tmpArray1);
    return this.getBodyDiff(overlaps, result);
};

OverlapKeeper.prototype.getBodyDiff = function(overlaps, result){
    result = result || [];
    var accumulator = this.tmpDict;

    var l = overlaps.length;

    while(l--){
        var data = overlaps[l];

        // Since we use body id's for the accumulator, these will be a subset of the original one
        accumulator.set(data.bodyA.id|0, data.bodyB.id|0, data);
    }

    l = accumulator.keys.length;
    while(l--){
        var data = accumulator.getByKey(accumulator.keys[l]);
        if(data){
            result.push(data.bodyA, data.bodyB);
        }
    }

    accumulator.reset();

    return result;
};

/**
 * Overlap data container for the OverlapKeeper
 * @class OverlapKeeperRecord
 * @constructor
 * @param {Body} bodyA
 * @param {Shape} shapeA
 * @param {Body} bodyB
 * @param {Shape} shapeB
 */
function OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB){
    /**
     * @property {Shape} shapeA
     */
    this.shapeA = shapeA;
    /**
     * @property {Shape} shapeB
     */
    this.shapeB = shapeB;
    /**
     * @property {Body} bodyA
     */
    this.bodyA = bodyA;
    /**
     * @property {Body} bodyB
     */
    this.bodyB = bodyB;
}

/**
 * Set the data for the record
 * @method set
 * @param {Body} bodyA
 * @param {Shape} shapeA
 * @param {Body} bodyB
 * @param {Shape} shapeB
 */
OverlapKeeperRecord.prototype.set = function(bodyA, shapeA, bodyB, shapeB){
    OverlapKeeperRecord.call(this, bodyA, shapeA, bodyB, shapeB);
};

},{"./TupleDictionary":49,"./Utils":50}],49:[function(_dereq_,module,exports){
var Utils = _dereq_('./Utils');

module.exports = TupleDictionary;

/**
 * @class TupleDictionary
 * @constructor
 */
function TupleDictionary() {

    /**
     * The data storage
     * @property data
     * @type {Object}
     */
    this.data = {};

    /**
     * Keys that are currently used.
     * @property {Array} keys
     */
    this.keys = [];
}

/**
 * Generate a key given two integers
 * @method getKey
 * @param  {number} i
 * @param  {number} j
 * @return {string}
 */
TupleDictionary.prototype.getKey = function(id1, id2) {
    id1 = id1|0;
    id2 = id2|0;

    if ( (id1|0) === (id2|0) ){
        return -1;
    }

    // valid for values < 2^16
    return ((id1|0) > (id2|0) ?
        (id1 << 16) | (id2 & 0xFFFF) :
        (id2 << 16) | (id1 & 0xFFFF))|0
        ;
};

/**
 * @method getByKey
 * @param  {Number} key
 * @return {Object}
 */
TupleDictionary.prototype.getByKey = function(key) {
    key = key|0;
    return this.data[key];
};

/**
 * @method get
 * @param  {Number} i
 * @param  {Number} j
 * @return {Number}
 */
TupleDictionary.prototype.get = function(i, j) {
    return this.data[this.getKey(i, j)];
};

/**
 * Set a value.
 * @method set
 * @param  {Number} i
 * @param  {Number} j
 * @param {Number} value
 */
TupleDictionary.prototype.set = function(i, j, value) {
    if(!value){
        throw new Error("No data!");
    }

    var key = this.getKey(i, j);

    // Check if key already exists
    if(!this.data[key]){
        this.keys.push(key);
    }

    this.data[key] = value;

    return key;
};

/**
 * Remove all data.
 * @method reset
 */
TupleDictionary.prototype.reset = function() {
    var data = this.data,
        keys = this.keys;

    var l = keys.length;
    while(l--) {
        delete data[keys[l]];
    }

    keys.length = 0;
};

/**
 * Copy another TupleDictionary. Note that all data in this dictionary will be removed.
 * @method copy
 * @param {TupleDictionary} dict The TupleDictionary to copy into this one.
 */
TupleDictionary.prototype.copy = function(dict) {
    this.reset();
    Utils.appendArray(this.keys, dict.keys);
    var l = dict.keys.length;
    while(l--){
        var key = dict.keys[l];
        this.data[key] = dict.data[key];
    }
};

},{"./Utils":50}],50:[function(_dereq_,module,exports){
/* global P2_ARRAY_TYPE */

module.exports = Utils;

/**
 * Misc utility functions
 * @class Utils
 * @constructor
 */
function Utils(){}

/**
 * Append the values in array b to the array a. See <a href="http://stackoverflow.com/questions/1374126/how-to-append-an-array-to-an-existing-javascript-array/1374131#1374131">this</a> for an explanation.
 * @method appendArray
 * @static
 * @param  {Array} a
 * @param  {Array} b
 */
Utils.appendArray = function(a,b){
    if (b.length < 150000) {
        a.push.apply(a, b);
    } else {
        for (var i = 0, len = b.length; i !== len; ++i) {
            a.push(b[i]);
        }
    }
};

/**
 * Garbage free Array.splice(). Does not allocate a new array.
 * @method splice
 * @static
 * @param  {Array} array
 * @param  {Number} index
 * @param  {Number} howmany
 */
Utils.splice = function(array,index,howmany){
    howmany = howmany || 1;
    for (var i=index, len=array.length-howmany; i < len; i++){
        array[i] = array[i + howmany];
    }
    array.length = len;
};

/**
 * The array type to use for internal numeric computations throughout the library. Float32Array is used if it is available, but falls back on Array. If you want to set array type manually, inject it via the global variable P2_ARRAY_TYPE. See example below.
 * @static
 * @property {function} ARRAY_TYPE
 * @example
 *     <script>
 *         <!-- Inject your preferred array type before loading p2.js -->
 *         P2_ARRAY_TYPE = Array;
 *     </script>
 *     <script src="p2.js"></script>
 */
if(typeof P2_ARRAY_TYPE !== 'undefined') {
    Utils.ARRAY_TYPE = P2_ARRAY_TYPE;
} else if (typeof Float32Array !== 'undefined'){
    Utils.ARRAY_TYPE = Float32Array;
} else {
    Utils.ARRAY_TYPE = Array;
}

/**
 * Extend an object with the properties of another
 * @static
 * @method extend
 * @param  {object} a
 * @param  {object} b
 */
Utils.extend = function(a,b){
    for(var key in b){
        a[key] = b[key];
    }
};

/**
 * Extend an options object with default values.
 * @static
 * @method defaults
 * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.
 * @param  {object} defaults An object containing default values.
 * @return {object} The modified options object.
 */
Utils.defaults = function(options, defaults){
    options = options || {};
    for(var key in defaults){
        if(!(key in options)){
            options[key] = defaults[key];
        }
    }
    return options;
};

},{}],51:[function(_dereq_,module,exports){
var Body = _dereq_('../objects/Body');

module.exports = Island;

/**
 * An island of bodies connected with equations.
 * @class Island
 * @constructor
 */
function Island(){

    /**
     * Current equations in this island.
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * Current bodies in this island.
     * @property bodies
     * @type {Array}
     */
    this.bodies = [];
}

/**
 * Clean this island from bodies and equations.
 * @method reset
 */
Island.prototype.reset = function(){
    this.equations.length = this.bodies.length = 0;
};

var bodyIds = [];

/**
 * Get all unique bodies in this island.
 * @method getBodies
 * @return {Array} An array of Body
 */
Island.prototype.getBodies = function(result){
    var bodies = result || [],
        eqs = this.equations;
    bodyIds.length = 0;
    for(var i=0; i!==eqs.length; i++){
        var eq = eqs[i];
        if(bodyIds.indexOf(eq.bodyA.id)===-1){
            bodies.push(eq.bodyA);
            bodyIds.push(eq.bodyA.id);
        }
        if(bodyIds.indexOf(eq.bodyB.id)===-1){
            bodies.push(eq.bodyB);
            bodyIds.push(eq.bodyB.id);
        }
    }
    return bodies;
};

/**
 * Check if the entire island wants to sleep.
 * @method wantsToSleep
 * @return {Boolean}
 */
Island.prototype.wantsToSleep = function(){
    for(var i=0; i<this.bodies.length; i++){
        var b = this.bodies[i];
        if(b.type === Body.DYNAMIC && !b.wantsToSleep){
            return false;
        }
    }
    return true;
};

/**
 * Make all bodies in the island sleep.
 * @method sleep
 */
Island.prototype.sleep = function(){
    for(var i=0; i<this.bodies.length; i++){
        var b = this.bodies[i];
        b.sleep();
    }
    return true;
};

},{"../objects/Body":32}],52:[function(_dereq_,module,exports){
var vec2 = _dereq_('../math/vec2')
,   Island = _dereq_('./Island')
,   IslandNode = _dereq_('./IslandNode')
,   Body = _dereq_('../objects/Body');

module.exports = IslandManager;

/**
 * Splits the system of bodies and equations into independent islands
 *
 * @class IslandManager
 * @constructor
 * @param {Object} [options]
 * @extends Solver
 */
function IslandManager(options){

    // Pooling of node objects saves some GC load
    this._nodePool = [];
    this._islandPool = [];

    /**
     * The equations to split. Manually fill this array before running .split().
     * @property {Array} equations
     */
    this.equations = [];

    /**
     * The resulting {{#crossLink "Island"}}{{/crossLink}}s.
     * @property {Array} islands
     */
    this.islands = [];

    /**
     * The resulting graph nodes.
     * @property {Array} nodes
     */
    this.nodes = [];

    /**
     * The node queue, used when traversing the graph of nodes.
     * @private
     * @property {Array} queue
     */
    this.queue = [];
}

/**
 * Get an unvisited node from a list of nodes.
 * @static
 * @method getUnvisitedNode
 * @param  {Array} nodes
 * @return {IslandNode|boolean} The node if found, else false.
 */
IslandManager.getUnvisitedNode = function(nodes){
    var Nnodes = nodes.length;
    for(var i=0; i!==Nnodes; i++){
        var node = nodes[i];
        if(!node.visited && node.body.type === Body.DYNAMIC){
            return node;
        }
    }
    return false;
};

/**
 * Visit a node.
 * @method visit
 * @param  {IslandNode} node
 * @param  {Array} bds
 * @param  {Array} eqs
 */
IslandManager.prototype.visit = function (node,bds,eqs){
    bds.push(node.body);
    var Neqs = node.equations.length;
    for(var i=0; i!==Neqs; i++){
        var eq = node.equations[i];
        if(eqs.indexOf(eq) === -1){ // Already added?
            eqs.push(eq);
        }
    }
};

/**
 * Runs the search algorithm, starting at a root node. The resulting bodies and equations will be stored in the provided arrays.
 * @method bfs
 * @param  {IslandNode} root The node to start from
 * @param  {Array} bds  An array to append resulting Bodies to.
 * @param  {Array} eqs  An array to append resulting Equations to.
 */
IslandManager.prototype.bfs = function(root,bds,eqs){

    // Reset the visit queue
    var queue = this.queue;
    queue.length = 0;

    // Add root node to queue
    queue.push(root);
    root.visited = true;
    this.visit(root,bds,eqs);

    // Process all queued nodes
    while(queue.length) {

        // Get next node in the queue
        var node = queue.pop();

        // Visit unvisited neighboring nodes
        var child;
        while((child = IslandManager.getUnvisitedNode(node.neighbors))) {
            child.visited = true;
            this.visit(child,bds,eqs);

            // Only visit the children of this node if it's dynamic
            if(child.body.type === Body.DYNAMIC){
                queue.push(child);
            }
        }
    }
};

/**
 * Split the world into independent islands. The result is stored in .islands.
 * @method split
 * @param  {World} world
 * @return {Array} The generated islands
 */
IslandManager.prototype.split = function(world){
    var bodies = world.bodies,
        nodes = this.nodes,
        equations = this.equations;

    // Move old nodes to the node pool
    while(nodes.length){
        this._nodePool.push(nodes.pop());
    }

    // Create needed nodes, reuse if possible
    for(var i=0; i!==bodies.length; i++){
        if(this._nodePool.length){
            var node = this._nodePool.pop();
            node.reset();
            node.body = bodies[i];
            nodes.push(node);
        } else {
            nodes.push(new IslandNode(bodies[i]));
        }
    }

    // Add connectivity data. Each equation connects 2 bodies.
    for(var k=0; k!==equations.length; k++){
        var eq=equations[k],
            i=bodies.indexOf(eq.bodyA),
            j=bodies.indexOf(eq.bodyB),
            ni=nodes[i],
            nj=nodes[j];
        ni.neighbors.push(nj);
        nj.neighbors.push(ni);
        ni.equations.push(eq);
        nj.equations.push(eq);
    }

    // Move old islands to the island pool
    var islands = this.islands;
    while(islands.length){
        var island = islands.pop();
        island.reset();
        this._islandPool.push(island);
    }

    // Get islands
    var child;
    while((child = IslandManager.getUnvisitedNode(nodes))){

        // Create new island
        var island = this._islandPool.length ? this._islandPool.pop() : new Island();

        // Get all equations and bodies in this island
        this.bfs(child, island.bodies, island.equations);

        islands.push(island);
    }

    return islands;
};

},{"../math/vec2":31,"../objects/Body":32,"./Island":51,"./IslandNode":53}],53:[function(_dereq_,module,exports){
module.exports = IslandNode;

/**
 * Holds a body and keeps track of some additional properties needed for graph traversal.
 * @class IslandNode
 * @constructor
 * @param {Body} body
 */
function IslandNode(body){

	/**
	 * The body that is contained in this node.
	 * @property {Body} body
	 */
    this.body = body;

    /**
     * Neighboring IslandNodes
     * @property {Array} neighbors
     */
    this.neighbors = [];

    /**
     * Equations connected to this node.
     * @property {Array} equations
     */
    this.equations = [];

    /**
     * If this node was visiting during the graph traversal.
     * @property visited
     * @type {Boolean}
     */
    this.visited = false;
}

/**
 * Clean this node from bodies and equations.
 * @method reset
 */
IslandNode.prototype.reset = function(){
    this.equations.length = 0;
    this.neighbors.length = 0;
    this.visited = false;
    this.body = null;
};

},{}],54:[function(_dereq_,module,exports){
/* global performance */
/*jshint -W020 */

var  GSSolver = _dereq_('../solver/GSSolver')
,    Solver = _dereq_('../solver/Solver')
,    NaiveBroadphase = _dereq_('../collision/NaiveBroadphase')
,    Ray = _dereq_('../collision/Ray')
,    vec2 = _dereq_('../math/vec2')
,    Circle = _dereq_('../shapes/Circle')
,    Rectangle = _dereq_('../shapes/Rectangle')
,    Convex = _dereq_('../shapes/Convex')
,    Line = _dereq_('../shapes/Line')
,    Plane = _dereq_('../shapes/Plane')
,    Capsule = _dereq_('../shapes/Capsule')
,    Particle = _dereq_('../shapes/Particle')
,    EventEmitter = _dereq_('../events/EventEmitter')
,    Body = _dereq_('../objects/Body')
,    Shape = _dereq_('../shapes/Shape')
,    LinearSpring = _dereq_('../objects/LinearSpring')
,    Material = _dereq_('../material/Material')
,    ContactMaterial = _dereq_('../material/ContactMaterial')
,    DistanceConstraint = _dereq_('../constraints/DistanceConstraint')
,    Constraint = _dereq_('../constraints/Constraint')
,    LockConstraint = _dereq_('../constraints/LockConstraint')
,    RevoluteConstraint = _dereq_('../constraints/RevoluteConstraint')
,    PrismaticConstraint = _dereq_('../constraints/PrismaticConstraint')
,    GearConstraint = _dereq_('../constraints/GearConstraint')
,    pkg = _dereq_('../../package.json')
,    Broadphase = _dereq_('../collision/Broadphase')
,    SAPBroadphase = _dereq_('../collision/SAPBroadphase')
,    Narrowphase = _dereq_('../collision/Narrowphase')
,    Utils = _dereq_('../utils/Utils')
,    OverlapKeeper = _dereq_('../utils/OverlapKeeper')
,    IslandManager = _dereq_('./IslandManager')
,    RotationalSpring = _dereq_('../objects/RotationalSpring');

module.exports = World;

if(typeof performance === 'undefined'){
    performance = {};
}
if(!performance.now){
    var nowOffset = Date.now();
    if (performance.timing && performance.timing.navigationStart){
        nowOffset = performance.timing.navigationStart;
    }
    performance.now = function(){
        return Date.now() - nowOffset;
    };
}

/**
 * The dynamics world, where all bodies and constraints lives.
 *
 * @class World
 * @constructor
 * @param {Object}          [options]
 * @param {Solver}          [options.solver]            Defaults to GSSolver.
 * @param {Array}           [options.gravity]           Defaults to [0,-9.78]
 * @param {Broadphase}      [options.broadphase]        Defaults to NaiveBroadphase
 * @param {Boolean}         [options.islandSplit=false]
 * @param {Boolean}         [options.doProfiling=false]
 * @extends EventEmitter
 *
 * @example
 *     var world = new World({
 *         gravity: [0, -9.81],
 *         broadphase: new SAPBroadphase()
 *     });
 */
function World(options){
    EventEmitter.apply(this);

    options = options || {};

    /**
     * All springs in the world. To add a spring to the world, use {{#crossLink "World/addSpring:method"}}{{/crossLink}}.
     *
     * @property springs
     * @type {Array}
     */
    this.springs = [];

    /**
     * All bodies in the world. To add a body to the world, use {{#crossLink "World/addBody:method"}}{{/crossLink}}.
     * @property {Array} bodies
     */
    this.bodies = [];

    /**
     * Disabled body collision pairs. See {{#crossLink "World/disableBodyCollision:method"}}.
     * @private
     * @property {Array} disabledBodyCollisionPairs
     */
    this.disabledBodyCollisionPairs = [];

    /**
     * The solver used to satisfy constraints and contacts. Default is {{#crossLink "GSSolver"}}{{/crossLink}}.
     * @property {Solver} solver
     */
    this.solver = options.solver || new GSSolver();

    /**
     * The narrowphase to use to generate contacts.
     *
     * @property narrowphase
     * @type {Narrowphase}
     */
    this.narrowphase = new Narrowphase(this);

    /**
     * The island manager of this world.
     * @property {IslandManager} islandManager
     */
    this.islandManager = new IslandManager();

    /**
     * Gravity in the world. This is applied on all bodies in the beginning of each step().
     *
     * @property gravity
     * @type {Array}
     */
    this.gravity = vec2.fromValues(0, -9.78);
    if(options.gravity){
        vec2.copy(this.gravity, options.gravity);
    }

    /**
     * Gravity to use when approximating the friction max force (mu*mass*gravity).
     * @property {Number} frictionGravity
     */
    this.frictionGravity = vec2.length(this.gravity) || 10;

    /**
     * Set to true if you want .frictionGravity to be automatically set to the length of .gravity.
     * @property {Boolean} useWorldGravityAsFrictionGravity
     */
    this.useWorldGravityAsFrictionGravity = true;

    /**
     * If the length of .gravity is zero, and .useWorldGravityAsFrictionGravity=true, then switch to using .frictionGravity for friction instead. This fallback is useful for gravityless games.
     * @property {Boolean} useFrictionGravityOnZeroGravity
     */
    this.useFrictionGravityOnZeroGravity = true;

    /**
     * Whether to do timing measurements during the step() or not.
     *
     * @property doPofiling
     * @type {Boolean}
     */
    this.doProfiling = options.doProfiling || false;

    /**
     * How many millisecconds the last step() took. This is updated each step if .doProfiling is set to true.
     *
     * @property lastStepTime
     * @type {Number}
     */
    this.lastStepTime = 0.0;

    /**
     * The broadphase algorithm to use.
     *
     * @property broadphase
     * @type {Broadphase}
     */
    this.broadphase = options.broadphase || new SAPBroadphase();
    this.broadphase.setWorld(this);

    /**
     * User-added constraints.
     *
     * @property constraints
     * @type {Array}
     */
    this.constraints = [];

    /**
     * Dummy default material in the world, used in .defaultContactMaterial
     * @property {Material} defaultMaterial
     */
    this.defaultMaterial = new Material();

    /**
     * The default contact material to use, if no contact material was set for the colliding materials.
     * @property {ContactMaterial} defaultContactMaterial
     */
    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial,this.defaultMaterial);

    /**
     * For keeping track of what time step size we used last step
     * @property lastTimeStep
     * @type {Number}
     */
    this.lastTimeStep = 1/60;

    /**
     * Enable to automatically apply spring forces each step.
     * @property applySpringForces
     * @type {Boolean}
     */
    this.applySpringForces = true;

    /**
     * Enable to automatically apply body damping each step.
     * @property applyDamping
     * @type {Boolean}
     */
    this.applyDamping = true;

    /**
     * Enable to automatically apply gravity each step.
     * @property applyGravity
     * @type {Boolean}
     */
    this.applyGravity = true;

    /**
     * Enable/disable constraint solving in each step.
     * @property solveConstraints
     * @type {Boolean}
     */
    this.solveConstraints = true;

    /**
     * The ContactMaterials added to the World.
     * @property contactMaterials
     * @type {Array}
     */
    this.contactMaterials = [];

    /**
     * World time.
     * @property time
     * @type {Number}
     */
    this.time = 0.0;

    /**
     * Is true during the step().
     * @property {Boolean} stepping
     */
    this.stepping = false;

    /**
     * Bodies that are scheduled to be removed at the end of the step.
     * @property {Array} bodiesToBeRemoved
     * @private
     */
    this.bodiesToBeRemoved = [];

    this.fixedStepTime = 0.0;

    /**
     * Whether to enable island splitting. Island splitting can be an advantage for many things, including solver performance. See {{#crossLink "IslandManager"}}{{/crossLink}}.
     * @property {Boolean} islandSplit
     */
    this.islandSplit = typeof(options.islandSplit)!=="undefined" ? !!options.islandSplit : false;

    /**
     * Set to true if you want to the world to emit the "impact" event. Turning this off could improve performance.
     * @property emitImpactEvent
     * @type {Boolean}
     */
    this.emitImpactEvent = true;

    // Id counters
    this._constraintIdCounter = 0;
    this._bodyIdCounter = 0;

    /**
     * Fired after the step().
     * @event postStep
     */
    this.postStepEvent = {
        type : "postStep",
    };

    /**
     * Fired when a body is added to the world.
     * @event addBody
     * @param {Body} body
     */
    this.addBodyEvent = {
        type : "addBody",
        body : null
    };

    /**
     * Fired when a body is removed from the world.
     * @event removeBody
     * @param {Body} body
     */
    this.removeBodyEvent = {
        type : "removeBody",
        body : null
    };

    /**
     * Fired when a spring is added to the world.
     * @event addSpring
     * @param {Spring} spring
     */
    this.addSpringEvent = {
        type : "addSpring",
        spring : null,
    };

    /**
     * Fired when a first contact is created between two bodies. This event is fired after the step has been done.
     * @event impact
     * @param {Body} bodyA
     * @param {Body} bodyB
     */
    this.impactEvent = {
        type: "impact",
        bodyA : null,
        bodyB : null,
        shapeA : null,
        shapeB : null,
        contactEquation : null,
    };

    /**
     * Fired after the Broadphase has collected collision pairs in the world.
     * Inside the event handler, you can modify the pairs array as you like, to
     * prevent collisions between objects that you don't want.
     * @event postBroadphase
     * @param {Array} pairs An array of collision pairs. If this array is [body1,body2,body3,body4], then the body pairs 1,2 and 3,4 would advance to narrowphase.
     */
    this.postBroadphaseEvent = {
        type:"postBroadphase",
        pairs:null,
    };

    /**
     * How to deactivate bodies during simulation. Possible modes are: {{#crossLink "World/NO_SLEEPING:property"}}World.NO_SLEEPING{{/crossLink}}, {{#crossLink "World/BODY_SLEEPING:property"}}World.BODY_SLEEPING{{/crossLink}} and {{#crossLink "World/ISLAND_SLEEPING:property"}}World.ISLAND_SLEEPING{{/crossLink}}.
     * If sleeping is enabled, you might need to {{#crossLink "Body/wakeUp:method"}}wake up{{/crossLink}} the bodies if they fall asleep when they shouldn't. If you want to enable sleeping in the world, but want to disable it for a particular body, see {{#crossLink "Body/allowSleep:property"}}Body.allowSleep{{/crossLink}}.
     * @property sleepMode
     * @type {number}
     * @default World.NO_SLEEPING
     */
    this.sleepMode = World.NO_SLEEPING;

    /**
     * Fired when two shapes starts start to overlap. Fired in the narrowphase, during step.
     * @event beginContact
     * @param {Shape} shapeA
     * @param {Shape} shapeB
     * @param {Body}  bodyA
     * @param {Body}  bodyB
     * @param {Array} contactEquations
     */
    this.beginContactEvent = {
        type:"beginContact",
        shapeA : null,
        shapeB : null,
        bodyA : null,
        bodyB : null,
        contactEquations : [],
    };

    /**
     * Fired when two shapes stop overlapping, after the narrowphase (during step).
     * @event endContact
     * @param {Shape} shapeA
     * @param {Shape} shapeB
     * @param {Body}  bodyA
     * @param {Body}  bodyB
     * @param {Array} contactEquations
     */
    this.endContactEvent = {
        type:"endContact",
        shapeA : null,
        shapeB : null,
        bodyA : null,
        bodyB : null,
    };

    /**
     * Fired just before equations are added to the solver to be solved. Can be used to control what equations goes into the solver.
     * @event preSolve
     * @param {Array} contactEquations  An array of contacts to be solved.
     * @param {Array} frictionEquations An array of friction equations to be solved.
     */
    this.preSolveEvent = {
        type:"preSolve",
        contactEquations:null,
        frictionEquations:null,
    };

    // For keeping track of overlapping shapes
    this.overlappingShapesLastState = { keys:[] };
    this.overlappingShapesCurrentState = { keys:[] };

    this.overlapKeeper = new OverlapKeeper();
}
World.prototype = new Object(EventEmitter.prototype);
World.prototype.constructor = World;

/**
 * Never deactivate bodies.
 * @static
 * @property {number} NO_SLEEPING
 */
World.NO_SLEEPING = 1;

/**
 * Deactivate individual bodies if they are sleepy.
 * @static
 * @property {number} BODY_SLEEPING
 */
World.BODY_SLEEPING = 2;

/**
 * Deactivates bodies that are in contact, if all of them are sleepy. Note that you must enable {{#crossLink "World/islandSplit:property"}}.islandSplit{{/crossLink}} for this to work.
 * @static
 * @property {number} ISLAND_SLEEPING
 */
World.ISLAND_SLEEPING = 4;

/**
 * Add a constraint to the simulation.
 *
 * @method addConstraint
 * @param {Constraint} c
 */
World.prototype.addConstraint = function(c){
    this.constraints.push(c);
};

/**
 * Add a ContactMaterial to the simulation.
 * @method addContactMaterial
 * @param {ContactMaterial} contactMaterial
 */
World.prototype.addContactMaterial = function(contactMaterial){
    this.contactMaterials.push(contactMaterial);
};

/**
 * Removes a contact material
 *
 * @method removeContactMaterial
 * @param {ContactMaterial} cm
 */
World.prototype.removeContactMaterial = function(cm){
    var idx = this.contactMaterials.indexOf(cm);
    if(idx!==-1){
        Utils.splice(this.contactMaterials,idx,1);
    }
};

/**
 * Get a contact material given two materials
 * @method getContactMaterial
 * @param {Material} materialA
 * @param {Material} materialB
 * @return {ContactMaterial} The matching ContactMaterial, or false on fail.
 * @todo Use faster hash map to lookup from material id's
 */
World.prototype.getContactMaterial = function(materialA,materialB){
    var cmats = this.contactMaterials;
    for(var i=0, N=cmats.length; i!==N; i++){
        var cm = cmats[i];
        if( (cm.materialA.id === materialA.id) && (cm.materialB.id === materialB.id) ||
            (cm.materialA.id === materialB.id) && (cm.materialB.id === materialA.id) ){
            return cm;
        }
    }
    return false;
};

/**
 * Removes a constraint
 *
 * @method removeConstraint
 * @param {Constraint} c
 */
World.prototype.removeConstraint = function(c){
    var idx = this.constraints.indexOf(c);
    if(idx!==-1){
        Utils.splice(this.constraints,idx,1);
    }
};

var step_r = vec2.create(),
    step_runit = vec2.create(),
    step_u = vec2.create(),
    step_f = vec2.create(),
    step_fhMinv = vec2.create(),
    step_velodt = vec2.create(),
    step_mg = vec2.create(),
    xiw = vec2.fromValues(0,0),
    xjw = vec2.fromValues(0,0),
    zero = vec2.fromValues(0,0),
    interpvelo = vec2.fromValues(0,0);

/**
 * Step the physics world forward in time.
 *
 * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
 *
 * @method step
 * @param {Number} dt                       The fixed time step size to use.
 * @param {Number} [timeSinceLastCalled=0]  The time elapsed since the function was last called.
 * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
 *
 * @example
 *     // fixed timestepping without interpolation
 *     var world = new World();
 *     world.step(0.01);
 *
 * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
 */
World.prototype.step = function(dt,timeSinceLastCalled,maxSubSteps){
    maxSubSteps = maxSubSteps || 10;
    timeSinceLastCalled = timeSinceLastCalled || 0;

    if(timeSinceLastCalled === 0){ // Fixed, simple stepping

        this.internalStep(dt);

        // Increment time
        this.time += dt;

    } else {

        // Compute the number of fixed steps we should have taken since the last step
        var internalSteps = Math.floor( (this.time+timeSinceLastCalled) / dt) - Math.floor(this.time / dt);
        internalSteps = Math.min(internalSteps,maxSubSteps);

        // Do some fixed steps to catch up
        var t0 = performance.now();
        for(var i=0; i!==internalSteps; i++){
            this.internalStep(dt);
            if(performance.now() - t0 > dt*1000){
                // We are slower than real-time. Better bail out.
                break;
            }
        }

        // Increment internal clock
        this.time += timeSinceLastCalled;

        // Compute "Left over" time step
        var h = this.time % dt;
        var h_div_dt = h/dt;

        for(var j=0; j!==this.bodies.length; j++){
            var b = this.bodies[j];
            if(b.type !== Body.STATIC && b.sleepState !== Body.SLEEPING){
                // Interpolate
                vec2.sub(interpvelo, b.position, b.previousPosition);
                vec2.scale(interpvelo, interpvelo, h_div_dt);
                vec2.add(b.interpolatedPosition, b.position, interpvelo);

                b.interpolatedAngle = b.angle + (b.angle - b.previousAngle) * h_div_dt;
            } else {
                // For static bodies, just copy. Who else will do it?
                vec2.copy(b.interpolatedPosition, b.position);
                b.interpolatedAngle = b.angle;
            }
        }
    }
};

var endOverlaps = [];

/**
 * Make a fixed step.
 * @method internalStep
 * @param  {number} dt
 * @private
 */
World.prototype.internalStep = function(dt){
    this.stepping = true;

    var that = this,
        doProfiling = this.doProfiling,
        Nsprings = this.springs.length,
        springs = this.springs,
        bodies = this.bodies,
        g = this.gravity,
        solver = this.solver,
        Nbodies = this.bodies.length,
        broadphase = this.broadphase,
        np = this.narrowphase,
        constraints = this.constraints,
        t0, t1,
        fhMinv = step_fhMinv,
        velodt = step_velodt,
        mg = step_mg,
        scale = vec2.scale,
        add = vec2.add,
        rotate = vec2.rotate,
        islandManager = this.islandManager;

    this.overlapKeeper.tick();

    this.lastTimeStep = dt;

    if(doProfiling){
        t0 = performance.now();
    }

    // Update approximate friction gravity.
    if(this.useWorldGravityAsFrictionGravity){
        var gravityLen = vec2.length(this.gravity);
        if(!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity)){
            // Nonzero gravity. Use it.
            this.frictionGravity = gravityLen;
        }
    }

    // Add gravity to bodies
    if(this.applyGravity){
        for(var i=0; i!==Nbodies; i++){
            var b = bodies[i],
                fi = b.force;
            if(b.type !== Body.DYNAMIC || b.sleepState === Body.SLEEPING){
                continue;
            }
            vec2.scale(mg,g,b.mass*b.gravityScale); // F=m*g
            add(fi,fi,mg);
        }
    }

    // Add spring forces
    if(this.applySpringForces){
        for(var i=0; i!==Nsprings; i++){
            var s = springs[i];
            s.applyForce();
        }
    }

    if(this.applyDamping){
        for(var i=0; i!==Nbodies; i++){
            var b = bodies[i];
            if(b.type === Body.DYNAMIC){
                b.applyDamping(dt);
            }
        }
    }

    // Broadphase
    var result = broadphase.getCollisionPairs(this);

    // Remove ignored collision pairs
    var ignoredPairs = this.disabledBodyCollisionPairs;
    for(var i=ignoredPairs.length-2; i>=0; i-=2){
        for(var j=result.length-2; j>=0; j-=2){
            if( (ignoredPairs[i]   === result[j] && ignoredPairs[i+1] === result[j+1]) ||
                (ignoredPairs[i+1] === result[j] && ignoredPairs[i]   === result[j+1])){
                result.splice(j,2);
            }
        }
    }

    // Remove constrained pairs with collideConnected == false
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        var c = constraints[i];
        if(!c.collideConnected){
            for(var j=result.length-2; j>=0; j-=2){
                if( (c.bodyA === result[j] && c.bodyB === result[j+1]) ||
                    (c.bodyB === result[j] && c.bodyA === result[j+1])){
                    result.splice(j,2);
                }
            }
        }
    }

    // postBroadphase event
    this.postBroadphaseEvent.pairs = result;
    this.emit(this.postBroadphaseEvent);

    // Narrowphase
    np.reset(this);
    for(var i=0, Nresults=result.length; i!==Nresults; i+=2){
        var bi = result[i],
            bj = result[i+1];

        // Loop over all shapes of body i
        for(var k=0, Nshapesi=bi.shapes.length; k!==Nshapesi; k++){
            var si = bi.shapes[k],
                xi = bi.shapeOffsets[k],
                ai = bi.shapeAngles[k];

            // All shapes of body j
            for(var l=0, Nshapesj=bj.shapes.length; l!==Nshapesj; l++){
                var sj = bj.shapes[l],
                    xj = bj.shapeOffsets[l],
                    aj = bj.shapeAngles[l];

                var cm = this.defaultContactMaterial;
                if(si.material && sj.material){
                    var tmp = this.getContactMaterial(si.material,sj.material);
                    if(tmp){
                        cm = tmp;
                    }
                }

                this.runNarrowphase(np,bi,si,xi,ai,bj,sj,xj,aj,cm,this.frictionGravity);
            }
        }
    }

    // Wake up bodies
    for(var i=0; i!==Nbodies; i++){
        var body = bodies[i];
        if(body._wakeUpAfterNarrowphase){
            body.wakeUp();
            body._wakeUpAfterNarrowphase = false;
        }
    }

    // Emit end overlap events
    if(this.has('endContact')){
        this.overlapKeeper.getEndOverlaps(endOverlaps);
        var e = this.endContactEvent;
        var l = endOverlaps.length;
        while(l--){
            var data = endOverlaps[l];
            e.shapeA = data.shapeA;
            e.shapeB = data.shapeB;
            e.bodyA = data.bodyA;
            e.bodyB = data.bodyB;
            this.emit(e);
        }
    }

    var preSolveEvent = this.preSolveEvent;
    preSolveEvent.contactEquations = np.contactEquations;
    preSolveEvent.frictionEquations = np.frictionEquations;
    this.emit(preSolveEvent);

    // update constraint equations
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        constraints[i].update();
    }

    if(np.contactEquations.length || np.frictionEquations.length || constraints.length){
        if(this.islandSplit){
            // Split into islands
            islandManager.equations.length = 0;
            Utils.appendArray(islandManager.equations, np.contactEquations);
            Utils.appendArray(islandManager.equations, np.frictionEquations);
            for(i=0; i!==Nconstraints; i++){
                Utils.appendArray(islandManager.equations, constraints[i].equations);
            }
            islandManager.split(this);

            for(var i=0; i!==islandManager.islands.length; i++){
                var island = islandManager.islands[i];
                if(island.equations.length){
                    solver.solveIsland(dt,island);
                }
            }

        } else {

            // Add contact equations to solver
            solver.addEquations(np.contactEquations);
            solver.addEquations(np.frictionEquations);

            // Add user-defined constraint equations
            for(i=0; i!==Nconstraints; i++){
                solver.addEquations(constraints[i].equations);
            }

            if(this.solveConstraints){
                solver.solve(dt,this);
            }

            solver.removeAllEquations();
        }
    }

    // Step forward
    for(var i=0; i!==Nbodies; i++){
        var body = bodies[i];

        if(body.sleepState !== Body.SLEEPING && body.type !== Body.STATIC){
            body.integrate(dt);
        }
    }

    // Reset force
    for(var i=0; i!==Nbodies; i++){
        bodies[i].setZeroForce();
    }

    if(doProfiling){
        t1 = performance.now();
        that.lastStepTime = t1-t0;
    }

    // Emit impact event
    if(this.emitImpactEvent && this.has('impact')){
        var ev = this.impactEvent;
        for(var i=0; i!==np.contactEquations.length; i++){
            var eq = np.contactEquations[i];
            if(eq.firstImpact){
                ev.bodyA = eq.bodyA;
                ev.bodyB = eq.bodyB;
                ev.shapeA = eq.shapeA;
                ev.shapeB = eq.shapeB;
                ev.contactEquation = eq;
                this.emit(ev);
            }
        }
    }

    // Sleeping update
    if(this.sleepMode === World.BODY_SLEEPING){
        for(i=0; i!==Nbodies; i++){
            bodies[i].sleepTick(this.time, false, dt);
        }
    } else if(this.sleepMode === World.ISLAND_SLEEPING && this.islandSplit){

        // Tell all bodies to sleep tick but dont sleep yet
        for(i=0; i!==Nbodies; i++){
            bodies[i].sleepTick(this.time, true, dt);
        }

        // Sleep islands
        for(var i=0; i<this.islandManager.islands.length; i++){
            var island = this.islandManager.islands[i];
            if(island.wantsToSleep()){
                island.sleep();
            }
        }
    }

    this.stepping = false;

    // Remove bodies that are scheduled for removal
    if(this.bodiesToBeRemoved.length){
        for(var i=0; i!==this.bodiesToBeRemoved.length; i++){
            this.removeBody(this.bodiesToBeRemoved[i]);
        }
        this.bodiesToBeRemoved.length = 0;
    }

    this.emit(this.postStepEvent);
};

/**
 * Runs narrowphase for the shape pair i and j.
 * @method runNarrowphase
 * @param  {Narrowphase} np
 * @param  {Body} bi
 * @param  {Shape} si
 * @param  {Array} xi
 * @param  {Number} ai
 * @param  {Body} bj
 * @param  {Shape} sj
 * @param  {Array} xj
 * @param  {Number} aj
 * @param  {Number} mu
 */
World.prototype.runNarrowphase = function(np,bi,si,xi,ai,bj,sj,xj,aj,cm,glen){

    // Check collision groups and masks
    if(!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)){
        return;
    }

    // Get world position and angle of each shape
    vec2.rotate(xiw, xi, bi.angle);
    vec2.rotate(xjw, xj, bj.angle);
    vec2.add(xiw, xiw, bi.position);
    vec2.add(xjw, xjw, bj.position);
    var aiw = ai + bi.angle;
    var ajw = aj + bj.angle;

    np.enableFriction = cm.friction > 0;
    np.frictionCoefficient = cm.friction;
    var reducedMass;
    if(bi.type === Body.STATIC || bi.type === Body.KINEMATIC){
        reducedMass = bj.mass;
    } else if(bj.type === Body.STATIC || bj.type === Body.KINEMATIC){
        reducedMass = bi.mass;
    } else {
        reducedMass = (bi.mass*bj.mass)/(bi.mass+bj.mass);
    }
    np.slipForce = cm.friction*glen*reducedMass;
    np.restitution = cm.restitution;
    np.surfaceVelocity = cm.surfaceVelocity;
    np.frictionStiffness = cm.frictionStiffness;
    np.frictionRelaxation = cm.frictionRelaxation;
    np.stiffness = cm.stiffness;
    np.relaxation = cm.relaxation;
    np.contactSkinSize = cm.contactSkinSize;
    np.enabledEquations = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;

    var resolver = np[si.type | sj.type],
        numContacts = 0;
    if (resolver) {
        var sensor = si.sensor || sj.sensor;
        var numFrictionBefore = np.frictionEquations.length;
        if (si.type < sj.type) {
            numContacts = resolver.call(np, bi,si,xiw,aiw, bj,sj,xjw,ajw, sensor);
        } else {
            numContacts = resolver.call(np, bj,sj,xjw,ajw, bi,si,xiw,aiw, sensor);
        }
        var numFrictionEquations = np.frictionEquations.length - numFrictionBefore;

        if(numContacts){

            if( bi.allowSleep &&
                bi.type === Body.DYNAMIC &&
                bi.sleepState  === Body.SLEEPING &&
                bj.sleepState  === Body.AWAKE &&
                bj.type !== Body.STATIC
            ){
                var speedSquaredB = vec2.squaredLength(bj.velocity) + Math.pow(bj.angularVelocity,2);
                var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit,2);
                if(speedSquaredB >= speedLimitSquaredB*2){
                    bi._wakeUpAfterNarrowphase = true;
                }
            }

            if( bj.allowSleep &&
                bj.type === Body.DYNAMIC &&
                bj.sleepState  === Body.SLEEPING &&
                bi.sleepState  === Body.AWAKE &&
                bi.type !== Body.STATIC
            ){
                var speedSquaredA = vec2.squaredLength(bi.velocity) + Math.pow(bi.angularVelocity,2);
                var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit,2);
                if(speedSquaredA >= speedLimitSquaredA*2){
                    bj._wakeUpAfterNarrowphase = true;
                }
            }

            this.overlapKeeper.setOverlapping(bi, si, bj, sj);
            if(this.has('beginContact') && this.overlapKeeper.isNewOverlap(si, sj)){

                // Report new shape overlap
                var e = this.beginContactEvent;
                e.shapeA = si;
                e.shapeB = sj;
                e.bodyA = bi;
                e.bodyB = bj;

                // Reset contact equations
                e.contactEquations.length = 0;

                if(typeof(numContacts)==="number"){
                    for(var i=np.contactEquations.length-numContacts; i<np.contactEquations.length; i++){
                        e.contactEquations.push(np.contactEquations[i]);
                    }
                }

                this.emit(e);
            }

            // divide the max friction force by the number of contacts
            if(typeof(numContacts)==="number" && numFrictionEquations > 1){ // Why divide by 1?
                for(var i=np.frictionEquations.length-numFrictionEquations; i<np.frictionEquations.length; i++){
                    var f = np.frictionEquations[i];
                    f.setSlipForce(f.getSlipForce() / numFrictionEquations);
                }
            }
        }
    }

};

/**
 * Add a spring to the simulation
 *
 * @method addSpring
 * @param {Spring} s
 */
World.prototype.addSpring = function(s){
    this.springs.push(s);
    this.addSpringEvent.spring = s;
    this.emit(this.addSpringEvent);
};

/**
 * Remove a spring
 *
 * @method removeSpring
 * @param {Spring} s
 */
World.prototype.removeSpring = function(s){
    var idx = this.springs.indexOf(s);
    if(idx!==-1){
        Utils.splice(this.springs,idx,1);
    }
};

/**
 * Add a body to the simulation
 *
 * @method addBody
 * @param {Body} body
 *
 * @example
 *     var world = new World(),
 *         body = new Body();
 *     world.addBody(body);
 * @todo What if this is done during step?
 */
World.prototype.addBody = function(body){
    if(this.bodies.indexOf(body) === -1){
        this.bodies.push(body);
        body.world = this;
        this.addBodyEvent.body = body;
        this.emit(this.addBodyEvent);
    }
};

/**
 * Remove a body from the simulation. If this method is called during step(), the body removal is scheduled to after the step.
 *
 * @method removeBody
 * @param {Body} body
 */
World.prototype.removeBody = function(body){
    if(this.stepping){
        this.bodiesToBeRemoved.push(body);
    } else {
        body.world = null;
        var idx = this.bodies.indexOf(body);
        if(idx!==-1){
            Utils.splice(this.bodies,idx,1);
            this.removeBodyEvent.body = body;
            body.resetConstraintVelocity();
            this.emit(this.removeBodyEvent);
        }
    }
};

/**
 * Get a body by its id.
 * @method getBodyById
 * @return {Body|Boolean} The body, or false if it was not found.
 */
World.prototype.getBodyById = function(id){
    var bodies = this.bodies;
    for(var i=0; i<bodies.length; i++){
        var b = bodies[i];
        if(b.id === id){
            return b;
        }
    }
    return false;
};

/**
 * Disable collision between two bodies
 * @method disableCollision
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
World.prototype.disableBodyCollision = function(bodyA,bodyB){
    this.disabledBodyCollisionPairs.push(bodyA,bodyB);
};

/**
 * Enable collisions between the given two bodies
 * @method enableCollision
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
World.prototype.enableBodyCollision = function(bodyA,bodyB){
    var pairs = this.disabledBodyCollisionPairs;
    for(var i=0; i<pairs.length; i+=2){
        if((pairs[i] === bodyA && pairs[i+1] === bodyB) || (pairs[i+1] === bodyA && pairs[i] === bodyB)){
            pairs.splice(i,2);
            return;
        }
    }
};


function v2a(v){
    if(!v){
        return v;
    }
    return [v[0],v[1]];
}

function extend(a,b){
    for(var key in b){
        a[key] = b[key];
    }
}

function contactMaterialToJSON(cm){
    return {
        id : cm.id,
        materialA :             cm.materialA.id,
        materialB :             cm.materialB.id,
        friction :              cm.friction,
        restitution :           cm.restitution,
        stiffness :             cm.stiffness,
        relaxation :            cm.relaxation,
        frictionStiffness :     cm.frictionStiffness,
        frictionRelaxation :    cm.frictionRelaxation,
    };
}

/**
 * Resets the World, removes all bodies, constraints and springs.
 *
 * @method clear
 */
World.prototype.clear = function(){

    this.time = 0;
    this.fixedStepTime = 0;

    // Remove all solver equations
    if(this.solver && this.solver.equations.length){
        this.solver.removeAllEquations();
    }

    // Remove all constraints
    var cs = this.constraints;
    for(var i=cs.length-1; i>=0; i--){
        this.removeConstraint(cs[i]);
    }

    // Remove all bodies
    var bodies = this.bodies;
    for(var i=bodies.length-1; i>=0; i--){
        this.removeBody(bodies[i]);
    }

    // Remove all springs
    var springs = this.springs;
    for(var i=springs.length-1; i>=0; i--){
        this.removeSpring(springs[i]);
    }

    // Remove all contact materials
    var cms = this.contactMaterials;
    for(var i=cms.length-1; i>=0; i--){
        this.removeContactMaterial(cms[i]);
    }

    World.apply(this);
};

/**
 * Get a copy of this World instance
 * @method clone
 * @return {World}
 */
World.prototype.clone = function(){
    var world = new World();
    world.fromJSON(this.toJSON());
    return world;
};

var hitTest_tmp1 = vec2.create(),
    hitTest_zero = vec2.fromValues(0,0),
    hitTest_tmp2 = vec2.fromValues(0,0);

/**
 * Test if a world point overlaps bodies
 * @method hitTest
 * @param  {Array}  worldPoint  Point to use for intersection tests
 * @param  {Array}  bodies      A list of objects to check for intersection
 * @param  {Number} precision   Used for matching against particles and lines. Adds some margin to these infinitesimal objects.
 * @return {Array}              Array of bodies that overlap the point
 */
World.prototype.hitTest = function(worldPoint,bodies,precision){
    precision = precision || 0;

    // Create a dummy particle body with a particle shape to test against the bodies
    var pb = new Body({ position:worldPoint }),
        ps = new Particle(),
        px = worldPoint,
        pa = 0,
        x = hitTest_tmp1,
        zero = hitTest_zero,
        tmp = hitTest_tmp2;
    pb.addShape(ps);

    var n = this.narrowphase,
        result = [];

    // Check bodies
    for(var i=0, N=bodies.length; i!==N; i++){
        var b = bodies[i];
        for(var j=0, NS=b.shapes.length; j!==NS; j++){
            var s = b.shapes[j],
                offset = b.shapeOffsets[j] || zero,
                angle = b.shapeAngles[j] || 0.0;

            // Get shape world position + angle
            vec2.rotate(x, offset, b.angle);
            vec2.add(x, x, b.position);
            var a = angle + b.angle;

            if( (s instanceof Circle    && n.circleParticle  (b,s,x,a,     pb,ps,px,pa, true)) ||
                (s instanceof Convex    && n.particleConvex  (pb,ps,px,pa, b,s,x,a,     true)) ||
                (s instanceof Plane     && n.particlePlane   (pb,ps,px,pa, b,s,x,a,     true)) ||
                (s instanceof Capsule   && n.particleCapsule (pb,ps,px,pa, b,s,x,a,     true)) ||
                (s instanceof Particle  && vec2.squaredLength(vec2.sub(tmp,x,worldPoint)) < precision*precision)
                ){
                result.push(b);
            }
        }
    }

    return result;
};

/**
 * Sets the Equation parameters for all constraints and contact materials.
 * @method setGlobalEquationParameters
 * @param {object} [parameters]
 * @param {Number} [parameters.relaxation]
 * @param {Number} [parameters.stiffness]
 */
World.prototype.setGlobalEquationParameters = function(parameters){
    parameters = parameters || {};

    // Set for all constraints
    for(var i=0; i !== this.constraints.length; i++){
        var c = this.constraints[i];
        for(var j=0; j !== c.equations.length; j++){
            var eq = c.equations[j];
            if(typeof(parameters.stiffness) !== "undefined"){
                eq.stiffness = parameters.stiffness;
            }
            if(typeof(parameters.relaxation) !== "undefined"){
                eq.relaxation = parameters.relaxation;
            }
            eq.needsUpdate = true;
        }
    }

    // Set for all contact materials
    for(var i=0; i !== this.contactMaterials.length; i++){
        var c = this.contactMaterials[i];
        if(typeof(parameters.stiffness) !== "undefined"){
            c.stiffness = parameters.stiffness;
            c.frictionStiffness = parameters.stiffness;
        }
        if(typeof(parameters.relaxation) !== "undefined"){
            c.relaxation = parameters.relaxation;
            c.frictionRelaxation = parameters.relaxation;
        }
    }

    // Set for default contact material
    var c = this.defaultContactMaterial;
    if(typeof(parameters.stiffness) !== "undefined"){
        c.stiffness = parameters.stiffness;
        c.frictionStiffness = parameters.stiffness;
    }
    if(typeof(parameters.relaxation) !== "undefined"){
        c.relaxation = parameters.relaxation;
        c.frictionRelaxation = parameters.relaxation;
    }
};

/**
 * Set the stiffness for all equations and contact materials.
 * @method setGlobalStiffness
 * @param {Number} stiffness
 */
World.prototype.setGlobalStiffness = function(stiffness){
    this.setGlobalEquationParameters({
        stiffness: stiffness
    });
};

/**
 * Set the relaxation for all equations and contact materials.
 * @method setGlobalRelaxation
 * @param {Number} relaxation
 */
World.prototype.setGlobalRelaxation = function(relaxation){
    this.setGlobalEquationParameters({
        relaxation: relaxation
    });
};

var tmpRay = new Ray();

/**
 * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
 * @method raycastAll
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionMask=-1]
 * @param  {number} [options.collisionGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {Function} callback
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastAll = function(from, to, options, callback){
    options.mode = Ray.ALL;
    options.from = from;
    options.to = to;
    options.callback = callback;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
 * @method raycastAny
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionMask=-1]
 * @param  {number} [options.collisionGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {RaycastResult} result
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastAny = function(from, to, options, result){
    options.mode = Ray.ANY;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Ray cast, and return information of the closest hit.
 * @method raycastClosest
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionMask=-1]
 * @param  {number} [options.collisionGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {RaycastResult} result
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastClosest = function(from, to, options, result){
    options.mode = Ray.CLOSEST;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
};
},{"../../package.json":6,"../collision/Broadphase":8,"../collision/NaiveBroadphase":10,"../collision/Narrowphase":11,"../collision/Ray":12,"../collision/SAPBroadphase":14,"../constraints/Constraint":15,"../constraints/DistanceConstraint":16,"../constraints/GearConstraint":17,"../constraints/LockConstraint":18,"../constraints/PrismaticConstraint":19,"../constraints/RevoluteConstraint":20,"../events/EventEmitter":27,"../material/ContactMaterial":28,"../material/Material":29,"../math/vec2":31,"../objects/Body":32,"../objects/LinearSpring":33,"../objects/RotationalSpring":34,"../shapes/Capsule":37,"../shapes/Circle":38,"../shapes/Convex":39,"../shapes/Line":41,"../shapes/Particle":42,"../shapes/Plane":43,"../shapes/Rectangle":44,"../shapes/Shape":45,"../solver/GSSolver":46,"../solver/Solver":47,"../utils/OverlapKeeper":48,"../utils/Utils":50,"./IslandManager":52}]},{},[36])
(36)
});;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/Lau/www/svjelly/src/core/Commands.js":[function(require,module,exports){
module.exports = {
	MOVE_TO: 1,
	LINE_TO: 2,
	BEZIER_TO: 3,
	QUADRA_TO: 4,
	CIRCLE: 5,
	ELLIPSE: 6
};

},{}],"/Users/Lau/www/svjelly/src/core/DecorationDrawing.js":[function(require,module,exports){
var DecorationDrawing =
{
	setScale: function ($scaleX, $scaleY)
	{
		for (var i = 0, length = this.commands.length; i < length; i += 1)
		{
			var command = this.commands[i];
			command.setScale($scaleX, $scaleY);
		}
	}
};

module.exports = DecorationDrawing;

},{}],"/Users/Lau/www/svjelly/src/core/DecorationDrawingCommand.js":[function(require,module,exports){
var Commands = require('./Commands');

var DecorationDrawingCommand = function ($instructions, $physicsManager)
{
	this.physicsManager = $physicsManager;
	this.name = $instructions.name;
	this.point = $instructions.point;
	this.options = $instructions.options;
	var self = this;
	this.physicsManager.addedToWorld.then(function ()
	{
		self.relativePoint =
		[
			self.point[0] - $physicsManager.getX(),
			self.point[1] - $physicsManager.getY()
		];
		if (self.name === Commands.BEZIER_TO || self.name === Commands.QUADRA_TO)
		{
			self.cp1 =
			[
				self.relativePoint[0] + self.options[0][0],
				self.relativePoint[1] + self.options[0][1]
			];
		}
		if (self.name === Commands.BEZIER_TO)
		{
			self.cp2 =
			[
				self.relativePoint[0] + self.options[1][0],
				self.relativePoint[1] + self.options[1][1]
			];
		}
	});
};

DecorationDrawingCommand.prototype.setScale = function ($scaleX, $scaleY)
{
	this.scaleX = $scaleX;
	this.scaleY = $scaleY;

	if (this.name === Commands.CIRCLE || this.name === Commands.ELLIPSE)
	{
		this.radius = this.options[0] * this.scaleX;
	}
	if (this.name === Commands.ELLIPSE)
	{
		this.radiusB = this.options[1] * this.scaleX;
	}
};

DecorationDrawingCommand.prototype.getRotation = function ()
{
	var rota = (this.physicsManager.getAngle());
	return this.options[2] - rota;//this.physicsManager.getAngle() * 180 / Math.PI;
};

DecorationDrawingCommand.prototype.getControlPoint = function ($cp)
{
	var angle = -this.physicsManager.getAngle();
	var x = $cp[0];
	var y = $cp[1];
	return [
		(this.physicsManager.getX() + x * Math.cos(angle) - y * Math.sin(angle)) * this.scaleX,
		(this.physicsManager.getY() + y * Math.cos(angle) + x * Math.sin(angle)) * this.scaleY
	];
};

DecorationDrawingCommand.prototype.getCP1 = function ()
{
	return this.getControlPoint(this.cp1);
};

DecorationDrawingCommand.prototype.getCP2 = function ()
{
	return this.getControlPoint(this.cp2);
};

DecorationDrawingCommand.prototype.getX = function ()
{
	var angle = -this.physicsManager.getAngle();
	var x = this.relativePoint[0];
	var y = this.relativePoint[1];
	return (this.physicsManager.getX() + x * Math.cos(angle) - y * Math.sin(angle)) * this.scaleX;
};

DecorationDrawingCommand.prototype.getY = function ()
{
	var angle = -this.physicsManager.getAngle();
	var x = this.relativePoint[0];
	var y = this.relativePoint[1];
	return (this.physicsManager.getY() + y * Math.cos(angle) + x * Math.sin(angle)) * this.scaleY;
};

module.exports = DecorationDrawingCommand;

},{"./Commands":"/Users/Lau/www/svjelly/src/core/Commands.js"}],"/Users/Lau/www/svjelly/src/core/NodeGraph.js":[function(require,module,exports){
var NodeGraph = function ()
{
	this.vertices = [];
	this.edges = [];
};

NodeGraph.prototype.getVertex = function ($node)
{
	for (var i = 0, length = this.vertices.length; i < length; i += 1)
	{
		var vertex = this.vertices[i];
		if (vertex.node === $node)
		{
			return vertex;
		}
	}
};

NodeGraph.prototype.createVertex = function ($node)
{
	var vertex = { node: $node };
	this.vertices.push(vertex);
	return vertex;
};

NodeGraph.prototype.getEdgeWeight = function ($edge)
{
	var dX = Math.abs($edge.vertexA.node.oX - $edge.vertexB.node.oX);
	var dY = Math.abs($edge.vertexA.node.oY - $edge.vertexB.node.oY);
	var dist = Math.sqrt(dX * dX + dY * dY);
	return dist;
};

NodeGraph.prototype.getVertexEdges = function ($vertex)
{
	var toReturn = [];
	for (var i = 0, length = this.edges.length; i < length; i += 1)
	{
		var edge = this.edges[i];
		if (edge.vertexA === $vertex || edge.vertexB === $vertex)
		{
			toReturn.push(edge);
		}
	}
	return toReturn;
};

NodeGraph.prototype.connect = function ($ANode, $BNode)
{
	var vertexA = this.getVertex($ANode) || this.createVertex($ANode);
	var vertexB = this.getVertex($BNode) || this.createVertex($BNode);

	var exists = false;
	for (var i = 0, length = this.edges.length; i < length; i += 1)
	{
		var edge = this.edges[i];
		if ((edge.vertexA === vertexA &&
			edge.vertexB === vertexB) ||
			(edge.vertexA === vertexB &&
			edge.vertexB === vertexA))
		{
			exists = true;
		}
	}
	if (!exists)
	{
		this.edges.push({ vertexA: vertexA, vertexB: vertexB });
	}
};

NodeGraph.prototype.traverse = function ($startingVertices)
{
	var i;
	var openList = [];
	var edgesLength;
	var vertexEdges;
	var startingVerticesLength = $startingVertices.length;
	for (i = 0; i < startingVerticesLength; i += 1)
	{
		$startingVertices[i].mapValue = 0;
		$startingVertices[i].opened = true;
		openList.push($startingVertices[i]);
	}

	while (openList.length)
	{
		var closedVertex = openList.shift();
		closedVertex.closed = true;

		vertexEdges = this.getVertexEdges(closedVertex);
		edgesLength = vertexEdges.length;
		for (i = 0; i < edgesLength; i += 1)
		{
			var currEdge = vertexEdges[i];
			var otherVertex = currEdge.vertexA === closedVertex ? currEdge.vertexB : currEdge.vertexA;
			if (otherVertex.closed) { continue; }

			if (!otherVertex.opened)
			{
				otherVertex.opened = true;
				openList.push(otherVertex);
			}
			var val = closedVertex.mapValue + this.getEdgeWeight(currEdge);
			otherVertex.mapValue = otherVertex.mapValue < val ? otherVertex.mapValue : val; //works even if undefined
		}
	}
};

module.exports = NodeGraph;

},{}],"/Users/Lau/www/svjelly/src/core/Polygon.js":[function(require,module,exports){
var Polygon =
{
	init: function ($points)
	{
		var polygon = Object.create(Polygon);
		polygon.points = $points;
		polygon._boundingBox = undefined;
		return polygon;
	},

	getArea: function ()
	{
		var sumA = 0;
		var sumB = 0;
		for (var i = 0, length = this.points.length; i < length; i += 1)
		{
			var currPoint = this.points[i];
			var next = i === length - 1 ? this.points[0] : this.points[i + 1];

			sumA += currPoint[0] * next[1];
			sumB += currPoint[1] * next[0];
		}

		return Math.abs((sumA - sumB) * 0.5);
	},

	getBoundingBox: function ()
	{
		if (!this._boundingBox)
		{
			var minX = this.points[0][0];
			var maxX = minX;
			var minY = this.points[0][1];
			var maxY = minY;

			for (var i = 0, length = this.points.length; i < length; i += 1)
			{
				var point = this.points[i];
				minX = Math.min(minX, point[0]);
				maxX = Math.max(maxX, point[0]);
				minY = Math.min(minY, point[1]);
				maxY = Math.max(maxY, point[1]);
			}
			this._boundingBox = [[minX, minY], [maxX, maxY]];
		}
		return this._boundingBox;
	},

	getCenter: function ()
	{
		var bounding = this.getBoundingBox();
		var x = bounding[0][0] + (bounding[1][0] - bounding[0][0]) / 2;
		var y = bounding[0][1] + (bounding[1][1] - bounding[0][1]) / 2;
		return [x, y];
	},

	getSegments: function ()
	{
		var segments = [];
		for (var i = 0, length = this.points.length - 1; i < length; i += 1)
		{
			segments.push([this.points[i], this.points[i + 1]]);
		}
		segments.push([this.points[this.points.length - 1], this.points[0]]);
		return segments;
	},

	getIntersectionsAtY: function ($testY)
	{
		var segments = this.getSegments();
		var intersections = [];
		for (var i = 0, length = segments.length; i < length; i += 1)
		{
			var currSegment = segments[i];
			var x1 = currSegment[0][0];
			var y1 = currSegment[0][1];
			var x2 = currSegment[1][0];
			var y2 = currSegment[1][1];
			var smallY = Math.min(y1, y2);
			var bigY = Math.max(y1, y2);

			if ($testY > smallY && $testY < bigY)
			{
				var pY = y2 - $testY;
				var segY = y2 - y1;
				var segX = x2 - x1;
				var pX = pY * segX / segY;
				intersections.push(x2 - pX);
			}
		}
		return intersections;
	},

	isInside: function ($point)
	{
		var infNumber = 0;
		var intersections = this.getIntersectionsAtY($point[1]);
		for (var i = 0, length = intersections.length; i < length; i += 1)
		{
			if ($point[0] < intersections[i]) { infNumber += 1; }
		}
		return infNumber % 2 > 0;
	}
};

module.exports = Polygon;


},{}],"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2GhostPhysicsManager.js":[function(require,module,exports){
var AnchorP2GhostPhysicsManager = function ($p2, $p2World, $worldHeight)
{
	this.p2 = $p2;
	this.p2World = $p2World;
	this.offset = [0, 0];
	this.worldHeight = $worldHeight;
};

AnchorP2GhostPhysicsManager.prototype.setFromPoint = function ($point)
{
	this.point = $point;
};

AnchorP2GhostPhysicsManager.prototype.addToWorld = function ()
{
	this.body = new this.p2.Body({
		position: [this.point[0], this.worldHeight - this.point[1]]
	});
	this.p2World.addBody(this.body);
};

AnchorP2GhostPhysicsManager.prototype.getX = function ()
{
	return this.body.position[0];
};

AnchorP2GhostPhysicsManager.prototype.getY = function ()
{
	return this.worldHeight - this.body.position[1];
};

module.exports = AnchorP2GhostPhysicsManager;

},{}],"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2HardPhysicsManager.js":[function(require,module,exports){
var AnchorP2HardPhysicsManager = function ($group) { this.group = $group; };

AnchorP2HardPhysicsManager.prototype.setFromPoint = function ($point)
{
	this.point = $point;
};

AnchorP2HardPhysicsManager.prototype.addToWorld = function ()
{
	this.body = this.group.physicsManager.body;
	this.worldHeight = this.group.physicsManager.worldHeight;
	this.offset = [this.point[0] - this.body.interpolatedPosition[0], (this.worldHeight - this.point[1]) - this.body.interpolatedPosition[1]];
	var dX = this.offset[0];
	var dY = this.offset[1];
	this.angle = Math.atan2(dY, dX);
	this.hyp = Math.sqrt(dX * dX + dY * dY);
};

AnchorP2HardPhysicsManager.prototype.setFixed = function ($fixed)
{
	this.group.fixed = $fixed;
};

AnchorP2HardPhysicsManager.prototype.getX = function ()
{
	return this.body.interpolatedPosition[0] + this.hyp * Math.cos(this.body.angle + this.angle);
};

AnchorP2HardPhysicsManager.prototype.getY = function ()
{
	return this.worldHeight - (this.body.interpolatedPosition[1] + this.hyp * Math.sin(this.body.angle + this.angle));
};

module.exports = AnchorP2HardPhysicsManager;

},{}],"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2SoftPhysicsManager.js":[function(require,module,exports){
var AnchorP2SoftPhysicsManager = function ($group) { this.group = $group; };

AnchorP2SoftPhysicsManager.prototype.setFromPoint = function ($point)
{
	this.point = $point;
	this.node = this.group.getClosestNode($point);
	this.worldHeight = this.group.physicsManager.worldHeight;
	this.offset = [0, 0];
};

AnchorP2SoftPhysicsManager.prototype.addToWorld = function ()
{
	this.body = this.node.physicsManager.body;
};

AnchorP2SoftPhysicsManager.prototype.setFixed = function ($fixed)
{
	this.node.fixed = $fixed;
};

AnchorP2SoftPhysicsManager.prototype.getX = function ()
{
	return this.body.interpolatedPosition[0];
};

AnchorP2SoftPhysicsManager.prototype.getY = function ()
{
	return this.worldHeight - this.body.interpolatedPosition[1];
};

module.exports = AnchorP2SoftPhysicsManager;

},{}],"/Users/Lau/www/svjelly/src/physics/p2physics/GroupGhostPhysicsManager.js":[function(require,module,exports){
var HardDecorationDrawing = require('./HardDecorationDrawing');

var GroupGhostPhysicsManager = function ($group)
{
	this.group = $group;
	this._boundingBox = undefined;
	this._position = [];
	var self = this;
	this.nodesAddedPromise = new window.Promise(function (resolve) { self.resolveNodesAdded = resolve; });
};

GroupGhostPhysicsManager.prototype.getNodePhysicsManager = function ($node)
{
	var manager = {};
	var getX = function ($nodeOX) { return function () { return $nodeOX; }; };
	var getY = function ($nodeOY) { return function () { return $nodeOY; }; };
	for (var i = 0, length = this.group.nodes.length; i < length; i += 1)
	{
		manager.getX = getX($node.oX);
		manager.getY = getY($node.oY);
	}
	return manager;
};

GroupGhostPhysicsManager.prototype.getDecorationDrawing = function ()
{
	return HardDecorationDrawing.create(this.group);
};

GroupGhostPhysicsManager.prototype.getBoundingBox = function ()
{
	if (!this._boundingBox)
	{
		var minX = Infinity;
		var minY = Infinity;
		var maxX = -Infinity;
		var maxY = -Infinity;
		for (var i = 0, length = this.group.nodesLength; i < length; i += 1)
		{
			var currNode = this.group.nodes[i];
			minX = Math.min(currNode.physicsManager.getX(), minX);
			minY = Math.min(currNode.physicsManager.getY(), minY);
			maxX = Math.min(currNode.physicsManager.getX(), maxX);
			maxY = Math.min(currNode.physicsManager.getY(), maxY);
		}
		this._boundingBox = [[minX, minY], [maxX, maxY]];
	}
	return this._boundingBox;
};

GroupGhostPhysicsManager.prototype.addJointsToWorld = function ()
{
	return null;
};

GroupGhostPhysicsManager.prototype.getAngle = function () { return 0; };
GroupGhostPhysicsManager.prototype.getX = function () { return 0; };
GroupGhostPhysicsManager.prototype.getY = function () { return 0; };

GroupGhostPhysicsManager.prototype.getBoundingBox = function ()
{
	if (!this._boundingBox)
	{
		var minX = Infinity;
		var minY = Infinity;
		var maxX = -Infinity;
		var maxY = -Infinity;
		for (var i = 0, length = this.group.nodesLength; i < length; i += 1)
		{
			var currNode = this.group.nodes[i];
			minX = Math.min(currNode.physicsManager.getX(), minX);
			minY = Math.min(currNode.physicsManager.getY(), minY);
			maxX = Math.max(currNode.physicsManager.getX(), maxX);
			maxY = Math.max(currNode.physicsManager.getY(), maxY);
		}

		this._boundingBox = [[minX, minY], [maxX, maxY]];
	}
	return this._boundingBox;
};

GroupGhostPhysicsManager.prototype.addNodesToWorld = function ()
{
	this.resolveNodesAdded();
};

module.exports = GroupGhostPhysicsManager;


},{"./HardDecorationDrawing":"/Users/Lau/www/svjelly/src/physics/p2physics/HardDecorationDrawing.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/GroupP2HardPhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/

var p2 = require('../../../libs/p2');
var NodeP2HardPhysicsManager = require('./NodeP2HardPhysicsManager');
var AnchorP2HardPhysicsManager = require('./AnchorP2HardPhysicsManager');
var HardDecorationDrawing = require('./HardDecorationDrawing');

var GroupP2HardPhysicsManager = function ($group, $P2World, $worldHeight, $materialsList)
{
	this.group = $group;
	var self = this;
	this._position = [];
	this.addedToWorld = new window.Promise(function (resolve) { self.resolveAddedToWorld = resolve; });
	this.materialsList = $materialsList;
	this.worldHeight = $worldHeight;
	this.P2World = $P2World;
	this.conf = $group.conf.physics;
	this._boundingBox = [[0, 0], [0, 0]];
};

GroupP2HardPhysicsManager.prototype.getDecorationDrawing = function ()
{
	return HardDecorationDrawing.create(this.group);
};

GroupP2HardPhysicsManager.prototype.getNodePhysicsManager = function ()
{
	return new NodeP2HardPhysicsManager();
};

GroupP2HardPhysicsManager.prototype.getBoundingBox = function ()
{
	var AABB = this.body.getAABB();
	this._boundingBox[0][0] = AABB.lowerBound[0];
	this._boundingBox[0][1] = this.worldHeight - AABB.upperBound[1];
	this._boundingBox[1][0] = AABB.upperBound[0];
	this._boundingBox[1][1] = this.worldHeight - AABB.lowerBound[1];
	return this._boundingBox;
};

GroupP2HardPhysicsManager.prototype.getX = function () { return this.body.interpolatedPosition[0]; };
GroupP2HardPhysicsManager.prototype.getY = function () { return this.worldHeight - this.body.interpolatedPosition[1]; };

GroupP2HardPhysicsManager.prototype.getAngle = function ()
{
	return this.body.interpolatedAngle;
};

GroupP2HardPhysicsManager.prototype.createAnchorFromPoint = function ($point)
{
	var anchor = new AnchorP2HardPhysicsManager(this.group);
	anchor.setFromPoint($point);
	return anchor;
};

GroupP2HardPhysicsManager.prototype.createAnchorFromLine = function ($linePoints)
{
	var closestPoint = this.group.getClosestPoint($linePoints);
	var anchor = new AnchorP2HardPhysicsManager(this.group);
	anchor.setFromPoint(closestPoint);
	return anchor;
};

GroupP2HardPhysicsManager.prototype.createAnchors = function ($points)
{
	var toReturn = [];
	var nodes = this.group.getNodesInside($points);
	if (!nodes.length)
	{
		var defaultAnchor = new AnchorP2HardPhysicsManager(this.group);
		var Polygon = require('../../core/Polygon');
		var polygon = Polygon.init($points);
		var center = polygon.getCenter();
		//var closest = this.group.getClosestPoint($points);
		defaultAnchor.setFromPoint(center);
		return [defaultAnchor];
	}
	for (var i = 0, length = nodes.length; i < length; i += 1)
	{
		var node = nodes[i];
		var currAnchorA = new AnchorP2HardPhysicsManager(this.group);
		currAnchorA.setFromPoint([node.oX, node.oY]);
		toReturn.push(currAnchorA);
	}
	return toReturn;
};

GroupP2HardPhysicsManager.prototype.applyForce = function ($vector)
{
	this.body.applyForce($vector, this.body.interpolatedPosition);
};

GroupP2HardPhysicsManager.prototype.addJointsToWorld = function () { return; };

GroupP2HardPhysicsManager.prototype.addNodesToWorld = function ()
{
	var path = [];

	var startX = this.group.nodes[0].oX;
	var startY = this.group.nodes[0].oY;
	var initX = startX;
	var initY = this.worldHeight - startY;

	this.body = new p2.Body({
		mass: this.group.fixed ? 0 : 1,
		position: [startX, this.worldHeight - startY]
	});
	var node;
	for (var i = 0, length = this.group.nodes.length; i < length; i += 1)
	{
		node = this.group.nodes[i];
		var pos = [node.oX - startX, -(node.oY - startY)];
		node.physicsManager.addToWorld(this.body, pos, this.worldHeight);
		path.push(pos);
	}

	if (length > 1)
	{
		this.body.fromPolygon(path);
		var offset = [initX - this.body.position[0], this.body.position[1] - initY];
		i = 0;
		for (i; i < length; i += 1)
		{
			node = this.group.nodes[i];
			node.physicsManager.setOffset(offset);
		}
	}
	else
	{
		var radius = this.group.structure.radiusX;
		var circleShape = new p2.Circle(radius);
		this.body.addShape(circleShape);
	}

	this.body.gravityScale = this.conf.gravityScale !== undefined ? this.conf.gravityScale : 1;
	// console.log(startX, this.worldHeight - startY, this.body.position[0], this.body.position[1]);
	//this.body.mass = this.conf.mass;
	//if (this.group.conf.fixed) { node.physicsManager.setFixed(this.group.conf.fixed); }
	//this.body.updateMassProperties();
	var shapesLength = this.body.shapes.length;
	for (i = 0; i < shapesLength; i += 1)
	{
		var currShape = this.body.shapes[i];
		currShape.material = this.conf.material ? this.materialsList[this.conf.material].material : this.materialsList.default.material;
	}
	this.P2World.addBody(this.body);
	if (this.conf.mass > 0)
	{
		this.body.setDensity(this.conf.mass);
	}

	this.body.collisionResponse = !this.conf.noCollide;
	console.log('trytfuyfpygvyofvut');

	// if (this.group.ID === 'rearWheel')
	// {
	// 	console.log(this.body.mass);
	// }

	this.body.interpolatedPosition[0] = this.body.position[0];
	this.body.interpolatedPosition[1] = this.body.position[1];
	//node.physicsManager.setFixed(this.group.conf.fixed);
	// console.log(this.body.shapes);
	// debugger;

	this.resolveAddedToWorld();
};

GroupP2HardPhysicsManager.prototype.hitTest = function ($point)
{
	var result = this.P2World.hitTest([$point[0], this.worldHeight - $point[1]], [this.body]);
	return result ? result[0] : undefined;
};

module.exports = GroupP2HardPhysicsManager;


},{"../../../libs/p2":"/Users/Lau/www/svjelly/libs/p2.js","../../core/Polygon":"/Users/Lau/www/svjelly/src/core/Polygon.js","./AnchorP2HardPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2HardPhysicsManager.js","./HardDecorationDrawing":"/Users/Lau/www/svjelly/src/physics/p2physics/HardDecorationDrawing.js","./NodeP2HardPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/NodeP2HardPhysicsManager.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/GroupP2SoftPhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/

var p2 = require('../../../libs/p2');
// var Dispatcher = require('../../event/Dispatcher');
var NodeP2SoftPhysicsManager = require('./NodeP2SoftPhysicsManager');
var AnchorP2SoftPhysicsManager = require('./AnchorP2SoftPhysicsManager');
var JointP2PhysicsManager = require('./JointP2PhysicsManager');
var SoftDecorationDrawing = require('./SoftDecorationDrawing');

var GroupP2SoftPhysicsManager = function ($group, $world, $worldHeight, $materialsList)
{
	this.group = $group;
	this._boundingBox = [[0, 0], [0, 0]];
	this.materialsList = $materialsList;
	this._position = [];
	var self = this;
	this.addedToWorld = new window.Promise(function (resolve) { self.resolveAddedToWorld = resolve; });
	this.world = $world;
	this.worldHeight = $worldHeight;
	this.conf = $group.conf.physics;
	// this.constraints = [];
	//this.nodesDiameter = this.conf.nodesDiameter;
};

GroupP2SoftPhysicsManager.prototype.addNodesToWorld = function ()
{
	for (var i = 0, length = this.group.nodes.length; i < length; i += 1)
	{
		// this.baseBody = new p2.Body({
		// 	mass: 1
		// });
		var node = this.group.nodes[i];
		//var fractionMass = this.conf.mass / this.group.nodes.length;
		var area = this.group.structure.area;
		var nodeMass = area * this.conf.mass / this.group.nodes.length;
		//var mass = 500;
		//var mass = this.conf.mass;//Math.random() * 10 + 1;
		var body = new p2.Body({
			mass: node.fixed ? 0 : nodeMass,
			position: [node.oX, this.worldHeight - node.oY]
		});
		body.interpolatedPosition[0] = body.position[0];
		body.interpolatedPosition[1] = body.position[1];

		//if (node.fixed) { body.type = p2.Body.STATIC; }
		//console.log(node.oX, node.oY);
		//this.body.fixedRotation = true;

		// var radius = this.conf.nodeRadius;
		// var circleShape = new p2.Circle(radius);
		// body.addShape(circleShape);

		var radius = this.group.structure.innerRadius || this.group.conf.nodeRadius || 0.1;
		var shape = new p2.Circle(radius);
		body.addShape(shape);
		shape.material = this.conf.material ? this.materialsList[this.conf.material].material : this.materialsList.default.material;

		//console.log(this.body.getArea());

		//this.body.setDensity(node.type === 'line' ? 1 : 5000);

		//body.damping = 1;
		//body.mass = mass;
		node.physicsManager.addToWorld(p2, body, this.worldHeight);
		node.physicsManager.radius = radius;
		//node.physicsManager.setFixed(node.fixed);
		//body.setDensity(0.1);
		this.world.addBody(body);

		//body.mass = body.getArea() * this.conf.mass;
		//body.gravityScale = 0.1;
		//body.updateMassProperties();
		// body.mass = 0;
		// body.setDensity(0);
		//node.physicsManager.applyForce([0, 0]);
		// body.mass = 10;
		var massVariance = this.conf.massVariance || 0;
		var random = -massVariance + Math.random() * massVariance * 2;
		body.mass = body.mass + body.mass * random;
		//body.mass = body.mass;
		body.invMass = 1 / body.mass;
		body.inertia = body.mass * 0.5;
		body.invInertia = 1 / body.inertia;
		body.collisionResponse = !this.conf.noCollide;

		body.angularDamping = this.conf.angularDamping || body.angularDamping;
		body.damping = this.conf.damping !== undefined && this.conf.damping !== null ? Number(this.conf.damping) : body.damping;

		body.gravityScale = this.conf.gravityScale !== undefined ? this.conf.gravityScale : 1;
	}

	var Polygon = require('../../core/Polygon');
	var points = [];
	var envelope = this.group.structure.envelope;
	var envelopeLength = this.group.structure.envelope.length;
	for (i = 0; i < envelopeLength; i += 1)
	{
		points.push(envelope[i].physicsManager.body.interpolatedPosition);
	}
	this.polygon = Polygon.init(points);
	//debugger;

	if (this.conf.structuralMassDecay) { this.setNodesMassFromJoints(); }

	this.resolveAddedToWorld();

	if (this.group.ID === 'smiley')
	{
		console.log(this.group.structure.area * this.conf.mass, this.getMass());
	}
};

GroupP2SoftPhysicsManager.prototype.getDecorationDrawing = function ()
{
	return SoftDecorationDrawing.create(this.group);
};

GroupP2SoftPhysicsManager.prototype.getNodePhysicsManager = function ()
{
	return new NodeP2SoftPhysicsManager();
};

GroupP2SoftPhysicsManager.prototype.getBoundingBox = function ()
{
	var minX = Infinity;
	var minY = Infinity;
	var maxX = -Infinity;
	var maxY = -Infinity;
	for (var i = 0, length = this.group.nodesLength; i < length; i += 1)
	{
		var currNode = this.group.nodes[i];
		minX = Math.min(currNode.physicsManager.getX(), minX);
		minY = Math.min(currNode.physicsManager.getY(), minY);
		maxX = Math.max(currNode.physicsManager.getX(), maxX);
		maxY = Math.max(currNode.physicsManager.getY(), maxY);
	}

	this._boundingBox[0][0] = minX;
	this._boundingBox[0][1] = minY;
	this._boundingBox[1][0] = maxX;
	this._boundingBox[1][1] = maxY;

	return this._boundingBox;
};

GroupP2SoftPhysicsManager.prototype.createAnchorFromPoint = function ($point)
{
	var anchor = new AnchorP2SoftPhysicsManager(this.group);
	anchor.setFromPoint($point);
	return anchor;
};

GroupP2SoftPhysicsManager.prototype.createAnchorFromLine = function ($linePoints)
{
	var closestPoint = this.group.getClosestPoint($linePoints);
	var anchor = new AnchorP2SoftPhysicsManager(this.group);
	anchor.setFromPoint(closestPoint);
	return anchor;
};

GroupP2SoftPhysicsManager.prototype.createAnchors = function ($points)
{
	var toReturn = [];
	var nodes = this.group.getNodesInside($points);
	for (var i = 0, length = nodes.length; i < length; i += 1)
	{
		var node = nodes[i];
		var currAnchorA = new AnchorP2SoftPhysicsManager(this.group);
		currAnchorA.setFromPoint([node.oX, node.oY]);
		toReturn.push(currAnchorA);
	}
	return toReturn;
};

GroupP2SoftPhysicsManager.prototype.addJointsToWorld = function ()
{
	for (var i = 0, length = this.group.joints.length; i < length; i += 1)
	{
		var joint = this.group.joints[i];
		joint.physicsManager = new JointP2PhysicsManager(joint, this.world, this.conf);
	}
};

GroupP2SoftPhysicsManager.prototype.setNodesMassFromJoints = function ()
{
	var NodeGraph = require('../../core/NodeGraph');
	var nodeGraph = new NodeGraph();
	var i;
	var startingVertices = [];
	var nodesLength = this.group.nodes.length;
	var jointsLength = this.group.joints.length;
	for (i = 0; i < jointsLength; i += 1)
	{
		var currJoint = this.group.joints[i];
		nodeGraph.connect(currJoint.nodeA, currJoint.nodeB);
	}
	for (i = 0; i < nodesLength; i += 1)
	{
		var node = this.group.nodes[i];
		if (node.fixed)
		{
			startingVertices.push(nodeGraph.getVertex(node));
		}
	}
	if (startingVertices.length === 0)
	{
		return;
	}
	nodeGraph.traverse(startingVertices);
	var verticesLength = nodeGraph.vertices.length;
	for (i = 0; i < verticesLength; i += 1)
	{
		var vertex = nodeGraph.vertices[i];
		var decay = Number(this.group.conf.physics.structuralMassDecay);
		var value = Math.pow(decay, vertex.mapValue / 2);//Math.pow(2, vertex.mapValue / 7.33);
		var body = vertex.node.physicsManager.body;
		if (!vertex.node.fixed)
		{
			//body.mass = this.conf.mass / this.group.nodes.length / value * body.getArea();
			//body.updateMassProperties();
			var massVariance = this.conf.massVariance || 0;
			var random = -massVariance + Math.random() * massVariance * 2;
			var baseMass = this.group.structure.area * this.conf.mass;
			var mass = baseMass + baseMass * random;
			body.mass = mass / value;
			body.invMass = 1 / body.mass;
			body.inertia = body.mass / 2;
			body.invInertia = 1 / body.inertia;
			vertex.node.debugText = Math.round(body.mass * 100) / 100;
			//vertex.node.debugText = Math.round(vertex.mapValue * 100) / 100;
		}
	}
};

GroupP2SoftPhysicsManager.prototype.applyAngularForce = function ($value)
{
	//this.group.nodes[0].physicsManager.body.angularForce += $value;
	for (var i = 0, length = this.group.nodes.length; i < length; i += 1)
	{
		var currPhys = this.group.nodes[i].physicsManager;
		currPhys.body.angularForce += $value;
	}
};

GroupP2SoftPhysicsManager.prototype.applyForce = function ($vector)
{
	for (var i = 0, length = this.group.nodes.length; i < length; i += 1)
	{
		var currPhys = this.group.nodes[i].physicsManager;
		currPhys.body.force = [
			currPhys.body.force[0] + $vector[0],
			currPhys.body.force[1] + $vector[1]
		];
	}
};

GroupP2SoftPhysicsManager.prototype.getMass = function ()
{
	var mass = 0;
	for (var i = 0, length = this.group.nodes.length; i < length; i += 1)
	{
		var node = this.group.nodes[i];
		mass += node.physicsManager.body.mass;
	}

	return mass;
};

GroupP2SoftPhysicsManager.prototype.getX = function () { return this.group.nodes[0].physicsManager.body.interpolatedPosition[0]; };
GroupP2SoftPhysicsManager.prototype.getY = function () { return this.worldHeight - this.group.nodes[0].physicsManager.body.interpolatedPosition[1]; };

GroupP2SoftPhysicsManager.prototype.getAngle = function ()
{
	return this.group.nodes[0].physicsManager.body.interpolatedAngle;
};

GroupP2SoftPhysicsManager.prototype.hitTest = function ($point, $precision)
{
	$point[1] = this.worldHeight - $point[1];
	var dx;
	var dy;
	var nodesLength = this.group.nodes.length;

	for (var m = 0; m < nodesLength; m += 1)
	{
		var body = this.group.nodes[m].physicsManager.body;
		dx = Math.abs(body.interpolatedPosition[0] - $point[0]);
		dy = Math.abs(body.interpolatedPosition[1] - $point[1]);
		if (dx < $precision && dy < $precision)
		{
			return body;
		}
	}
	if (this.polygon.isInside($point))
	{
		var closest;
		var closestHyp;
		for (var i = 0, length = this.polygon.points.length; i < length; i += 1)
		{
			var currPoint = this.polygon.points[i];
			dx = Math.abs($point[0] - currPoint[0]);
			dy = Math.abs($point[1] - currPoint[1]);
			var hyp = Math.sqrt(dx * dx + dy * dy);
			if (closestHyp === undefined || hyp < closestHyp)
			{
				closest = currPoint;
				closestHyp = hyp;
			}
		}
		for (var k = 0; k < nodesLength; k += 1)
		{
			var currNode = this.group.nodes[k];
			if (currNode.physicsManager.body.interpolatedPosition[0] === closest[0] &&
				currNode.physicsManager.body.interpolatedPosition[1] === closest[1])
			{
				return currNode.physicsManager.body;
			}
		}
		return closest;
	}
};

module.exports = GroupP2SoftPhysicsManager;


},{"../../../libs/p2":"/Users/Lau/www/svjelly/libs/p2.js","../../core/NodeGraph":"/Users/Lau/www/svjelly/src/core/NodeGraph.js","../../core/Polygon":"/Users/Lau/www/svjelly/src/core/Polygon.js","./AnchorP2SoftPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2SoftPhysicsManager.js","./JointP2PhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/JointP2PhysicsManager.js","./NodeP2SoftPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/NodeP2SoftPhysicsManager.js","./SoftDecorationDrawing":"/Users/Lau/www/svjelly/src/physics/p2physics/SoftDecorationDrawing.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/HardDecorationDrawing.js":[function(require,module,exports){
var DecorationDrawingCommand = require('../../core/DecorationDrawingCommand');
var DecorationDrawing = require('../../core/DecorationDrawing');

var HardDecorationDrawing = Object.create(DecorationDrawing);
HardDecorationDrawing.create = function ($group)
{
	var inst = Object.create(HardDecorationDrawing);
	inst.group = $group;
	inst.commands = [];

	inst.properties = undefined;

	return inst;
};

HardDecorationDrawing.setDrawingCommands = function ($drawingCommands)
{
	for (var i = 0, length = $drawingCommands.pointCommands.length; i < length; i += 1)
	{
		var curr = $drawingCommands.pointCommands[i];
		this.commands.push(new DecorationDrawingCommand(curr, this.group.physicsManager));
	}
	this.commandsLength = this.commands.length;
};

HardDecorationDrawing.setProperties = function ($properties)
{
	this.properties = $properties;
	this.useDynamicGradient = false;
};

HardDecorationDrawing.getBoundingBox = function ()
{
	return this.group.physicsManager.getBoundingBox();
};

HardDecorationDrawing.isStatic = function ()
{
	return this.group.conf.fixed === true;
};

HardDecorationDrawing.willNotIntersect = function ()
{
	return false;
};

HardDecorationDrawing.isSimpleDrawing = function ()
{
	return false;
};

module.exports = HardDecorationDrawing;

},{"../../core/DecorationDrawing":"/Users/Lau/www/svjelly/src/core/DecorationDrawing.js","../../core/DecorationDrawingCommand":"/Users/Lau/www/svjelly/src/core/DecorationDrawingCommand.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/JointP2PhysicsManager.js":[function(require,module,exports){
//var p2 = require('../../../libs/p2');
var P2Utils = require('./P2Utils');

var JointP2PhysicsManager = function ($joint, $world, $conf)
{
	var jointConf = $conf.joints[$joint.type];
	var bodyA = $joint.nodeA.physicsManager.body;
	var bodyB = $joint.nodeB.physicsManager.body;
	this.constraints = P2Utils.createConstraints($world, bodyA, bodyB, jointConf);
};

module.exports = JointP2PhysicsManager;

},{"./P2Utils":"/Users/Lau/www/svjelly/src/physics/p2physics/P2Utils.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/NodeP2HardPhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/
var p2 = require('../../../libs/p2');

var NodeP2HardPhysicsManager = function ()
{
	this.getX = this.getXSimple;
	this.getY = this.getYSimple;
};

NodeP2HardPhysicsManager.prototype.addToWorld = function ($body, $position, $worldHeight)
{
	this.body = $body;
	this.position = $position;
	this.worldHeight = $worldHeight;
	this.offset = [0, 0];
};

NodeP2HardPhysicsManager.prototype.setFixed = function ($fixed)
{
	if ($fixed)
	{
		this.body.type = p2.Body.STATIC;
		this.body.updateMassProperties();
	}
};

NodeP2HardPhysicsManager.prototype.setOffset = function ($offset)
{
	var dX = this.position[0] + $offset[0];
	var dY = this.position[1] - $offset[1];
	this.angle = Math.atan2(dY, dX);
	this.hyp = Math.sqrt(dX * dX + dY * dY);
	this.getX = this.getXOffset;
	this.getY = this.getYOffset;
};

NodeP2HardPhysicsManager.prototype.getXSimple = function ()
{
	return this.body.interpolatedPosition[0];
};

NodeP2HardPhysicsManager.prototype.getYSimple = function ()
{
	return this.worldHeight - this.body.interpolatedPosition[1];
};

NodeP2HardPhysicsManager.prototype.getXOffset = function ()
{
	return this.body.interpolatedPosition[0] + this.hyp * Math.cos(this.body.interpolatedAngle + this.angle);
};

NodeP2HardPhysicsManager.prototype.getYOffset = function ()
{
	return this.worldHeight - (this.body.interpolatedPosition[1] + this.hyp * Math.sin(this.body.interpolatedAngle + this.angle));
};

module.exports = NodeP2HardPhysicsManager;


},{"../../../libs/p2":"/Users/Lau/www/svjelly/libs/p2.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/NodeP2SoftPhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/

var NodeP2SoftPhysicsManager = function ()
{
	var self = this;
	this.addedToWorld = new window.Promise(function (resolve) { self.resolveAddedToWorld = resolve; });
};

NodeP2SoftPhysicsManager.prototype.addToWorld = function ($p2, $body, $worldHeight)
{
	this.p2 = $p2;
	this.body = $body;
	this.worldHeight = $worldHeight;
	this.resolveAddedToWorld();
};

NodeP2SoftPhysicsManager.prototype.applyForce = function ($vec)
{
	//console.log('nop', this.body.applyForceLocal, $vec);
	var loc = [];
	this.body.toWorldFrame(loc, [0, 0]);
	this.body.applyForce($vec, loc);
};

NodeP2SoftPhysicsManager.prototype.setFixed = function ($fixed)
{
	if ($fixed)
	{
		this.body.type = this.p2.Body.STATIC;
	}
};

NodeP2SoftPhysicsManager.prototype.getAngle = function ()
{
	return this.body.interpolatedAngle;
};

NodeP2SoftPhysicsManager.prototype.getX = function ()
{
	//console.log(this.body.GetWorldCenter().get_x());
	return this.body.interpolatedPosition[0];
};

NodeP2SoftPhysicsManager.prototype.getY = function ()
{
	return this.worldHeight - this.body.interpolatedPosition[1];
};

module.exports = NodeP2SoftPhysicsManager;


},{}],"/Users/Lau/www/svjelly/src/physics/p2physics/P2PhysicsManager.js":[function(require,module,exports){
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
/*jshint camelcase:false*/

var p2 = require('../../../libs/p2');
var P2Utils = require('./P2Utils');
var GroupP2SoftPhysicsManager = require('./GroupP2SoftPhysicsManager');
var GroupP2HardPhysicsManager = require('./GroupP2HardPhysicsManager');
var GroupGhostPhysicsManager = require('./GroupGhostPhysicsManager');
var AnchorP2GhostPhysicsManager = require('./AnchorP2GhostPhysicsManager');

var P2PhysicsManager = function ($conf, $p2World)
{
	this.p2World = $p2World || new p2.World($conf);
	this.p2 = p2;
	this.conf = $conf;
	this.worldWidth = undefined;
	this.worldHeight = undefined;
	this.newTime = undefined;
	this.lastTime = undefined;
	this.materialsList = [];

	//this.p2World.gravity = this.conf.gravity;

	this.setMaterials();
};

P2PhysicsManager.prototype.step = function ($time)
{
	this.newTime = $time - this.lastTime || 0;
	this.lastTime = $time;
	this.p2World.step(1 / 60, this.newTime / 1000, 5);
};

P2PhysicsManager.prototype.constrainGroups = function ($anchorA, $anchorB, $type)
{
	$anchorA.addToWorld();
	$anchorB.addToWorld();

	var constraintConfig = this.conf.constraints[$type];

	P2Utils.createConstraints(this.p2World, $anchorA.body, $anchorB.body, constraintConfig, [$anchorA.offset, $anchorB.offset]);
};

P2PhysicsManager.prototype.createGhostAnchorFromPoints = function ($points)
{
	var Polygon = require('../../core/Polygon');
	var polygon = Polygon.init($points);
	var center = polygon.getCenter();
	return this.createGhostAnchorFromPoint(center);
};

P2PhysicsManager.prototype.createGhostAnchorFromPoint = function ($point)
{
	var anchor = new AnchorP2GhostPhysicsManager(this.p2, this.p2World, this.worldHeight);
	anchor.setFromPoint($point);
	return anchor;
};

P2PhysicsManager.prototype.getGroupPhysicsManager = function ($group)
{
	switch ($group.conf.physics.bodyType)
	{
		case 'ghost': return new GroupGhostPhysicsManager($group);
		case 'hard': return new GroupP2HardPhysicsManager($group, this.p2World, this.worldHeight, this.materialsList);
		case 'soft': return new GroupP2SoftPhysicsManager($group, this.p2World, this.worldHeight, this.materialsList);
	}
};

P2PhysicsManager.prototype.setMaterials = function ()
{
	var materialName;
	for (materialName in this.conf.materials)
	{
		var materialConf = this.conf.materials[materialName];
		var currMaterial = new p2.Material();
		var curr = this.materialsList[materialName] = { material: currMaterial, materialConfig: materialConf };
		for (var otherName in this.materialsList)
		{
			var other = this.materialsList[otherName];
			var contactMaterial = new p2.ContactMaterial(curr.material, other.material, {
				friction: curr.materialConfig.friction + (other.materialConfig.friction - curr.materialConfig.friction) / 2,
				relaxation: curr.materialConfig.bounciness + (other.materialConfig.bounciness - curr.materialConfig.bounciness) / 2
			});
			this.p2World.addContactMaterial(contactMaterial);
		}
	}
};

module.exports = P2PhysicsManager;


},{"../../../libs/p2":"/Users/Lau/www/svjelly/libs/p2.js","../../core/Polygon":"/Users/Lau/www/svjelly/src/core/Polygon.js","./AnchorP2GhostPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/AnchorP2GhostPhysicsManager.js","./GroupGhostPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/GroupGhostPhysicsManager.js","./GroupP2HardPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/GroupP2HardPhysicsManager.js","./GroupP2SoftPhysicsManager":"/Users/Lau/www/svjelly/src/physics/p2physics/GroupP2SoftPhysicsManager.js","./P2Utils":"/Users/Lau/www/svjelly/src/physics/p2physics/P2Utils.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/P2Utils.js":[function(require,module,exports){
var p2 = require('../../../libs/p2');
var P2Utils = {};

P2Utils.createConstraints = function ($world, $bodyA, $bodyB, $config, $options)
{
	if (!$config) { return; }

	var constraints = [];
	for (var i = 0, length = $config.length; i < length; i += 1)
	{
		var config = $config[i];

		var constraint;

		var notNullOrUndefined = function ($property)
		{
			return $property !== undefined && $property !== null;
		};

		switch (config.type)
		{
			case 'revoluteConstraint':
				var vecWorldA = p2.vec2.create();
				var vecWorldB = p2.vec2.create();
				var vecLocA = p2.vec2.create();
				var vecLocB = p2.vec2.create();
				$bodyA.toWorldFrame(vecWorldA, [0, 0]);
				$bodyB.toWorldFrame(vecWorldB, [0, 0]);
				$bodyA.toLocalFrame(vecLocA, $bodyB.interpolatedPosition);
				$bodyB.toLocalFrame(vecLocB, $bodyA.interpolatedPosition);

				// console.log(revolute.autoPivot);
				if (!$options || !$options[0] || !$options[1]) { config.autoPivot = true; }
				var localPivotA = config.autoPivot ? undefined : $options[0];
				var localPivotB = config.autoPivot ? undefined : $options[1];
				var worldPivot = config.autoPivot ? $bodyA.interpolatedPosition : undefined;
				constraint = new p2.RevoluteConstraint($bodyA, $bodyB,
				{
					worldPivot: worldPivot,
					localPivotA: localPivotA,
					localPivotB: localPivotB
				});
				if (!config.motor)
				{
					//constraint.setLimits(0, 0);
					if (config.collideConnected !== undefined) { constraint.collideConnected = config.collideConnected; }
				}
				else
				{
					constraint.enableMotor();
					constraint.setMotorSpeed(-1);
					constraint.collideConnected = false;
				}
				if (config.noRotation) { constraint.setLimits(0, 0); }
				if (notNullOrUndefined(config.stiffness)) { constraint.setStiffness(Number(config.stiffness)); } //default 20
				if (notNullOrUndefined(config.relaxation)) { constraint.setRelaxation(Number(config.relaxation)); }
				$world.addConstraint(constraint);
				constraints.push(constraint);

				break;
			case 'prismaticConstraint':
				var axisVec = p2.vec2.create();
				var worldOffsetB = p2.vec2.create();
				$bodyB.toWorldFrame(worldOffsetB, $options[1]);
				$bodyA.toLocalFrame(axisVec, worldOffsetB);//[$bodyB.interpolatedPosition[0] + $options[1][0] - ($bodyA.interpolatedPosition[0] + $options[0][0]), $bodyB.interpolatedPosition[1] - $bodyA.interpolatedPosition[1]];
				var sx = axisVec[0] - $options[0][0];
				var sy = axisVec[1] - $options[0][1];
				// var cx = Math.abs(sx);
				// var cy = Math.abs(sy);
				// var dist = Math.sqrt(cx * cx + cy * cy);
				//console.log(axisVec, $options[0]);
				//debugger;
				constraint = new p2.PrismaticConstraint($bodyA, $bodyB, {
					localAnchorA: $options[0],
					localAnchorB: $options[1],
					localAxisA: [sx, sy],
					upperLimit: notNullOrUndefined(config.upperLimit) ? Number(config.upperLimit) : 1,
					lowerLimit: notNullOrUndefined(config.lowerLimit) ? Number(config.lowerLimit) : 0,
					disableRotationalLock: config.canRotate === true ? true : false
				});
				if (config.collideConnected !== undefined) { constraint.collideConnected = config.collideConnected; }
				if (notNullOrUndefined(config.stiffness)) {
				console.log('not nullllll');
				constraint.setStiffness(Number(config.stiffness)); } //default 20
				if (notNullOrUndefined(config.relaxation)) { constraint.setRelaxation(Number(config.relaxation)); }
				$world.addConstraint(constraint);
				constraints.push(constraint);
				break;
			case 'lockConstraint':
				constraint = new p2.LockConstraint($bodyA, $bodyB);
				//if ($options && $options[0]) { constraint.localOffsetB = $options[0]; }
				if (config.collideConnected !== undefined) { constraint.collideConnected = config.collideConnected; }
				if (notNullOrUndefined(config.stiffness)) { constraint.setStiffness(Number(config.stiffness)); } //default 20
				if (notNullOrUndefined(config.relaxation)) { constraint.setRelaxation(Number(config.relaxation)); }
				$world.addConstraint(constraint);
				constraints.push(constraint);
				break;
			case 'linearSpring':
				constraint = new p2.LinearSpring($bodyA, $bodyB, {
					localAnchorA: $options && $options[0] ? $options[0] : undefined,
					localAnchorB: $options && $options[1] ? $options[1] : undefined
				});
				if (notNullOrUndefined(config.stiffness)) { constraint.stiffness = Number(config.stiffness); }
				if (notNullOrUndefined(config.damping)) { constraint.damping = Number(config.damping); }
				$world.addSpring(constraint);
				constraints.push(constraint);
				break;
			case 'rotationalSpring':
				constraint = new p2.RotationalSpring($bodyA, $bodyB);
				if (notNullOrUndefined(config.stiffness)) { constraint.stiffness = Number(config.stiffness); }
				if (notNullOrUndefined(config.damping)) { constraint.damping = Number(config.damping); }
				constraints.push(constraint);
				$world.addSpring(constraint);
				break;
			default:
				constraint = new p2.DistanceConstraint($bodyA, $bodyB);
				if ($options && $options[0]) { constraint.localAnchorA = $options[0]; }
				if ($options && $options[1]) { constraint.localAnchorB = $options[1]; }
				if (notNullOrUndefined(config.stiffness)) { constraint.setStiffness(Number(config.stiffness)); } // default 500
				if (notNullOrUndefined(config.relaxation)) { constraint.setRelaxation(Number(config.relaxation)); }// default 0.1
				$world.addConstraint(constraint);
				constraints.push(constraint);
				break;
		}
	}
	console.log(constraints);
	return constraints;
};

module.exports = P2Utils;

},{"../../../libs/p2":"/Users/Lau/www/svjelly/libs/p2.js"}],"/Users/Lau/www/svjelly/src/physics/p2physics/SoftDecorationDrawing.js":[function(require,module,exports){
var DecorationDrawingCommand = require('../../core/DecorationDrawingCommand');
var DecorationDrawing = require('../../core/DecorationDrawing');

var SoftDecorationDrawing = Object.create(DecorationDrawing);
SoftDecorationDrawing.create = function ($group)
{
	var inst = Object.create(SoftDecorationDrawing);
	inst.group = $group;
	inst.commands = [];

	inst.properties = undefined;

	return inst;
};

SoftDecorationDrawing.setDrawingCommands = function ($drawingCommands)
{
	for (var i = 0, length = $drawingCommands.pointCommands.length; i < length; i += 1)
	{
		var curr = $drawingCommands.pointCommands[i];
		var closestNode = this.group.getClosestNode(curr.point);
		console.log(closestNode.ID);
		this.commands.push(new DecorationDrawingCommand(curr, closestNode.physicsManager));
	}
	this.commandsLength = this.commands.length;
};

SoftDecorationDrawing.setProperties = function ($properties)
{
	this.properties = $properties;
	this.useDynamicGradient = false;
};

SoftDecorationDrawing.getBoundingBox = function ()
{
	return this.group.physicsManager.getBoundingBox();
};

SoftDecorationDrawing.isStatic = function ()
{
	return this.group.conf.fixed === true;
};

SoftDecorationDrawing.willNotIntersect = function ()
{
	return false;
};

SoftDecorationDrawing.isSimpleDrawing = function ()
{
	return false;
};

module.exports = SoftDecorationDrawing;

},{"../../core/DecorationDrawing":"/Users/Lau/www/svjelly/src/core/DecorationDrawing.js","../../core/DecorationDrawingCommand":"/Users/Lau/www/svjelly/src/core/DecorationDrawingCommand.js"}]},{},["/Users/Lau/www/svjelly/src/physics/p2physics/P2PhysicsManager.js"])("/Users/Lau/www/svjelly/src/physics/p2physics/P2PhysicsManager.js")
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWJzL3AyLmpzIiwic3JjL2NvcmUvQ29tbWFuZHMuanMiLCJzcmMvY29yZS9EZWNvcmF0aW9uRHJhd2luZy5qcyIsInNyYy9jb3JlL0RlY29yYXRpb25EcmF3aW5nQ29tbWFuZC5qcyIsInNyYy9jb3JlL05vZGVHcmFwaC5qcyIsInNyYy9jb3JlL1BvbHlnb24uanMiLCJzcmMvcGh5c2ljcy9wMnBoeXNpY3MvQW5jaG9yUDJHaG9zdFBoeXNpY3NNYW5hZ2VyLmpzIiwic3JjL3BoeXNpY3MvcDJwaHlzaWNzL0FuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyLmpzIiwic3JjL3BoeXNpY3MvcDJwaHlzaWNzL0FuY2hvclAyU29mdFBoeXNpY3NNYW5hZ2VyLmpzIiwic3JjL3BoeXNpY3MvcDJwaHlzaWNzL0dyb3VwR2hvc3RQaHlzaWNzTWFuYWdlci5qcyIsInNyYy9waHlzaWNzL3AycGh5c2ljcy9Hcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyLmpzIiwic3JjL3BoeXNpY3MvcDJwaHlzaWNzL0dyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXIuanMiLCJzcmMvcGh5c2ljcy9wMnBoeXNpY3MvSGFyZERlY29yYXRpb25EcmF3aW5nLmpzIiwic3JjL3BoeXNpY3MvcDJwaHlzaWNzL0pvaW50UDJQaHlzaWNzTWFuYWdlci5qcyIsInNyYy9waHlzaWNzL3AycGh5c2ljcy9Ob2RlUDJIYXJkUGh5c2ljc01hbmFnZXIuanMiLCJzcmMvcGh5c2ljcy9wMnBoeXNpY3MvTm9kZVAyU29mdFBoeXNpY3NNYW5hZ2VyLmpzIiwic3JjL3BoeXNpY3MvcDJwaHlzaWNzL1AyUGh5c2ljc01hbmFnZXIuanMiLCJzcmMvcGh5c2ljcy9wMnBoeXNpY3MvUDJVdGlscy5qcyIsInNyYy9waHlzaWNzL3AycGh5c2ljcy9Tb2Z0RGVjb3JhdGlvbkRyYXdpbmcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3OVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IHAyLmpzIGF1dGhvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG4hZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZmYWxzZSlkZWZpbmUoZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYucDI9ZSgpfX0oZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2NhbGFyID0gX2RlcmVxXygnLi9TY2FsYXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xuXG4vKipcbiAqIENvbnRhaW5lciBmb3IgbGluZS1yZWxhdGVkIGZ1bmN0aW9uc1xuICogQGNsYXNzIExpbmVcbiAqL1xuZnVuY3Rpb24gTGluZSgpe307XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdHdvIGxpbmVzLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBsaW5lSW50XG4gKiBAcGFyYW0gIHtBcnJheX0gIGwxICAgICAgICAgIExpbmUgdmVjdG9yIDFcbiAqIEBwYXJhbSAge0FycmF5fSAgbDIgICAgICAgICAgTGluZSB2ZWN0b3IgMlxuICogQHBhcmFtICB7TnVtYmVyfSBwcmVjaXNpb24gICBQcmVjaXNpb24gdG8gdXNlIHdoZW4gY2hlY2tpbmcgaWYgdGhlIGxpbmVzIGFyZSBwYXJhbGxlbFxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBUaGUgaW50ZXJzZWN0aW9uIHBvaW50LlxuICovXG5MaW5lLmxpbmVJbnQgPSBmdW5jdGlvbihsMSxsMixwcmVjaXNpb24pe1xuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuICAgIHZhciBpID0gWzAsMF07IC8vIHBvaW50XG4gICAgdmFyIGExLCBiMSwgYzEsIGEyLCBiMiwgYzIsIGRldDsgLy8gc2NhbGFyc1xuICAgIGExID0gbDFbMV1bMV0gLSBsMVswXVsxXTtcbiAgICBiMSA9IGwxWzBdWzBdIC0gbDFbMV1bMF07XG4gICAgYzEgPSBhMSAqIGwxWzBdWzBdICsgYjEgKiBsMVswXVsxXTtcbiAgICBhMiA9IGwyWzFdWzFdIC0gbDJbMF1bMV07XG4gICAgYjIgPSBsMlswXVswXSAtIGwyWzFdWzBdO1xuICAgIGMyID0gYTIgKiBsMlswXVswXSArIGIyICogbDJbMF1bMV07XG4gICAgZGV0ID0gYTEgKiBiMiAtIGEyKmIxO1xuICAgIGlmICghU2NhbGFyLmVxKGRldCwgMCwgcHJlY2lzaW9uKSkgeyAvLyBsaW5lcyBhcmUgbm90IHBhcmFsbGVsXG4gICAgICAgIGlbMF0gPSAoYjIgKiBjMSAtIGIxICogYzIpIC8gZGV0O1xuICAgICAgICBpWzFdID0gKGExICogYzIgLSBhMiAqIGMxKSAvIGRldDtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0d28gbGluZSBzZWdtZW50cyBpbnRlcnNlY3RzLlxuICogQG1ldGhvZCBzZWdtZW50c0ludGVyc2VjdFxuICogQHBhcmFtIHtBcnJheX0gcDEgVGhlIHN0YXJ0IHZlcnRleCBvZiB0aGUgZmlyc3QgbGluZSBzZWdtZW50LlxuICogQHBhcmFtIHtBcnJheX0gcDIgVGhlIGVuZCB2ZXJ0ZXggb2YgdGhlIGZpcnN0IGxpbmUgc2VnbWVudC5cbiAqIEBwYXJhbSB7QXJyYXl9IHExIFRoZSBzdGFydCB2ZXJ0ZXggb2YgdGhlIHNlY29uZCBsaW5lIHNlZ21lbnQuXG4gKiBAcGFyYW0ge0FycmF5fSBxMiBUaGUgZW5kIHZlcnRleCBvZiB0aGUgc2Vjb25kIGxpbmUgc2VnbWVudC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHR3byBsaW5lIHNlZ21lbnRzIGludGVyc2VjdFxuICovXG5MaW5lLnNlZ21lbnRzSW50ZXJzZWN0ID0gZnVuY3Rpb24ocDEsIHAyLCBxMSwgcTIpe1xuICAgdmFyIGR4ID0gcDJbMF0gLSBwMVswXTtcbiAgIHZhciBkeSA9IHAyWzFdIC0gcDFbMV07XG4gICB2YXIgZGEgPSBxMlswXSAtIHExWzBdO1xuICAgdmFyIGRiID0gcTJbMV0gLSBxMVsxXTtcblxuICAgLy8gc2VnbWVudHMgYXJlIHBhcmFsbGVsXG4gICBpZihkYSpkeSAtIGRiKmR4ID09IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgIHZhciBzID0gKGR4ICogKHExWzFdIC0gcDFbMV0pICsgZHkgKiAocDFbMF0gLSBxMVswXSkpIC8gKGRhICogZHkgLSBkYiAqIGR4KVxuICAgdmFyIHQgPSAoZGEgKiAocDFbMV0gLSBxMVsxXSkgKyBkYiAqIChxMVswXSAtIHAxWzBdKSkgLyAoZGIgKiBkeCAtIGRhICogZHkpXG5cbiAgIHJldHVybiAocz49MCAmJiBzPD0xICYmIHQ+PTAgJiYgdDw9MSk7XG59O1xuXG5cbn0se1wiLi9TY2FsYXJcIjo0fV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xuXG4vKipcbiAqIFBvaW50IHJlbGF0ZWQgZnVuY3Rpb25zXG4gKiBAY2xhc3MgUG9pbnRcbiAqL1xuZnVuY3Rpb24gUG9pbnQoKXt9O1xuXG4vKipcbiAqIEdldCB0aGUgYXJlYSBvZiBhIHRyaWFuZ2xlIHNwYW5uZWQgYnkgdGhlIHRocmVlIGdpdmVuIHBvaW50cy4gTm90ZSB0aGF0IHRoZSBhcmVhIHdpbGwgYmUgbmVnYXRpdmUgaWYgdGhlIHBvaW50cyBhcmUgbm90IGdpdmVuIGluIGNvdW50ZXItY2xvY2t3aXNlIG9yZGVyLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBhcmVhXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7QXJyYXl9IGJcbiAqIEBwYXJhbSAge0FycmF5fSBjXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblBvaW50LmFyZWEgPSBmdW5jdGlvbihhLGIsYyl7XG4gICAgcmV0dXJuICgoKGJbMF0gLSBhWzBdKSooY1sxXSAtIGFbMV0pKS0oKGNbMF0gLSBhWzBdKSooYlsxXSAtIGFbMV0pKSk7XG59O1xuXG5Qb2ludC5sZWZ0ID0gZnVuY3Rpb24oYSxiLGMpe1xuICAgIHJldHVybiBQb2ludC5hcmVhKGEsYixjKSA+IDA7XG59O1xuXG5Qb2ludC5sZWZ0T24gPSBmdW5jdGlvbihhLGIsYykge1xuICAgIHJldHVybiBQb2ludC5hcmVhKGEsIGIsIGMpID49IDA7XG59O1xuXG5Qb2ludC5yaWdodCA9IGZ1bmN0aW9uKGEsYixjKSB7XG4gICAgcmV0dXJuIFBvaW50LmFyZWEoYSwgYiwgYykgPCAwO1xufTtcblxuUG9pbnQucmlnaHRPbiA9IGZ1bmN0aW9uKGEsYixjKSB7XG4gICAgcmV0dXJuIFBvaW50LmFyZWEoYSwgYiwgYykgPD0gMDtcbn07XG5cbnZhciB0bXBQb2ludDEgPSBbXSxcbiAgICB0bXBQb2ludDIgPSBbXTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aHJlZSBwb2ludHMgYXJlIGNvbGxpbmVhclxuICogQG1ldGhvZCBjb2xsaW5lYXJcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHBhcmFtICB7QXJyYXl9IGNcbiAqIEBwYXJhbSAge051bWJlcn0gW3RocmVzaG9sZEFuZ2xlPTBdIFRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBjb21wYXJpbmcgdGhlIHZlY3RvcnMuIFRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0cnVlIGlmIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSByZXN1bHRpbmcgdmVjdG9ycyBpcyBsZXNzIHRoYW4gdGhpcyB2YWx1ZS4gVXNlIHplcm8gZm9yIG1heCBwcmVjaXNpb24uXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Qb2ludC5jb2xsaW5lYXIgPSBmdW5jdGlvbihhLGIsYyx0aHJlc2hvbGRBbmdsZSkge1xuICAgIGlmKCF0aHJlc2hvbGRBbmdsZSlcbiAgICAgICAgcmV0dXJuIFBvaW50LmFyZWEoYSwgYiwgYykgPT0gMDtcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGFiID0gdG1wUG9pbnQxLFxuICAgICAgICAgICAgYmMgPSB0bXBQb2ludDI7XG5cbiAgICAgICAgYWJbMF0gPSBiWzBdLWFbMF07XG4gICAgICAgIGFiWzFdID0gYlsxXS1hWzFdO1xuICAgICAgICBiY1swXSA9IGNbMF0tYlswXTtcbiAgICAgICAgYmNbMV0gPSBjWzFdLWJbMV07XG5cbiAgICAgICAgdmFyIGRvdCA9IGFiWzBdKmJjWzBdICsgYWJbMV0qYmNbMV0sXG4gICAgICAgICAgICBtYWdBID0gTWF0aC5zcXJ0KGFiWzBdKmFiWzBdICsgYWJbMV0qYWJbMV0pLFxuICAgICAgICAgICAgbWFnQiA9IE1hdGguc3FydChiY1swXSpiY1swXSArIGJjWzFdKmJjWzFdKSxcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hY29zKGRvdC8obWFnQSptYWdCKSk7XG4gICAgICAgIHJldHVybiBhbmdsZSA8IHRocmVzaG9sZEFuZ2xlO1xuICAgIH1cbn07XG5cblBvaW50LnNxZGlzdCA9IGZ1bmN0aW9uKGEsYil7XG4gICAgdmFyIGR4ID0gYlswXSAtIGFbMF07XG4gICAgdmFyIGR5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufTtcblxufSx7fV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgTGluZSA9IF9kZXJlcV8oXCIuL0xpbmVcIilcbiwgICBQb2ludCA9IF9kZXJlcV8oXCIuL1BvaW50XCIpXG4sICAgU2NhbGFyID0gX2RlcmVxXyhcIi4vU2NhbGFyXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gUG9seWdvbjtcblxuLyoqXG4gKiBQb2x5Z29uIGNsYXNzLlxuICogQGNsYXNzIFBvbHlnb25cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQb2x5Z29uKCl7XG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNlcyB0aGF0IHRoaXMgcG9seWdvbiBjb25zaXN0cyBvZi4gQW4gYXJyYXkgb2YgYXJyYXkgb2YgbnVtYmVycywgZXhhbXBsZTogW1swLDBdLFsxLDBdLC4uXVxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0aWNlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRpY2VzID0gW107XG59XG5cbi8qKlxuICogR2V0IGEgdmVydGV4IGF0IHBvc2l0aW9uIGkuIEl0IGRvZXMgbm90IG1hdHRlciBpZiBpIGlzIG91dCBvZiBib3VuZHMsIHRoaXMgZnVuY3Rpb24gd2lsbCBqdXN0IGN5Y2xlLlxuICogQG1ldGhvZCBhdFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihpKXtcbiAgICB2YXIgdiA9IHRoaXMudmVydGljZXMsXG4gICAgICAgIHMgPSB2Lmxlbmd0aDtcbiAgICByZXR1cm4gdltpIDwgMCA/IGkgJSBzICsgcyA6IGkgJSBzXTtcbn07XG5cbi8qKlxuICogR2V0IGZpcnN0IHZlcnRleFxuICogQG1ldGhvZCBmaXJzdFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy52ZXJ0aWNlc1swXTtcbn07XG5cbi8qKlxuICogR2V0IGxhc3QgdmVydGV4XG4gKiBAbWV0aG9kIGxhc3RcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy52ZXJ0aWNlc1t0aGlzLnZlcnRpY2VzLmxlbmd0aC0xXTtcbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIHBvbHlnb24gZGF0YVxuICogQG1ldGhvZCBjbGVhclxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLnZlcnRpY2VzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIEFwcGVuZCBwb2ludHMgXCJmcm9tXCIgdG8gXCJ0b1wiLTEgZnJvbSBhbiBvdGhlciBwb2x5Z29uIFwicG9seVwiIG9udG8gdGhpcyBvbmUuXG4gKiBAbWV0aG9kIGFwcGVuZFxuICogQHBhcmFtIHtQb2x5Z29ufSBwb2x5IFRoZSBwb2x5Z29uIHRvIGdldCBwb2ludHMgZnJvbS5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgZnJvbSBUaGUgdmVydGV4IGluZGV4IGluIFwicG9seVwiLlxuICogQHBhcmFtIHtOdW1iZXJ9ICB0byBUaGUgZW5kIHZlcnRleCBpbmRleCBpbiBcInBvbHlcIi4gTm90ZSB0aGF0IHRoaXMgdmVydGV4IGlzIE5PVCBpbmNsdWRlZCB3aGVuIGFwcGVuZGluZy5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihwb2x5LGZyb20sdG8pe1xuICAgIGlmKHR5cGVvZihmcm9tKSA9PSBcInVuZGVmaW5lZFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJGcm9tIGlzIG5vdCBnaXZlbiFcIik7XG4gICAgaWYodHlwZW9mKHRvKSA9PSBcInVuZGVmaW5lZFwiKSAgIHRocm93IG5ldyBFcnJvcihcIlRvIGlzIG5vdCBnaXZlbiFcIik7XG5cbiAgICBpZih0by0xIDwgZnJvbSkgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxvbDFcIik7XG4gICAgaWYodG8gPiBwb2x5LnZlcnRpY2VzLmxlbmd0aCkgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2wyXCIpO1xuICAgIGlmKGZyb20gPCAwKSAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9sM1wiKTtcblxuICAgIGZvcih2YXIgaT1mcm9tOyBpPHRvOyBpKyspe1xuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2gocG9seS52ZXJ0aWNlc1tpXSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBNYWtlIHN1cmUgdGhhdCB0aGUgcG9seWdvbiB2ZXJ0aWNlcyBhcmUgb3JkZXJlZCBjb3VudGVyLWNsb2Nrd2lzZS5cbiAqIEBtZXRob2QgbWFrZUNDV1xuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5tYWtlQ0NXID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYnIgPSAwLFxuICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlcztcblxuICAgIC8vIGZpbmQgYm90dG9tIHJpZ2h0IHBvaW50XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh2W2ldWzFdIDwgdlticl1bMV0gfHwgKHZbaV1bMV0gPT0gdlticl1bMV0gJiYgdltpXVswXSA+IHZbYnJdWzBdKSkge1xuICAgICAgICAgICAgYnIgPSBpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV2ZXJzZSBwb2x5IGlmIGNsb2Nrd2lzZVxuICAgIGlmICghUG9pbnQubGVmdCh0aGlzLmF0KGJyIC0gMSksIHRoaXMuYXQoYnIpLCB0aGlzLmF0KGJyICsgMSkpKSB7XG4gICAgICAgIHRoaXMucmV2ZXJzZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV2ZXJzZSB0aGUgdmVydGljZXMgaW4gdGhlIHBvbHlnb25cbiAqIEBtZXRob2QgcmV2ZXJzZVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgdG1wID0gW107XG4gICAgZm9yKHZhciBpPTAsIE49dGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkhPT1OOyBpKyspe1xuICAgICAgICB0bXAucHVzaCh0aGlzLnZlcnRpY2VzLnBvcCgpKTtcbiAgICB9XG4gICAgdGhpcy52ZXJ0aWNlcyA9IHRtcDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBwb2ludCBpbiB0aGUgcG9seWdvbiBpcyBhIHJlZmxleCBwb2ludFxuICogQG1ldGhvZCBpc1JlZmxleFxuICogQHBhcmFtICB7TnVtYmVyfSAgaVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuaXNSZWZsZXggPSBmdW5jdGlvbihpKXtcbiAgICByZXR1cm4gUG9pbnQucmlnaHQodGhpcy5hdChpIC0gMSksIHRoaXMuYXQoaSksIHRoaXMuYXQoaSArIDEpKTtcbn07XG5cbnZhciB0bXBMaW5lMT1bXSxcbiAgICB0bXBMaW5lMj1bXTtcblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmVydGljZXMgaW4gdGhlIHBvbHlnb24gY2FuIHNlZSBlYWNoIG90aGVyXG4gKiBAbWV0aG9kIGNhblNlZVxuICogQHBhcmFtICB7TnVtYmVyfSBhIFZlcnRleCBpbmRleCAxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGIgVmVydGV4IGluZGV4IDJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmNhblNlZSA9IGZ1bmN0aW9uKGEsYikge1xuICAgIHZhciBwLCBkaXN0LCBsMT10bXBMaW5lMSwgbDI9dG1wTGluZTI7XG5cbiAgICBpZiAoUG9pbnQubGVmdE9uKHRoaXMuYXQoYSArIDEpLCB0aGlzLmF0KGEpLCB0aGlzLmF0KGIpKSAmJiBQb2ludC5yaWdodE9uKHRoaXMuYXQoYSAtIDEpLCB0aGlzLmF0KGEpLCB0aGlzLmF0KGIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRpc3QgPSBQb2ludC5zcWRpc3QodGhpcy5hdChhKSwgdGhpcy5hdChiKSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IHRoaXMudmVydGljZXMubGVuZ3RoOyArK2kpIHsgLy8gZm9yIGVhY2ggZWRnZVxuICAgICAgICBpZiAoKGkgKyAxKSAlIHRoaXMudmVydGljZXMubGVuZ3RoID09PSBhIHx8IGkgPT09IGEpIC8vIGlnbm9yZSBpbmNpZGVudCBlZGdlc1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChQb2ludC5sZWZ0T24odGhpcy5hdChhKSwgdGhpcy5hdChiKSwgdGhpcy5hdChpICsgMSkpICYmIFBvaW50LnJpZ2h0T24odGhpcy5hdChhKSwgdGhpcy5hdChiKSwgdGhpcy5hdChpKSkpIHsgLy8gaWYgZGlhZyBpbnRlcnNlY3RzIGFuIGVkZ2VcbiAgICAgICAgICAgIGwxWzBdID0gdGhpcy5hdChhKTtcbiAgICAgICAgICAgIGwxWzFdID0gdGhpcy5hdChiKTtcbiAgICAgICAgICAgIGwyWzBdID0gdGhpcy5hdChpKTtcbiAgICAgICAgICAgIGwyWzFdID0gdGhpcy5hdChpICsgMSk7XG4gICAgICAgICAgICBwID0gTGluZS5saW5lSW50KGwxLGwyKTtcbiAgICAgICAgICAgIGlmIChQb2ludC5zcWRpc3QodGhpcy5hdChhKSwgcCkgPCBkaXN0KSB7IC8vIGlmIGVkZ2UgaXMgYmxvY2tpbmcgdmlzaWJpbGl0eSB0byBiXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHBvbHlnb24gZnJvbSB2ZXJ0ZXggaSB0byB2ZXJ0ZXggai5cbiAqIEBtZXRob2QgY29weVxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAqIEBwYXJhbSAge1BvbHlnb259IFt0YXJnZXRQb2x5XSAgIE9wdGlvbmFsIHRhcmdldCBwb2x5Z29uIHRvIHNhdmUgaW4uXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSAgICAgICAgICAgICAgICBUaGUgcmVzdWx0aW5nIGNvcHkuXG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihpLGosdGFyZ2V0UG9seSl7XG4gICAgdmFyIHAgPSB0YXJnZXRQb2x5IHx8IG5ldyBQb2x5Z29uKCk7XG4gICAgcC5jbGVhcigpO1xuICAgIGlmIChpIDwgaikge1xuICAgICAgICAvLyBJbnNlcnQgYWxsIHZlcnRpY2VzIGZyb20gaSB0byBqXG4gICAgICAgIGZvcih2YXIgaz1pOyBrPD1qOyBrKyspXG4gICAgICAgICAgICBwLnZlcnRpY2VzLnB1c2godGhpcy52ZXJ0aWNlc1trXSk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIEluc2VydCB2ZXJ0aWNlcyAwIHRvIGpcbiAgICAgICAgZm9yKHZhciBrPTA7IGs8PWo7IGsrKylcbiAgICAgICAgICAgIHAudmVydGljZXMucHVzaCh0aGlzLnZlcnRpY2VzW2tdKTtcblxuICAgICAgICAvLyBJbnNlcnQgdmVydGljZXMgaSB0byBlbmRcbiAgICAgICAgZm9yKHZhciBrPWk7IGs8dGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGsrKylcbiAgICAgICAgICAgIHAudmVydGljZXMucHVzaCh0aGlzLnZlcnRpY2VzW2tdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbn07XG5cbi8qKlxuICogRGVjb21wb3NlcyB0aGUgcG9seWdvbiBpbnRvIGNvbnZleCBwaWVjZXMuIFJldHVybnMgYSBsaXN0IG9mIGVkZ2VzIFtbcDEscDJdLFtwMixwM10sLi4uXSB0aGF0IGN1dHMgdGhlIHBvbHlnb24uXG4gKiBOb3RlIHRoYXQgdGhpcyBhbGdvcml0aG0gaGFzIGNvbXBsZXhpdHkgTyhOXjQpIGFuZCB3aWxsIGJlIHZlcnkgc2xvdyBmb3IgcG9seWdvbnMgd2l0aCBtYW55IHZlcnRpY2VzLlxuICogQG1ldGhvZCBnZXRDdXRFZGdlc1xuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmdldEN1dEVkZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1pbj1bXSwgdG1wMT1bXSwgdG1wMj1bXSwgdG1wUG9seSA9IG5ldyBQb2x5Z29uKCk7XG4gICAgdmFyIG5EaWFncyA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWZsZXgoaSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhblNlZShpLCBqKSkge1xuICAgICAgICAgICAgICAgICAgICB0bXAxID0gdGhpcy5jb3B5KGksIGosIHRtcFBvbHkpLmdldEN1dEVkZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcDIgPSB0aGlzLmNvcHkoaiwgaSwgdG1wUG9seSkuZ2V0Q3V0RWRnZXMoKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGs9MDsgazx0bXAyLmxlbmd0aDsgaysrKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wMS5wdXNoKHRtcDJba10pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0bXAxLmxlbmd0aCA8IG5EaWFncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gdG1wMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5EaWFncyA9IHRtcDEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluLnB1c2goW3RoaXMuYXQoaSksIHRoaXMuYXQoaildKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtaW47XG59O1xuXG4vKipcbiAqIERlY29tcG9zZXMgdGhlIHBvbHlnb24gaW50byBvbmUgb3IgbW9yZSBjb252ZXggc3ViLVBvbHlnb25zLlxuICogQG1ldGhvZCBkZWNvbXBcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvciBQb2x5Z29uIG9iamVjdHMuXG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmRlY29tcCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5nZXRDdXRFZGdlcygpO1xuICAgIGlmKGVkZ2VzLmxlbmd0aCA+IDApXG4gICAgICAgIHJldHVybiB0aGlzLnNsaWNlKGVkZ2VzKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBbdGhpc107XG59O1xuXG4vKipcbiAqIFNsaWNlcyB0aGUgcG9seWdvbiBnaXZlbiBvbmUgb3IgbW9yZSBjdXQgZWRnZXMuIElmIGdpdmVuIG9uZSwgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0d28gcG9seWdvbnMgKGZhbHNlIG9uIGZhaWx1cmUpLiBJZiBtYW55LCBhbiBhcnJheSBvZiBwb2x5Z29ucy5cbiAqIEBtZXRob2Qgc2xpY2VcbiAqIEBwYXJhbSB7QXJyYXl9IGN1dEVkZ2VzIEEgbGlzdCBvZiBlZGdlcywgYXMgcmV0dXJuZWQgYnkgLmdldEN1dEVkZ2VzKClcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKGN1dEVkZ2VzKXtcbiAgICBpZihjdXRFZGdlcy5sZW5ndGggPT0gMCkgcmV0dXJuIFt0aGlzXTtcbiAgICBpZihjdXRFZGdlcyBpbnN0YW5jZW9mIEFycmF5ICYmIGN1dEVkZ2VzLmxlbmd0aCAmJiBjdXRFZGdlc1swXSBpbnN0YW5jZW9mIEFycmF5ICYmIGN1dEVkZ2VzWzBdLmxlbmd0aD09MiAmJiBjdXRFZGdlc1swXVswXSBpbnN0YW5jZW9mIEFycmF5KXtcblxuICAgICAgICB2YXIgcG9seXMgPSBbdGhpc107XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8Y3V0RWRnZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGN1dEVkZ2UgPSBjdXRFZGdlc1tpXTtcbiAgICAgICAgICAgIC8vIEN1dCBhbGwgcG9seXNcbiAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPHBvbHlzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgICAgICB2YXIgcG9seSA9IHBvbHlzW2pdO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBwb2x5LnNsaWNlKGN1dEVkZ2UpO1xuICAgICAgICAgICAgICAgIGlmKHJlc3VsdCl7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIHBvbHkhIEN1dCBhbmQgcXVpdFxuICAgICAgICAgICAgICAgICAgICBwb2x5cy5zcGxpY2UoaiwxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seXMucHVzaChyZXN1bHRbMF0scmVzdWx0WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvbHlzO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gV2FzIGdpdmVuIG9uZSBlZGdlXG4gICAgICAgIHZhciBjdXRFZGdlID0gY3V0RWRnZXM7XG4gICAgICAgIHZhciBpID0gdGhpcy52ZXJ0aWNlcy5pbmRleE9mKGN1dEVkZ2VbMF0pO1xuICAgICAgICB2YXIgaiA9IHRoaXMudmVydGljZXMuaW5kZXhPZihjdXRFZGdlWzFdKTtcblxuICAgICAgICBpZihpICE9IC0xICYmIGogIT0gLTEpe1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLmNvcHkoaSxqKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3B5KGosaSldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVja3MgdGhhdCB0aGUgbGluZSBzZWdtZW50cyBvZiB0aGlzIHBvbHlnb24gZG8gbm90IGludGVyc2VjdCBlYWNoIG90aGVyLlxuICogQG1ldGhvZCBpc1NpbXBsZVxuICogQHBhcmFtICB7QXJyYXl9IHBhdGggQW4gYXJyYXkgb2YgdmVydGljZXMgZS5nLiBbWzAsMF0sWzAsMV0sLi4uXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEB0b2RvIFNob3VsZCBpdCBjaGVjayBhbGwgc2VnbWVudHMgd2l0aCBhbGwgb3RoZXJzP1xuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5pc1NpbXBsZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHBhdGggPSB0aGlzLnZlcnRpY2VzO1xuICAgIC8vIENoZWNrXG4gICAgZm9yKHZhciBpPTA7IGk8cGF0aC5sZW5ndGgtMTsgaSsrKXtcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8aS0xOyBqKyspe1xuICAgICAgICAgICAgaWYoTGluZS5zZWdtZW50c0ludGVyc2VjdChwYXRoW2ldLCBwYXRoW2krMV0sIHBhdGhbal0sIHBhdGhbaisxXSApKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGUgc2VnbWVudCBiZXR3ZWVuIHRoZSBsYXN0IGFuZCB0aGUgZmlyc3QgcG9pbnQgdG8gYWxsIG90aGVyc1xuICAgIGZvcih2YXIgaT0xOyBpPHBhdGgubGVuZ3RoLTI7IGkrKyl7XG4gICAgICAgIGlmKExpbmUuc2VnbWVudHNJbnRlcnNlY3QocGF0aFswXSwgcGF0aFtwYXRoLmxlbmd0aC0xXSwgcGF0aFtpXSwgcGF0aFtpKzFdICkpe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25Qb2ludChwMSwgcDIsIHExLCBxMiwgZGVsdGEpe1xuICAgIGRlbHRhID0gZGVsdGEgfHwgMDtcbiAgIHZhciBhMSA9IHAyWzFdIC0gcDFbMV07XG4gICB2YXIgYjEgPSBwMVswXSAtIHAyWzBdO1xuICAgdmFyIGMxID0gKGExICogcDFbMF0pICsgKGIxICogcDFbMV0pO1xuICAgdmFyIGEyID0gcTJbMV0gLSBxMVsxXTtcbiAgIHZhciBiMiA9IHExWzBdIC0gcTJbMF07XG4gICB2YXIgYzIgPSAoYTIgKiBxMVswXSkgKyAoYjIgKiBxMVsxXSk7XG4gICB2YXIgZGV0ID0gKGExICogYjIpIC0gKGEyICogYjEpO1xuXG4gICBpZighU2NhbGFyLmVxKGRldCwwLGRlbHRhKSlcbiAgICAgIHJldHVybiBbKChiMiAqIGMxKSAtIChiMSAqIGMyKSkgLyBkZXQsICgoYTEgKiBjMikgLSAoYTIgKiBjMSkpIC8gZGV0XVxuICAgZWxzZVxuICAgICAgcmV0dXJuIFswLDBdXG59XG5cbi8qKlxuICogUXVpY2tseSBkZWNvbXBvc2UgdGhlIFBvbHlnb24gaW50byBjb252ZXggc3ViLXBvbHlnb25zLlxuICogQG1ldGhvZCBxdWlja0RlY29tcFxuICogQHBhcmFtICB7QXJyYXl9IHJlc3VsdFxuICogQHBhcmFtICB7QXJyYXl9IFtyZWZsZXhWZXJ0aWNlc11cbiAqIEBwYXJhbSAge0FycmF5fSBbc3RlaW5lclBvaW50c11cbiAqIEBwYXJhbSAge051bWJlcn0gW2RlbHRhXVxuICogQHBhcmFtICB7TnVtYmVyfSBbbWF4bGV2ZWxdXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtsZXZlbF1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5xdWlja0RlY29tcCA9IGZ1bmN0aW9uKHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKXtcbiAgICBtYXhsZXZlbCA9IG1heGxldmVsIHx8IDEwMDtcbiAgICBsZXZlbCA9IGxldmVsIHx8IDA7XG4gICAgZGVsdGEgPSBkZWx0YSB8fCAyNTtcbiAgICByZXN1bHQgPSB0eXBlb2YocmVzdWx0KSE9XCJ1bmRlZmluZWRcIiA/IHJlc3VsdCA6IFtdO1xuICAgIHJlZmxleFZlcnRpY2VzID0gcmVmbGV4VmVydGljZXMgfHwgW107XG4gICAgc3RlaW5lclBvaW50cyA9IHN0ZWluZXJQb2ludHMgfHwgW107XG5cbiAgICB2YXIgdXBwZXJJbnQ9WzAsMF0sIGxvd2VySW50PVswLDBdLCBwPVswLDBdOyAvLyBQb2ludHNcbiAgICB2YXIgdXBwZXJEaXN0PTAsIGxvd2VyRGlzdD0wLCBkPTAsIGNsb3Nlc3REaXN0PTA7IC8vIHNjYWxhcnNcbiAgICB2YXIgdXBwZXJJbmRleD0wLCBsb3dlckluZGV4PTAsIGNsb3Nlc3RJbmRleD0wOyAvLyBJbnRlZ2Vyc1xuICAgIHZhciBsb3dlclBvbHk9bmV3IFBvbHlnb24oKSwgdXBwZXJQb2x5PW5ldyBQb2x5Z29uKCk7IC8vIHBvbHlnb25zXG4gICAgdmFyIHBvbHkgPSB0aGlzLFxuICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlcztcblxuICAgIGlmKHYubGVuZ3RoIDwgMykgcmV0dXJuIHJlc3VsdDtcblxuICAgIGxldmVsKys7XG4gICAgaWYobGV2ZWwgPiBtYXhsZXZlbCl7XG4gICAgICAgIGNvbnNvbGUud2FybihcInF1aWNrRGVjb21wOiBtYXggbGV2ZWwgKFwiK21heGxldmVsK1wiKSByZWFjaGVkLlwiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHBvbHkuaXNSZWZsZXgoaSkpIHtcbiAgICAgICAgICAgIHJlZmxleFZlcnRpY2VzLnB1c2gocG9seS52ZXJ0aWNlc1tpXSk7XG4gICAgICAgICAgICB1cHBlckRpc3QgPSBsb3dlckRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmIChQb2ludC5sZWZ0KHBvbHkuYXQoaSAtIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGopKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgUG9pbnQucmlnaHRPbihwb2x5LmF0KGkgLSAxKSwgcG9seS5hdChpKSwgcG9seS5hdChqIC0gMSkpKSB7IC8vIGlmIGxpbmUgaW50ZXJzZWN0cyB3aXRoIGFuIGVkZ2VcbiAgICAgICAgICAgICAgICAgICAgcCA9IGdldEludGVyc2VjdGlvblBvaW50KHBvbHkuYXQoaSAtIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGopLCBwb2x5LmF0KGogLSAxKSk7IC8vIGZpbmQgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoUG9pbnQucmlnaHQocG9seS5hdChpICsgMSksIHBvbHkuYXQoaSksIHApKSB7IC8vIG1ha2Ugc3VyZSBpdCdzIGluc2lkZSB0aGUgcG9seVxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IFBvaW50LnNxZGlzdChwb2x5LnZlcnRpY2VzW2ldLCBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkIDwgbG93ZXJEaXN0KSB7IC8vIGtlZXAgb25seSB0aGUgY2xvc2VzdCBpbnRlcnNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckRpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VySW50ID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckluZGV4ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoUG9pbnQubGVmdChwb2x5LmF0KGkgKyAxKSwgcG9seS5hdChpKSwgcG9seS5hdChqICsgMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBQb2ludC5yaWdodE9uKHBvbHkuYXQoaSArIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGopKSkge1xuICAgICAgICAgICAgICAgICAgICBwID0gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocG9seS5hdChpICsgMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaiksIHBvbHkuYXQoaiArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFBvaW50LmxlZnQocG9seS5hdChpIC0gMSksIHBvbHkuYXQoaSksIHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gUG9pbnQuc3FkaXN0KHBvbHkudmVydGljZXNbaV0sIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCB1cHBlckRpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckRpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVySW50ID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckluZGV4ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIHZlcnRpY2VzIHRvIGNvbm5lY3QgdG8sIGNob29zZSBhIHBvaW50IGluIHRoZSBtaWRkbGVcbiAgICAgICAgICAgIGlmIChsb3dlckluZGV4ID09ICh1cHBlckluZGV4ICsgMSkgJSB0aGlzLnZlcnRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJDYXNlIDE6IFZlcnRleChcIitpK1wiKSwgbG93ZXJJbmRleChcIitsb3dlckluZGV4K1wiKSwgdXBwZXJJbmRleChcIit1cHBlckluZGV4K1wiKSwgcG9seS5zaXplKFwiK3RoaXMudmVydGljZXMubGVuZ3RoK1wiKVwiKTtcbiAgICAgICAgICAgICAgICBwWzBdID0gKGxvd2VySW50WzBdICsgdXBwZXJJbnRbMF0pIC8gMjtcbiAgICAgICAgICAgICAgICBwWzFdID0gKGxvd2VySW50WzFdICsgdXBwZXJJbnRbMV0pIC8gMjtcbiAgICAgICAgICAgICAgICBzdGVpbmVyUG9pbnRzLnB1c2gocCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA8IHVwcGVySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgaSwgcG9seS5iZWdpbigpICsgdXBwZXJJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkuYXBwZW5kKHBvbHksIGksIHVwcGVySW5kZXgrMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS52ZXJ0aWNlcy5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkudmVydGljZXMucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd2VySW5kZXggIT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3VwcGVyUG9seS5pbnNlcnQodXBwZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBsb3dlckluZGV4LCBwb2x5LmVuZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5hcHBlbmQocG9seSxsb3dlckluZGV4LHBvbHkudmVydGljZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL3VwcGVyUG9seS5pbnNlcnQodXBwZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCksIHBvbHkuYmVnaW4oKSArIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LmFwcGVuZChwb2x5LDAsaSsxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbG93ZXJQb2x5Lmluc2VydChsb3dlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGksIHBvbHkuZW5kKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LmFwcGVuZChwb2x5LGkscG9seS52ZXJ0aWNlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vbG93ZXJQb2x5Lmluc2VydChsb3dlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSwgcG9seS5iZWdpbigpICsgdXBwZXJJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkuYXBwZW5kKHBvbHksMCx1cHBlckluZGV4KzEpO1xuICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkudmVydGljZXMucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LnZlcnRpY2VzLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIC8vdXBwZXJQb2x5Lmluc2VydCh1cHBlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGxvd2VySW5kZXgsIHBvbHkuYmVnaW4oKSArIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LmFwcGVuZChwb2x5LGxvd2VySW5kZXgsaSsxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3QgdG8gdGhlIGNsb3Nlc3QgcG9pbnQgd2l0aGluIHRoZSB0cmlhbmdsZVxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJDYXNlIDI6IFZlcnRleChcIitpK1wiKSwgY2xvc2VzdEluZGV4KFwiK2Nsb3Nlc3RJbmRleCtcIiksIHBvbHkuc2l6ZShcIit0aGlzLnZlcnRpY2VzLmxlbmd0aCtcIilcXG5cIik7XG5cbiAgICAgICAgICAgICAgICBpZiAobG93ZXJJbmRleCA+IHVwcGVySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJJbmRleCArPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgICAgICAgICAgaWYodXBwZXJJbmRleCA8IGxvd2VySW5kZXgpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBsb3dlckluZGV4OyBqIDw9IHVwcGVySW5kZXg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoUG9pbnQubGVmdE9uKHBvbHkuYXQoaSAtIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGopKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIFBvaW50LnJpZ2h0T24ocG9seS5hdChpICsgMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gUG9pbnQuc3FkaXN0KHBvbHkuYXQoaSksIHBvbHkuYXQoaikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBjbG9zZXN0RGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSBqICUgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA8IGNsb3Nlc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkuYXBwZW5kKHBvbHksaSxjbG9zZXN0SW5kZXgrMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0SW5kZXggIT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkuYXBwZW5kKHBvbHksY2xvc2VzdEluZGV4LHYubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkuYXBwZW5kKHBvbHksMCxpKzEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LmFwcGVuZChwb2x5LGksdi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5hcHBlbmQocG9seSwwLGNsb3Nlc3RJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LmFwcGVuZChwb2x5LGNsb3Nlc3RJbmRleCxpKzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc29sdmUgc21hbGxlc3QgcG9seSBmaXJzdFxuICAgICAgICAgICAgaWYgKGxvd2VyUG9seS52ZXJ0aWNlcy5sZW5ndGggPCB1cHBlclBvbHkudmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbG93ZXJQb2x5LnF1aWNrRGVjb21wKHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgICAgICB1cHBlclBvbHkucXVpY2tEZWNvbXAocmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cHBlclBvbHkucXVpY2tEZWNvbXAocmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpO1xuICAgICAgICAgICAgICAgIGxvd2VyUG9seS5xdWlja0RlY29tcChyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnB1c2godGhpcyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZW1vdmUgY29sbGluZWFyIHBvaW50cyBpbiB0aGUgcG9seWdvbi5cbiAqIEBtZXRob2QgcmVtb3ZlQ29sbGluZWFyUG9pbnRzXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtwcmVjaXNpb25dIFRoZSB0aHJlc2hvbGQgYW5nbGUgdG8gdXNlIHdoZW4gZGV0ZXJtaW5pbmcgd2hldGhlciB0d28gZWRnZXMgYXJlIGNvbGxpbmVhci4gVXNlIHplcm8gZm9yIGZpbmVzdCBwcmVjaXNpb24uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICBUaGUgbnVtYmVyIG9mIHBvaW50cyByZW1vdmVkXG4gKi9cblBvbHlnb24ucHJvdG90eXBlLnJlbW92ZUNvbGxpbmVhclBvaW50cyA9IGZ1bmN0aW9uKHByZWNpc2lvbil7XG4gICAgdmFyIG51bSA9IDA7XG4gICAgZm9yKHZhciBpPXRoaXMudmVydGljZXMubGVuZ3RoLTE7IHRoaXMudmVydGljZXMubGVuZ3RoPjMgJiYgaT49MDsgLS1pKXtcbiAgICAgICAgaWYoUG9pbnQuY29sbGluZWFyKHRoaXMuYXQoaS0xKSx0aGlzLmF0KGkpLHRoaXMuYXQoaSsxKSxwcmVjaXNpb24pKXtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbWlkZGxlIHBvaW50XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnNwbGljZShpJXRoaXMudmVydGljZXMubGVuZ3RoLDEpO1xuICAgICAgICAgICAgaS0tOyAvLyBKdW1wIG9uZSBwb2ludCBmb3J3YXJkLiBPdGhlcndpc2Ugd2UgbWF5IGdldCBhIGNoYWluIHJlbW92YWxcbiAgICAgICAgICAgIG51bSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW07XG59O1xuXG59LHtcIi4vTGluZVwiOjEsXCIuL1BvaW50XCI6MixcIi4vU2NhbGFyXCI6NH1dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBTY2FsYXI7XG5cbi8qKlxuICogU2NhbGFyIGZ1bmN0aW9uc1xuICogQGNsYXNzIFNjYWxhclxuICovXG5mdW5jdGlvbiBTY2FsYXIoKXt9XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHNjYWxhcnMgYXJlIGVxdWFsXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGVxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSAge051bWJlcn0gYlxuICogQHBhcmFtICB7TnVtYmVyfSBbcHJlY2lzaW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuU2NhbGFyLmVxID0gZnVuY3Rpb24oYSxiLHByZWNpc2lvbil7XG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDA7XG4gICAgcmV0dXJuIE1hdGguYWJzKGEtYikgPCBwcmVjaXNpb247XG59O1xuXG59LHt9XSw1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFBvbHlnb24gOiBfZGVyZXFfKFwiLi9Qb2x5Z29uXCIpLFxuICAgIFBvaW50IDogX2RlcmVxXyhcIi4vUG9pbnRcIiksXG59O1xuXG59LHtcIi4vUG9pbnRcIjoyLFwiLi9Qb2x5Z29uXCI6M31dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJwMlwiLFxuICBcInZlcnNpb25cIjogXCIwLjYuMVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQSBKYXZhU2NyaXB0IDJEIHBoeXNpY3MgZW5naW5lLlwiLFxuICBcImF1dGhvclwiOiBcIlN0ZWZhbiBIZWRtYW4gPHNjaHRlcHBlQGdtYWlsLmNvbT4gKGh0dHA6Ly9zdGVmZmUuc2UpXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwicDIuanNcIixcbiAgICBcInAyXCIsXG4gICAgXCJwaHlzaWNzXCIsXG4gICAgXCJlbmdpbmVcIixcbiAgICBcIjJkXCJcbiAgXSxcbiAgXCJtYWluXCI6IFwiLi9zcmMvcDIuanNcIixcbiAgXCJlbmdpbmVzXCI6IHtcbiAgICBcIm5vZGVcIjogXCIqXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZS9wMi5qcy5naXRcIlxuICB9LFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL3AyLmpzL2lzc3Vlc1wiXG4gIH0sXG4gIFwibGljZW5zZXNcIjogW1xuICAgIHtcbiAgICAgIFwidHlwZVwiOiBcIk1JVFwiXG4gICAgfVxuICBdLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJncnVudFwiOiBcIn4wLjQuMFwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi1qc2hpbnRcIjogXCJ+MC45LjJcIixcbiAgICBcImdydW50LWNvbnRyaWItbm9kZXVuaXRcIjogXCJ+MC4xLjJcIixcbiAgICBcImdydW50LWNvbnRyaWItdWdsaWZ5XCI6IFwifjAuNC4wXCIsXG4gICAgXCJncnVudC1jb250cmliLXdhdGNoXCI6IFwifjAuNS4wXCIsXG4gICAgXCJncnVudC1icm93c2VyaWZ5XCI6IFwifjIuMC4xXCIsXG4gICAgXCJncnVudC1jb250cmliLWNvbmNhdFwiOiBcIl4wLjQuMFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcInBvbHktZGVjb21wXCI6IFwiMC4xLjBcIlxuICB9XG59XG5cbn0se31dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBQUJCO1xuXG4vKipcbiAqIEF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggY2xhc3MuXG4gKiBAY2xhc3MgQUFCQlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gIFtvcHRpb25zXVxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy51cHBlckJvdW5kXVxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb3dlckJvdW5kXVxuICovXG5mdW5jdGlvbiBBQUJCKG9wdGlvbnMpe1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHByb3BlcnR5IGxvd2VyQm91bmRcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb3dlckJvdW5kID0gdmVjMi5jcmVhdGUoKTtcbiAgICBpZihvcHRpb25zICYmIG9wdGlvbnMubG93ZXJCb3VuZCl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmxvd2VyQm91bmQsIG9wdGlvbnMubG93ZXJCb3VuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHVwcGVyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHByb3BlcnR5IHVwcGVyQm91bmRcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy51cHBlckJvdW5kID0gdmVjMi5jcmVhdGUoKTtcbiAgICBpZihvcHRpb25zICYmIG9wdGlvbnMudXBwZXJCb3VuZCl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLnVwcGVyQm91bmQsIG9wdGlvbnMudXBwZXJCb3VuZCk7XG4gICAgfVxufVxuXG52YXIgdG1wID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBTZXQgdGhlIEFBQkIgYm91bmRzIGZyb20gYSBzZXQgb2YgcG9pbnRzLlxuICogQG1ldGhvZCBzZXRGcm9tUG9pbnRzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgQW4gYXJyYXkgb2YgdmVjMidzLlxuICovXG5BQUJCLnByb3RvdHlwZS5zZXRGcm9tUG9pbnRzID0gZnVuY3Rpb24ocG9pbnRzLCBwb3NpdGlvbiwgYW5nbGUsIHNraW5TaXplKXtcbiAgICB2YXIgbCA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgdSA9IHRoaXMudXBwZXJCb3VuZDtcblxuICAgIGlmKHR5cGVvZihhbmdsZSkgIT09IFwibnVtYmVyXCIpe1xuICAgICAgICBhbmdsZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRvIHRoZSBmaXJzdCBwb2ludFxuICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgdmVjMi5yb3RhdGUobCwgcG9pbnRzWzBdLCBhbmdsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmVjMi5jb3B5KGwsIHBvaW50c1swXSk7XG4gICAgfVxuICAgIHZlYzIuY29weSh1LCBsKTtcblxuICAgIC8vIENvbXB1dGUgY29zaW5lcyBhbmQgc2luZXMganVzdCBvbmNlXG4gICAgdmFyIGNvc0FuZ2xlID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICBzaW5BbmdsZSA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBmb3IodmFyIGkgPSAxOyBpPHBvaW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBwID0gcG9pbnRzW2ldO1xuXG4gICAgICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgICAgIHZhciB4ID0gcFswXSxcbiAgICAgICAgICAgICAgICB5ID0gcFsxXTtcbiAgICAgICAgICAgIHRtcFswXSA9IGNvc0FuZ2xlICogeCAtc2luQW5nbGUgKiB5O1xuICAgICAgICAgICAgdG1wWzFdID0gc2luQW5nbGUgKiB4ICtjb3NBbmdsZSAqIHk7XG4gICAgICAgICAgICBwID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKHZhciBqPTA7IGo8MjsgaisrKXtcbiAgICAgICAgICAgIGlmKHBbal0gPiB1W2pdKXtcbiAgICAgICAgICAgICAgICB1W2pdID0gcFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHBbal0gPCBsW2pdKXtcbiAgICAgICAgICAgICAgICBsW2pdID0gcFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBvZmZzZXRcbiAgICBpZihwb3NpdGlvbil7XG4gICAgICAgIHZlYzIuYWRkKHRoaXMubG93ZXJCb3VuZCwgdGhpcy5sb3dlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgICAgIHZlYzIuYWRkKHRoaXMudXBwZXJCb3VuZCwgdGhpcy51cHBlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYoc2tpblNpemUpe1xuICAgICAgICB0aGlzLmxvd2VyQm91bmRbMF0gLT0gc2tpblNpemU7XG4gICAgICAgIHRoaXMubG93ZXJCb3VuZFsxXSAtPSBza2luU2l6ZTtcbiAgICAgICAgdGhpcy51cHBlckJvdW5kWzBdICs9IHNraW5TaXplO1xuICAgICAgICB0aGlzLnVwcGVyQm91bmRbMV0gKz0gc2tpblNpemU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb3B5IGJvdW5kcyBmcm9tIGFuIEFBQkIgdG8gdGhpcyBBQUJCXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqL1xuQUFCQi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIHZlYzIuY29weSh0aGlzLmxvd2VyQm91bmQsIGFhYmIubG93ZXJCb3VuZCk7XG4gICAgdmVjMi5jb3B5KHRoaXMudXBwZXJCb3VuZCwgYWFiYi51cHBlckJvdW5kKTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIHRoaXMgQUFCQiBzbyB0aGF0IGl0IGNvdmVycyB0aGUgZ2l2ZW4gQUFCQiB0b28uXG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICovXG5BQUJCLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbihhYWJiKXtcbiAgICAvLyBMb29wIG92ZXIgeCBhbmQgeVxuICAgIHZhciBpID0gMjtcbiAgICB3aGlsZShpLS0pe1xuICAgICAgICAvLyBFeHRlbmQgbG93ZXIgYm91bmRcbiAgICAgICAgdmFyIGwgPSBhYWJiLmxvd2VyQm91bmRbaV07XG4gICAgICAgIGlmKHRoaXMubG93ZXJCb3VuZFtpXSA+IGwpe1xuICAgICAgICAgICAgdGhpcy5sb3dlckJvdW5kW2ldID0gbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwcGVyXG4gICAgICAgIHZhciB1ID0gYWFiYi51cHBlckJvdW5kW2ldO1xuICAgICAgICBpZih0aGlzLnVwcGVyQm91bmRbaV0gPCB1KXtcbiAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZFtpXSA9IHU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gQUFCQiBvdmVybGFwcyB0aGlzIEFBQkIuXG4gKiBAbWV0aG9kIG92ZXJsYXBzXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5BQUJCLnByb3RvdHlwZS5vdmVybGFwcyA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIHZhciBsMSA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgdTEgPSB0aGlzLnVwcGVyQm91bmQsXG4gICAgICAgIGwyID0gYWFiYi5sb3dlckJvdW5kLFxuICAgICAgICB1MiA9IGFhYmIudXBwZXJCb3VuZDtcblxuICAgIC8vICAgICAgbDIgICAgICAgIHUyXG4gICAgLy8gICAgICB8LS0tLS0tLS0tfFxuICAgIC8vIHwtLS0tLS0tLXxcbiAgICAvLyBsMSAgICAgICB1MVxuXG4gICAgcmV0dXJuICgobDJbMF0gPD0gdTFbMF0gJiYgdTFbMF0gPD0gdTJbMF0pIHx8IChsMVswXSA8PSB1MlswXSAmJiB1MlswXSA8PSB1MVswXSkpICYmXG4gICAgICAgICAgICgobDJbMV0gPD0gdTFbMV0gJiYgdTFbMV0gPD0gdTJbMV0pIHx8IChsMVsxXSA8PSB1MlsxXSAmJiB1MlsxXSA8PSB1MVsxXSkpO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4uL3V0aWxzL1V0aWxzXCI6NTB9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG52YXIgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJyb2FkcGhhc2U7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYnJvYWRwaGFzZSBpbXBsZW1lbnRhdGlvbnMuXG4gKiBAY2xhc3MgQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJyb2FkcGhhc2UodHlwZSl7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdGluZyBvdmVybGFwcGluZyBwYWlycy4gV2lsbCBiZSBmaWxsZWQgd2l0aCByZXN1bHRzIGR1cmluZyAuZ2V0Q29sbGlzaW9uUGFpcnMoKS5cbiAgICAgKiBAcHJvcGVydHkgcmVzdWx0XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMucmVzdWx0ID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd29ybGQgdG8gc2VhcmNoIGZvciBjb2xsaXNpb24gcGFpcnMgaW4uIFRvIGNoYW5nZSBpdCwgdXNlIC5zZXRXb3JsZCgpXG4gICAgICogQHByb3BlcnR5IHdvcmxkXG4gICAgICogQHR5cGUge1dvcmxkfVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMud29ybGQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJvdW5kaW5nIHZvbHVtZSB0eXBlIHRvIHVzZSBpbiB0aGUgYnJvYWRwaGFzZSBhbGdvcml0aG1zLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBib3VuZGluZ1ZvbHVtZVR5cGVcbiAgICAgKi9cbiAgICB0aGlzLmJvdW5kaW5nVm9sdW1lVHlwZSA9IEJyb2FkcGhhc2UuQUFCQjtcbn1cblxuLyoqXG4gKiBBeGlzIGFsaWduZWQgYm91bmRpbmcgYm94IHR5cGUuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gQUFCQlxuICovXG5Ccm9hZHBoYXNlLkFBQkIgPSAxO1xuXG4vKipcbiAqIEJvdW5kaW5nIGNpcmNsZSB0eXBlLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IEJPVU5ESU5HX0NJUkNMRVxuICovXG5Ccm9hZHBoYXNlLkJPVU5ESU5HX0NJUkNMRSA9IDI7XG5cbi8qKlxuICogU2V0IHRoZSB3b3JsZCB0aGF0IHdlIGFyZSBzZWFyY2hpbmcgZm9yIGNvbGxpc2lvbiBwYWlycyBpblxuICogQG1ldGhvZCBzZXRXb3JsZFxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKi9cbkJyb2FkcGhhc2UucHJvdG90eXBlLnNldFdvcmxkID0gZnVuY3Rpb24od29ybGQpe1xuICAgIHRoaXMud29ybGQgPSB3b3JsZDtcbn07XG5cbi8qKlxuICogR2V0IGFsbCBwb3RlbnRpYWwgaW50ZXJzZWN0aW5nIGJvZHkgcGFpcnMuXG4gKiBAbWV0aG9kIGdldENvbGxpc2lvblBhaXJzXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGQgVGhlIHdvcmxkIHRvIHNlYXJjaCBpbi5cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiB0aGUgYm9kaWVzLCBvcmRlcmVkIGluIHBhaXJzLiBFeGFtcGxlOiBBIHJlc3VsdCBvZiBbYSxiLGMsZF0gbWVhbnMgdGhhdCB0aGUgcG90ZW50aWFsIHBhaXJzIGFyZTogKGEsYiksIChjLGQpLlxuICovXG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5nZXRDb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRDb2xsaXNpb25QYWlycyBtdXN0IGJlIGltcGxlbWVudGVkIGluIGEgc3ViY2xhc3MhXCIpO1xufTtcblxudmFyIGRpc3QgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0d28gYm9kaWVzIG92ZXJsYXAuXG4gKiBAbWV0aG9kICBib3VuZGluZ1JhZGl1c0NoZWNrXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkJyb2FkcGhhc2UuYm91bmRpbmdSYWRpdXNDaGVjayA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgdmVjMi5zdWIoZGlzdCwgYm9keUEucG9zaXRpb24sIGJvZHlCLnBvc2l0aW9uKTtcbiAgICB2YXIgZDIgPSB2ZWMyLnNxdWFyZWRMZW5ndGgoZGlzdCksXG4gICAgICAgIHIgPSBib2R5QS5ib3VuZGluZ1JhZGl1cyArIGJvZHlCLmJvdW5kaW5nUmFkaXVzO1xuICAgIHJldHVybiBkMiA8PSByKnI7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0d28gYm9kaWVzIG92ZXJsYXAuXG4gKiBAbWV0aG9kICBib3VuZGluZ1JhZGl1c0NoZWNrXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkJyb2FkcGhhc2UuYWFiYkNoZWNrID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKXtcbiAgICByZXR1cm4gYm9keUEuZ2V0QUFCQigpLm92ZXJsYXBzKGJvZHlCLmdldEFBQkIoKSk7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0d28gYm9kaWVzIG92ZXJsYXAuXG4gKiBAbWV0aG9kICBib3VuZGluZ1JhZGl1c0NoZWNrXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkJyb2FkcGhhc2UucHJvdG90eXBlLmJvdW5kaW5nVm9sdW1lQ2hlY2sgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpe1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBzd2l0Y2godGhpcy5ib3VuZGluZ1ZvbHVtZVR5cGUpe1xuICAgIGNhc2UgQnJvYWRwaGFzZS5CT1VORElOR19DSVJDTEU6XG4gICAgICAgIHJlc3VsdCA9ICBCcm9hZHBoYXNlLmJvdW5kaW5nUmFkaXVzQ2hlY2soYm9keUEsYm9keUIpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIEJyb2FkcGhhc2UuQUFCQjpcbiAgICAgICAgcmVzdWx0ID0gQnJvYWRwaGFzZS5hYWJiQ2hlY2soYm9keUEsYm9keUIpO1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kaW5nIHZvbHVtZSB0eXBlIG5vdCByZWNvZ25pemVkOiAnK3RoaXMuYm91bmRpbmdWb2x1bWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0d28gYm9kaWVzIGFyZSBhbGxvd2VkIHRvIGNvbGxpZGUgYXQgYWxsLlxuICogQG1ldGhvZCAgY2FuQ29sbGlkZVxuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Ccm9hZHBoYXNlLmNhbkNvbGxpZGUgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpe1xuXG4gICAgLy8gQ2Fubm90IGNvbGxpZGUgc3RhdGljIGJvZGllc1xuICAgIGlmKGJvZHlBLnR5cGUgPT09IEJvZHkuU1RBVElDICYmIGJvZHlCLnR5cGUgPT09IEJvZHkuU1RBVElDKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENhbm5vdCBjb2xsaWRlIHN0YXRpYyB2cyBraW5lbWF0aWMgYm9kaWVzXG4gICAgaWYoIChib2R5QS50eXBlID09PSBCb2R5LktJTkVNQVRJQyAmJiBib2R5Qi50eXBlID09PSBCb2R5LlNUQVRJQykgfHxcbiAgICAgICAgKGJvZHlBLnR5cGUgPT09IEJvZHkuU1RBVElDICAgICYmIGJvZHlCLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKSl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDYW5ub3QgY29sbGlkZSBraW5lbWF0aWMgdnMga2luZW1hdGljXG4gICAgaWYoYm9keUEudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMgJiYgYm9keUIudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2Fubm90IGNvbGxpZGUgYm90aCBzbGVlcGluZyBib2RpZXNcbiAgICBpZihib2R5QS5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HICYmIGJvZHlCLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2Fubm90IGNvbGxpZGUgaWYgb25lIGlzIHN0YXRpYyBhbmQgdGhlIG90aGVyIGlzIHNsZWVwaW5nXG4gICAgaWYoIChib2R5QS5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HICYmIGJvZHlCLnR5cGUgPT09IEJvZHkuU1RBVElDKSB8fFxuICAgICAgICAoYm9keUIuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyAmJiBib2R5QS50eXBlID09PSBCb2R5LlNUQVRJQykpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Ccm9hZHBoYXNlLk5BSVZFID0gMTtcbkJyb2FkcGhhc2UuU0FQID0gMjtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4uL29iamVjdHMvQm9keVwiOjMyfV0sOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgQ2lyY2xlID0gX2RlcmVxXygnLi4vc2hhcGVzL0NpcmNsZScpXG4sICAgUGxhbmUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvUGxhbmUnKVxuLCAgIFBhcnRpY2xlID0gX2RlcmVxXygnLi4vc2hhcGVzL1BhcnRpY2xlJylcbiwgICBCcm9hZHBoYXNlID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2UnKVxuLCAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmlkQnJvYWRwaGFzZTtcblxuLyoqXG4gKiBCcm9hZHBoYXNlIHRoYXQgdXNlcyBheGlzLWFsaWduZWQgYmlucy5cbiAqIEBjbGFzcyBHcmlkQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMueG1pbl0gICBMb3dlciB4IGJvdW5kIG9mIHRoZSBncmlkXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMueG1heF0gICBVcHBlciB4IGJvdW5kXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMueW1pbl0gICBMb3dlciB5IGJvdW5kXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMueW1heF0gICBVcHBlciB5IGJvdW5kXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubnhdICAgICBOdW1iZXIgb2YgYmlucyBhbG9uZyB4IGF4aXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5ueV0gICAgIE51bWJlciBvZiBiaW5zIGFsb25nIHkgYXhpc1xuICogQHRvZG8gU2hvdWxkIGhhdmUgYW4gb3B0aW9uIGZvciBkeW5hbWljIHNjZW5lIHNpemVcbiAqL1xuZnVuY3Rpb24gR3JpZEJyb2FkcGhhc2Uob3B0aW9ucyl7XG4gICAgQnJvYWRwaGFzZS5hcHBseSh0aGlzKTtcblxuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLHtcbiAgICAgICAgeG1pbjogICAtMTAwLFxuICAgICAgICB4bWF4OiAgIDEwMCxcbiAgICAgICAgeW1pbjogICAtMTAwLFxuICAgICAgICB5bWF4OiAgIDEwMCxcbiAgICAgICAgbng6ICAgICAxMCxcbiAgICAgICAgbnk6ICAgICAxMFxuICAgIH0pO1xuXG4gICAgdGhpcy54bWluID0gb3B0aW9ucy54bWluO1xuICAgIHRoaXMueW1pbiA9IG9wdGlvbnMueW1pbjtcbiAgICB0aGlzLnhtYXggPSBvcHRpb25zLnhtYXg7XG4gICAgdGhpcy55bWF4ID0gb3B0aW9ucy55bWF4O1xuICAgIHRoaXMubnggPSBvcHRpb25zLm54O1xuICAgIHRoaXMubnkgPSBvcHRpb25zLm55O1xuXG4gICAgdGhpcy5iaW5zaXplWCA9ICh0aGlzLnhtYXgtdGhpcy54bWluKSAvIHRoaXMubng7XG4gICAgdGhpcy5iaW5zaXplWSA9ICh0aGlzLnltYXgtdGhpcy55bWluKSAvIHRoaXMubnk7XG59XG5HcmlkQnJvYWRwaGFzZS5wcm90b3R5cGUgPSBuZXcgQnJvYWRwaGFzZSgpO1xuR3JpZEJyb2FkcGhhc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR3JpZEJyb2FkcGhhc2U7XG5cbi8qKlxuICogR2V0IGNvbGxpc2lvbiBwYWlycy5cbiAqIEBtZXRob2QgZ2V0Q29sbGlzaW9uUGFpcnNcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbkdyaWRCcm9hZHBoYXNlLnByb3RvdHlwZS5nZXRDb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIGJvZGllcyA9IHdvcmxkLmJvZGllcyxcbiAgICAgICAgTmNvbGxpZGluZyA9IGJvZGllcy5sZW5ndGgsXG4gICAgICAgIGJpbnNpemVYID0gdGhpcy5iaW5zaXplWCxcbiAgICAgICAgYmluc2l6ZVkgPSB0aGlzLmJpbnNpemVZLFxuICAgICAgICBueCA9IHRoaXMubngsXG4gICAgICAgIG55ID0gdGhpcy5ueSxcbiAgICAgICAgeG1pbiA9IHRoaXMueG1pbixcbiAgICAgICAgeW1pbiA9IHRoaXMueW1pbixcbiAgICAgICAgeG1heCA9IHRoaXMueG1heCxcbiAgICAgICAgeW1heCA9IHRoaXMueW1heDtcblxuICAgIC8vIFRvZG86IG1ha2UgZ2FyYmFnZSBmcmVlXG4gICAgdmFyIGJpbnM9W10sIE5iaW5zPW54Km55O1xuICAgIGZvcih2YXIgaT0wOyBpPE5iaW5zOyBpKyspe1xuICAgICAgICBiaW5zLnB1c2goW10pO1xuICAgIH1cblxuICAgIHZhciB4bXVsdCA9IG54IC8gKHhtYXgteG1pbik7XG4gICAgdmFyIHltdWx0ID0gbnkgLyAoeW1heC15bWluKTtcblxuICAgIC8vIFB1dCBhbGwgYm9kaWVzIGludG8gYmluc1xuICAgIGZvcih2YXIgaT0wOyBpIT09TmNvbGxpZGluZzsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuICAgICAgICB2YXIgYWFiYiA9IGJpLmFhYmI7XG4gICAgICAgIHZhciBsb3dlclggPSBNYXRoLm1heChhYWJiLmxvd2VyQm91bmRbMF0sIHhtaW4pO1xuICAgICAgICB2YXIgbG93ZXJZID0gTWF0aC5tYXgoYWFiYi5sb3dlckJvdW5kWzFdLCB5bWluKTtcbiAgICAgICAgdmFyIHVwcGVyWCA9IE1hdGgubWluKGFhYmIudXBwZXJCb3VuZFswXSwgeG1heCk7XG4gICAgICAgIHZhciB1cHBlclkgPSBNYXRoLm1pbihhYWJiLnVwcGVyQm91bmRbMV0sIHltYXgpO1xuICAgICAgICB2YXIgeGkxID0gTWF0aC5mbG9vcih4bXVsdCAqIChsb3dlclggLSB4bWluKSk7XG4gICAgICAgIHZhciB5aTEgPSBNYXRoLmZsb29yKHltdWx0ICogKGxvd2VyWSAtIHltaW4pKTtcbiAgICAgICAgdmFyIHhpMiA9IE1hdGguZmxvb3IoeG11bHQgKiAodXBwZXJYIC0geG1pbikpO1xuICAgICAgICB2YXIgeWkyID0gTWF0aC5mbG9vcih5bXVsdCAqICh1cHBlclkgLSB5bWluKSk7XG5cbiAgICAgICAgLy8gUHV0IGluIGJpblxuICAgICAgICBmb3IodmFyIGo9eGkxOyBqPD14aTI7IGorKyl7XG4gICAgICAgICAgICBmb3IodmFyIGs9eWkxOyBrPD15aTI7IGsrKyl7XG4gICAgICAgICAgICAgICAgdmFyIHhpID0gajtcbiAgICAgICAgICAgICAgICB2YXIgeWkgPSBrO1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSB4aSoobnktMSkgKyB5aTtcbiAgICAgICAgICAgICAgICBpZihpZHggPj0gMCAmJiBpZHggPCBOYmlucyl7XG4gICAgICAgICAgICAgICAgICAgIGJpbnNbIGlkeCBdLnB1c2goYmkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGVhY2ggYmluXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OYmluczsgaSsrKXtcbiAgICAgICAgdmFyIGJpbiA9IGJpbnNbaV07XG5cbiAgICAgICAgZm9yKHZhciBqPTAsIE5ib2RpZXNJbkJpbj1iaW4ubGVuZ3RoOyBqIT09TmJvZGllc0luQmluOyBqKyspe1xuICAgICAgICAgICAgdmFyIGJpID0gYmluW2pdO1xuICAgICAgICAgICAgZm9yKHZhciBrPTA7IGshPT1qOyBrKyspe1xuICAgICAgICAgICAgICAgIHZhciBiaiA9IGJpbltrXTtcbiAgICAgICAgICAgICAgICBpZihCcm9hZHBoYXNlLmNhbkNvbGxpZGUoYmksYmopICYmIHRoaXMuYm91bmRpbmdWb2x1bWVDaGVjayhiaSxiaikpe1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiaSxiaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG59LHtcIi4uL2NvbGxpc2lvbi9Ccm9hZHBoYXNlXCI6OCxcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vc2hhcGVzL0NpcmNsZVwiOjM4LFwiLi4vc2hhcGVzL1BhcnRpY2xlXCI6NDIsXCIuLi9zaGFwZXMvUGxhbmVcIjo0MyxcIi4uL3V0aWxzL1V0aWxzXCI6NTB9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgQ2lyY2xlID0gX2RlcmVxXygnLi4vc2hhcGVzL0NpcmNsZScpLFxuICAgIFBsYW5lID0gX2RlcmVxXygnLi4vc2hhcGVzL1BsYW5lJyksXG4gICAgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKSxcbiAgICBQYXJ0aWNsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9QYXJ0aWNsZScpLFxuICAgIEJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpLFxuICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOYWl2ZUJyb2FkcGhhc2U7XG5cbi8qKlxuICogTmFpdmUgYnJvYWRwaGFzZSBpbXBsZW1lbnRhdGlvbi4gRG9lcyBOXjIgdGVzdHMuXG4gKlxuICogQGNsYXNzIE5haXZlQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXG4gKi9cbmZ1bmN0aW9uIE5haXZlQnJvYWRwaGFzZSgpe1xuICAgIEJyb2FkcGhhc2UuY2FsbCh0aGlzLCBCcm9hZHBoYXNlLk5BSVZFKTtcbn1cbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUgPSBuZXcgQnJvYWRwaGFzZSgpO1xuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5haXZlQnJvYWRwaGFzZTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvbGxpZGluZyBwYWlyc1xuICogQG1ldGhvZCBnZXRDb2xsaXNpb25QYWlyc1xuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZS5nZXRDb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB2YXIgYm9kaWVzID0gd29ybGQuYm9kaWVzLFxuICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdDtcblxuICAgIHJlc3VsdC5sZW5ndGggPSAwO1xuXG4gICAgZm9yKHZhciBpPTAsIE5jb2xsaWRpbmc9Ym9kaWVzLmxlbmd0aDsgaSE9PU5jb2xsaWRpbmc7IGkrKyl7XG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcblxuICAgICAgICBmb3IodmFyIGo9MDsgajxpOyBqKyspe1xuICAgICAgICAgICAgdmFyIGJqID0gYm9kaWVzW2pdO1xuXG4gICAgICAgICAgICBpZihCcm9hZHBoYXNlLmNhbkNvbGxpZGUoYmksYmopICYmIHRoaXMuYm91bmRpbmdWb2x1bWVDaGVjayhiaSxiaikpe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJpLGJqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIHRoZSBib2RpZXMgd2l0aGluIGFuIEFBQkIuXG4gKiBAbWV0aG9kIGFhYmJRdWVyeVxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcGFyYW0ge2FycmF5fSByZXN1bHQgQW4gYXJyYXkgdG8gc3RvcmUgcmVzdWx0aW5nIGJvZGllcyBpbi5cbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5OYWl2ZUJyb2FkcGhhc2UucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uKHdvcmxkLCBhYWJiLCByZXN1bHQpe1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcblxuICAgIHZhciBib2RpZXMgPSB3b3JsZC5ib2RpZXM7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuXG4gICAgICAgIGlmKGIuYWFiYk5lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgIGIudXBkYXRlQUFCQigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYi5hYWJiLm92ZXJsYXBzKGFhYmIpKXtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG59LHtcIi4uL2NvbGxpc2lvbi9Ccm9hZHBoYXNlXCI6OCxcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vc2hhcGVzL0NpcmNsZVwiOjM4LFwiLi4vc2hhcGVzL1BhcnRpY2xlXCI6NDIsXCIuLi9zaGFwZXMvUGxhbmVcIjo0MyxcIi4uL3NoYXBlcy9TaGFwZVwiOjQ1fV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIHN1YiA9IHZlYzIuc3ViXG4sICAgYWRkID0gdmVjMi5hZGRcbiwgICBkb3QgPSB2ZWMyLmRvdFxuLCAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKVxuLCAgIFR1cGxlRGljdGlvbmFyeSA9IF9kZXJlcV8oJy4uL3V0aWxzL1R1cGxlRGljdGlvbmFyeScpXG4sICAgRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvRXF1YXRpb24nKVxuLCAgIENvbnRhY3RFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKVxuLCAgIEZyaWN0aW9uRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvbicpXG4sICAgQ2lyY2xlID0gX2RlcmVxXygnLi4vc2hhcGVzL0NpcmNsZScpXG4sICAgQ29udmV4ID0gX2RlcmVxXygnLi4vc2hhcGVzL0NvbnZleCcpXG4sICAgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKVxuLCAgIEJvZHkgPSBfZGVyZXFfKCcuLi9vYmplY3RzL0JvZHknKVxuLCAgIFJlY3RhbmdsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9SZWN0YW5nbGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOYXJyb3dwaGFzZTtcblxuLy8gVGVtcCB0aGluZ3NcbnZhciB5QXhpcyA9IHZlYzIuZnJvbVZhbHVlcygwLDEpO1xuXG52YXIgdG1wMSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMiA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMyA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wNCA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wNSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wNiA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wNyA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wOCA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wOSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTAgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDExID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxMiA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDE0ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxNSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTYgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDE3ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxOCA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wQXJyYXkgPSBbXTtcblxuLyoqXG4gKiBOYXJyb3dwaGFzZS4gQ3JlYXRlcyBjb250YWN0cyBhbmQgZnJpY3Rpb24gZ2l2ZW4gc2hhcGVzIGFuZCB0cmFuc2Zvcm1zLlxuICogQGNsYXNzIE5hcnJvd3BoYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTmFycm93cGhhc2UoKXtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0RXF1YXRpb25zXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uRXF1YXRpb25zXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gbWFrZSBmcmljdGlvbiBlcXVhdGlvbnMgaW4gdGhlIHVwY29taW5nIGNvbnRhY3RzLlxuICAgICAqIEBwcm9wZXJ0eSBlbmFibGVGcmljdGlvblxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBtYWtlIGVxdWF0aW9ucyBlbmFibGVkIGluIHVwY29taW5nIGNvbnRhY3RzLlxuICAgICAqIEBwcm9wZXJ0eSBlbmFibGVkRXF1YXRpb25zXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5lbmFibGVkRXF1YXRpb25zID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmljdGlvbiBzbGlwIGZvcmNlIHRvIHVzZSB3aGVuIGNyZWF0aW5nIGZyaWN0aW9uIGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkgc2xpcEZvcmNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNsaXBGb3JjZSA9IDEwLjA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJpY3Rpb24gdmFsdWUgdG8gdXNlIGluIHRoZSB1cGNvbWluZyBmcmljdGlvbiBlcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uQ29lZmZpY2llbnRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25Db2VmZmljaWVudCA9IDAuMztcblxuICAgIC8qKlxuICAgICAqIFdpbGwgYmUgdGhlIC5yZWxhdGl2ZVZlbG9jaXR5IGluIGVhY2ggcHJvZHVjZWQgRnJpY3Rpb25FcXVhdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc3VyZmFjZVZlbG9jaXR5XG4gICAgICovXG4gICAgdGhpcy5zdXJmYWNlVmVsb2NpdHkgPSAwO1xuXG4gICAgdGhpcy5yZXVzZU9iamVjdHMgPSB0cnVlO1xuICAgIHRoaXMucmV1c2FibGVDb250YWN0RXF1YXRpb25zID0gW107XG4gICAgdGhpcy5yZXVzYWJsZUZyaWN0aW9uRXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdGl0dXRpb24gdmFsdWUgdG8gdXNlIGluIHRoZSBuZXh0IGNvbnRhY3QgZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSByZXN0aXR1dGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXN0aXR1dGlvbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RpZmZuZXNzIHZhbHVlIHRvIHVzZSBpbiB0aGUgbmV4dCBjb250YWN0IGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc3RpZmZuZXNzXG4gICAgICovXG4gICAgdGhpcy5zdGlmZm5lc3MgPSBFcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTUztcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGlmZm5lc3MgdmFsdWUgdG8gdXNlIGluIHRoZSBuZXh0IGNvbnRhY3QgZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzdGlmZm5lc3NcbiAgICAgKi9cbiAgICB0aGlzLnJlbGF4YXRpb24gPSBFcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT047XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RpZmZuZXNzIHZhbHVlIHRvIHVzZSBpbiB0aGUgbmV4dCBmcmljdGlvbiBlcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uU3RpZmZuZXNzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uU3RpZmZuZXNzID0gRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1M7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVsYXhhdGlvbiB2YWx1ZSB0byB1c2UgaW4gdGhlIG5leHQgZnJpY3Rpb24gZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblJlbGF4YXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25SZWxheGF0aW9uID0gRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OO1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHJlZHVjdGlvbiBvZiBmcmljdGlvbiBlcXVhdGlvbnMuIElmIGRpc2FibGVkLCBhIGJveCBvbiBhIHBsYW5lIHdpbGwgZ2VuZXJhdGUgMiBjb250YWN0IGVxdWF0aW9ucyBhbmQgMiBmcmljdGlvbiBlcXVhdGlvbnMuIElmIGVuYWJsZWQsIHRoZXJlIHdpbGwgYmUgb25seSBvbmUgZnJpY3Rpb24gZXF1YXRpb24uIFNhbWUga2luZCBvZiBzaW1wbGlmaWNhdGlvbnMgYXJlIG1hZGUgIGZvciBhbGwgY29sbGlzaW9uIHR5cGVzLlxuICAgICAqIEBwcm9wZXJ0eSBlbmFibGVGcmljdGlvblJlZHVjdGlvblxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgZmxhZyB3aWxsIGJlIHJlbW92ZWQgd2hlbiB0aGUgZmVhdHVyZSBpcyBzdGFibGUgZW5vdWdoLlxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjb2xsaWRpbmcgYm9kaWVzIGxhc3Qgc3RlcC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaWRpbmdCb2RpZXNMYXN0U3RlcFxuICAgICAqIEB0eXBlIHtUdXBsZURpY3Rpb25hcnl9XG4gICAgICovXG4gICAgdGhpcy5jb2xsaWRpbmdCb2RpZXNMYXN0U3RlcCA9IG5ldyBUdXBsZURpY3Rpb25hcnkoKTtcblxuICAgIC8qKlxuICAgICAqIENvbnRhY3Qgc2tpbiBzaXplIHZhbHVlIHRvIHVzZSBpbiB0aGUgbmV4dCBjb250YWN0IGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY29udGFjdFNraW5TaXplXG4gICAgICogQGRlZmF1bHQgMC4wMVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdFNraW5TaXplID0gMC4wMTtcbn1cblxudmFyIGJvZGllc092ZXJsYXBfc2hhcGVQb3NpdGlvbkEgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGJvZGllc092ZXJsYXBfc2hhcGVQb3NpdGlvbkIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgYm9kaWVzT3ZlcmxhcFxuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuYm9kaWVzT3ZlcmxhcCA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgdmFyIHNoYXBlUG9zaXRpb25BID0gYm9kaWVzT3ZlcmxhcF9zaGFwZVBvc2l0aW9uQTtcbiAgICB2YXIgc2hhcGVQb3NpdGlvbkIgPSBib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25CO1xuXG4gICAgLy8gTG9vcCBvdmVyIGFsbCBzaGFwZXMgb2YgYm9keUFcbiAgICBmb3IodmFyIGs9MCwgTnNoYXBlc2k9Ym9keUEuc2hhcGVzLmxlbmd0aDsgayE9PU5zaGFwZXNpOyBrKyspe1xuICAgICAgICB2YXIgc2hhcGVBID0gYm9keUEuc2hhcGVzW2tdLFxuICAgICAgICAgICAgcG9zaXRpb25BID0gYm9keUEuc2hhcGVPZmZzZXRzW2tdLFxuICAgICAgICAgICAgYW5nbGVBID0gYm9keUEuc2hhcGVBbmdsZXNba107XG5cbiAgICAgICAgYm9keUEudG9Xb3JsZEZyYW1lKHNoYXBlUG9zaXRpb25BLCBwb3NpdGlvbkEpO1xuXG4gICAgICAgIC8vIEFsbCBzaGFwZXMgb2YgYm9keSBqXG4gICAgICAgIGZvcih2YXIgbD0wLCBOc2hhcGVzaj1ib2R5Qi5zaGFwZXMubGVuZ3RoOyBsIT09TnNoYXBlc2o7IGwrKyl7XG4gICAgICAgICAgICB2YXIgc2hhcGVCID0gYm9keUIuc2hhcGVzW2xdLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uQiA9IGJvZHlCLnNoYXBlT2Zmc2V0c1tsXSxcbiAgICAgICAgICAgICAgICBhbmdsZUIgPSBib2R5Qi5zaGFwZUFuZ2xlc1tsXTtcblxuICAgICAgICAgICAgYm9keUIudG9Xb3JsZEZyYW1lKHNoYXBlUG9zaXRpb25CLCBwb3NpdGlvbkIpO1xuXG4gICAgICAgICAgICBpZih0aGlzW3NoYXBlQS50eXBlIHwgc2hhcGVCLnR5cGVdKFxuICAgICAgICAgICAgICAgIGJvZHlBLFxuICAgICAgICAgICAgICAgIHNoYXBlQSxcbiAgICAgICAgICAgICAgICBzaGFwZVBvc2l0aW9uQSxcbiAgICAgICAgICAgICAgICBzaGFwZUEuYW5nbGUgKyBib2R5QS5hbmdsZSxcbiAgICAgICAgICAgICAgICBib2R5QixcbiAgICAgICAgICAgICAgICBzaGFwZUIsXG4gICAgICAgICAgICAgICAgc2hhcGVQb3NpdGlvbkIsXG4gICAgICAgICAgICAgICAgc2hhcGVCLmFuZ2xlICsgYm9keUIuYW5nbGUsXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBib2RpZXMgd2VyZSBpbiBjb250YWN0IHNpbmNlIHRoZSBsYXN0IHJlc2V0KCkuXG4gKiBAbWV0aG9kIGNvbGxpZGVkTGFzdFN0ZXBcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbGxpZGVkTGFzdFN0ZXAgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpe1xuICAgIHZhciBpZDEgPSBib2R5QS5pZHwwLFxuICAgICAgICBpZDIgPSBib2R5Qi5pZHwwO1xuICAgIHJldHVybiAhIXRoaXMuY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXAuZ2V0KGlkMSwgaWQyKTtcbn07XG5cbi8qKlxuICogVGhyb3dzIGF3YXkgdGhlIG9sZCBlcXVhdGlvbnMgYW5kIGdldHMgcmVhZHkgdG8gY3JlYXRlIG5ld1xuICogQG1ldGhvZCByZXNldFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXAucmVzZXQoKTtcblxuICAgIHZhciBlcXMgPSB0aGlzLmNvbnRhY3RFcXVhdGlvbnM7XG4gICAgdmFyIGwgPSBlcXMubGVuZ3RoO1xuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIHZhciBlcSA9IGVxc1tsXSxcbiAgICAgICAgICAgIGlkMSA9IGVxLmJvZHlBLmlkLFxuICAgICAgICAgICAgaWQyID0gZXEuYm9keUIuaWQ7XG4gICAgICAgIHRoaXMuY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXAuc2V0KGlkMSwgaWQyLCB0cnVlKTtcbiAgICB9XG5cbiAgICBpZih0aGlzLnJldXNlT2JqZWN0cyl7XG4gICAgICAgIHZhciBjZSA9IHRoaXMuY29udGFjdEVxdWF0aW9ucyxcbiAgICAgICAgICAgIGZlID0gdGhpcy5mcmljdGlvbkVxdWF0aW9ucyxcbiAgICAgICAgICAgIHJmZSA9IHRoaXMucmV1c2FibGVGcmljdGlvbkVxdWF0aW9ucyxcbiAgICAgICAgICAgIHJjZSA9IHRoaXMucmV1c2FibGVDb250YWN0RXF1YXRpb25zO1xuICAgICAgICBVdGlscy5hcHBlbmRBcnJheShyY2UsY2UpO1xuICAgICAgICBVdGlscy5hcHBlbmRBcnJheShyZmUsZmUpO1xuICAgIH1cblxuICAgIC8vIFJlc2V0XG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25zLmxlbmd0aCA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIENvbnRhY3RFcXVhdGlvbiwgZWl0aGVyIGJ5IHJldXNpbmcgYW4gZXhpc3Rpbmcgb2JqZWN0IG9yIGNyZWF0aW5nIGEgbmV3IG9uZS5cbiAqIEBtZXRob2QgY3JlYXRlQ29udGFjdEVxdWF0aW9uXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge0NvbnRhY3RFcXVhdGlvbn1cbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbiA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qiwgc2hhcGVBLCBzaGFwZUIpe1xuICAgIHZhciBjID0gdGhpcy5yZXVzYWJsZUNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoID8gdGhpcy5yZXVzYWJsZUNvbnRhY3RFcXVhdGlvbnMucG9wKCkgOiBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcbiAgICBjLmJvZHlBID0gYm9keUE7XG4gICAgYy5ib2R5QiA9IGJvZHlCO1xuICAgIGMuc2hhcGVBID0gc2hhcGVBO1xuICAgIGMuc2hhcGVCID0gc2hhcGVCO1xuICAgIGMucmVzdGl0dXRpb24gPSB0aGlzLnJlc3RpdHV0aW9uO1xuICAgIGMuZmlyc3RJbXBhY3QgPSAhdGhpcy5jb2xsaWRlZExhc3RTdGVwKGJvZHlBLGJvZHlCKTtcbiAgICBjLnN0aWZmbmVzcyA9IHRoaXMuc3RpZmZuZXNzO1xuICAgIGMucmVsYXhhdGlvbiA9IHRoaXMucmVsYXhhdGlvbjtcbiAgICBjLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBjLmVuYWJsZWQgPSB0aGlzLmVuYWJsZWRFcXVhdGlvbnM7XG4gICAgYy5vZmZzZXQgPSB0aGlzLmNvbnRhY3RTa2luU2l6ZTtcblxuICAgIHJldHVybiBjO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgRnJpY3Rpb25FcXVhdGlvbiwgZWl0aGVyIGJ5IHJldXNpbmcgYW4gZXhpc3Rpbmcgb2JqZWN0IG9yIGNyZWF0aW5nIGEgbmV3IG9uZS5cbiAqIEBtZXRob2QgY3JlYXRlRnJpY3Rpb25FcXVhdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtGcmljdGlvbkVxdWF0aW9ufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbiA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qiwgc2hhcGVBLCBzaGFwZUIpe1xuICAgIHZhciBjID0gdGhpcy5yZXVzYWJsZUZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCA/IHRoaXMucmV1c2FibGVGcmljdGlvbkVxdWF0aW9ucy5wb3AoKSA6IG5ldyBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcbiAgICBjLmJvZHlBID0gYm9keUE7XG4gICAgYy5ib2R5QiA9IGJvZHlCO1xuICAgIGMuc2hhcGVBID0gc2hhcGVBO1xuICAgIGMuc2hhcGVCID0gc2hhcGVCO1xuICAgIGMuc2V0U2xpcEZvcmNlKHRoaXMuc2xpcEZvcmNlKTtcbiAgICBjLmZyaWN0aW9uQ29lZmZpY2llbnQgPSB0aGlzLmZyaWN0aW9uQ29lZmZpY2llbnQ7XG4gICAgYy5yZWxhdGl2ZVZlbG9jaXR5ID0gdGhpcy5zdXJmYWNlVmVsb2NpdHk7XG4gICAgYy5lbmFibGVkID0gdGhpcy5lbmFibGVkRXF1YXRpb25zO1xuICAgIGMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIGMuc3RpZmZuZXNzID0gdGhpcy5mcmljdGlvblN0aWZmbmVzcztcbiAgICBjLnJlbGF4YXRpb24gPSB0aGlzLmZyaWN0aW9uUmVsYXhhdGlvbjtcbiAgICBjLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gYztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIEZyaWN0aW9uRXF1YXRpb24gZ2l2ZW4gdGhlIGRhdGEgaW4gdGhlIENvbnRhY3RFcXVhdGlvbi4gVXNlcyBzYW1lIG9mZnNldCB2ZWN0b3JzIHJpIGFuZCByaiwgYnV0IHRoZSB0YW5nZW50IHZlY3RvciB3aWxsIGJlIGNvbnN0cnVjdGVkIGZyb20gdGhlIGNvbGxpc2lvbiBub3JtYWwuXG4gKiBAbWV0aG9kIGNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3RcbiAqIEBwYXJhbSAge0NvbnRhY3RFcXVhdGlvbn0gY29udGFjdEVxdWF0aW9uXG4gKiBAcmV0dXJuIHtGcmljdGlvbkVxdWF0aW9ufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdCA9IGZ1bmN0aW9uKGMpe1xuICAgIHZhciBlcSA9IHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbihjLmJvZHlBLCBjLmJvZHlCLCBjLnNoYXBlQSwgYy5zaGFwZUIpO1xuICAgIHZlYzIuY29weShlcS5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEpO1xuICAgIHZlYzIuY29weShlcS5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIpO1xuICAgIHZlYzIucm90YXRlOTBjdyhlcS50LCBjLm5vcm1hbEEpO1xuICAgIGVxLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcbiAgICByZXR1cm4gZXE7XG59O1xuXG4vLyBUYWtlIHRoZSBhdmVyYWdlIE4gbGF0ZXN0IGNvbnRhY3QgcG9pbnQgb24gdGhlIHBsYW5lLlxuTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UgPSBmdW5jdGlvbihudW1Db250YWN0cyl7XG4gICAgdmFyIGMgPSB0aGlzLmNvbnRhY3RFcXVhdGlvbnNbdGhpcy5jb250YWN0RXF1YXRpb25zLmxlbmd0aCAtIDFdO1xuICAgIHZhciBlcSA9IHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbihjLmJvZHlBLCBjLmJvZHlCLCBjLnNoYXBlQSwgYy5zaGFwZUIpO1xuICAgIHZhciBib2R5QSA9IGMuYm9keUE7XG4gICAgdmFyIGJvZHlCID0gYy5ib2R5QjtcbiAgICB2ZWMyLnNldChlcS5jb250YWN0UG9pbnRBLCAwLCAwKTtcbiAgICB2ZWMyLnNldChlcS5jb250YWN0UG9pbnRCLCAwLCAwKTtcbiAgICB2ZWMyLnNldChlcS50LCAwLCAwKTtcbiAgICBmb3IodmFyIGk9MDsgaSE9PW51bUNvbnRhY3RzOyBpKyspe1xuICAgICAgICBjID0gdGhpcy5jb250YWN0RXF1YXRpb25zW3RoaXMuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggLSAxIC0gaV07XG4gICAgICAgIGlmKGMuYm9keUEgPT09IGJvZHlBKXtcbiAgICAgICAgICAgIHZlYzIuYWRkKGVxLnQsIGVxLnQsIGMubm9ybWFsQSk7XG4gICAgICAgICAgICB2ZWMyLmFkZChlcS5jb250YWN0UG9pbnRBLCBlcS5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEpO1xuICAgICAgICAgICAgdmVjMi5hZGQoZXEuY29udGFjdFBvaW50QiwgZXEuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlYzIuc3ViKGVxLnQsIGVxLnQsIGMubm9ybWFsQSk7XG4gICAgICAgICAgICB2ZWMyLmFkZChlcS5jb250YWN0UG9pbnRBLCBlcS5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEIpO1xuICAgICAgICAgICAgdmVjMi5hZGQoZXEuY29udGFjdFBvaW50QiwgZXEuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRBKTtcbiAgICAgICAgfVxuICAgICAgICBlcS5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG4gICAgfVxuXG4gICAgdmFyIGludk51bUNvbnRhY3RzID0gMS9udW1Db250YWN0cztcbiAgICB2ZWMyLnNjYWxlKGVxLmNvbnRhY3RQb2ludEEsIGVxLmNvbnRhY3RQb2ludEEsIGludk51bUNvbnRhY3RzKTtcbiAgICB2ZWMyLnNjYWxlKGVxLmNvbnRhY3RQb2ludEIsIGVxLmNvbnRhY3RQb2ludEIsIGludk51bUNvbnRhY3RzKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZShlcS50LCBlcS50KTtcbiAgICB2ZWMyLnJvdGF0ZTkwY3coZXEudCwgZXEudCk7XG4gICAgcmV0dXJuIGVxO1xufTtcblxuLyoqXG4gKiBDb252ZXgvbGluZSBuYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjb252ZXhMaW5lXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBjb252ZXhCb2R5XG4gKiBAcGFyYW0gIHtDb252ZXh9ICAgICBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgY29udmV4T2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBjb252ZXhBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgbGluZUJvZHlcbiAqIEBwYXJhbSAge0xpbmV9ICAgICAgIGxpbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgbGluZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgbGluZUFuZ2xlXG4gKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBqdXN0VGVzdFxuICogQHRvZG8gSW1wbGVtZW50IG1lIVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuTElORSB8IFNoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleExpbmUgPSBmdW5jdGlvbihcbiAgICBjb252ZXhCb2R5LFxuICAgIGNvbnZleFNoYXBlLFxuICAgIGNvbnZleE9mZnNldCxcbiAgICBjb252ZXhBbmdsZSxcbiAgICBsaW5lQm9keSxcbiAgICBsaW5lU2hhcGUsXG4gICAgbGluZU9mZnNldCxcbiAgICBsaW5lQW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgLy8gVE9ET1xuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGluZS9yZWN0YW5nbGUgbmFycm93cGhhc2VcbiAqIEBtZXRob2QgbGluZVJlY3RhbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgbGluZUJvZHlcbiAqIEBwYXJhbSAge0xpbmV9ICAgICAgIGxpbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgbGluZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgbGluZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICByZWN0YW5nbGVCb2R5XG4gKiBAcGFyYW0gIHtSZWN0YW5nbGV9ICByZWN0YW5nbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcmVjdGFuZ2xlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICByZWN0YW5nbGVBbmdsZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gICAganVzdFRlc3RcbiAqIEB0b2RvIEltcGxlbWVudCBtZSFcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkxJTkUgfCBTaGFwZS5SRUNUQU5HTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5saW5lUmVjdGFuZ2xlID0gZnVuY3Rpb24oXG4gICAgbGluZUJvZHksXG4gICAgbGluZVNoYXBlLFxuICAgIGxpbmVPZmZzZXQsXG4gICAgbGluZUFuZ2xlLFxuICAgIHJlY3RhbmdsZUJvZHksXG4gICAgcmVjdGFuZ2xlU2hhcGUsXG4gICAgcmVjdGFuZ2xlT2Zmc2V0LFxuICAgIHJlY3RhbmdsZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIC8vIFRPRE9cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBzZXRDb252ZXhUb0NhcHN1bGVTaGFwZU1pZGRsZShjb252ZXhTaGFwZSwgY2Fwc3VsZVNoYXBlKXtcbiAgICB2ZWMyLnNldChjb252ZXhTaGFwZS52ZXJ0aWNlc1swXSwgLWNhcHN1bGVTaGFwZS5sZW5ndGggKiAwLjUsIC1jYXBzdWxlU2hhcGUucmFkaXVzKTtcbiAgICB2ZWMyLnNldChjb252ZXhTaGFwZS52ZXJ0aWNlc1sxXSwgIGNhcHN1bGVTaGFwZS5sZW5ndGggKiAwLjUsIC1jYXBzdWxlU2hhcGUucmFkaXVzKTtcbiAgICB2ZWMyLnNldChjb252ZXhTaGFwZS52ZXJ0aWNlc1syXSwgIGNhcHN1bGVTaGFwZS5sZW5ndGggKiAwLjUsICBjYXBzdWxlU2hhcGUucmFkaXVzKTtcbiAgICB2ZWMyLnNldChjb252ZXhTaGFwZS52ZXJ0aWNlc1szXSwgLWNhcHN1bGVTaGFwZS5sZW5ndGggKiAwLjUsICBjYXBzdWxlU2hhcGUucmFkaXVzKTtcbn1cblxudmFyIGNvbnZleENhcHN1bGVfdGVtcFJlY3QgPSBuZXcgUmVjdGFuZ2xlKDEsMSksXG4gICAgY29udmV4Q2Fwc3VsZV90ZW1wVmVjID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBDb252ZXgvY2Fwc3VsZSBuYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjb252ZXhDYXBzdWxlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBjb252ZXhCb2R5XG4gKiBAcGFyYW0gIHtDb252ZXh9ICAgICBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgY29udmV4UG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGNvbnZleEFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBjYXBzdWxlQm9keVxuICogQHBhcmFtICB7Q2Fwc3VsZX0gICAgY2Fwc3VsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBjYXBzdWxlUG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGNhcHN1bGVBbmdsZVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0FQU1VMRSB8IFNoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNBUFNVTEUgfCBTaGFwZS5SRUNUQU5HTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhDYXBzdWxlID0gZnVuY3Rpb24oXG4gICAgY29udmV4Qm9keSxcbiAgICBjb252ZXhTaGFwZSxcbiAgICBjb252ZXhQb3NpdGlvbixcbiAgICBjb252ZXhBbmdsZSxcbiAgICBjYXBzdWxlQm9keSxcbiAgICBjYXBzdWxlU2hhcGUsXG4gICAgY2Fwc3VsZVBvc2l0aW9uLFxuICAgIGNhcHN1bGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcblxuICAgIC8vIENoZWNrIHRoZSBjaXJjbGVzXG4gICAgLy8gQWRkIG9mZnNldHMhXG4gICAgdmFyIGNpcmNsZVBvcyA9IGNvbnZleENhcHN1bGVfdGVtcFZlYztcbiAgICB2ZWMyLnNldChjaXJjbGVQb3MsIGNhcHN1bGVTaGFwZS5sZW5ndGgvMiwwKTtcbiAgICB2ZWMyLnJvdGF0ZShjaXJjbGVQb3MsY2lyY2xlUG9zLGNhcHN1bGVBbmdsZSk7XG4gICAgdmVjMi5hZGQoY2lyY2xlUG9zLGNpcmNsZVBvcyxjYXBzdWxlUG9zaXRpb24pO1xuICAgIHZhciByZXN1bHQxID0gdGhpcy5jaXJjbGVDb252ZXgoY2Fwc3VsZUJvZHksY2Fwc3VsZVNoYXBlLGNpcmNsZVBvcyxjYXBzdWxlQW5nbGUsIGNvbnZleEJvZHksY29udmV4U2hhcGUsY29udmV4UG9zaXRpb24sY29udmV4QW5nbGUsIGp1c3RUZXN0LCBjYXBzdWxlU2hhcGUucmFkaXVzKTtcblxuICAgIHZlYzIuc2V0KGNpcmNsZVBvcywtY2Fwc3VsZVNoYXBlLmxlbmd0aC8yLCAwKTtcbiAgICB2ZWMyLnJvdGF0ZShjaXJjbGVQb3MsY2lyY2xlUG9zLGNhcHN1bGVBbmdsZSk7XG4gICAgdmVjMi5hZGQoY2lyY2xlUG9zLGNpcmNsZVBvcyxjYXBzdWxlUG9zaXRpb24pO1xuICAgIHZhciByZXN1bHQyID0gdGhpcy5jaXJjbGVDb252ZXgoY2Fwc3VsZUJvZHksY2Fwc3VsZVNoYXBlLGNpcmNsZVBvcyxjYXBzdWxlQW5nbGUsIGNvbnZleEJvZHksY29udmV4U2hhcGUsY29udmV4UG9zaXRpb24sY29udmV4QW5nbGUsIGp1c3RUZXN0LCBjYXBzdWxlU2hhcGUucmFkaXVzKTtcblxuICAgIGlmKGp1c3RUZXN0ICYmIChyZXN1bHQxIHx8IHJlc3VsdDIpKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgY2VudGVyIHJlY3RcbiAgICB2YXIgciA9IGNvbnZleENhcHN1bGVfdGVtcFJlY3Q7XG4gICAgc2V0Q29udmV4VG9DYXBzdWxlU2hhcGVNaWRkbGUocixjYXBzdWxlU2hhcGUpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnZleENvbnZleChjb252ZXhCb2R5LGNvbnZleFNoYXBlLGNvbnZleFBvc2l0aW9uLGNvbnZleEFuZ2xlLCBjYXBzdWxlQm9keSxyLGNhcHN1bGVQb3NpdGlvbixjYXBzdWxlQW5nbGUsIGp1c3RUZXN0KTtcblxuICAgIHJldHVybiByZXN1bHQgKyByZXN1bHQxICsgcmVzdWx0Mjtcbn07XG5cbi8qKlxuICogQ2Fwc3VsZS9saW5lIG5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGxpbmVDYXBzdWxlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBsaW5lQm9keVxuICogQHBhcmFtICB7TGluZX0gICAgICAgbGluZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBsaW5lUG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGxpbmVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgY2Fwc3VsZUJvZHlcbiAqIEBwYXJhbSAge0NhcHN1bGV9ICAgIGNhcHN1bGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgY2Fwc3VsZVBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBjYXBzdWxlQW5nbGVcbiAqIEB0b2RvIEltcGxlbWVudCBtZSFcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNBUFNVTEUgfCBTaGFwZS5MSU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUubGluZUNhcHN1bGUgPSBmdW5jdGlvbihcbiAgICBsaW5lQm9keSxcbiAgICBsaW5lU2hhcGUsXG4gICAgbGluZVBvc2l0aW9uLFxuICAgIGxpbmVBbmdsZSxcbiAgICBjYXBzdWxlQm9keSxcbiAgICBjYXBzdWxlU2hhcGUsXG4gICAgY2Fwc3VsZVBvc2l0aW9uLFxuICAgIGNhcHN1bGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICAvLyBUT0RPXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufTtcblxudmFyIGNhcHN1bGVDYXBzdWxlX3RlbXBWZWMxID0gdmVjMi5jcmVhdGUoKTtcbnZhciBjYXBzdWxlQ2Fwc3VsZV90ZW1wVmVjMiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgY2Fwc3VsZUNhcHN1bGVfdGVtcFJlY3QxID0gbmV3IFJlY3RhbmdsZSgxLDEpO1xuXG4vKipcbiAqIENhcHN1bGUvY2Fwc3VsZSBuYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjYXBzdWxlQ2Fwc3VsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAqIEBwYXJhbSAge0NhcHN1bGV9ICAgIHNpXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICB4aVxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYWlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gKiBAcGFyYW0gIHtDYXBzdWxlfSAgICBzalxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgeGpcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGFqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DQVBTVUxFIHwgU2hhcGUuQ0FQU1VMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNhcHN1bGVDYXBzdWxlID0gZnVuY3Rpb24oYmksc2kseGksYWksIGJqLHNqLHhqLGFqLCBqdXN0VGVzdCl7XG5cbiAgICB2YXIgZW5hYmxlRnJpY3Rpb25CZWZvcmU7XG5cbiAgICAvLyBDaGVjayB0aGUgY2lyY2xlc1xuICAgIC8vIEFkZCBvZmZzZXRzIVxuICAgIHZhciBjaXJjbGVQb3NpID0gY2Fwc3VsZUNhcHN1bGVfdGVtcFZlYzEsXG4gICAgICAgIGNpcmNsZVBvc2ogPSBjYXBzdWxlQ2Fwc3VsZV90ZW1wVmVjMjtcblxuICAgIHZhciBudW1Db250YWN0cyA9IDA7XG5cblxuICAgIC8vIE5lZWQgNCBjaXJjbGUgY2hlY2tzLCBiZXR3ZWVuIGFsbFxuICAgIGZvcih2YXIgaT0wOyBpPDI7IGkrKyl7XG5cbiAgICAgICAgdmVjMi5zZXQoY2lyY2xlUG9zaSwoaT09PTA/LTE6MSkqc2kubGVuZ3RoLzIsMCk7XG4gICAgICAgIHZlYzIucm90YXRlKGNpcmNsZVBvc2ksY2lyY2xlUG9zaSxhaSk7XG4gICAgICAgIHZlYzIuYWRkKGNpcmNsZVBvc2ksY2lyY2xlUG9zaSx4aSk7XG5cbiAgICAgICAgZm9yKHZhciBqPTA7IGo8MjsgaisrKXtcblxuICAgICAgICAgICAgdmVjMi5zZXQoY2lyY2xlUG9zaiwoaj09PTA/LTE6MSkqc2oubGVuZ3RoLzIsIDApO1xuICAgICAgICAgICAgdmVjMi5yb3RhdGUoY2lyY2xlUG9zaixjaXJjbGVQb3NqLGFqKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKGNpcmNsZVBvc2osY2lyY2xlUG9zaix4aik7XG5cbiAgICAgICAgICAgIC8vIFRlbXBvcmFyaWx5IHR1cm4gb2ZmIGZyaWN0aW9uXG4gICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgICAgICAgICBlbmFibGVGcmljdGlvbkJlZm9yZSA9IHRoaXMuZW5hYmxlRnJpY3Rpb247XG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jaXJjbGVDaXJjbGUoYmksc2ksY2lyY2xlUG9zaSxhaSwgYmosc2osY2lyY2xlUG9zaixhaiwganVzdFRlc3QsIHNpLnJhZGl1cywgc2oucmFkaXVzKTtcblxuICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihqdXN0VGVzdCAmJiByZXN1bHQpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBudW1Db250YWN0cyArPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgLy8gVGVtcG9yYXJpbHkgdHVybiBvZmYgZnJpY3Rpb25cbiAgICAgICAgZW5hYmxlRnJpY3Rpb25CZWZvcmUgPSB0aGlzLmVuYWJsZUZyaWN0aW9uO1xuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgY2lyY2xlcyBhZ2FpbnN0IHRoZSBjZW50ZXIgcmVjdGFuZ2xlc1xuICAgIHZhciByZWN0ID0gY2Fwc3VsZUNhcHN1bGVfdGVtcFJlY3QxO1xuICAgIHNldENvbnZleFRvQ2Fwc3VsZVNoYXBlTWlkZGxlKHJlY3Qsc2kpO1xuICAgIHZhciByZXN1bHQxID0gdGhpcy5jb252ZXhDYXBzdWxlKGJpLHJlY3QseGksYWksIGJqLHNqLHhqLGFqLCBqdXN0VGVzdCk7XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xuICAgIH1cblxuICAgIGlmKGp1c3RUZXN0ICYmIHJlc3VsdDEpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbnVtQ29udGFjdHMgKz0gcmVzdWx0MTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAvLyBUZW1wb3JhcmlseSB0dXJuIG9mZiBmcmljdGlvblxuICAgICAgICB2YXIgZW5hYmxlRnJpY3Rpb25CZWZvcmUgPSB0aGlzLmVuYWJsZUZyaWN0aW9uO1xuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZmFsc2U7XG4gICAgfVxuXG4gICAgc2V0Q29udmV4VG9DYXBzdWxlU2hhcGVNaWRkbGUocmVjdCxzaik7XG4gICAgdmFyIHJlc3VsdDIgPSB0aGlzLmNvbnZleENhcHN1bGUoYmoscmVjdCx4aixhaiwgYmksc2kseGksYWksIGp1c3RUZXN0KTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZW5hYmxlRnJpY3Rpb25CZWZvcmU7XG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3QgJiYgcmVzdWx0Mil7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBudW1Db250YWN0cyArPSByZXN1bHQyO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIGlmKG51bUNvbnRhY3RzICYmIHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bUNvbnRhY3RzO1xufTtcblxuLyoqXG4gKiBMaW5lL2xpbmUgbmFycm93cGhhc2VcbiAqIEBtZXRob2QgbGluZUxpbmVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJvZHlBXG4gKiBAcGFyYW0gIHtMaW5lfSAgICAgICBzaGFwZUFcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHBvc2l0aW9uQVxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYW5nbGVBXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBib2R5QlxuICogQHBhcmFtICB7TGluZX0gICAgICAgc2hhcGVCXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBwb3NpdGlvbkJcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGFuZ2xlQlxuICogQHRvZG8gSW1wbGVtZW50IG1lIVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuTElORSB8IFNoYXBlLkxJTkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5saW5lTGluZSA9IGZ1bmN0aW9uKFxuICAgIGJvZHlBLFxuICAgIHNoYXBlQSxcbiAgICBwb3NpdGlvbkEsXG4gICAgYW5nbGVBLFxuICAgIGJvZHlCLFxuICAgIHNoYXBlQixcbiAgICBwb3NpdGlvbkIsXG4gICAgYW5nbGVCLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIC8vIFRPRE9cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFBsYW5lL2xpbmUgTmFycm93cGhhc2VcbiAqIEBtZXRob2QgcGxhbmVMaW5lXG4gKiBAcGFyYW0gIHtCb2R5fSAgIHBsYW5lQm9keVxuICogQHBhcmFtICB7UGxhbmV9ICBwbGFuZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gIHBsYW5lT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBsYW5lQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgbGluZUJvZHlcbiAqIEBwYXJhbSAge0xpbmV9ICAgbGluZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gIGxpbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gbGluZUFuZ2xlXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QTEFORSB8IFNoYXBlLkxJTkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZUxpbmUgPSBmdW5jdGlvbihwbGFuZUJvZHksIHBsYW5lU2hhcGUsIHBsYW5lT2Zmc2V0LCBwbGFuZUFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVCb2R5LCAgbGluZVNoYXBlLCAgbGluZU9mZnNldCwgIGxpbmVBbmdsZSwganVzdFRlc3Qpe1xuICAgIHZhciB3b3JsZFZlcnRleDAgPSB0bXAxLFxuICAgICAgICB3b3JsZFZlcnRleDEgPSB0bXAyLFxuICAgICAgICB3b3JsZFZlcnRleDAxID0gdG1wMyxcbiAgICAgICAgd29ybGRWZXJ0ZXgxMSA9IHRtcDQsXG4gICAgICAgIHdvcmxkRWRnZSA9IHRtcDUsXG4gICAgICAgIHdvcmxkRWRnZVVuaXQgPSB0bXA2LFxuICAgICAgICBkaXN0ID0gdG1wNyxcbiAgICAgICAgd29ybGROb3JtYWwgPSB0bXA4LFxuICAgICAgICB3b3JsZFRhbmdlbnQgPSB0bXA5LFxuICAgICAgICB2ZXJ0cyA9IHRtcEFycmF5LFxuICAgICAgICBudW1Db250YWN0cyA9IDA7XG5cbiAgICAvLyBHZXQgc3RhcnQgYW5kIGVuZCBwb2ludHNcbiAgICB2ZWMyLnNldCh3b3JsZFZlcnRleDAsIC1saW5lU2hhcGUubGVuZ3RoLzIsIDApO1xuICAgIHZlYzIuc2V0KHdvcmxkVmVydGV4MSwgIGxpbmVTaGFwZS5sZW5ndGgvMiwgMCk7XG5cbiAgICAvLyBOb3Qgc3VyZSB3aHkgd2UgaGF2ZSB0byB1c2Ugd29ybGRWZXJ0ZXgqMSBoZXJlLCBidXQgaXQgd29uJ3Qgd29yayBvdGhlcndpc2UuIFRpcmVkLlxuICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MDEsIHdvcmxkVmVydGV4MCwgbGluZUFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDExLCB3b3JsZFZlcnRleDEsIGxpbmVBbmdsZSk7XG5cbiAgICBhZGQod29ybGRWZXJ0ZXgwMSwgd29ybGRWZXJ0ZXgwMSwgbGluZU9mZnNldCk7XG4gICAgYWRkKHdvcmxkVmVydGV4MTEsIHdvcmxkVmVydGV4MTEsIGxpbmVPZmZzZXQpO1xuXG4gICAgdmVjMi5jb3B5KHdvcmxkVmVydGV4MCx3b3JsZFZlcnRleDAxKTtcbiAgICB2ZWMyLmNvcHkod29ybGRWZXJ0ZXgxLHdvcmxkVmVydGV4MTEpO1xuXG4gICAgLy8gR2V0IHZlY3RvciBhbG9uZyB0aGUgbGluZVxuICAgIHN1Yih3b3JsZEVkZ2UsIHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgwKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZSh3b3JsZEVkZ2VVbml0LCB3b3JsZEVkZ2UpO1xuXG4gICAgLy8gR2V0IHRhbmdlbnQgdG8gdGhlIGVkZ2UuXG4gICAgdmVjMi5yb3RhdGU5MGN3KHdvcmxkVGFuZ2VudCwgd29ybGRFZGdlVW5pdCk7XG5cbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbCwgeUF4aXMsIHBsYW5lQW5nbGUpO1xuXG4gICAgLy8gQ2hlY2sgbGluZSBlbmRzXG4gICAgdmVydHNbMF0gPSB3b3JsZFZlcnRleDA7XG4gICAgdmVydHNbMV0gPSB3b3JsZFZlcnRleDE7XG4gICAgZm9yKHZhciBpPTA7IGk8dmVydHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdiA9IHZlcnRzW2ldO1xuXG4gICAgICAgIHN1YihkaXN0LCB2LCBwbGFuZU9mZnNldCk7XG5cbiAgICAgICAgdmFyIGQgPSBkb3QoZGlzdCx3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgaWYoZCA8IDApe1xuXG4gICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LGxpbmVCb2R5LHBsYW5lU2hhcGUsbGluZVNoYXBlKTtcbiAgICAgICAgICAgIG51bUNvbnRhY3RzKys7XG5cbiAgICAgICAgICAgIHZlYzIuY29weShjLm5vcm1hbEEsIHdvcmxkTm9ybWFsKTtcbiAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgICAgICAgICAvLyBkaXN0YW5jZSB2ZWN0b3IgYWxvbmcgcGxhbmUgbm9ybWFsXG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGRpc3QsIHdvcmxkTm9ybWFsLCBkKTtcblxuICAgICAgICAgICAgLy8gVmVjdG9yIGZyb20gcGxhbmUgY2VudGVyIHRvIGNvbnRhY3RcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIHYsIGRpc3QpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwbGFuZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICAvLyBGcm9tIGxpbmUgY2VudGVyIHRvIGNvbnRhY3RcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHYsICAgIGxpbmVPZmZzZXQpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lT2Zmc2V0KTtcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgaWYoIXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZighdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIGlmKG51bUNvbnRhY3RzICYmIHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bUNvbnRhY3RzO1xufTtcblxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBBUlRJQ0xFIHwgU2hhcGUuQ0FQU1VMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBhcnRpY2xlQ2Fwc3VsZSA9IGZ1bmN0aW9uKFxuICAgIHBhcnRpY2xlQm9keSxcbiAgICBwYXJ0aWNsZVNoYXBlLFxuICAgIHBhcnRpY2xlUG9zaXRpb24sXG4gICAgcGFydGljbGVBbmdsZSxcbiAgICBjYXBzdWxlQm9keSxcbiAgICBjYXBzdWxlU2hhcGUsXG4gICAgY2Fwc3VsZVBvc2l0aW9uLFxuICAgIGNhcHN1bGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICByZXR1cm4gdGhpcy5jaXJjbGVMaW5lKHBhcnRpY2xlQm9keSxwYXJ0aWNsZVNoYXBlLHBhcnRpY2xlUG9zaXRpb24scGFydGljbGVBbmdsZSwgY2Fwc3VsZUJvZHksY2Fwc3VsZVNoYXBlLGNhcHN1bGVQb3NpdGlvbixjYXBzdWxlQW5nbGUsIGp1c3RUZXN0LCBjYXBzdWxlU2hhcGUucmFkaXVzLCAwKTtcbn07XG5cbi8qKlxuICogQ2lyY2xlL2xpbmUgTmFycm93cGhhc2VcbiAqIEBtZXRob2QgY2lyY2xlTGluZVxuICogQHBhcmFtICB7Qm9keX0gY2lyY2xlQm9keVxuICogQHBhcmFtICB7Q2lyY2xlfSBjaXJjbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNpcmNsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjaXJjbGVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gbGluZUJvZHlcbiAqIEBwYXJhbSAge0xpbmV9IGxpbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGxpbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gbGluZUFuZ2xlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0IElmIHNldCB0byB0cnVlLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgKGludGVyc2VjdGlvbiBvciBub3QpIHdpdGhvdXQgYWRkaW5nIGVxdWF0aW9ucy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lUmFkaXVzIFJhZGl1cyB0byBhZGQgdG8gdGhlIGxpbmUuIENhbiBiZSB1c2VkIHRvIHRlc3QgQ2Fwc3VsZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gY2lyY2xlUmFkaXVzIElmIHNldCwgdGhpcyB2YWx1ZSBvdmVycmlkZXMgdGhlIGNpcmNsZSBzaGFwZSByYWRpdXMuXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5MSU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlTGluZSA9IGZ1bmN0aW9uKFxuICAgIGNpcmNsZUJvZHksXG4gICAgY2lyY2xlU2hhcGUsXG4gICAgY2lyY2xlT2Zmc2V0LFxuICAgIGNpcmNsZUFuZ2xlLFxuICAgIGxpbmVCb2R5LFxuICAgIGxpbmVTaGFwZSxcbiAgICBsaW5lT2Zmc2V0LFxuICAgIGxpbmVBbmdsZSxcbiAgICBqdXN0VGVzdCxcbiAgICBsaW5lUmFkaXVzLFxuICAgIGNpcmNsZVJhZGl1c1xuKXtcbiAgICB2YXIgbGluZVJhZGl1cyA9IGxpbmVSYWRpdXMgfHwgMCxcbiAgICAgICAgY2lyY2xlUmFkaXVzID0gdHlwZW9mKGNpcmNsZVJhZGl1cykhPT1cInVuZGVmaW5lZFwiID8gY2lyY2xlUmFkaXVzIDogY2lyY2xlU2hhcGUucmFkaXVzLFxuXG4gICAgICAgIG9ydGhvRGlzdCA9IHRtcDEsXG4gICAgICAgIGxpbmVUb0NpcmNsZU9ydGhvVW5pdCA9IHRtcDIsXG4gICAgICAgIHByb2plY3RlZFBvaW50ID0gdG1wMyxcbiAgICAgICAgY2VudGVyRGlzdCA9IHRtcDQsXG4gICAgICAgIHdvcmxkVGFuZ2VudCA9IHRtcDUsXG4gICAgICAgIHdvcmxkRWRnZSA9IHRtcDYsXG4gICAgICAgIHdvcmxkRWRnZVVuaXQgPSB0bXA3LFxuICAgICAgICB3b3JsZFZlcnRleDAgPSB0bXA4LFxuICAgICAgICB3b3JsZFZlcnRleDEgPSB0bXA5LFxuICAgICAgICB3b3JsZFZlcnRleDAxID0gdG1wMTAsXG4gICAgICAgIHdvcmxkVmVydGV4MTEgPSB0bXAxMSxcbiAgICAgICAgZGlzdCA9IHRtcDEyLFxuICAgICAgICBsaW5lVG9DaXJjbGUgPSB0bXAxMyxcbiAgICAgICAgbGluZUVuZFRvTGluZVJhZGl1cyA9IHRtcDE0LFxuXG4gICAgICAgIHZlcnRzID0gdG1wQXJyYXk7XG5cbiAgICAvLyBHZXQgc3RhcnQgYW5kIGVuZCBwb2ludHNcbiAgICB2ZWMyLnNldCh3b3JsZFZlcnRleDAsIC1saW5lU2hhcGUubGVuZ3RoLzIsIDApO1xuICAgIHZlYzIuc2V0KHdvcmxkVmVydGV4MSwgIGxpbmVTaGFwZS5sZW5ndGgvMiwgMCk7XG5cbiAgICAvLyBOb3Qgc3VyZSB3aHkgd2UgaGF2ZSB0byB1c2Ugd29ybGRWZXJ0ZXgqMSBoZXJlLCBidXQgaXQgd29uJ3Qgd29yayBvdGhlcndpc2UuIFRpcmVkLlxuICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MDEsIHdvcmxkVmVydGV4MCwgbGluZUFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDExLCB3b3JsZFZlcnRleDEsIGxpbmVBbmdsZSk7XG5cbiAgICBhZGQod29ybGRWZXJ0ZXgwMSwgd29ybGRWZXJ0ZXgwMSwgbGluZU9mZnNldCk7XG4gICAgYWRkKHdvcmxkVmVydGV4MTEsIHdvcmxkVmVydGV4MTEsIGxpbmVPZmZzZXQpO1xuXG4gICAgdmVjMi5jb3B5KHdvcmxkVmVydGV4MCx3b3JsZFZlcnRleDAxKTtcbiAgICB2ZWMyLmNvcHkod29ybGRWZXJ0ZXgxLHdvcmxkVmVydGV4MTEpO1xuXG4gICAgLy8gR2V0IHZlY3RvciBhbG9uZyB0aGUgbGluZVxuICAgIHN1Yih3b3JsZEVkZ2UsIHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgwKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZSh3b3JsZEVkZ2VVbml0LCB3b3JsZEVkZ2UpO1xuXG4gICAgLy8gR2V0IHRhbmdlbnQgdG8gdGhlIGVkZ2UuXG4gICAgdmVjMi5yb3RhdGU5MGN3KHdvcmxkVGFuZ2VudCwgd29ybGRFZGdlVW5pdCk7XG5cbiAgICAvLyBDaGVjayBkaXN0YW5jZSBmcm9tIHRoZSBwbGFuZSBzcGFubmVkIGJ5IHRoZSBlZGdlIHZzIHRoZSBjaXJjbGVcbiAgICBzdWIoZGlzdCwgY2lyY2xlT2Zmc2V0LCB3b3JsZFZlcnRleDApO1xuICAgIHZhciBkID0gZG90KGRpc3QsIHdvcmxkVGFuZ2VudCk7IC8vIERpc3RhbmNlIGZyb20gY2VudGVyIG9mIGxpbmUgdG8gY2lyY2xlIGNlbnRlclxuICAgIHN1YihjZW50ZXJEaXN0LCB3b3JsZFZlcnRleDAsIGxpbmVPZmZzZXQpO1xuXG4gICAgc3ViKGxpbmVUb0NpcmNsZSwgY2lyY2xlT2Zmc2V0LCBsaW5lT2Zmc2V0KTtcblxuICAgIHZhciByYWRpdXNTdW0gPSBjaXJjbGVSYWRpdXMgKyBsaW5lUmFkaXVzO1xuXG4gICAgaWYoTWF0aC5hYnMoZCkgPCByYWRpdXNTdW0pe1xuXG4gICAgICAgIC8vIE5vdyBwcm9qZWN0IHRoZSBjaXJjbGUgb250byB0aGUgZWRnZVxuICAgICAgICB2ZWMyLnNjYWxlKG9ydGhvRGlzdCwgd29ybGRUYW5nZW50LCBkKTtcbiAgICAgICAgc3ViKHByb2plY3RlZFBvaW50LCBjaXJjbGVPZmZzZXQsIG9ydGhvRGlzdCk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBtaXNzaW5nIGxpbmUgcmFkaXVzXG4gICAgICAgIHZlYzIuc2NhbGUobGluZVRvQ2lyY2xlT3J0aG9Vbml0LCB3b3JsZFRhbmdlbnQsIGRvdCh3b3JsZFRhbmdlbnQsIGxpbmVUb0NpcmNsZSkpO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShsaW5lVG9DaXJjbGVPcnRob1VuaXQsbGluZVRvQ2lyY2xlT3J0aG9Vbml0KTtcbiAgICAgICAgdmVjMi5zY2FsZShsaW5lVG9DaXJjbGVPcnRob1VuaXQsIGxpbmVUb0NpcmNsZU9ydGhvVW5pdCwgbGluZVJhZGl1cyk7XG4gICAgICAgIGFkZChwcm9qZWN0ZWRQb2ludCxwcm9qZWN0ZWRQb2ludCxsaW5lVG9DaXJjbGVPcnRob1VuaXQpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGVkZ2Ugc3BhblxuICAgICAgICB2YXIgcG9zID0gIGRvdCh3b3JsZEVkZ2VVbml0LCBwcm9qZWN0ZWRQb2ludCk7XG4gICAgICAgIHZhciBwb3MwID0gZG90KHdvcmxkRWRnZVVuaXQsIHdvcmxkVmVydGV4MCk7XG4gICAgICAgIHZhciBwb3MxID0gZG90KHdvcmxkRWRnZVVuaXQsIHdvcmxkVmVydGV4MSk7XG5cbiAgICAgICAgaWYocG9zID4gcG9zMCAmJiBwb3MgPCBwb3MxKXtcbiAgICAgICAgICAgIC8vIFdlIGdvdCBjb250YWN0IVxuXG4gICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSxsaW5lQm9keSxjaXJjbGVTaGFwZSxsaW5lU2hhcGUpO1xuXG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGMubm9ybWFsQSwgb3J0aG9EaXN0LCAtMSk7XG4gICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsIGMubm9ybWFsQSk7XG5cbiAgICAgICAgICAgIHZlYzIuc2NhbGUoIGMuY29udGFjdFBvaW50QSwgYy5ub3JtYWxBLCAgY2lyY2xlUmFkaXVzKTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlT2Zmc2V0KTtcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHByb2plY3RlZFBvaW50LCBsaW5lT2Zmc2V0KTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZU9mZnNldCk7XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBjb3JuZXJcbiAgICB2ZXJ0c1swXSA9IHdvcmxkVmVydGV4MDtcbiAgICB2ZXJ0c1sxXSA9IHdvcmxkVmVydGV4MTtcblxuICAgIGZvcih2YXIgaT0wOyBpPHZlcnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSB2ZXJ0c1tpXTtcblxuICAgICAgICBzdWIoZGlzdCwgdiwgY2lyY2xlT2Zmc2V0KTtcblxuICAgICAgICBpZih2ZWMyLnNxdWFyZWRMZW5ndGgoZGlzdCkgPCBNYXRoLnBvdyhyYWRpdXNTdW0sIDIpKXtcblxuICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGNpcmNsZUJvZHksbGluZUJvZHksY2lyY2xlU2hhcGUsbGluZVNoYXBlKTtcblxuICAgICAgICAgICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgZGlzdCk7XG4gICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsYy5ub3JtYWxBKTtcblxuICAgICAgICAgICAgLy8gVmVjdG9yIGZyb20gY2lyY2xlIHRvIGNvbnRhY3QgcG9pbnQgaXMgdGhlIG5vcm1hbCB0aW1lcyB0aGUgY2lyY2xlIHJhZGl1c1xuICAgICAgICAgICAgdmVjMi5zY2FsZShjLmNvbnRhY3RQb2ludEEsIGMubm9ybWFsQSwgY2lyY2xlUmFkaXVzKTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlT2Zmc2V0KTtcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHYsIGxpbmVPZmZzZXQpO1xuICAgICAgICAgICAgdmVjMi5zY2FsZShsaW5lRW5kVG9MaW5lUmFkaXVzLCBjLm5vcm1hbEEsIC1saW5lUmFkaXVzKTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZUVuZFRvTGluZVJhZGl1cyk7XG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVPZmZzZXQpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn07XG5cbi8qKlxuICogQ2lyY2xlL2NhcHN1bGUgTmFycm93cGhhc2VcbiAqIEBtZXRob2QgY2lyY2xlQ2Fwc3VsZVxuICogQHBhcmFtICB7Qm9keX0gICBiaVxuICogQHBhcmFtICB7Q2lyY2xlfSBzaVxuICogQHBhcmFtICB7QXJyYXl9ICB4aVxuICogQHBhcmFtICB7TnVtYmVyfSBhaVxuICogQHBhcmFtICB7Qm9keX0gICBialxuICogQHBhcmFtICB7TGluZX0gICBzalxuICogQHBhcmFtICB7QXJyYXl9ICB4alxuICogQHBhcmFtICB7TnVtYmVyfSBhalxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuQ0FQU1VMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZUNhcHN1bGUgPSBmdW5jdGlvbihiaSxzaSx4aSxhaSwgYmosc2oseGosYWosIGp1c3RUZXN0KXtcbiAgICByZXR1cm4gdGhpcy5jaXJjbGVMaW5lKGJpLHNpLHhpLGFpLCBiaixzaix4aixhaiwganVzdFRlc3QsIHNqLnJhZGl1cyk7XG59O1xuXG4vKipcbiAqIENpcmNsZS9jb252ZXggTmFycm93cGhhc2UuXG4gKiBAbWV0aG9kIGNpcmNsZUNvbnZleFxuICogQHBhcmFtICB7Qm9keX0gY2lyY2xlQm9keVxuICogQHBhcmFtICB7Q2lyY2xlfSBjaXJjbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNpcmNsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjaXJjbGVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gY29udmV4Qm9keVxuICogQHBhcmFtICB7Q29udmV4fSBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNvbnZleE9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjb252ZXhBbmdsZVxuICogQHBhcmFtICB7Qm9vbGVhbn0ganVzdFRlc3RcbiAqIEBwYXJhbSAge051bWJlcn0gY2lyY2xlUmFkaXVzXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5DT05WRVhdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5SRUNUQU5HTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVDb252ZXggPSBmdW5jdGlvbihcbiAgICBjaXJjbGVCb2R5LFxuICAgIGNpcmNsZVNoYXBlLFxuICAgIGNpcmNsZU9mZnNldCxcbiAgICBjaXJjbGVBbmdsZSxcbiAgICBjb252ZXhCb2R5LFxuICAgIGNvbnZleFNoYXBlLFxuICAgIGNvbnZleE9mZnNldCxcbiAgICBjb252ZXhBbmdsZSxcbiAgICBqdXN0VGVzdCxcbiAgICBjaXJjbGVSYWRpdXNcbil7XG4gICAgdmFyIGNpcmNsZVJhZGl1cyA9IHR5cGVvZihjaXJjbGVSYWRpdXMpPT09XCJudW1iZXJcIiA/IGNpcmNsZVJhZGl1cyA6IGNpcmNsZVNoYXBlLnJhZGl1cztcblxuICAgIHZhciB3b3JsZFZlcnRleDAgPSB0bXAxLFxuICAgICAgICB3b3JsZFZlcnRleDEgPSB0bXAyLFxuICAgICAgICB3b3JsZEVkZ2UgPSB0bXAzLFxuICAgICAgICB3b3JsZEVkZ2VVbml0ID0gdG1wNCxcbiAgICAgICAgd29ybGROb3JtYWwgPSB0bXA1LFxuICAgICAgICBjZW50ZXJEaXN0ID0gdG1wNixcbiAgICAgICAgY29udmV4VG9DaXJjbGUgPSB0bXA3LFxuICAgICAgICBvcnRob0Rpc3QgPSB0bXA4LFxuICAgICAgICBwcm9qZWN0ZWRQb2ludCA9IHRtcDksXG4gICAgICAgIGRpc3QgPSB0bXAxMCxcbiAgICAgICAgd29ybGRWZXJ0ZXggPSB0bXAxMSxcblxuICAgICAgICBjbG9zZXN0RWRnZSA9IC0xLFxuICAgICAgICBjbG9zZXN0RWRnZURpc3RhbmNlID0gbnVsbCxcbiAgICAgICAgY2xvc2VzdEVkZ2VPcnRob0Rpc3QgPSB0bXAxMixcbiAgICAgICAgY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCA9IHRtcDEzLFxuICAgICAgICBjYW5kaWRhdGUgPSB0bXAxNCxcbiAgICAgICAgY2FuZGlkYXRlRGlzdCA9IHRtcDE1LFxuICAgICAgICBtaW5DYW5kaWRhdGUgPSB0bXAxNixcblxuICAgICAgICBmb3VuZCA9IGZhbHNlLFxuICAgICAgICBtaW5DYW5kaWRhdGVEaXN0YW5jZSA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICB2YXIgbnVtUmVwb3J0ZWQgPSAwO1xuXG4gICAgLy8gTmV3IGFsZ29yaXRobTpcbiAgICAvLyAxLiBDaGVjayBzbyBjZW50ZXIgb2YgY2lyY2xlIGlzIG5vdCBpbnNpZGUgdGhlIHBvbHlnb24uIElmIGl0IGlzLCB0aGlzIHdvbnQgd29yay4uLlxuICAgIC8vIDIuIEZvciBlYWNoIGVkZ2VcbiAgICAvLyAyLiAxLiBHZXQgcG9pbnQgb24gY2lyY2xlIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgZWRnZSAoc2NhbGUgbm9ybWFsIHdpdGggLXJhZGl1cylcbiAgICAvLyAyLiAyLiBDaGVjayBpZiBwb2ludCBpcyBpbnNpZGUuXG5cbiAgICB2YXIgdmVydHMgPSBjb252ZXhTaGFwZS52ZXJ0aWNlcztcblxuICAgIC8vIENoZWNrIGFsbCBlZGdlcyBmaXJzdFxuICAgIGZvcih2YXIgaT0wOyBpIT09dmVydHMubGVuZ3RoKzE7IGkrKyl7XG4gICAgICAgIHZhciB2MCA9IHZlcnRzW2kldmVydHMubGVuZ3RoXSxcbiAgICAgICAgICAgIHYxID0gdmVydHNbKGkrMSkldmVydHMubGVuZ3RoXTtcblxuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDAsIHYwLCBjb252ZXhBbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MSwgdjEsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgYWRkKHdvcmxkVmVydGV4MCwgd29ybGRWZXJ0ZXgwLCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBhZGQod29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDEsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIHN1Yih3b3JsZEVkZ2UsIHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgwKTtcblxuICAgICAgICB2ZWMyLm5vcm1hbGl6ZSh3b3JsZEVkZ2VVbml0LCB3b3JsZEVkZ2UpO1xuXG4gICAgICAgIC8vIEdldCB0YW5nZW50IHRvIHRoZSBlZGdlLiBQb2ludHMgb3V0IG9mIHRoZSBDb252ZXhcbiAgICAgICAgdmVjMi5yb3RhdGU5MGN3KHdvcmxkTm9ybWFsLCB3b3JsZEVkZ2VVbml0KTtcblxuICAgICAgICAvLyBHZXQgcG9pbnQgb24gY2lyY2xlLCBjbG9zZXN0IHRvIHRoZSBwb2x5Z29uXG4gICAgICAgIHZlYzIuc2NhbGUoY2FuZGlkYXRlLHdvcmxkTm9ybWFsLC1jaXJjbGVTaGFwZS5yYWRpdXMpO1xuICAgICAgICBhZGQoY2FuZGlkYXRlLGNhbmRpZGF0ZSxjaXJjbGVPZmZzZXQpO1xuXG4gICAgICAgIGlmKHBvaW50SW5Db252ZXgoY2FuZGlkYXRlLGNvbnZleFNoYXBlLGNvbnZleE9mZnNldCxjb252ZXhBbmdsZSkpe1xuXG4gICAgICAgICAgICB2ZWMyLnN1YihjYW5kaWRhdGVEaXN0LHdvcmxkVmVydGV4MCxjYW5kaWRhdGUpO1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZURpc3RhbmNlID0gTWF0aC5hYnModmVjMi5kb3QoY2FuZGlkYXRlRGlzdCx3b3JsZE5vcm1hbCkpO1xuXG4gICAgICAgICAgICBpZihjYW5kaWRhdGVEaXN0YW5jZSA8IG1pbkNhbmRpZGF0ZURpc3RhbmNlKXtcbiAgICAgICAgICAgICAgICB2ZWMyLmNvcHkobWluQ2FuZGlkYXRlLGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgbWluQ2FuZGlkYXRlRGlzdGFuY2UgPSBjYW5kaWRhdGVEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB2ZWMyLnNjYWxlKGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsd29ybGROb3JtYWwsY2FuZGlkYXRlRGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIHZlYzIuYWRkKGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCxjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGZvdW5kKXtcblxuICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSxjb252ZXhCb2R5LGNpcmNsZVNoYXBlLGNvbnZleFNoYXBlKTtcbiAgICAgICAgdmVjMi5zdWIoYy5ub3JtYWxBLCBtaW5DYW5kaWRhdGUsIGNpcmNsZU9mZnNldCk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSwgYy5ub3JtYWxBKTtcblxuICAgICAgICB2ZWMyLnNjYWxlKGMuY29udGFjdFBvaW50QSwgIGMubm9ybWFsQSwgY2lyY2xlUmFkaXVzKTtcbiAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCggdGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBhbGwgdmVydGljZXNcbiAgICBpZihjaXJjbGVSYWRpdXMgPiAwKXtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dmVydHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGxvY2FsVmVydGV4ID0gdmVydHNbaV07XG4gICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleCwgbG9jYWxWZXJ0ZXgsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgICAgIGFkZCh3b3JsZFZlcnRleCwgd29ybGRWZXJ0ZXgsIGNvbnZleE9mZnNldCk7XG5cbiAgICAgICAgICAgIHN1YihkaXN0LCB3b3JsZFZlcnRleCwgY2lyY2xlT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmKHZlYzIuc3F1YXJlZExlbmd0aChkaXN0KSA8IE1hdGgucG93KGNpcmNsZVJhZGl1cywgMikpe1xuXG4gICAgICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGNpcmNsZUJvZHksY29udmV4Qm9keSxjaXJjbGVTaGFwZSxjb252ZXhTaGFwZSk7XG5cbiAgICAgICAgICAgICAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCBkaXN0KTtcbiAgICAgICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsYy5ub3JtYWxBKTtcblxuICAgICAgICAgICAgICAgIC8vIFZlY3RvciBmcm9tIGNpcmNsZSB0byBjb250YWN0IHBvaW50IGlzIHRoZSBub3JtYWwgdGltZXMgdGhlIGNpcmNsZSByYWRpdXNcbiAgICAgICAgICAgICAgICB2ZWMyLnNjYWxlKGMuY29udGFjdFBvaW50QSwgYy5ub3JtYWxBLCBjaXJjbGVSYWRpdXMpO1xuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50Qiwgd29ybGRWZXJ0ZXgsIGNvbnZleE9mZnNldCk7XG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4Qm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAwO1xufTtcblxudmFyIHBpY193b3JsZFZlcnRleDAgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHBpY193b3JsZFZlcnRleDEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHBpY19yMCA9IHZlYzIuY3JlYXRlKCksXG4gICAgcGljX3IxID0gdmVjMi5jcmVhdGUoKTtcblxuLypcbiAqIENoZWNrIGlmIGEgcG9pbnQgaXMgaW4gYSBwb2x5Z29uXG4gKi9cbmZ1bmN0aW9uIHBvaW50SW5Db252ZXgod29ybGRQb2ludCxjb252ZXhTaGFwZSxjb252ZXhPZmZzZXQsY29udmV4QW5nbGUpe1xuICAgIHZhciB3b3JsZFZlcnRleDAgPSBwaWNfd29ybGRWZXJ0ZXgwLFxuICAgICAgICB3b3JsZFZlcnRleDEgPSBwaWNfd29ybGRWZXJ0ZXgxLFxuICAgICAgICByMCA9IHBpY19yMCxcbiAgICAgICAgcjEgPSBwaWNfcjEsXG4gICAgICAgIHBvaW50ID0gd29ybGRQb2ludCxcbiAgICAgICAgdmVydHMgPSBjb252ZXhTaGFwZS52ZXJ0aWNlcyxcbiAgICAgICAgbGFzdENyb3NzID0gbnVsbDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PXZlcnRzLmxlbmd0aCsxOyBpKyspe1xuICAgICAgICB2YXIgdjAgPSB2ZXJ0c1tpJXZlcnRzLmxlbmd0aF0sXG4gICAgICAgICAgICB2MSA9IHZlcnRzWyhpKzEpJXZlcnRzLmxlbmd0aF07XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtIHZlcnRpY2VzIHRvIHdvcmxkXG4gICAgICAgIC8vIEB0b2RvIFRoZSBwb2ludCBzaG91bGQgYmUgdHJhbnNmb3JtZWQgdG8gbG9jYWwgY29vcmRpbmF0ZXMgaW4gdGhlIGNvbnZleCwgbm8gbmVlZCB0byB0cmFuc2Zvcm0gZWFjaCB2ZXJ0ZXhcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgwLCB2MCwgY29udmV4QW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDEsIHYxLCBjb252ZXhBbmdsZSk7XG4gICAgICAgIGFkZCh3b3JsZFZlcnRleDAsIHdvcmxkVmVydGV4MCwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgYWRkKHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgxLCBjb252ZXhPZmZzZXQpO1xuXG4gICAgICAgIHN1YihyMCwgd29ybGRWZXJ0ZXgwLCBwb2ludCk7XG4gICAgICAgIHN1YihyMSwgd29ybGRWZXJ0ZXgxLCBwb2ludCk7XG4gICAgICAgIHZhciBjcm9zcyA9IHZlYzIuY3Jvc3NMZW5ndGgocjAscjEpO1xuXG4gICAgICAgIGlmKGxhc3RDcm9zcz09PW51bGwpe1xuICAgICAgICAgICAgbGFzdENyb3NzID0gY3Jvc3M7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBnb3QgYSBkaWZmZXJlbnQgc2lnbiBvZiB0aGUgZGlzdGFuY2UgdmVjdG9yLCB0aGUgcG9pbnQgaXMgb3V0IG9mIHRoZSBwb2x5Z29uXG4gICAgICAgIGlmKGNyb3NzKmxhc3RDcm9zcyA8PSAwKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0Q3Jvc3MgPSBjcm9zcztcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogUGFydGljbGUvY29udmV4IE5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIHBhcnRpY2xlQ29udmV4XG4gKiBAcGFyYW0gIHtCb2R5fSBwYXJ0aWNsZUJvZHlcbiAqIEBwYXJhbSAge1BhcnRpY2xlfSBwYXJ0aWNsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gcGFydGljbGVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gcGFydGljbGVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gY29udmV4Qm9keVxuICogQHBhcmFtICB7Q29udmV4fSBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNvbnZleE9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjb252ZXhBbmdsZVxuICogQHBhcmFtIHtCb29sZWFufSBqdXN0VGVzdFxuICogQHRvZG8gdXNlIHBvaW50SW5Db252ZXggYW5kIGNvZGUgbW9yZSBzaW1pbGFyIHRvIGNpcmNsZUNvbnZleFxuICogQHRvZG8gZG9uJ3QgdHJhbnNmb3JtIGVhY2ggdmVydGV4LCBidXQgdHJhbnNmb3JtIHRoZSBwYXJ0aWNsZSBwb3NpdGlvbiB0byBjb252ZXgtbG9jYWwgaW5zdGVhZFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUEFSVElDTEUgfCBTaGFwZS5DT05WRVhdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QQVJUSUNMRSB8IFNoYXBlLlJFQ1RBTkdMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBhcnRpY2xlQ29udmV4ID0gZnVuY3Rpb24oXG4gICAgcGFydGljbGVCb2R5LFxuICAgIHBhcnRpY2xlU2hhcGUsXG4gICAgcGFydGljbGVPZmZzZXQsXG4gICAgcGFydGljbGVBbmdsZSxcbiAgICBjb252ZXhCb2R5LFxuICAgIGNvbnZleFNoYXBlLFxuICAgIGNvbnZleE9mZnNldCxcbiAgICBjb252ZXhBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICB2YXIgd29ybGRWZXJ0ZXgwID0gdG1wMSxcbiAgICAgICAgd29ybGRWZXJ0ZXgxID0gdG1wMixcbiAgICAgICAgd29ybGRFZGdlID0gdG1wMyxcbiAgICAgICAgd29ybGRFZGdlVW5pdCA9IHRtcDQsXG4gICAgICAgIHdvcmxkVGFuZ2VudCA9IHRtcDUsXG4gICAgICAgIGNlbnRlckRpc3QgPSB0bXA2LFxuICAgICAgICBjb252ZXhUb3BhcnRpY2xlID0gdG1wNyxcbiAgICAgICAgb3J0aG9EaXN0ID0gdG1wOCxcbiAgICAgICAgcHJvamVjdGVkUG9pbnQgPSB0bXA5LFxuICAgICAgICBkaXN0ID0gdG1wMTAsXG4gICAgICAgIHdvcmxkVmVydGV4ID0gdG1wMTEsXG4gICAgICAgIGNsb3Nlc3RFZGdlID0gLTEsXG4gICAgICAgIGNsb3Nlc3RFZGdlRGlzdGFuY2UgPSBudWxsLFxuICAgICAgICBjbG9zZXN0RWRnZU9ydGhvRGlzdCA9IHRtcDEyLFxuICAgICAgICBjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50ID0gdG1wMTMsXG4gICAgICAgIHIwID0gdG1wMTQsIC8vIHZlY3RvciBmcm9tIHBhcnRpY2xlIHRvIHZlcnRleDBcbiAgICAgICAgcjEgPSB0bXAxNSxcbiAgICAgICAgbG9jYWxQb2ludCA9IHRtcDE2LFxuICAgICAgICBjYW5kaWRhdGVEaXN0ID0gdG1wMTcsXG4gICAgICAgIG1pbkVkZ2VOb3JtYWwgPSB0bXAxOCxcbiAgICAgICAgbWluQ2FuZGlkYXRlRGlzdGFuY2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgdmFyIG51bVJlcG9ydGVkID0gMCxcbiAgICAgICAgZm91bmQgPSBmYWxzZSxcbiAgICAgICAgdmVydHMgPSBjb252ZXhTaGFwZS52ZXJ0aWNlcztcblxuICAgIC8vIENoZWNrIGlmIHRoZSBwYXJ0aWNsZSBpcyBpbiB0aGUgcG9seWdvbiBhdCBhbGxcbiAgICBpZighcG9pbnRJbkNvbnZleChwYXJ0aWNsZU9mZnNldCxjb252ZXhTaGFwZSxjb252ZXhPZmZzZXQsY29udmV4QW5nbGUpKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBlZGdlcyBmaXJzdFxuICAgIHZhciBsYXN0Q3Jvc3MgPSBudWxsO1xuICAgIGZvcih2YXIgaT0wOyBpIT09dmVydHMubGVuZ3RoKzE7IGkrKyl7XG4gICAgICAgIHZhciB2MCA9IHZlcnRzW2kldmVydHMubGVuZ3RoXSxcbiAgICAgICAgICAgIHYxID0gdmVydHNbKGkrMSkldmVydHMubGVuZ3RoXTtcblxuICAgICAgICAvLyBUcmFuc2Zvcm0gdmVydGljZXMgdG8gd29ybGRcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgwLCB2MCwgY29udmV4QW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDEsIHYxLCBjb252ZXhBbmdsZSk7XG4gICAgICAgIGFkZCh3b3JsZFZlcnRleDAsIHdvcmxkVmVydGV4MCwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgYWRkKHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgxLCBjb252ZXhPZmZzZXQpO1xuXG4gICAgICAgIC8vIEdldCB3b3JsZCBlZGdlXG4gICAgICAgIHN1Yih3b3JsZEVkZ2UsIHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgwKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUod29ybGRFZGdlVW5pdCwgd29ybGRFZGdlKTtcblxuICAgICAgICAvLyBHZXQgdGFuZ2VudCB0byB0aGUgZWRnZS4gUG9pbnRzIG91dCBvZiB0aGUgQ29udmV4XG4gICAgICAgIHZlYzIucm90YXRlOTBjdyh3b3JsZFRhbmdlbnQsIHdvcmxkRWRnZVVuaXQpO1xuXG4gICAgICAgIC8vIENoZWNrIGRpc3RhbmNlIGZyb20gdGhlIGluZmluaXRlIGxpbmUgKHNwYW5uZWQgYnkgdGhlIGVkZ2UpIHRvIHRoZSBwYXJ0aWNsZVxuICAgICAgICBzdWIoZGlzdCwgcGFydGljbGVPZmZzZXQsIHdvcmxkVmVydGV4MCk7XG4gICAgICAgIHZhciBkID0gZG90KGRpc3QsIHdvcmxkVGFuZ2VudCk7XG4gICAgICAgIHN1YihjZW50ZXJEaXN0LCB3b3JsZFZlcnRleDAsIGNvbnZleE9mZnNldCk7XG5cbiAgICAgICAgc3ViKGNvbnZleFRvcGFydGljbGUsIHBhcnRpY2xlT2Zmc2V0LCBjb252ZXhPZmZzZXQpO1xuXG4gICAgICAgIHZlYzIuc3ViKGNhbmRpZGF0ZURpc3Qsd29ybGRWZXJ0ZXgwLHBhcnRpY2xlT2Zmc2V0KTtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZURpc3RhbmNlID0gTWF0aC5hYnModmVjMi5kb3QoY2FuZGlkYXRlRGlzdCx3b3JsZFRhbmdlbnQpKTtcblxuICAgICAgICBpZihjYW5kaWRhdGVEaXN0YW5jZSA8IG1pbkNhbmRpZGF0ZURpc3RhbmNlKXtcbiAgICAgICAgICAgIG1pbkNhbmRpZGF0ZURpc3RhbmNlID0gY2FuZGlkYXRlRGlzdGFuY2U7XG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsd29ybGRUYW5nZW50LGNhbmRpZGF0ZURpc3RhbmNlKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCxwYXJ0aWNsZU9mZnNldCk7XG4gICAgICAgICAgICB2ZWMyLmNvcHkobWluRWRnZU5vcm1hbCx3b3JsZFRhbmdlbnQpO1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoZm91bmQpe1xuICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBhcnRpY2xlQm9keSxjb252ZXhCb2R5LHBhcnRpY2xlU2hhcGUsY29udmV4U2hhcGUpO1xuXG4gICAgICAgIHZlYzIuc2NhbGUoYy5ub3JtYWxBLCBtaW5FZGdlTm9ybWFsLCAtMSk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSwgYy5ub3JtYWxBKTtcblxuICAgICAgICAvLyBQYXJ0aWNsZSBoYXMgbm8gZXh0ZW50IHRvIHRoZSBjb250YWN0IHBvaW50XG4gICAgICAgIHZlYzIuc2V0KGMuY29udGFjdFBvaW50QSwgIDAsIDApO1xuICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIHBhcnRpY2xlT2Zmc2V0KTtcbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwYXJ0aWNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgIC8vIEZyb20gY29udmV4IGNlbnRlciB0byBwb2ludFxuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4Qm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2goIHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG5cbiAgICByZXR1cm4gMDtcbn07XG5cbi8qKlxuICogQ2lyY2xlL2NpcmNsZSBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjaXJjbGVDaXJjbGVcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtDaXJjbGV9IHNoYXBlQVxuICogQHBhcmFtICB7QXJyYXl9IG9mZnNldEFcbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHBhcmFtICB7Q2lyY2xlfSBzaGFwZUJcbiAqIEBwYXJhbSAge0FycmF5fSBvZmZzZXRCXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlQlxuICogQHBhcmFtIHtCb29sZWFufSBqdXN0VGVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtyYWRpdXNBXSBPcHRpb25hbCByYWRpdXMgdG8gdXNlIGZvciBzaGFwZUFcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcmFkaXVzQl0gT3B0aW9uYWwgcmFkaXVzIHRvIHVzZSBmb3Igc2hhcGVCXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVDaXJjbGUgPSBmdW5jdGlvbihcbiAgICBib2R5QSxcbiAgICBzaGFwZUEsXG4gICAgb2Zmc2V0QSxcbiAgICBhbmdsZUEsXG4gICAgYm9keUIsXG4gICAgc2hhcGVCLFxuICAgIG9mZnNldEIsXG4gICAgYW5nbGVCLFxuICAgIGp1c3RUZXN0LFxuICAgIHJhZGl1c0EsXG4gICAgcmFkaXVzQlxuKXtcblxuICAgIHZhciBkaXN0ID0gdG1wMSxcbiAgICAgICAgcmFkaXVzQSA9IHJhZGl1c0EgfHwgc2hhcGVBLnJhZGl1cyxcbiAgICAgICAgcmFkaXVzQiA9IHJhZGl1c0IgfHwgc2hhcGVCLnJhZGl1cztcblxuICAgIHN1YihkaXN0LG9mZnNldEEsb2Zmc2V0Qik7XG4gICAgdmFyIHIgPSByYWRpdXNBICsgcmFkaXVzQjtcbiAgICBpZih2ZWMyLnNxdWFyZWRMZW5ndGgoZGlzdCkgPiBNYXRoLnBvdyhyLDIpKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCLHNoYXBlQSxzaGFwZUIpO1xuICAgIHN1YihjLm5vcm1hbEEsIG9mZnNldEIsIG9mZnNldEEpO1xuICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgdmVjMi5zY2FsZSggYy5jb250YWN0UG9pbnRBLCBjLm5vcm1hbEEsICByYWRpdXNBKTtcbiAgICB2ZWMyLnNjYWxlKCBjLmNvbnRhY3RQb2ludEIsIGMubm9ybWFsQSwgLXJhZGl1c0IpO1xuXG4gICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBvZmZzZXRBKTtcbiAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGJvZHlBLnBvc2l0aW9uKTtcblxuICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50Qiwgb2Zmc2V0Qik7XG4gICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBib2R5Qi5wb3NpdGlvbik7XG5cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG59O1xuXG4vKipcbiAqIFBsYW5lL0NvbnZleCBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBwbGFuZUNvbnZleFxuICogQHBhcmFtICB7Qm9keX0gcGxhbmVCb2R5XG4gKiBAcGFyYW0gIHtQbGFuZX0gcGxhbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IHBsYW5lT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBsYW5lQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9IGNvbnZleEJvZHlcbiAqIEBwYXJhbSAge0NvbnZleH0gY29udmV4U2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBjb252ZXhPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gY29udmV4QW5nbGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0ganVzdFRlc3RcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBMQU5FIHwgU2hhcGUuQ09OVkVYXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUExBTkUgfCBTaGFwZS5SRUNUQU5HTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZUNvbnZleCA9IGZ1bmN0aW9uKFxuICAgIHBsYW5lQm9keSxcbiAgICBwbGFuZVNoYXBlLFxuICAgIHBsYW5lT2Zmc2V0LFxuICAgIHBsYW5lQW5nbGUsXG4gICAgY29udmV4Qm9keSxcbiAgICBjb252ZXhTaGFwZSxcbiAgICBjb252ZXhPZmZzZXQsXG4gICAgY29udmV4QW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgdmFyIHdvcmxkVmVydGV4ID0gdG1wMSxcbiAgICAgICAgd29ybGROb3JtYWwgPSB0bXAyLFxuICAgICAgICBkaXN0ID0gdG1wMztcblxuICAgIHZhciBudW1SZXBvcnRlZCA9IDA7XG4gICAgdmVjMi5yb3RhdGUod29ybGROb3JtYWwsIHlBeGlzLCBwbGFuZUFuZ2xlKTtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09Y29udmV4U2hhcGUudmVydGljZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdiA9IGNvbnZleFNoYXBlLnZlcnRpY2VzW2ldO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleCwgdiwgY29udmV4QW5nbGUpO1xuICAgICAgICBhZGQod29ybGRWZXJ0ZXgsIHdvcmxkVmVydGV4LCBjb252ZXhPZmZzZXQpO1xuXG4gICAgICAgIHN1YihkaXN0LCB3b3JsZFZlcnRleCwgcGxhbmVPZmZzZXQpO1xuXG4gICAgICAgIGlmKGRvdChkaXN0LHdvcmxkTm9ybWFsKSA8PSAwKXtcblxuICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGb3VuZCB2ZXJ0ZXhcbiAgICAgICAgICAgIG51bVJlcG9ydGVkKys7XG5cbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LGNvbnZleEJvZHkscGxhbmVTaGFwZSxjb252ZXhTaGFwZSk7XG5cbiAgICAgICAgICAgIHN1YihkaXN0LCB3b3JsZFZlcnRleCwgcGxhbmVPZmZzZXQpO1xuXG4gICAgICAgICAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCB3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgICAgIHZhciBkID0gZG90KGRpc3QsIGMubm9ybWFsQSk7XG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGRpc3QsIGMubm9ybWFsQSwgZCk7XG5cbiAgICAgICAgICAgIC8vIHJqIGlzIGZyb20gY29udmV4IGNlbnRlciB0byBjb250YWN0XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCB3b3JsZFZlcnRleCwgY29udmV4Qm9keS5wb3NpdGlvbik7XG5cblxuICAgICAgICAgICAgLy8gcmkgaXMgZnJvbSBwbGFuZSBjZW50ZXIgdG8gY29udGFjdFxuICAgICAgICAgICAgc3ViKCBjLmNvbnRhY3RQb2ludEEsIHdvcmxkVmVydGV4LCBkaXN0KTtcbiAgICAgICAgICAgIHN1YiggYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIHBsYW5lQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICBpZighdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uICYmIG51bVJlcG9ydGVkKXtcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtUmVwb3J0ZWQpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudW1SZXBvcnRlZDtcbn07XG5cbi8qKlxuICogTmFycm93cGhhc2UgZm9yIHBhcnRpY2xlIHZzIHBsYW5lXG4gKiBAbWV0aG9kIHBhcnRpY2xlUGxhbmVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIHBhcnRpY2xlQm9keVxuICogQHBhcmFtICB7UGFydGljbGV9ICAgcGFydGljbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcGFydGljbGVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIHBhcnRpY2xlQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIHBsYW5lQm9keVxuICogQHBhcmFtICB7UGxhbmV9ICAgICAgcGxhbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcGxhbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIHBsYW5lQW5nbGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgIGp1c3RUZXN0XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QQVJUSUNMRSB8IFNoYXBlLlBMQU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGFydGljbGVQbGFuZSA9IGZ1bmN0aW9uKFxuICAgIHBhcnRpY2xlQm9keSxcbiAgICBwYXJ0aWNsZVNoYXBlLFxuICAgIHBhcnRpY2xlT2Zmc2V0LFxuICAgIHBhcnRpY2xlQW5nbGUsXG4gICAgcGxhbmVCb2R5LFxuICAgIHBsYW5lU2hhcGUsXG4gICAgcGxhbmVPZmZzZXQsXG4gICAgcGxhbmVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICB2YXIgZGlzdCA9IHRtcDEsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gdG1wMjtcblxuICAgIHBsYW5lQW5nbGUgPSBwbGFuZUFuZ2xlIHx8IDA7XG5cbiAgICBzdWIoZGlzdCwgcGFydGljbGVPZmZzZXQsIHBsYW5lT2Zmc2V0KTtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbCwgeUF4aXMsIHBsYW5lQW5nbGUpO1xuXG4gICAgdmFyIGQgPSBkb3QoZGlzdCwgd29ybGROb3JtYWwpO1xuXG4gICAgaWYoZCA+IDApe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBsYW5lQm9keSxwYXJ0aWNsZUJvZHkscGxhbmVTaGFwZSxwYXJ0aWNsZVNoYXBlKTtcblxuICAgIHZlYzIuY29weShjLm5vcm1hbEEsIHdvcmxkTm9ybWFsKTtcbiAgICB2ZWMyLnNjYWxlKCBkaXN0LCBjLm5vcm1hbEEsIGQgKTtcbiAgICAvLyBkaXN0IGlzIG5vdyB0aGUgZGlzdGFuY2UgdmVjdG9yIGluIHRoZSBub3JtYWwgZGlyZWN0aW9uXG5cbiAgICAvLyByaSBpcyB0aGUgcGFydGljbGUgcG9zaXRpb24gcHJvamVjdGVkIGRvd24gb250byB0aGUgcGxhbmUsIGZyb20gdGhlIHBsYW5lIGNlbnRlclxuICAgIHN1YiggYy5jb250YWN0UG9pbnRBLCBwYXJ0aWNsZU9mZnNldCwgZGlzdCk7XG4gICAgc3ViKCBjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGxhbmVCb2R5LnBvc2l0aW9uKTtcblxuICAgIC8vIHJqIGlzIGZyb20gdGhlIGJvZHkgY2VudGVyIHRvIHRoZSBwYXJ0aWNsZSBjZW50ZXJcbiAgICBzdWIoIGMuY29udGFjdFBvaW50QiwgcGFydGljbGVPZmZzZXQsIHBhcnRpY2xlQm9keS5wb3NpdGlvbiApO1xuXG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgfVxuICAgIHJldHVybiAxO1xufTtcblxuLyoqXG4gKiBDaXJjbGUvUGFydGljbGUgTmFycm93cGhhc2VcbiAqIEBtZXRob2QgY2lyY2xlUGFydGljbGVcbiAqIEBwYXJhbSAge0JvZHl9IGNpcmNsZUJvZHlcbiAqIEBwYXJhbSAge0NpcmNsZX0gY2lyY2xlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBjaXJjbGVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gY2lyY2xlQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9IHBhcnRpY2xlQm9keVxuICogQHBhcmFtICB7UGFydGljbGV9IHBhcnRpY2xlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBwYXJ0aWNsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBwYXJ0aWNsZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb29sZWFufSBqdXN0VGVzdFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuUEFSVElDTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVQYXJ0aWNsZSA9IGZ1bmN0aW9uKFxuICAgIGNpcmNsZUJvZHksXG4gICAgY2lyY2xlU2hhcGUsXG4gICAgY2lyY2xlT2Zmc2V0LFxuICAgIGNpcmNsZUFuZ2xlLFxuICAgIHBhcnRpY2xlQm9keSxcbiAgICBwYXJ0aWNsZVNoYXBlLFxuICAgIHBhcnRpY2xlT2Zmc2V0LFxuICAgIHBhcnRpY2xlQW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgdmFyIGRpc3QgPSB0bXAxO1xuXG4gICAgc3ViKGRpc3QsIHBhcnRpY2xlT2Zmc2V0LCBjaXJjbGVPZmZzZXQpO1xuICAgIGlmKHZlYzIuc3F1YXJlZExlbmd0aChkaXN0KSA+IE1hdGgucG93KGNpcmNsZVNoYXBlLnJhZGl1cywgMikpe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGNpcmNsZUJvZHkscGFydGljbGVCb2R5LGNpcmNsZVNoYXBlLHBhcnRpY2xlU2hhcGUpO1xuICAgIHZlYzIuY29weShjLm5vcm1hbEEsIGRpc3QpO1xuICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgLy8gVmVjdG9yIGZyb20gY2lyY2xlIHRvIGNvbnRhY3QgcG9pbnQgaXMgdGhlIG5vcm1hbCB0aW1lcyB0aGUgY2lyY2xlIHJhZGl1c1xuICAgIHZlYzIuc2NhbGUoYy5jb250YWN0UG9pbnRBLCBjLm5vcm1hbEEsIGNpcmNsZVNoYXBlLnJhZGl1cyk7XG4gICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xuICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAvLyBWZWN0b3IgZnJvbSBwYXJ0aWNsZSBjZW50ZXIgdG8gY29udGFjdCBwb2ludCBpcyB6ZXJvXG4gICAgc3ViKGMuY29udGFjdFBvaW50QiwgcGFydGljbGVPZmZzZXQsIHBhcnRpY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbn07XG5cbnZhciBwbGFuZUNhcHN1bGVfdG1wQ2lyY2xlID0gbmV3IENpcmNsZSgxKSxcbiAgICBwbGFuZUNhcHN1bGVfdG1wMSA9IHZlYzIuY3JlYXRlKCksXG4gICAgcGxhbmVDYXBzdWxlX3RtcDIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHBsYW5lQ2Fwc3VsZV90bXAzID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIHBsYW5lQ2Fwc3VsZVxuICogQHBhcmFtICB7Qm9keX0gcGxhbmVCb2R5XG4gKiBAcGFyYW0gIHtDaXJjbGV9IHBsYW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBwbGFuZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBwbGFuZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBjYXBzdWxlQm9keVxuICogQHBhcmFtICB7UGFydGljbGV9IGNhcHN1bGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNhcHN1bGVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gY2Fwc3VsZUFuZ2xlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QTEFORSB8IFNoYXBlLkNBUFNVTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZUNhcHN1bGUgPSBmdW5jdGlvbihcbiAgICBwbGFuZUJvZHksXG4gICAgcGxhbmVTaGFwZSxcbiAgICBwbGFuZU9mZnNldCxcbiAgICBwbGFuZUFuZ2xlLFxuICAgIGNhcHN1bGVCb2R5LFxuICAgIGNhcHN1bGVTaGFwZSxcbiAgICBjYXBzdWxlT2Zmc2V0LFxuICAgIGNhcHN1bGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICB2YXIgZW5kMSA9IHBsYW5lQ2Fwc3VsZV90bXAxLFxuICAgICAgICBlbmQyID0gcGxhbmVDYXBzdWxlX3RtcDIsXG4gICAgICAgIGNpcmNsZSA9IHBsYW5lQ2Fwc3VsZV90bXBDaXJjbGUsXG4gICAgICAgIGRzdCA9IHBsYW5lQ2Fwc3VsZV90bXAzO1xuXG4gICAgLy8gQ29tcHV0ZSB3b3JsZCBlbmQgcG9zaXRpb25zXG4gICAgdmVjMi5zZXQoZW5kMSwgLWNhcHN1bGVTaGFwZS5sZW5ndGgvMiwgMCk7XG4gICAgdmVjMi5yb3RhdGUoZW5kMSxlbmQxLGNhcHN1bGVBbmdsZSk7XG4gICAgYWRkKGVuZDEsZW5kMSxjYXBzdWxlT2Zmc2V0KTtcblxuICAgIHZlYzIuc2V0KGVuZDIsICBjYXBzdWxlU2hhcGUubGVuZ3RoLzIsIDApO1xuICAgIHZlYzIucm90YXRlKGVuZDIsZW5kMixjYXBzdWxlQW5nbGUpO1xuICAgIGFkZChlbmQyLGVuZDIsY2Fwc3VsZU9mZnNldCk7XG5cbiAgICBjaXJjbGUucmFkaXVzID0gY2Fwc3VsZVNoYXBlLnJhZGl1cztcblxuICAgIHZhciBlbmFibGVGcmljdGlvbkJlZm9yZTtcblxuICAgIC8vIFRlbXBvcmFyaWx5IHR1cm4gb2ZmIGZyaWN0aW9uXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIGVuYWJsZUZyaWN0aW9uQmVmb3JlID0gdGhpcy5lbmFibGVGcmljdGlvbjtcbiAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIERvIE5hcnJvd3BoYXNlIGFzIHR3byBjaXJjbGVzXG4gICAgdmFyIG51bUNvbnRhY3RzMSA9IHRoaXMuY2lyY2xlUGxhbmUoY2Fwc3VsZUJvZHksY2lyY2xlLGVuZDEsMCwgcGxhbmVCb2R5LHBsYW5lU2hhcGUscGxhbmVPZmZzZXQscGxhbmVBbmdsZSwganVzdFRlc3QpLFxuICAgICAgICBudW1Db250YWN0czIgPSB0aGlzLmNpcmNsZVBsYW5lKGNhcHN1bGVCb2R5LGNpcmNsZSxlbmQyLDAsIHBsYW5lQm9keSxwbGFuZVNoYXBlLHBsYW5lT2Zmc2V0LHBsYW5lQW5nbGUsIGp1c3RUZXN0KTtcblxuICAgIC8vIFJlc3RvcmUgZnJpY3Rpb25cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xuICAgIH1cblxuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIG51bUNvbnRhY3RzMSB8fCBudW1Db250YWN0czI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG51bVRvdGFsID0gbnVtQ29udGFjdHMxICsgbnVtQ29udGFjdHMyO1xuICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgICAgIGlmKG51bVRvdGFsKXtcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bVRvdGFsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bVRvdGFsO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBDb250YWN0RXF1YXRpb25zIGFuZCBGcmljdGlvbkVxdWF0aW9ucyBmb3IgYSBjb2xsaXNpb24uXG4gKiBAbWV0aG9kIGNpcmNsZVBsYW5lXG4gKiBAcGFyYW0gIHtCb2R5fSAgICBiaSAgICAgVGhlIGZpcnN0IGJvZHkgdGhhdCBzaG91bGQgYmUgY29ubmVjdGVkIHRvIHRoZSBlcXVhdGlvbnMuXG4gKiBAcGFyYW0gIHtDaXJjbGV9ICBzaSAgICAgVGhlIGNpcmNsZSBzaGFwZSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb2xsaXNpb24uXG4gKiBAcGFyYW0gIHtBcnJheX0gICB4aSAgICAgRXh0cmEgb2Zmc2V0IHRvIHRha2UgaW50byBhY2NvdW50IGZvciB0aGUgU2hhcGUsIGluIGFkZGl0aW9uIHRvIHRoZSBvbmUgaW4gY2lyY2xlQm9keS5wb3NpdGlvbi4gV2lsbCAqbm90KiBiZSByb3RhdGVkIGJ5IGNpcmNsZUJvZHkuYW5nbGUgKG1heWJlIGl0IHNob3VsZCwgZm9yIHNha2Ugb2YgaG9tb2dlbml0eT8pLiBTZXQgdG8gbnVsbCBpZiBub25lLlxuICogQHBhcmFtICB7Qm9keX0gICAgYmogICAgIFRoZSBzZWNvbmQgYm9keSB0aGF0IHNob3VsZCBiZSBjb25uZWN0ZWQgdG8gdGhlIGVxdWF0aW9ucy5cbiAqIEBwYXJhbSAge1BsYW5lfSAgIHNqICAgICBUaGUgUGxhbmUgc2hhcGUgdGhhdCBpcyBwYXJ0aWNpcGF0aW5nXG4gKiBAcGFyYW0gIHtBcnJheX0gICB4aiAgICAgRXh0cmEgb2Zmc2V0IGZvciB0aGUgcGxhbmUgc2hhcGUuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBhaiAgICAgRXh0cmEgYW5nbGUgdG8gYXBwbHkgdG8gdGhlIHBsYW5lXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5QTEFORV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZVBsYW5lID0gZnVuY3Rpb24oICAgYmksc2kseGksYWksIGJqLHNqLHhqLGFqLCBqdXN0VGVzdCApe1xuICAgIHZhciBjaXJjbGVCb2R5ID0gYmksXG4gICAgICAgIGNpcmNsZVNoYXBlID0gc2ksXG4gICAgICAgIGNpcmNsZU9mZnNldCA9IHhpLCAvLyBPZmZzZXQgZnJvbSBib2R5IGNlbnRlciwgcm90YXRlZCFcbiAgICAgICAgcGxhbmVCb2R5ID0gYmosXG4gICAgICAgIHNoYXBlQiA9IHNqLFxuICAgICAgICBwbGFuZU9mZnNldCA9IHhqLFxuICAgICAgICBwbGFuZUFuZ2xlID0gYWo7XG5cbiAgICBwbGFuZUFuZ2xlID0gcGxhbmVBbmdsZSB8fCAwO1xuXG4gICAgLy8gVmVjdG9yIGZyb20gcGxhbmUgdG8gY2lyY2xlXG4gICAgdmFyIHBsYW5lVG9DaXJjbGUgPSB0bXAxLFxuICAgICAgICB3b3JsZE5vcm1hbCA9IHRtcDIsXG4gICAgICAgIHRlbXAgPSB0bXAzO1xuXG4gICAgc3ViKHBsYW5lVG9DaXJjbGUsIGNpcmNsZU9mZnNldCwgcGxhbmVPZmZzZXQpO1xuXG4gICAgLy8gV29ybGQgcGxhbmUgbm9ybWFsXG4gICAgdmVjMi5yb3RhdGUod29ybGROb3JtYWwsIHlBeGlzLCBwbGFuZUFuZ2xlKTtcblxuICAgIC8vIE5vcm1hbCBkaXJlY3Rpb24gZGlzdGFuY2VcbiAgICB2YXIgZCA9IGRvdCh3b3JsZE5vcm1hbCwgcGxhbmVUb0NpcmNsZSk7XG5cbiAgICBpZihkID4gY2lyY2xlU2hhcGUucmFkaXVzKXtcbiAgICAgICAgcmV0dXJuIDA7IC8vIE5vIG92ZXJsYXAuIEFib3J0LlxuICAgIH1cblxuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGNvbnRhY3RcbiAgICB2YXIgY29udGFjdCA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBsYW5lQm9keSxjaXJjbGVCb2R5LHNqLHNpKTtcblxuICAgIC8vIG5pIGlzIHRoZSBwbGFuZSB3b3JsZCBub3JtYWxcbiAgICB2ZWMyLmNvcHkoY29udGFjdC5ub3JtYWxBLCB3b3JsZE5vcm1hbCk7XG5cbiAgICAvLyByaiBpcyB0aGUgdmVjdG9yIGZyb20gY2lyY2xlIGNlbnRlciB0byB0aGUgY29udGFjdCBwb2ludFxuICAgIHZlYzIuc2NhbGUoY29udGFjdC5jb250YWN0UG9pbnRCLCBjb250YWN0Lm5vcm1hbEEsIC1jaXJjbGVTaGFwZS5yYWRpdXMpO1xuICAgIGFkZChjb250YWN0LmNvbnRhY3RQb2ludEIsIGNvbnRhY3QuY29udGFjdFBvaW50QiwgY2lyY2xlT2Zmc2V0KTtcbiAgICBzdWIoY29udGFjdC5jb250YWN0UG9pbnRCLCBjb250YWN0LmNvbnRhY3RQb2ludEIsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgLy8gcmkgaXMgdGhlIGRpc3RhbmNlIGZyb20gcGxhbmUgY2VudGVyIHRvIGNvbnRhY3QuXG4gICAgdmVjMi5zY2FsZSh0ZW1wLCBjb250YWN0Lm5vcm1hbEEsIGQpO1xuICAgIHN1Yihjb250YWN0LmNvbnRhY3RQb2ludEEsIHBsYW5lVG9DaXJjbGUsIHRlbXAgKTsgLy8gU3VidHJhY3Qgbm9ybWFsIGRpc3RhbmNlIHZlY3RvciBmcm9tIHRoZSBkaXN0YW5jZSB2ZWN0b3JcbiAgICBhZGQoY29udGFjdC5jb250YWN0UG9pbnRBLCBjb250YWN0LmNvbnRhY3RQb2ludEEsIHBsYW5lT2Zmc2V0KTtcbiAgICBzdWIoY29udGFjdC5jb250YWN0UG9pbnRBLCBjb250YWN0LmNvbnRhY3RQb2ludEEsIHBsYW5lQm9keS5wb3NpdGlvbik7XG5cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjb250YWN0KTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2goIHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjb250YWN0KSApO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xufTtcblxuLyoqXG4gKiBDb252ZXgvY29udmV4IE5hcnJvd3BoYXNlLlNlZSA8YSBocmVmPVwiaHR0cDovL3d3dy5hbHRkZXZibG9nYWRheS5jb20vMjAxMS8wNS8xMy9jb250YWN0LWdlbmVyYXRpb24tYmV0d2Vlbi0zZC1jb252ZXgtbWVzaGVzL1wiPnRoaXMgYXJ0aWNsZTwvYT4gZm9yIG1vcmUgaW5mby5cbiAqIEBtZXRob2QgY29udmV4Q29udmV4XG4gKiBAcGFyYW0gIHtCb2R5fSBiaVxuICogQHBhcmFtICB7Q29udmV4fSBzaVxuICogQHBhcmFtICB7QXJyYXl9IHhpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFpXG4gKiBAcGFyYW0gIHtCb2R5fSBialxuICogQHBhcmFtICB7Q29udmV4fSBzalxuICogQHBhcmFtICB7QXJyYXl9IHhqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DT05WRVhdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DT05WRVggfCBTaGFwZS5SRUNUQU5HTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5SRUNUQU5HTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhDb252ZXggPSBmdW5jdGlvbiggIGJpLHNpLHhpLGFpLCBiaixzaix4aixhaiwganVzdFRlc3QsIHByZWNpc2lvbiApe1xuICAgIHZhciBzZXBBeGlzID0gdG1wMSxcbiAgICAgICAgd29ybGRQb2ludCA9IHRtcDIsXG4gICAgICAgIHdvcmxkUG9pbnQwID0gdG1wMyxcbiAgICAgICAgd29ybGRQb2ludDEgPSB0bXA0LFxuICAgICAgICB3b3JsZEVkZ2UgPSB0bXA1LFxuICAgICAgICBwcm9qZWN0ZWQgPSB0bXA2LFxuICAgICAgICBwZW5ldHJhdGlvblZlYyA9IHRtcDcsXG4gICAgICAgIGRpc3QgPSB0bXA4LFxuICAgICAgICB3b3JsZE5vcm1hbCA9IHRtcDksXG4gICAgICAgIG51bUNvbnRhY3RzID0gMCxcbiAgICAgICAgcHJlY2lzaW9uID0gdHlwZW9mKHByZWNpc2lvbikgPT09ICdudW1iZXInID8gcHJlY2lzaW9uIDogMDtcblxuICAgIHZhciBmb3VuZCA9IE5hcnJvd3BoYXNlLmZpbmRTZXBhcmF0aW5nQXhpcyhzaSx4aSxhaSxzaix4aixhaixzZXBBeGlzKTtcbiAgICBpZighZm91bmQpe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIHNlcGFyYXRpbmcgYXhpcyBpcyBkaXJlY3RlZCBmcm9tIHNoYXBlIGkgdG8gc2hhcGUgalxuICAgIHN1YihkaXN0LHhqLHhpKTtcbiAgICBpZihkb3Qoc2VwQXhpcyxkaXN0KSA+IDApe1xuICAgICAgICB2ZWMyLnNjYWxlKHNlcEF4aXMsc2VwQXhpcywtMSk7XG4gICAgfVxuXG4gICAgLy8gRmluZCBlZGdlcyB3aXRoIG5vcm1hbHMgY2xvc2VzdCB0byB0aGUgc2VwYXJhdGluZyBheGlzXG4gICAgdmFyIGNsb3Nlc3RFZGdlMSA9IE5hcnJvd3BoYXNlLmdldENsb3Nlc3RFZGdlKHNpLGFpLHNlcEF4aXMsdHJ1ZSksIC8vIEZsaXBwZWQgYXhpc1xuICAgICAgICBjbG9zZXN0RWRnZTIgPSBOYXJyb3dwaGFzZS5nZXRDbG9zZXN0RWRnZShzaixhaixzZXBBeGlzKTtcblxuICAgIGlmKGNsb3Nlc3RFZGdlMSA9PT0gLTEgfHwgY2xvc2VzdEVkZ2UyID09PSAtMSl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIExvb3Agb3ZlciB0aGUgc2hhcGVzXG4gICAgZm9yKHZhciBrPTA7IGs8MjsgaysrKXtcblxuICAgICAgICB2YXIgY2xvc2VzdEVkZ2VBID0gY2xvc2VzdEVkZ2UxLFxuICAgICAgICAgICAgY2xvc2VzdEVkZ2VCID0gY2xvc2VzdEVkZ2UyLFxuICAgICAgICAgICAgc2hhcGVBID0gIHNpLCBzaGFwZUIgPSAgc2osXG4gICAgICAgICAgICBvZmZzZXRBID0geGksIG9mZnNldEIgPSB4aixcbiAgICAgICAgICAgIGFuZ2xlQSA9IGFpLCBhbmdsZUIgPSBhaixcbiAgICAgICAgICAgIGJvZHlBID0gYmksIGJvZHlCID0gYmo7XG5cbiAgICAgICAgaWYoayA9PT0gMCl7XG4gICAgICAgICAgICAvLyBTd2FwIVxuICAgICAgICAgICAgdmFyIHRtcDtcbiAgICAgICAgICAgIHRtcCA9IGNsb3Nlc3RFZGdlQTtcbiAgICAgICAgICAgIGNsb3Nlc3RFZGdlQSA9IGNsb3Nlc3RFZGdlQjtcbiAgICAgICAgICAgIGNsb3Nlc3RFZGdlQiA9IHRtcDtcblxuICAgICAgICAgICAgdG1wID0gc2hhcGVBO1xuICAgICAgICAgICAgc2hhcGVBID0gc2hhcGVCO1xuICAgICAgICAgICAgc2hhcGVCID0gdG1wO1xuXG4gICAgICAgICAgICB0bXAgPSBvZmZzZXRBO1xuICAgICAgICAgICAgb2Zmc2V0QSA9IG9mZnNldEI7XG4gICAgICAgICAgICBvZmZzZXRCID0gdG1wO1xuXG4gICAgICAgICAgICB0bXAgPSBhbmdsZUE7XG4gICAgICAgICAgICBhbmdsZUEgPSBhbmdsZUI7XG4gICAgICAgICAgICBhbmdsZUIgPSB0bXA7XG5cbiAgICAgICAgICAgIHRtcCA9IGJvZHlBO1xuICAgICAgICAgICAgYm9keUEgPSBib2R5QjtcbiAgICAgICAgICAgIGJvZHlCID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9vcCBvdmVyIDIgcG9pbnRzIGluIGNvbnZleCBCXG4gICAgICAgIGZvcih2YXIgaj1jbG9zZXN0RWRnZUI7IGo8Y2xvc2VzdEVkZ2VCKzI7IGorKyl7XG5cbiAgICAgICAgICAgIC8vIEdldCB3b3JsZCBwb2ludFxuICAgICAgICAgICAgdmFyIHYgPSBzaGFwZUIudmVydGljZXNbKGorc2hhcGVCLnZlcnRpY2VzLmxlbmd0aCklc2hhcGVCLnZlcnRpY2VzLmxlbmd0aF07XG4gICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50LCB2LCBhbmdsZUIpO1xuICAgICAgICAgICAgYWRkKHdvcmxkUG9pbnQsIHdvcmxkUG9pbnQsIG9mZnNldEIpO1xuXG4gICAgICAgICAgICB2YXIgaW5zaWRlTnVtRWRnZXMgPSAwO1xuXG4gICAgICAgICAgICAvLyBMb29wIG92ZXIgdGhlIDMgY2xvc2VzdCBlZGdlcyBpbiBjb252ZXggQVxuICAgICAgICAgICAgZm9yKHZhciBpPWNsb3Nlc3RFZGdlQS0xOyBpPGNsb3Nlc3RFZGdlQSsyOyBpKyspe1xuXG4gICAgICAgICAgICAgICAgdmFyIHYwID0gc2hhcGVBLnZlcnRpY2VzWyhpICArc2hhcGVBLnZlcnRpY2VzLmxlbmd0aCklc2hhcGVBLnZlcnRpY2VzLmxlbmd0aF0sXG4gICAgICAgICAgICAgICAgICAgIHYxID0gc2hhcGVBLnZlcnRpY2VzWyhpKzErc2hhcGVBLnZlcnRpY2VzLmxlbmd0aCklc2hhcGVBLnZlcnRpY2VzLmxlbmd0aF07XG5cbiAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIGVkZ2VcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50MCwgdjAsIGFuZ2xlQSk7XG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb2ludDEsIHYxLCBhbmdsZUEpO1xuICAgICAgICAgICAgICAgIGFkZCh3b3JsZFBvaW50MCwgd29ybGRQb2ludDAsIG9mZnNldEEpO1xuICAgICAgICAgICAgICAgIGFkZCh3b3JsZFBvaW50MSwgd29ybGRQb2ludDEsIG9mZnNldEEpO1xuXG4gICAgICAgICAgICAgICAgc3ViKHdvcmxkRWRnZSwgd29ybGRQb2ludDEsIHdvcmxkUG9pbnQwKTtcblxuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlOTBjdyh3b3JsZE5vcm1hbCwgd29ybGRFZGdlKTsgLy8gTm9ybWFsIHBvaW50cyBvdXQgb2YgY29udmV4IDFcbiAgICAgICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZSh3b3JsZE5vcm1hbCx3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgICAgICAgICBzdWIoZGlzdCwgd29ybGRQb2ludCwgd29ybGRQb2ludDApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBkb3Qod29ybGROb3JtYWwsZGlzdCk7XG5cbiAgICAgICAgICAgICAgICBpZigoaSA9PT0gY2xvc2VzdEVkZ2VBICYmIGQgPD0gcHJlY2lzaW9uKSB8fCAoaSAhPT0gY2xvc2VzdEVkZ2VBICYmIGQgPD0gMCkpe1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGVOdW1FZGdlcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoaW5zaWRlTnVtRWRnZXMgPj0gMyl7XG5cbiAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHdvcmxkUG9pbnQgd2FzIG9uIHRoZSBcImluc2lkZVwiIHNpZGUgb2YgZWFjaCBvZiB0aGUgMyBjaGVja2VkIGVkZ2VzLlxuICAgICAgICAgICAgICAgIC8vIFByb2plY3QgaXQgdG8gdGhlIGNlbnRlciBlZGdlIGFuZCB1c2UgdGhlIHByb2plY3Rpb24gZGlyZWN0aW9uIGFzIG5vcm1hbFxuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGNvbnRhY3RcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCLHNoYXBlQSxzaGFwZUIpO1xuICAgICAgICAgICAgICAgIG51bUNvbnRhY3RzKys7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgY2VudGVyIGVkZ2UgZnJvbSBib2R5IEFcbiAgICAgICAgICAgICAgICB2YXIgdjAgPSBzaGFwZUEudmVydGljZXNbKGNsb3Nlc3RFZGdlQSkgICAlIHNoYXBlQS52ZXJ0aWNlcy5sZW5ndGhdLFxuICAgICAgICAgICAgICAgICAgICB2MSA9IHNoYXBlQS52ZXJ0aWNlc1soY2xvc2VzdEVkZ2VBKzEpICUgc2hhcGVBLnZlcnRpY2VzLmxlbmd0aF07XG5cbiAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIGVkZ2VcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50MCwgdjAsIGFuZ2xlQSk7XG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb2ludDEsIHYxLCBhbmdsZUEpO1xuICAgICAgICAgICAgICAgIGFkZCh3b3JsZFBvaW50MCwgd29ybGRQb2ludDAsIG9mZnNldEEpO1xuICAgICAgICAgICAgICAgIGFkZCh3b3JsZFBvaW50MSwgd29ybGRQb2ludDEsIG9mZnNldEEpO1xuXG4gICAgICAgICAgICAgICAgc3ViKHdvcmxkRWRnZSwgd29ybGRQb2ludDEsIHdvcmxkUG9pbnQwKTtcblxuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlOTBjdyhjLm5vcm1hbEEsIHdvcmxkRWRnZSk7IC8vIE5vcm1hbCBwb2ludHMgb3V0IG9mIGNvbnZleCBBXG4gICAgICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLGMubm9ybWFsQSk7XG5cbiAgICAgICAgICAgICAgICBzdWIoZGlzdCwgd29ybGRQb2ludCwgd29ybGRQb2ludDApOyAvLyBGcm9tIGVkZ2UgcG9pbnQgdG8gdGhlIHBlbmV0cmF0aW5nIHBvaW50XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBkb3QoYy5ub3JtYWxBLGRpc3QpOyAgICAgICAgICAgICAvLyBQZW5ldHJhdGlvblxuICAgICAgICAgICAgICAgIHZlYzIuc2NhbGUocGVuZXRyYXRpb25WZWMsIGMubm9ybWFsQSwgZCk7ICAgICAvLyBWZWN0b3IgcGVuZXRyYXRpb25cblxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIHdvcmxkUG9pbnQsIG9mZnNldEEpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGVuZXRyYXRpb25WZWMpO1xuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgb2Zmc2V0QSk7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBib2R5QS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCB3b3JsZFBvaW50LCBvZmZzZXRCKTtcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIG9mZnNldEIpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgYm9keUIucG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgICAgICAvLyBUb2RvIHJlZHVjZSB0byAxIGZyaWN0aW9uIGVxdWF0aW9uIGlmIHdlIGhhdmUgMiBjb250YWN0IHBvaW50c1xuICAgICAgICAgICAgICAgIGlmKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uICYmIG51bUNvbnRhY3RzKXtcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtQ29udGFjdHMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudW1Db250YWN0cztcbn07XG5cbi8vIC5wcm9qZWN0Q29udmV4IGlzIGNhbGxlZCBieSBvdGhlciBmdW5jdGlvbnMsIG5lZWQgbG9jYWwgdG1wIHZlY3RvcnNcbnZhciBwY29hX3RtcDEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuLyoqXG4gKiBQcm9qZWN0IGEgQ29udmV4IG9udG8gYSB3b3JsZC1vcmllbnRlZCBheGlzXG4gKiBAbWV0aG9kIHByb2plY3RDb252ZXhPbnRvQXhpc1xuICogQHN0YXRpY1xuICogQHBhcmFtICB7Q29udmV4fSBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNvbnZleE9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjb252ZXhBbmdsZVxuICogQHBhcmFtICB7QXJyYXl9IHdvcmxkQXhpc1xuICogQHBhcmFtICB7QXJyYXl9IHJlc3VsdFxuICovXG5OYXJyb3dwaGFzZS5wcm9qZWN0Q29udmV4T250b0F4aXMgPSBmdW5jdGlvbihjb252ZXhTaGFwZSwgY29udmV4T2Zmc2V0LCBjb252ZXhBbmdsZSwgd29ybGRBeGlzLCByZXN1bHQpe1xuICAgIHZhciBtYXg9bnVsbCxcbiAgICAgICAgbWluPW51bGwsXG4gICAgICAgIHYsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBsb2NhbEF4aXMgPSBwY29hX3RtcDE7XG5cbiAgICAvLyBDb252ZXJ0IHRoZSBheGlzIHRvIGxvY2FsIGNvb3JkcyBvZiB0aGUgYm9keVxuICAgIHZlYzIucm90YXRlKGxvY2FsQXhpcywgd29ybGRBeGlzLCAtY29udmV4QW5nbGUpO1xuXG4gICAgLy8gR2V0IHByb2plY3RlZCBwb3NpdGlvbiBvZiBhbGwgdmVydGljZXNcbiAgICBmb3IodmFyIGk9MDsgaTxjb252ZXhTaGFwZS52ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHYgPSBjb252ZXhTaGFwZS52ZXJ0aWNlc1tpXTtcbiAgICAgICAgdmFsdWUgPSBkb3Qodixsb2NhbEF4aXMpO1xuICAgICAgICBpZihtYXggPT09IG51bGwgfHwgdmFsdWUgPiBtYXgpe1xuICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYobWluID09PSBudWxsIHx8IHZhbHVlIDwgbWluKXtcbiAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYobWluID4gbWF4KXtcbiAgICAgICAgdmFyIHQgPSBtaW47XG4gICAgICAgIG1pbiA9IG1heDtcbiAgICAgICAgbWF4ID0gdDtcbiAgICB9XG5cbiAgICAvLyBQcm9qZWN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgYm9keSBvbnRvIHRoZSBheGlzIC0gbmVlZCB0byBhZGQgdGhpcyB0byB0aGUgcmVzdWx0XG4gICAgdmFyIG9mZnNldCA9IGRvdChjb252ZXhPZmZzZXQsIHdvcmxkQXhpcyk7XG5cbiAgICB2ZWMyLnNldCggcmVzdWx0LCBtaW4gKyBvZmZzZXQsIG1heCArIG9mZnNldCk7XG59O1xuXG4vLyAuZmluZFNlcGFyYXRpbmdBeGlzIGlzIGNhbGxlZCBieSBvdGhlciBmdW5jdGlvbnMsIG5lZWQgbG9jYWwgdG1wIHZlY3RvcnNcbnZhciBmc2FfdG1wMSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgZnNhX3RtcDIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIGZzYV90bXAzID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICBmc2FfdG1wNCA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgZnNhX3RtcDUgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIGZzYV90bXA2ID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbi8qKlxuICogRmluZCBhIHNlcGFyYXRpbmcgYXhpcyBiZXR3ZWVuIHRoZSBzaGFwZXMsIHRoYXQgbWF4aW1pemVzIHRoZSBzZXBhcmF0aW5nIGRpc3RhbmNlIGJldHdlZW4gdGhlbS5cbiAqIEBtZXRob2QgZmluZFNlcGFyYXRpbmdBeGlzXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtDb252ZXh9ICAgICBjMVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgb2Zmc2V0MVxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYW5nbGUxXG4gKiBAcGFyYW0gIHtDb252ZXh9ICAgICBjMlxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgb2Zmc2V0MlxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYW5nbGUyXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBzZXBBeGlzICAgICBUaGUgcmVzdWx0aW5nIGF4aXNcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgIFdoZXRoZXIgdGhlIGF4aXMgY291bGQgYmUgZm91bmQuXG4gKi9cbk5hcnJvd3BoYXNlLmZpbmRTZXBhcmF0aW5nQXhpcyA9IGZ1bmN0aW9uKGMxLG9mZnNldDEsYW5nbGUxLGMyLG9mZnNldDIsYW5nbGUyLHNlcEF4aXMpe1xuICAgIHZhciBtYXhEaXN0ID0gbnVsbCxcbiAgICAgICAgb3ZlcmxhcCA9IGZhbHNlLFxuICAgICAgICBmb3VuZCA9IGZhbHNlLFxuICAgICAgICBlZGdlID0gZnNhX3RtcDEsXG4gICAgICAgIHdvcmxkUG9pbnQwID0gZnNhX3RtcDIsXG4gICAgICAgIHdvcmxkUG9pbnQxID0gZnNhX3RtcDMsXG4gICAgICAgIG5vcm1hbCA9IGZzYV90bXA0LFxuICAgICAgICBzcGFuMSA9IGZzYV90bXA1LFxuICAgICAgICBzcGFuMiA9IGZzYV90bXA2O1xuXG4gICAgaWYoYzEgaW5zdGFuY2VvZiBSZWN0YW5nbGUgJiYgYzIgaW5zdGFuY2VvZiBSZWN0YW5nbGUpe1xuXG4gICAgICAgIGZvcih2YXIgaj0wOyBqIT09MjsgaisrKXtcbiAgICAgICAgICAgIHZhciBjID0gYzEsXG4gICAgICAgICAgICAgICAgYW5nbGUgPSBhbmdsZTE7XG4gICAgICAgICAgICBpZihqPT09MSl7XG4gICAgICAgICAgICAgICAgYyA9IGMyO1xuICAgICAgICAgICAgICAgIGFuZ2xlID0gYW5nbGUyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaSE9PTI7IGkrKyl7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHdvcmxkIGVkZ2VcbiAgICAgICAgICAgICAgICBpZihpID09PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5zZXQobm9ybWFsLCAwLCAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoaSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2ZWMyLnNldChub3JtYWwsIDEsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihhbmdsZSAhPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgIHZlYzIucm90YXRlKG5vcm1hbCwgbm9ybWFsLCBhbmdsZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUHJvamVjdCBodWxscyBvbnRvIHRoYXQgbm9ybWFsXG4gICAgICAgICAgICAgICAgTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzKGMxLG9mZnNldDEsYW5nbGUxLG5vcm1hbCxzcGFuMSk7XG4gICAgICAgICAgICAgICAgTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzKGMyLG9mZnNldDIsYW5nbGUyLG5vcm1hbCxzcGFuMik7XG5cbiAgICAgICAgICAgICAgICAvLyBPcmRlciBieSBzcGFuIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdmFyIGE9c3BhbjEsXG4gICAgICAgICAgICAgICAgICAgIGI9c3BhbjIsXG4gICAgICAgICAgICAgICAgICAgIHN3YXBwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZihzcGFuMVswXSA+IHNwYW4yWzBdKXtcbiAgICAgICAgICAgICAgICAgICAgYj1zcGFuMTtcbiAgICAgICAgICAgICAgICAgICAgYT1zcGFuMjtcbiAgICAgICAgICAgICAgICAgICAgc3dhcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHNlcGFyYXRpbmcgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGJbMF0gLSBhWzFdO1xuICAgICAgICAgICAgICAgIG92ZXJsYXAgPSAoZGlzdCA8PSAwKTtcblxuICAgICAgICAgICAgICAgIGlmKG1heERpc3Q9PT1udWxsIHx8IGRpc3QgPiBtYXhEaXN0KXtcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5jb3B5KHNlcEF4aXMsIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIG1heERpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IG92ZXJsYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIGZvcih2YXIgaj0wOyBqIT09MjsgaisrKXtcbiAgICAgICAgICAgIHZhciBjID0gYzEsXG4gICAgICAgICAgICAgICAgYW5nbGUgPSBhbmdsZTE7XG4gICAgICAgICAgICBpZihqPT09MSl7XG4gICAgICAgICAgICAgICAgYyA9IGMyO1xuICAgICAgICAgICAgICAgIGFuZ2xlID0gYW5nbGUyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaSE9PWMudmVydGljZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgd29ybGQgZWRnZVxuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9pbnQwLCBjLnZlcnRpY2VzW2ldLCBhbmdsZSk7XG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb2ludDEsIGMudmVydGljZXNbKGkrMSklYy52ZXJ0aWNlcy5sZW5ndGhdLCBhbmdsZSk7XG5cbiAgICAgICAgICAgICAgICBzdWIoZWRnZSwgd29ybGRQb2ludDEsIHdvcmxkUG9pbnQwKTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBub3JtYWwgLSBqdXN0IHJvdGF0ZSA5MCBkZWdyZWVzIHNpbmNlIHZlcnRpY2VzIGFyZSBnaXZlbiBpbiBDQ1dcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZTkwY3cobm9ybWFsLCBlZGdlKTtcbiAgICAgICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShub3JtYWwsbm9ybWFsKTtcblxuICAgICAgICAgICAgICAgIC8vIFByb2plY3QgaHVsbHMgb250byB0aGF0IG5vcm1hbFxuICAgICAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb2plY3RDb252ZXhPbnRvQXhpcyhjMSxvZmZzZXQxLGFuZ2xlMSxub3JtYWwsc3BhbjEpO1xuICAgICAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb2plY3RDb252ZXhPbnRvQXhpcyhjMixvZmZzZXQyLGFuZ2xlMixub3JtYWwsc3BhbjIpO1xuXG4gICAgICAgICAgICAgICAgLy8gT3JkZXIgYnkgc3BhbiBwb3NpdGlvblxuICAgICAgICAgICAgICAgIHZhciBhPXNwYW4xLFxuICAgICAgICAgICAgICAgICAgICBiPXNwYW4yLFxuICAgICAgICAgICAgICAgICAgICBzd2FwcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYoc3BhbjFbMF0gPiBzcGFuMlswXSl7XG4gICAgICAgICAgICAgICAgICAgIGI9c3BhbjE7XG4gICAgICAgICAgICAgICAgICAgIGE9c3BhbjI7XG4gICAgICAgICAgICAgICAgICAgIHN3YXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEdldCBzZXBhcmF0aW5nIGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBiWzBdIC0gYVsxXTtcbiAgICAgICAgICAgICAgICBvdmVybGFwID0gKGRpc3QgPD0gMCk7XG5cbiAgICAgICAgICAgICAgICBpZihtYXhEaXN0PT09bnVsbCB8fCBkaXN0ID4gbWF4RGlzdCl7XG4gICAgICAgICAgICAgICAgICAgIHZlYzIuY29weShzZXBBeGlzLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICBtYXhEaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLypcbiAgICAvLyBOZWVkcyB0byBiZSB0ZXN0ZWQgc29tZSBtb3JlXG4gICAgZm9yKHZhciBqPTA7IGohPT0yOyBqKyspe1xuICAgICAgICB2YXIgYyA9IGMxLFxuICAgICAgICAgICAgYW5nbGUgPSBhbmdsZTE7XG4gICAgICAgIGlmKGo9PT0xKXtcbiAgICAgICAgICAgIGMgPSBjMjtcbiAgICAgICAgICAgIGFuZ2xlID0gYW5nbGUyO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1jLmF4ZXMubGVuZ3RoOyBpKyspe1xuXG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gYy5heGVzW2ldO1xuXG4gICAgICAgICAgICAvLyBQcm9qZWN0IGh1bGxzIG9udG8gdGhhdCBub3JtYWxcbiAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb2plY3RDb252ZXhPbnRvQXhpcyhjMSwgb2Zmc2V0MSwgYW5nbGUxLCBub3JtYWwsIHNwYW4xKTtcbiAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb2plY3RDb252ZXhPbnRvQXhpcyhjMiwgb2Zmc2V0MiwgYW5nbGUyLCBub3JtYWwsIHNwYW4yKTtcblxuICAgICAgICAgICAgLy8gT3JkZXIgYnkgc3BhbiBwb3NpdGlvblxuICAgICAgICAgICAgdmFyIGE9c3BhbjEsXG4gICAgICAgICAgICAgICAgYj1zcGFuMixcbiAgICAgICAgICAgICAgICBzd2FwcGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZihzcGFuMVswXSA+IHNwYW4yWzBdKXtcbiAgICAgICAgICAgICAgICBiPXNwYW4xO1xuICAgICAgICAgICAgICAgIGE9c3BhbjI7XG4gICAgICAgICAgICAgICAgc3dhcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCBzZXBhcmF0aW5nIGRpc3RhbmNlXG4gICAgICAgICAgICB2YXIgZGlzdCA9IGJbMF0gLSBhWzFdO1xuICAgICAgICAgICAgb3ZlcmxhcCA9IChkaXN0IDw9IE5hcnJvd3BoYXNlLmNvbnZleFByZWNpc2lvbik7XG5cbiAgICAgICAgICAgIGlmKG1heERpc3Q9PT1udWxsIHx8IGRpc3QgPiBtYXhEaXN0KXtcbiAgICAgICAgICAgICAgICB2ZWMyLmNvcHkoc2VwQXhpcywgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICBtYXhEaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IG92ZXJsYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgKi9cblxuICAgIHJldHVybiBmb3VuZDtcbn07XG5cbi8vIC5nZXRDbG9zZXN0RWRnZSBpcyBjYWxsZWQgYnkgb3RoZXIgZnVuY3Rpb25zLCBuZWVkIGxvY2FsIHRtcCB2ZWN0b3JzXG52YXIgZ2NlX3RtcDEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIGdjZV90bXAyID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICBnY2VfdG1wMyA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4vKipcbiAqIEdldCB0aGUgZWRnZSB0aGF0IGhhcyBhIG5vcm1hbCBjbG9zZXN0IHRvIGFuIGF4aXMuXG4gKiBAbWV0aG9kIGdldENsb3Nlc3RFZGdlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtDb252ZXh9ICAgICBjXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhbmdsZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgYXhpc1xuICogQHBhcmFtICB7Qm9vbGVhbn0gICAgZmxpcFxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICBJbmRleCBvZiB0aGUgZWRnZSB0aGF0IGlzIGNsb3Nlc3QuIFRoaXMgaW5kZXggYW5kIHRoZSBuZXh0IHNwYW5zIHRoZSByZXN1bHRpbmcgZWRnZS4gUmV0dXJucyAtMSBpZiBmYWlsZWQuXG4gKi9cbk5hcnJvd3BoYXNlLmdldENsb3Nlc3RFZGdlID0gZnVuY3Rpb24oYyxhbmdsZSxheGlzLGZsaXApe1xuICAgIHZhciBsb2NhbEF4aXMgPSBnY2VfdG1wMSxcbiAgICAgICAgZWRnZSA9IGdjZV90bXAyLFxuICAgICAgICBub3JtYWwgPSBnY2VfdG1wMztcblxuICAgIC8vIENvbnZlcnQgdGhlIGF4aXMgdG8gbG9jYWwgY29vcmRzIG9mIHRoZSBib2R5XG4gICAgdmVjMi5yb3RhdGUobG9jYWxBeGlzLCBheGlzLCAtYW5nbGUpO1xuICAgIGlmKGZsaXApe1xuICAgICAgICB2ZWMyLnNjYWxlKGxvY2FsQXhpcyxsb2NhbEF4aXMsLTEpO1xuICAgIH1cblxuICAgIHZhciBjbG9zZXN0RWRnZSA9IC0xLFxuICAgICAgICBOID0gYy52ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgIG1heERvdCA9IC0xO1xuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgLy8gR2V0IHRoZSBlZGdlXG4gICAgICAgIHN1YihlZGdlLCBjLnZlcnRpY2VzWyhpKzEpJU5dLCBjLnZlcnRpY2VzW2klTl0pO1xuXG4gICAgICAgIC8vIEdldCBub3JtYWwgLSBqdXN0IHJvdGF0ZSA5MCBkZWdyZWVzIHNpbmNlIHZlcnRpY2VzIGFyZSBnaXZlbiBpbiBDQ1dcbiAgICAgICAgdmVjMi5yb3RhdGU5MGN3KG5vcm1hbCwgZWRnZSk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCxub3JtYWwpO1xuXG4gICAgICAgIHZhciBkID0gZG90KG5vcm1hbCxsb2NhbEF4aXMpO1xuICAgICAgICBpZihjbG9zZXN0RWRnZSA9PT0gLTEgfHwgZCA+IG1heERvdCl7XG4gICAgICAgICAgICBjbG9zZXN0RWRnZSA9IGkgJSBOO1xuICAgICAgICAgICAgbWF4RG90ID0gZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9zZXN0RWRnZTtcbn07XG5cbnZhciBjaXJjbGVIZWlnaHRmaWVsZF9jYW5kaWRhdGUgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNpcmNsZUhlaWdodGZpZWxkX2Rpc3QgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNpcmNsZUhlaWdodGZpZWxkX3YwID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjaXJjbGVIZWlnaHRmaWVsZF92MSA9IHZlYzIuY3JlYXRlKCksXG4gICAgY2lyY2xlSGVpZ2h0ZmllbGRfbWluQ2FuZGlkYXRlID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjaXJjbGVIZWlnaHRmaWVsZF93b3JsZE5vcm1hbCA9IHZlYzIuY3JlYXRlKCksXG4gICAgY2lyY2xlSGVpZ2h0ZmllbGRfbWluQ2FuZGlkYXRlTm9ybWFsID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGNpcmNsZUhlaWdodGZpZWxkXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICAgICAgYmlcbiAqIEBwYXJhbSAge0NpcmNsZX0gICAgICAgICBzaVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgIHhpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICAgICAgYmpcbiAqIEBwYXJhbSAge0hlaWdodGZpZWxkfSAgICBzalxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgIHhqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICAgYWpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkhFSUdIVEZJRUxEXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlSGVpZ2h0ZmllbGQgPSBmdW5jdGlvbiggY2lyY2xlQm9keSxjaXJjbGVTaGFwZSxjaXJjbGVQb3MsY2lyY2xlQW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGZCb2R5LGhmU2hhcGUsaGZQb3MsaGZBbmdsZSwganVzdFRlc3QsIHJhZGl1cyApe1xuICAgIHZhciBkYXRhID0gaGZTaGFwZS5kYXRhLFxuICAgICAgICByYWRpdXMgPSByYWRpdXMgfHwgY2lyY2xlU2hhcGUucmFkaXVzLFxuICAgICAgICB3ID0gaGZTaGFwZS5lbGVtZW50V2lkdGgsXG4gICAgICAgIGRpc3QgPSBjaXJjbGVIZWlnaHRmaWVsZF9kaXN0LFxuICAgICAgICBjYW5kaWRhdGUgPSBjaXJjbGVIZWlnaHRmaWVsZF9jYW5kaWRhdGUsXG4gICAgICAgIG1pbkNhbmRpZGF0ZSA9IGNpcmNsZUhlaWdodGZpZWxkX21pbkNhbmRpZGF0ZSxcbiAgICAgICAgbWluQ2FuZGlkYXRlTm9ybWFsID0gY2lyY2xlSGVpZ2h0ZmllbGRfbWluQ2FuZGlkYXRlTm9ybWFsLFxuICAgICAgICB3b3JsZE5vcm1hbCA9IGNpcmNsZUhlaWdodGZpZWxkX3dvcmxkTm9ybWFsLFxuICAgICAgICB2MCA9IGNpcmNsZUhlaWdodGZpZWxkX3YwLFxuICAgICAgICB2MSA9IGNpcmNsZUhlaWdodGZpZWxkX3YxO1xuXG4gICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgcG9pbnRzIHRvIHRlc3QgYWdhaW5zdFxuICAgIHZhciBpZHhBID0gTWF0aC5mbG9vciggKGNpcmNsZVBvc1swXSAtIHJhZGl1cyAtIGhmUG9zWzBdKSAvIHcgKSxcbiAgICAgICAgaWR4QiA9IE1hdGguY2VpbCggIChjaXJjbGVQb3NbMF0gKyByYWRpdXMgLSBoZlBvc1swXSkgLyB3ICk7XG5cbiAgICAvKmlmKGlkeEIgPCAwIHx8IGlkeEEgPj0gZGF0YS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBqdXN0VGVzdCA/IGZhbHNlIDogMDsqL1xuXG4gICAgaWYoaWR4QSA8IDApe1xuICAgICAgICBpZHhBID0gMDtcbiAgICB9XG4gICAgaWYoaWR4QiA+PSBkYXRhLmxlbmd0aCl7XG4gICAgICAgIGlkeEIgPSBkYXRhLmxlbmd0aC0xO1xuICAgIH1cblxuICAgIC8vIEdldCBtYXggYW5kIG1pblxuICAgIHZhciBtYXggPSBkYXRhW2lkeEFdLFxuICAgICAgICBtaW4gPSBkYXRhW2lkeEJdO1xuICAgIGZvcih2YXIgaT1pZHhBOyBpPGlkeEI7IGkrKyl7XG4gICAgICAgIGlmKGRhdGFbaV0gPCBtaW4pe1xuICAgICAgICAgICAgbWluID0gZGF0YVtpXTtcbiAgICAgICAgfVxuICAgICAgICBpZihkYXRhW2ldID4gbWF4KXtcbiAgICAgICAgICAgIG1heCA9IGRhdGFbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihjaXJjbGVQb3NbMV0tcmFkaXVzID4gbWF4KXtcbiAgICAgICAgcmV0dXJuIGp1c3RUZXN0ID8gZmFsc2UgOiAwO1xuICAgIH1cblxuICAgIC8qXG4gICAgaWYoY2lyY2xlUG9zWzFdK3JhZGl1cyA8IG1pbil7XG4gICAgICAgIC8vIEJlbG93IHRoZSBtaW5pbXVtIHBvaW50Li4uIFdlIGNhbiBqdXN0IGd1ZXNzLlxuICAgICAgICAvLyBUT0RPXG4gICAgfVxuICAgICovXG5cbiAgICAvLyAxLiBDaGVjayBzbyBjZW50ZXIgb2YgY2lyY2xlIGlzIG5vdCBpbnNpZGUgdGhlIGZpZWxkLiBJZiBpdCBpcywgdGhpcyB3b250IHdvcmsuLi5cbiAgICAvLyAyLiBGb3IgZWFjaCBlZGdlXG4gICAgLy8gMi4gMS4gR2V0IHBvaW50IG9uIGNpcmNsZSB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIGVkZ2UgKHNjYWxlIG5vcm1hbCB3aXRoIC1yYWRpdXMpXG4gICAgLy8gMi4gMi4gQ2hlY2sgaWYgcG9pbnQgaXMgaW5zaWRlLlxuXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBhbGwgZWRnZXMgZmlyc3RcbiAgICBmb3IodmFyIGk9aWR4QTsgaTxpZHhCOyBpKyspe1xuXG4gICAgICAgIC8vIEdldCBwb2ludHNcbiAgICAgICAgdmVjMi5zZXQodjAsICAgICBpKncsIGRhdGFbaV0gICk7XG4gICAgICAgIHZlYzIuc2V0KHYxLCAoaSsxKSp3LCBkYXRhW2krMV0pO1xuICAgICAgICB2ZWMyLmFkZCh2MCx2MCxoZlBvcyk7XG4gICAgICAgIHZlYzIuYWRkKHYxLHYxLGhmUG9zKTtcblxuICAgICAgICAvLyBHZXQgbm9ybWFsXG4gICAgICAgIHZlYzIuc3ViKHdvcmxkTm9ybWFsLCB2MSwgdjApO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbCwgd29ybGROb3JtYWwsIE1hdGguUEkvMik7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKHdvcmxkTm9ybWFsLHdvcmxkTm9ybWFsKTtcblxuICAgICAgICAvLyBHZXQgcG9pbnQgb24gY2lyY2xlLCBjbG9zZXN0IHRvIHRoZSBlZGdlXG4gICAgICAgIHZlYzIuc2NhbGUoY2FuZGlkYXRlLHdvcmxkTm9ybWFsLC1yYWRpdXMpO1xuICAgICAgICB2ZWMyLmFkZChjYW5kaWRhdGUsY2FuZGlkYXRlLGNpcmNsZVBvcyk7XG5cbiAgICAgICAgLy8gRGlzdGFuY2UgZnJvbSB2MCB0byB0aGUgY2FuZGlkYXRlIHBvaW50XG4gICAgICAgIHZlYzIuc3ViKGRpc3QsY2FuZGlkYXRlLHYwKTtcblxuICAgICAgICAvLyBDaGVjayBpZiBpdCBpcyBpbiB0aGUgZWxlbWVudCBcInN0aWNrXCJcbiAgICAgICAgdmFyIGQgPSB2ZWMyLmRvdChkaXN0LHdvcmxkTm9ybWFsKTtcbiAgICAgICAgaWYoY2FuZGlkYXRlWzBdID49IHYwWzBdICYmIGNhbmRpZGF0ZVswXSA8IHYxWzBdICYmIGQgPD0gMCl7XG5cbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgY2FuZGlkYXRlIHBvaW50LCBwcm9qZWN0ZWQgdG8gdGhlIGVkZ2VcbiAgICAgICAgICAgIHZlYzIuc2NhbGUoZGlzdCx3b3JsZE5vcm1hbCwtZCk7XG4gICAgICAgICAgICB2ZWMyLmFkZChtaW5DYW5kaWRhdGUsY2FuZGlkYXRlLGRpc3QpO1xuICAgICAgICAgICAgdmVjMi5jb3B5KG1pbkNhbmRpZGF0ZU5vcm1hbCx3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oaGZCb2R5LGNpcmNsZUJvZHksaGZTaGFwZSxjaXJjbGVTaGFwZSk7XG5cbiAgICAgICAgICAgIC8vIE5vcm1hbCBpcyBvdXQgb2YgdGhlIGhlaWdodGZpZWxkXG4gICAgICAgICAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCBtaW5DYW5kaWRhdGVOb3JtYWwpO1xuXG4gICAgICAgICAgICAvLyBWZWN0b3IgZnJvbSBjaXJjbGUgdG8gaGVpZ2h0ZmllbGRcbiAgICAgICAgICAgIHZlYzIuc2NhbGUoYy5jb250YWN0UG9pbnRCLCAgYy5ub3JtYWxBLCAtcmFkaXVzKTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY2lyY2xlUG9zKTtcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHZlYzIuY29weShjLmNvbnRhY3RQb2ludEEsIG1pbkNhbmRpZGF0ZSk7XG4gICAgICAgICAgICB2ZWMyLnN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgaGZCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCggdGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBhbGwgdmVydGljZXNcbiAgICBmb3VuZCA9IGZhbHNlO1xuICAgIGlmKHJhZGl1cyA+IDApe1xuICAgICAgICBmb3IodmFyIGk9aWR4QTsgaTw9aWR4QjsgaSsrKXtcblxuICAgICAgICAgICAgLy8gR2V0IHBvaW50XG4gICAgICAgICAgICB2ZWMyLnNldCh2MCwgaSp3LCBkYXRhW2ldKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKHYwLHYwLGhmUG9zKTtcblxuICAgICAgICAgICAgdmVjMi5zdWIoZGlzdCwgY2lyY2xlUG9zLCB2MCk7XG5cbiAgICAgICAgICAgIGlmKHZlYzIuc3F1YXJlZExlbmd0aChkaXN0KSA8IE1hdGgucG93KHJhZGl1cywgMikpe1xuXG4gICAgICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGhmQm9keSxjaXJjbGVCb2R5LGhmU2hhcGUsY2lyY2xlU2hhcGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IG5vcm1hbCAtIG91dCBvZiBoZWlnaHRmaWVsZFxuICAgICAgICAgICAgICAgIHZlYzIuY29weShjLm5vcm1hbEEsIGRpc3QpO1xuICAgICAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgICAgICAgICAgICAgdmVjMi5zY2FsZShjLmNvbnRhY3RQb2ludEIsIGMubm9ybWFsQSwgLXJhZGl1cyk7XG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjaXJjbGVQb3MpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCB2MCwgaGZQb3MpO1xuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgaGZQb3MpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgaGZCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGZvdW5kKXtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG5cbn07XG5cbnZhciBjb252ZXhIZWlnaHRmaWVsZF92MCA9IHZlYzIuY3JlYXRlKCksXG4gICAgY29udmV4SGVpZ2h0ZmllbGRfdjEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvbnZleEhlaWdodGZpZWxkX3RpbGVQb3MgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvbnZleEhlaWdodGZpZWxkX3RlbXBDb252ZXhTaGFwZSA9IG5ldyBDb252ZXgoW3ZlYzIuY3JlYXRlKCksdmVjMi5jcmVhdGUoKSx2ZWMyLmNyZWF0ZSgpLHZlYzIuY3JlYXRlKCldKTtcbi8qKlxuICogQG1ldGhvZCBjaXJjbGVIZWlnaHRmaWVsZFxuICogQHBhcmFtICB7Qm9keX0gICAgICAgICAgIGJpXG4gKiBAcGFyYW0gIHtDaXJjbGV9ICAgICAgICAgc2lcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICB4aVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgICAgIGJqXG4gKiBAcGFyYW0gIHtIZWlnaHRmaWVsZH0gICAgc2pcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICB4alxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgIGFqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5SRUNUQU5HTEUgfCBTaGFwZS5IRUlHSFRGSUVMRF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNPTlZFWCB8IFNoYXBlLkhFSUdIVEZJRUxEXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4SGVpZ2h0ZmllbGQgPSBmdW5jdGlvbiggY29udmV4Qm9keSxjb252ZXhTaGFwZSxjb252ZXhQb3MsY29udmV4QW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGZCb2R5LGhmU2hhcGUsaGZQb3MsaGZBbmdsZSwganVzdFRlc3QgKXtcbiAgICB2YXIgZGF0YSA9IGhmU2hhcGUuZGF0YSxcbiAgICAgICAgdyA9IGhmU2hhcGUuZWxlbWVudFdpZHRoLFxuICAgICAgICB2MCA9IGNvbnZleEhlaWdodGZpZWxkX3YwLFxuICAgICAgICB2MSA9IGNvbnZleEhlaWdodGZpZWxkX3YxLFxuICAgICAgICB0aWxlUG9zID0gY29udmV4SGVpZ2h0ZmllbGRfdGlsZVBvcyxcbiAgICAgICAgdGlsZUNvbnZleCA9IGNvbnZleEhlaWdodGZpZWxkX3RlbXBDb252ZXhTaGFwZTtcblxuICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIHBvaW50cyB0byB0ZXN0IGFnYWluc3RcbiAgICB2YXIgaWR4QSA9IE1hdGguZmxvb3IoIChjb252ZXhCb2R5LmFhYmIubG93ZXJCb3VuZFswXSAtIGhmUG9zWzBdKSAvIHcgKSxcbiAgICAgICAgaWR4QiA9IE1hdGguY2VpbCggIChjb252ZXhCb2R5LmFhYmIudXBwZXJCb3VuZFswXSAtIGhmUG9zWzBdKSAvIHcgKTtcblxuICAgIGlmKGlkeEEgPCAwKXtcbiAgICAgICAgaWR4QSA9IDA7XG4gICAgfVxuICAgIGlmKGlkeEIgPj0gZGF0YS5sZW5ndGgpe1xuICAgICAgICBpZHhCID0gZGF0YS5sZW5ndGgtMTtcbiAgICB9XG5cbiAgICAvLyBHZXQgbWF4IGFuZCBtaW5cbiAgICB2YXIgbWF4ID0gZGF0YVtpZHhBXSxcbiAgICAgICAgbWluID0gZGF0YVtpZHhCXTtcbiAgICBmb3IodmFyIGk9aWR4QTsgaTxpZHhCOyBpKyspe1xuICAgICAgICBpZihkYXRhW2ldIDwgbWluKXtcbiAgICAgICAgICAgIG1pbiA9IGRhdGFbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYoZGF0YVtpXSA+IG1heCl7XG4gICAgICAgICAgICBtYXggPSBkYXRhW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoY29udmV4Qm9keS5hYWJiLmxvd2VyQm91bmRbMV0gPiBtYXgpe1xuICAgICAgICByZXR1cm4ganVzdFRlc3QgPyBmYWxzZSA6IDA7XG4gICAgfVxuXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgdmFyIG51bUNvbnRhY3RzID0gMDtcblxuICAgIC8vIExvb3Agb3ZlciBhbGwgZWRnZXNcbiAgICAvLyBUT0RPOiBJZiBwb3NzaWJsZSwgY29uc3RydWN0IGEgY29udmV4IGZyb20gc2V2ZXJhbCBkYXRhIHBvaW50cyAobmVlZCBvIGNoZWNrIGlmIHRoZSBwb2ludHMgbWFrZSBhIGNvbnZleCBzaGFwZSlcbiAgICBmb3IodmFyIGk9aWR4QTsgaTxpZHhCOyBpKyspe1xuXG4gICAgICAgIC8vIEdldCBwb2ludHNcbiAgICAgICAgdmVjMi5zZXQodjAsICAgICBpKncsIGRhdGFbaV0gICk7XG4gICAgICAgIHZlYzIuc2V0KHYxLCAoaSsxKSp3LCBkYXRhW2krMV0pO1xuICAgICAgICB2ZWMyLmFkZCh2MCx2MCxoZlBvcyk7XG4gICAgICAgIHZlYzIuYWRkKHYxLHYxLGhmUG9zKTtcblxuICAgICAgICAvLyBDb25zdHJ1Y3QgYSBjb252ZXhcbiAgICAgICAgdmFyIHRpbGVIZWlnaHQgPSAxMDA7IC8vIHRvZG9cbiAgICAgICAgdmVjMi5zZXQodGlsZVBvcywgKHYxWzBdICsgdjBbMF0pKjAuNSwgKHYxWzFdICsgdjBbMV0gLSB0aWxlSGVpZ2h0KSowLjUpO1xuXG4gICAgICAgIHZlYzIuc3ViKHRpbGVDb252ZXgudmVydGljZXNbMF0sIHYxLCB0aWxlUG9zKTtcbiAgICAgICAgdmVjMi5zdWIodGlsZUNvbnZleC52ZXJ0aWNlc1sxXSwgdjAsIHRpbGVQb3MpO1xuICAgICAgICB2ZWMyLmNvcHkodGlsZUNvbnZleC52ZXJ0aWNlc1syXSwgdGlsZUNvbnZleC52ZXJ0aWNlc1sxXSk7XG4gICAgICAgIHZlYzIuY29weSh0aWxlQ29udmV4LnZlcnRpY2VzWzNdLCB0aWxlQ29udmV4LnZlcnRpY2VzWzBdKTtcbiAgICAgICAgdGlsZUNvbnZleC52ZXJ0aWNlc1syXVsxXSAtPSB0aWxlSGVpZ2h0O1xuICAgICAgICB0aWxlQ29udmV4LnZlcnRpY2VzWzNdWzFdIC09IHRpbGVIZWlnaHQ7XG5cbiAgICAgICAgLy8gRG8gY29udmV4IGNvbGxpc2lvblxuICAgICAgICBudW1Db250YWN0cyArPSB0aGlzLmNvbnZleENvbnZleCggICBjb252ZXhCb2R5LCBjb252ZXhTaGFwZSwgY29udmV4UG9zLCBjb252ZXhBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGZCb2R5LCB0aWxlQ29udmV4LCB0aWxlUG9zLCAwLCBqdXN0VGVzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bUNvbnRhY3RzO1xufTtcbn0se1wiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjIyLFwiLi4vZXF1YXRpb25zL0VxdWF0aW9uXCI6MjMsXCIuLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvblwiOjI0LFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi9vYmplY3RzL0JvZHlcIjozMixcIi4uL3NoYXBlcy9DaXJjbGVcIjozOCxcIi4uL3NoYXBlcy9Db252ZXhcIjozOSxcIi4uL3NoYXBlcy9SZWN0YW5nbGVcIjo0NCxcIi4uL3NoYXBlcy9TaGFwZVwiOjQ1LFwiLi4vdXRpbHMvVHVwbGVEaWN0aW9uYXJ5XCI6NDksXCIuLi91dGlscy9VdGlsc1wiOjUwfV0sMTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBSYXk7XG5cbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG52YXIgUmF5Y2FzdFJlc3VsdCA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0Jyk7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKTtcbnZhciBBQUJCID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0FBQkInKTtcblxuLyoqXG4gKiBBIGxpbmUgd2l0aCBhIHN0YXJ0IGFuZCBlbmQgcG9pbnQgdGhhdCBpcyB1c2VkIHRvIGludGVyc2VjdCBzaGFwZXMuXG4gKiBAY2xhc3MgUmF5XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUmF5KG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gZnJvbVxuICAgICAqL1xuICAgIHRoaXMuZnJvbSA9IG9wdGlvbnMuZnJvbSA/IHZlYzIuZnJvbVZhbHVlcyhvcHRpb25zLmZyb21bMF0sIG9wdGlvbnMuZnJvbVsxXSkgOiB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gdG9cbiAgICAgKi9cbiAgICB0aGlzLnRvID0gb3B0aW9ucy50byA/IHZlYzIuZnJvbVZhbHVlcyhvcHRpb25zLnRvWzBdLCBvcHRpb25zLnRvWzFdKSA6IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IF9kaXJlY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLl9kaXJlY3Rpb24gPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZWNpc2lvbiBvZiB0aGUgcmF5LiBVc2VkIHdoZW4gY2hlY2tpbmcgcGFyYWxsZWxpdHkgZXRjLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBwcmVjaXNpb25cbiAgICAgKi9cbiAgICB0aGlzLnByZWNpc2lvbiA9IDAuMDAwMTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRoZSBSYXkgdG8gdGFrZSAuY29sbGlzaW9uUmVzcG9uc2UgZmxhZ3MgaW50byBhY2NvdW50IG9uIGJvZGllcyBhbmQgc2hhcGVzLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY2hlY2tDb2xsaXNpb25SZXNwb25zZVxuICAgICAqL1xuICAgIHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHJheSBza2lwcyBhbnkgaGl0cyB3aXRoIG5vcm1hbC5kb3QocmF5RGlyZWN0aW9uKSA8IDAuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBza2lwQmFja2ZhY2VzXG4gICAgICovXG4gICAgdGhpcy5za2lwQmFja2ZhY2VzID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY29sbGlzaW9uTWFza1xuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25NYXNrID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY29sbGlzaW9uR3JvdXBcbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uR3JvdXAgPSAtMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcnNlY3Rpb24gbW9kZS4gU2hvdWxkIGJlIFJheS5BTlksIFJheS5BTEwgb3IgUmF5LkNMT1NFU1QuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1vZGVcbiAgICAgKi9cbiAgICB0aGlzLm1vZGUgPSBSYXkuQU5ZO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCByZXN1bHQgb2JqZWN0LlxuICAgICAqIEBwcm9wZXJ0eSB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gICAgICovXG4gICAgdGhpcy5yZXN1bHQgPSBuZXcgUmF5Y2FzdFJlc3VsdCgpO1xuXG4gICAgLyoqXG4gICAgICogV2lsbCBiZSBzZXQgdG8gdHJ1ZSBkdXJpbmcgaW50ZXJzZWN0V29ybGQoKSBpZiB0aGUgcmF5IGhpdCBhbnl0aGluZy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGhhc0hpdFxuICAgICAqL1xuICAgIHRoaXMuaGFzSGl0ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50LCB1c2VyLXByb3ZpZGVkIHJlc3VsdCBjYWxsYmFjay4gV2lsbCBiZSB1c2VkIGlmIG1vZGUgaXMgUmF5LkFMTC5cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIHRoaXMuY2FsbGJhY2sgPSBmdW5jdGlvbihyZXN1bHQpe307XG59XG5SYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmF5O1xuXG5SYXkuQ0xPU0VTVCA9IDE7XG5SYXkuQU5ZID0gMjtcblJheS5BTEwgPSA0O1xuXG52YXIgdG1wQUFCQiA9IG5ldyBBQUJCKCk7XG52YXIgdG1wQXJyYXkgPSBbXTtcblxuLyoqXG4gKiBEbyBpdGVyc2VjdGlvbiBhZ2FpbnN0IGFsbCBib2RpZXMgaW4gdGhlIGdpdmVuIFdvcmxkLlxuICogQG1ldGhvZCBpbnRlcnNlY3RXb3JsZFxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHJheSBoaXQgYW55dGhpbmcsIG90aGVyd2lzZSBmYWxzZS5cbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RXb3JsZCA9IGZ1bmN0aW9uICh3b3JsZCwgb3B0aW9ucykge1xuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCBSYXkuQU5ZO1xuICAgIHRoaXMucmVzdWx0ID0gb3B0aW9ucy5yZXN1bHQgfHwgbmV3IFJheWNhc3RSZXN1bHQoKTtcbiAgICB0aGlzLnNraXBCYWNrZmFjZXMgPSAhIW9wdGlvbnMuc2tpcEJhY2tmYWNlcztcbiAgICB0aGlzLmNvbGxpc2lvbk1hc2sgPSB0eXBlb2Yob3B0aW9ucy5jb2xsaXNpb25NYXNrKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmNvbGxpc2lvbk1hc2sgOiAtMTtcbiAgICB0aGlzLmNvbGxpc2lvbkdyb3VwID0gdHlwZW9mKG9wdGlvbnMuY29sbGlzaW9uR3JvdXApICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuY29sbGlzaW9uR3JvdXAgOiAtMTtcbiAgICBpZihvcHRpb25zLmZyb20pe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy5mcm9tLCBvcHRpb25zLmZyb20pO1xuICAgIH1cbiAgICBpZihvcHRpb25zLnRvKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMudG8sIG9wdGlvbnMudG8pO1xuICAgIH1cbiAgICB0aGlzLmNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbigpe307XG4gICAgdGhpcy5oYXNIaXQgPSBmYWxzZTtcblxuICAgIHRoaXMucmVzdWx0LnJlc2V0KCk7XG4gICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKCk7XG5cbiAgICB0aGlzLmdldEFBQkIodG1wQUFCQik7XG4gICAgdG1wQXJyYXkubGVuZ3RoID0gMDtcbiAgICB3b3JsZC5icm9hZHBoYXNlLmFhYmJRdWVyeSh3b3JsZCwgdG1wQUFCQiwgdG1wQXJyYXkpO1xuICAgIHRoaXMuaW50ZXJzZWN0Qm9kaWVzKHRtcEFycmF5KTtcblxuICAgIHJldHVybiB0aGlzLmhhc0hpdDtcbn07XG5cbnZhciB2MSA9IHZlYzIuY3JlYXRlKCksXG4gICAgdjIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG52YXIgaW50ZXJzZWN0Qm9keV93b3JsZFBvc2l0aW9uID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBTaG9vdCBhIHJheSBhdCBhIGJvZHksIGdldCBiYWNrIGluZm9ybWF0aW9uIGFib3V0IHRoZSBoaXQuXG4gKiBAbWV0aG9kIGludGVyc2VjdEJvZHlcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqIEBwYXJhbSB7UmF5Y2FzdFJlc3VsdH0gW3Jlc3VsdF0gRGVwcmVjYXRlZCAtIHNldCB0aGUgcmVzdWx0IHByb3BlcnR5IG9mIHRoZSBSYXkgaW5zdGVhZC5cbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RCb2R5ID0gZnVuY3Rpb24gKGJvZHksIHJlc3VsdCkge1xuXG4gICAgaWYocmVzdWx0KXtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigpO1xuICAgIH1cbiAgICB2YXIgY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZTtcblxuICAgIGlmKGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgJiYgIWJvZHkuY29sbGlzaW9uUmVzcG9uc2Upe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYoKHRoaXMuY29sbGlzaW9uR3JvdXAgJiBib2R5LmNvbGxpc2lvbk1hc2spPT09MCB8fCAoYm9keS5jb2xsaXNpb25Hcm91cCAmIHRoaXMuY29sbGlzaW9uTWFzayk9PT0wKXtcbiAgICAvLyAgICAgcmV0dXJuO1xuICAgIC8vIH1cblxuICAgIHZhciB3b3JsZFBvc2l0aW9uID0gaW50ZXJzZWN0Qm9keV93b3JsZFBvc2l0aW9uO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIE4gPSBib2R5LnNoYXBlcy5sZW5ndGg7IGkgPCBOOyBpKyspIHtcbiAgICAgICAgdmFyIHNoYXBlID0gYm9keS5zaGFwZXNbaV07XG5cbiAgICAgICAgaWYoY2hlY2tDb2xsaXNpb25SZXNwb25zZSAmJiAhc2hhcGUuY29sbGlzaW9uUmVzcG9uc2Upe1xuICAgICAgICAgICAgY29udGludWU7IC8vIFNraXBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB3b3JsZCBhbmdsZSBhbmQgcG9zaXRpb24gb2YgdGhlIHNoYXBlXG4gICAgICAgIHZlYzIuY29weSh3b3JsZFBvc2l0aW9uLCBib2R5LnNoYXBlT2Zmc2V0c1tpXSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9zaXRpb24sIHdvcmxkUG9zaXRpb24sIGJvZHkuYW5nbGUpO1xuICAgICAgICB2ZWMyLmFkZCh3b3JsZFBvc2l0aW9uLCB3b3JsZFBvc2l0aW9uLCBib2R5LnBvc2l0aW9uKTtcbiAgICAgICAgdmFyIHdvcmxkQW5nbGUgPSBib2R5LnNoYXBlQW5nbGVzW2ldICsgYm9keS5hbmdsZTtcblxuICAgICAgICB0aGlzLmludGVyc2VjdFNoYXBlKFxuICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICB3b3JsZEFuZ2xlLFxuICAgICAgICAgICAgd29ybGRQb3NpdGlvbixcbiAgICAgICAgICAgIGJvZHlcbiAgICAgICAgKTtcblxuICAgICAgICBpZih0aGlzLnJlc3VsdC5fc2hvdWxkU3RvcCl7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQG1ldGhvZCBpbnRlcnNlY3RCb2RpZXNcbiAqIEBwYXJhbSB7QXJyYXl9IGJvZGllcyBBbiBhcnJheSBvZiBCb2R5IG9iamVjdHMuXG4gKiBAcGFyYW0ge1JheWNhc3RSZXN1bHR9IFtyZXN1bHRdIERlcHJlY2F0ZWRcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RCb2RpZXMgPSBmdW5jdGlvbiAoYm9kaWVzLCByZXN1bHQpIHtcbiAgICBpZihyZXN1bHQpe1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gYm9kaWVzLmxlbmd0aDsgIXRoaXMucmVzdWx0Ll9zaG91bGRTdG9wICYmIGkgPCBsOyBpICsrICkge1xuICAgICAgICB0aGlzLmludGVyc2VjdEJvZHkoYm9kaWVzW2ldKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIF9kaXJlY3Rpb24gdmVjdG9yLlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgX3VwZGF0ZURpcmVjdGlvblxuICovXG5SYXkucHJvdG90eXBlLl91cGRhdGVEaXJlY3Rpb24gPSBmdW5jdGlvbigpe1xuICAgIHZhciBkID0gdGhpcy5fZGlyZWN0aW9uO1xuICAgIHZlYzIuc3ViKGQsIHRoaXMudG8sIHRoaXMuZnJvbSk7IC8vIHRoaXMudG8udnN1Yih0aGlzLmZyb20sIHRoaXMuX2RpcmVjdGlvbik7XG4gICAgdmVjMi5ub3JtYWxpemUoZCwgZCk7IC8vIHRoaXMuX2RpcmVjdGlvbi5ub3JtYWxpemUoKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBpbnRlcnNlY3RTaGFwZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAqIEBwYXJhbSB7YXJyYXl9IHBvc2l0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlLCBhbmdsZSwgcG9zaXRpb24sIGJvZHkpe1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuXG5cbiAgICAvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZVxuICAgIHZhciBkaXN0YW5jZSA9IGRpc3RhbmNlRnJvbUludGVyc2VjdGlvbihmcm9tLCB0aGlzLl9kaXJlY3Rpb24sIHBvc2l0aW9uKTtcbiAgICBpZiAoIGRpc3RhbmNlID4gc2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWV0aG9kID0gdGhpc1tzaGFwZS50eXBlXTtcbiAgICBpZihtZXRob2Qpe1xuICAgICAgICBtZXRob2QuY2FsbCh0aGlzLCBzaGFwZSwgYW5nbGUsIHBvc2l0aW9uLCBib2R5KTtcbiAgICB9XG59O1xuXG52YXIgdmVjdG9yID0gdmVjMi5jcmVhdGUoKTtcbnZhciBub3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFBvaW50ID0gdmVjMi5jcmVhdGUoKTtcblxudmFyIGEgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGIgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGMgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG52YXIgdG1wUmF5Y2FzdFJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XG52YXIgaW50ZXJzZWN0UmVjdGFuZ2xlX2RpcmVjdGlvbiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UmVjdGFuZ2xlX3JheVN0YXJ0ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RSZWN0YW5nbGVfd29ybGROb3JtYWxNaW4gPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFJlY3RhbmdsZV93b3JsZE5vcm1hbE1heCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UmVjdGFuZ2xlX2hpdFBvaW50V29ybGQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFJlY3RhbmdsZV9ib3hNaW4gPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFJlY3RhbmdsZV9ib3hNYXggPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgaW50ZXJzZWN0UmVjdGFuZ2xlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlXG4gKiBAcGFyYW0gIHthcnJheX0gcG9zaXRpb25cbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RSZWN0YW5nbGUgPSBmdW5jdGlvbihzaGFwZSwgYW5nbGUsIHBvc2l0aW9uLCBib2R5KXtcbiAgICB2YXIgdG1pbiA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHZhciB0bWF4ID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIHZhciBkaXJlY3Rpb24gPSBpbnRlcnNlY3RSZWN0YW5nbGVfZGlyZWN0aW9uO1xuICAgIHZhciByYXlTdGFydCA9IGludGVyc2VjdFJlY3RhbmdsZV9yYXlTdGFydDtcbiAgICB2YXIgd29ybGROb3JtYWxNaW4gPSBpbnRlcnNlY3RSZWN0YW5nbGVfd29ybGROb3JtYWxNaW47XG4gICAgdmFyIHdvcmxkTm9ybWFsTWF4ID0gaW50ZXJzZWN0UmVjdGFuZ2xlX3dvcmxkTm9ybWFsTWF4O1xuICAgIHZhciBoaXRQb2ludFdvcmxkID0gaW50ZXJzZWN0UmVjdGFuZ2xlX2hpdFBvaW50V29ybGQ7XG4gICAgdmFyIGJveE1pbiA9IGludGVyc2VjdFJlY3RhbmdsZV9ib3hNaW47XG4gICAgdmFyIGJveE1heCA9IGludGVyc2VjdFJlY3RhbmdsZV9ib3hNYXg7XG5cbiAgICB2ZWMyLnNldChib3hNaW4sIC1zaGFwZS53aWR0aCAqIDAuNSwgLXNoYXBlLmhlaWdodCAqIDAuNSk7XG4gICAgdmVjMi5zZXQoYm94TWF4LCBzaGFwZS53aWR0aCAqIDAuNSwgc2hhcGUuaGVpZ2h0ICogMC41KTtcblxuICAgIC8vIFRyYW5zZm9ybSB0aGUgcmF5IGRpcmVjdGlvbiBhbmQgc3RhcnQgdG8gbG9jYWwgc3BhY2VcbiAgICB2ZWMyLnJvdGF0ZShkaXJlY3Rpb24sIHRoaXMuX2RpcmVjdGlvbiwgLWFuZ2xlKTtcbiAgICBib2R5LnRvTG9jYWxGcmFtZShyYXlTdGFydCwgdGhpcy5mcm9tKTtcblxuICAgIGlmIChkaXJlY3Rpb25bMF0gIT09IDApIHtcbiAgICAgICAgdmFyIHR4MSA9IChib3hNaW5bMF0gLSByYXlTdGFydFswXSkgLyBkaXJlY3Rpb25bMF07XG4gICAgICAgIHZhciB0eDIgPSAoYm94TWF4WzBdIC0gcmF5U3RhcnRbMF0pIC8gZGlyZWN0aW9uWzBdO1xuXG4gICAgICAgIHZhciB0bWluT2xkID0gdG1pbjtcbiAgICAgICAgdG1pbiA9IE1hdGgubWF4KHRtaW4sIE1hdGgubWluKHR4MSwgdHgyKSk7XG4gICAgICAgIGlmKHRtaW4gIT09IHRtaW5PbGQpe1xuICAgICAgICAgICAgdmVjMi5zZXQod29ybGROb3JtYWxNaW4sIHR4MSA+IHR4MiA/IDEgOiAtMSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG1heE9sZCA9IHRtYXg7XG4gICAgICAgIHRtYXggPSBNYXRoLm1pbih0bWF4LCBNYXRoLm1heCh0eDEsIHR4MikpO1xuICAgICAgICBpZih0bWF4ICE9PSB0bWF4T2xkKXtcbiAgICAgICAgICAgIHZlYzIuc2V0KHdvcmxkTm9ybWFsTWF4LCB0eDEgPCB0eDIgPyAxIDogLTEsIDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpcmVjdGlvblsxXSAhPT0gMCkge1xuICAgICAgICB2YXIgdHkxID0gKGJveE1pblsxXSAtIHJheVN0YXJ0WzFdKSAvIGRpcmVjdGlvblsxXTtcbiAgICAgICAgdmFyIHR5MiA9IChib3hNYXhbMV0gLSByYXlTdGFydFsxXSkgLyBkaXJlY3Rpb25bMV07XG5cbiAgICAgICAgdmFyIHRtaW5PbGQgPSB0bWluO1xuICAgICAgICB0bWluID0gTWF0aC5tYXgodG1pbiwgTWF0aC5taW4odHkxLCB0eTIpKTtcbiAgICAgICAgaWYodG1pbiAhPT0gdG1pbk9sZCl7XG4gICAgICAgICAgICB2ZWMyLnNldCh3b3JsZE5vcm1hbE1pbiwgMCwgdHkxID4gdHkyID8gMSA6IC0xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0bWF4T2xkID0gdG1heDtcbiAgICAgICAgdG1heCA9IE1hdGgubWluKHRtYXgsIE1hdGgubWF4KHR5MSwgdHkyKSk7XG4gICAgICAgIGlmKHRtYXggIT09IHRtYXhPbGQpe1xuICAgICAgICAgICAgdmVjMi5zZXQod29ybGROb3JtYWxNYXgsIDAsIHR5MSA8IHR5MiA/IDEgOiAtMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0bWF4ID49IHRtaW4pe1xuICAgICAgICAvLyBIaXQgcG9pbnRcbiAgICAgICAgdmVjMi5zZXQoXG4gICAgICAgICAgICBoaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgcmF5U3RhcnRbMF0gKyBkaXJlY3Rpb25bMF0gKiB0bWluLFxuICAgICAgICAgICAgcmF5U3RhcnRbMV0gKyBkaXJlY3Rpb25bMV0gKiB0bWluXG4gICAgICAgICk7XG5cbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGROb3JtYWxNaW4sIHdvcmxkTm9ybWFsTWluLCBhbmdsZSk7XG5cbiAgICAgICAgYm9keS50b1dvcmxkRnJhbWUoaGl0UG9pbnRXb3JsZCwgaGl0UG9pbnRXb3JsZCk7XG5cbiAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24od29ybGROb3JtYWxNaW4sIGhpdFBvaW50V29ybGQsIHNoYXBlLCBib2R5LCAtMSk7XG4gICAgICAgIGlmKHRoaXMuX3Nob3VsZFN0b3Ape1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGROb3JtYWxNYXgsIHdvcmxkTm9ybWFsTWF4LCBhbmdsZSk7XG5cbiAgICAgICAgLy8gSGl0IHBvaW50XG4gICAgICAgIHZlYzIuc2V0KFxuICAgICAgICAgICAgaGl0UG9pbnRXb3JsZCxcbiAgICAgICAgICAgIHJheVN0YXJ0WzBdICsgZGlyZWN0aW9uWzBdICogdG1heCxcbiAgICAgICAgICAgIHJheVN0YXJ0WzFdICsgZGlyZWN0aW9uWzFdICogdG1heFxuICAgICAgICApO1xuICAgICAgICBib2R5LnRvV29ybGRGcmFtZShoaXRQb2ludFdvcmxkLCBoaXRQb2ludFdvcmxkKTtcblxuICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbih3b3JsZE5vcm1hbE1heCwgaGl0UG9pbnRXb3JsZCwgc2hhcGUsIGJvZHksIC0xKTtcbiAgICB9XG59O1xuUmF5LnByb3RvdHlwZVtTaGFwZS5SRUNUQU5HTEVdID0gUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RSZWN0YW5nbGU7XG5cbnZhciBpbnRlcnNlY3RQbGFuZV9wbGFuZVBvaW50VG9Gcm9tID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RQbGFuZV9kaXJfc2NhbGVkX3dpdGhfdCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UGxhbmVfaGl0UG9pbnRXb3JsZCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UGxhbmVfd29ybGROb3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFBsYW5lX2xlbiA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQG1ldGhvZCBpbnRlcnNlY3RQbGFuZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxuICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZVxuICogQHBhcmFtICB7YXJyYXl9IHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5XG4gKi9cblJheS5wcm90b3R5cGUuaW50ZXJzZWN0UGxhbmUgPSBmdW5jdGlvbihzaGFwZSwgYW5nbGUsIHBvc2l0aW9uLCBib2R5KXtcbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xuICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLl9kaXJlY3Rpb247XG5cbiAgICB2YXIgcGxhbmVQb2ludFRvRnJvbSA9IGludGVyc2VjdFBsYW5lX3BsYW5lUG9pbnRUb0Zyb207XG4gICAgdmFyIGRpcl9zY2FsZWRfd2l0aF90ID0gaW50ZXJzZWN0UGxhbmVfZGlyX3NjYWxlZF93aXRoX3Q7XG4gICAgdmFyIGhpdFBvaW50V29ybGQgPSBpbnRlcnNlY3RQbGFuZV9oaXRQb2ludFdvcmxkO1xuICAgIHZhciB3b3JsZE5vcm1hbCA9IGludGVyc2VjdFBsYW5lX3dvcmxkTm9ybWFsO1xuICAgIHZhciBsZW4gPSBpbnRlcnNlY3RQbGFuZV9sZW47XG5cbiAgICAvLyBHZXQgcGxhbmUgbm9ybWFsXG4gICAgdmVjMi5zZXQod29ybGROb3JtYWwsIDAsIDEpO1xuICAgIHZlYzIucm90YXRlKHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCwgYW5nbGUpO1xuXG4gICAgdmVjMi5zdWIobGVuLCBmcm9tLCBwb3NpdGlvbik7IC8vZnJvbS52c3ViKHBvc2l0aW9uLCBsZW4pO1xuICAgIHZhciBwbGFuZVRvRnJvbSA9IHZlYzIuZG90KGxlbiwgd29ybGROb3JtYWwpOyAvLyBsZW4uZG90KHdvcmxkTm9ybWFsKTtcbiAgICB2ZWMyLnN1YihsZW4sIHRvLCBwb3NpdGlvbik7IC8vIHRvLnZzdWIocG9zaXRpb24sIGxlbik7XG4gICAgdmFyIHBsYW5lVG9UbyA9IHZlYzIuZG90KGxlbiwgd29ybGROb3JtYWwpOyAvLyBsZW4uZG90KHdvcmxkTm9ybWFsKTtcblxuICAgIGlmKHBsYW5lVG9Gcm9tICogcGxhbmVUb1RvID4gMCl7XG4gICAgICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgYXJlIG9uIHRoZSBzYW1lIHNpZGUgb2YgdGhlIHBsYW5lLi4uIGJhaWwgb3V0XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZih2ZWMyLmRpc3RhbmNlKGZyb20sIHRvKSAvKiBmcm9tLmRpc3RhbmNlVG8odG8pICovIDwgcGxhbmVUb0Zyb20pe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5fZG90X2RpciA9IHZlYzIuZG90KHdvcmxkTm9ybWFsLCBkaXJlY3Rpb24pOyAvLyB3b3JsZE5vcm1hbC5kb3QoZGlyZWN0aW9uKTtcblxuICAgIC8vIGlmIChNYXRoLmFicyhuX2RvdF9kaXIpIDwgdGhpcy5wcmVjaXNpb24pIHtcbiAgICAvLyAgICAgLy8gTm8gaW50ZXJzZWN0aW9uXG4gICAgLy8gICAgIHJldHVybjtcbiAgICAvLyB9XG5cbiAgICB2ZWMyLnN1YihwbGFuZVBvaW50VG9Gcm9tLCBmcm9tLCBwb3NpdGlvbik7IC8vIGZyb20udnN1Yihwb3NpdGlvbiwgcGxhbmVQb2ludFRvRnJvbSk7XG4gICAgdmFyIHQgPSAtdmVjMi5kb3Qod29ybGROb3JtYWwsIHBsYW5lUG9pbnRUb0Zyb20pIC8gbl9kb3RfZGlyOyAvLyAtIHdvcmxkTm9ybWFsLmRvdChwbGFuZVBvaW50VG9Gcm9tKSAvIG5fZG90X2RpcjtcbiAgICB2ZWMyLnNjYWxlKGRpcl9zY2FsZWRfd2l0aF90LCBkaXJlY3Rpb24sIHQpOyAvLyBkaXJlY3Rpb24uc2NhbGUodCwgZGlyX3NjYWxlZF93aXRoX3QpO1xuICAgIHZlYzIuYWRkKGhpdFBvaW50V29ybGQsIGZyb20sIGRpcl9zY2FsZWRfd2l0aF90KTsgLy8gZnJvbS52YWRkKGRpcl9zY2FsZWRfd2l0aF90LCBoaXRQb2ludFdvcmxkKTtcblxuICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKHdvcmxkTm9ybWFsLCBoaXRQb2ludFdvcmxkLCBzaGFwZSwgYm9keSwgLTEpO1xufTtcblJheS5wcm90b3R5cGVbU2hhcGUuUExBTkVdID0gUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RQbGFuZTtcblxudmFyIFJheV9pbnRlcnNlY3RTcGhlcmVfaW50ZXJzZWN0aW9uUG9pbnQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIFJheV9pbnRlcnNlY3RTcGhlcmVfbm9ybWFsID0gdmVjMi5jcmVhdGUoKTtcblJheS5wcm90b3R5cGUuaW50ZXJzZWN0Q2lyY2xlID0gZnVuY3Rpb24oc2hhcGUsIGFuZ2xlLCBwb3NpdGlvbiwgYm9keSl7XG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb20sXG4gICAgICAgIHRvID0gdGhpcy50byxcbiAgICAgICAgciA9IHNoYXBlLnJhZGl1cztcblxuICAgIHZhciBhID0gTWF0aC5wb3codG9bMF0gLSBmcm9tWzBdLCAyKSArIE1hdGgucG93KHRvWzFdIC0gZnJvbVsxXSwgMik7XG4gICAgdmFyIGIgPSAyICogKCh0b1swXSAtIGZyb21bMF0pICogKGZyb21bMF0gLSBwb3NpdGlvblswXSkgKyAodG9bMV0gLSBmcm9tWzFdKSAqIChmcm9tWzFdIC0gcG9zaXRpb25bMV0pKTtcbiAgICB2YXIgYyA9IE1hdGgucG93KGZyb21bMF0gLSBwb3NpdGlvblswXSwgMikgKyBNYXRoLnBvdyhmcm9tWzFdIC0gcG9zaXRpb25bMV0sIDIpIC0gTWF0aC5wb3cociwgMik7XG5cbiAgICB2YXIgZGVsdGEgPSBNYXRoLnBvdyhiLCAyKSAtIDQgKiBhICogYztcblxuICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IFJheV9pbnRlcnNlY3RTcGhlcmVfaW50ZXJzZWN0aW9uUG9pbnQ7XG4gICAgdmFyIG5vcm1hbCA9IFJheV9pbnRlcnNlY3RTcGhlcmVfbm9ybWFsO1xuXG4gICAgaWYoZGVsdGEgPCAwKXtcbiAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uXG4gICAgICAgIHJldHVybjtcblxuICAgIH0gZWxzZSBpZihkZWx0YSA9PT0gMCl7XG4gICAgICAgIC8vIHNpbmdsZSBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgICAgdmVjMi5sZXJwKGludGVyc2VjdGlvblBvaW50LCBmcm9tLCB0bywgZGVsdGEpOyAvLyBmcm9tLmxlcnAodG8sIGRlbHRhLCBpbnRlcnNlY3Rpb25Qb2ludCk7XG5cbiAgICAgICAgdmVjMi5zdWIobm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcG9zaXRpb24pOyAvLyBpbnRlcnNlY3Rpb25Qb2ludC52c3ViKHBvc2l0aW9uLCBub3JtYWwpO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShub3JtYWwsbm9ybWFsKTsgLy9ub3JtYWwubm9ybWFsaXplKCk7XG5cbiAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgc2hhcGUsIGJvZHksIC0xKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkMSA9ICgtIGIgLSBNYXRoLnNxcnQoZGVsdGEpKSAvICgyICogYSk7XG4gICAgICAgIHZhciBkMiA9ICgtIGIgKyBNYXRoLnNxcnQoZGVsdGEpKSAvICgyICogYSk7XG5cbiAgICAgICAgdmVjMi5sZXJwKGludGVyc2VjdGlvblBvaW50LCBmcm9tLCB0bywgZDEpOyAvLyBmcm9tLmxlcnAodG8sIGQxLCBpbnRlcnNlY3Rpb25Qb2ludCk7XG5cbiAgICAgICAgdmVjMi5zdWIobm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcG9zaXRpb24pOyAvLyBpbnRlcnNlY3Rpb25Qb2ludC52c3ViKHBvc2l0aW9uLCBub3JtYWwpO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShub3JtYWwsbm9ybWFsKTsgLy9ub3JtYWwubm9ybWFsaXplKCk7XG5cbiAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgc2hhcGUsIGJvZHksIC0xKTtcblxuICAgICAgICBpZih0aGlzLnJlc3VsdC5fc2hvdWxkU3RvcCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2ZWMyLmxlcnAoaW50ZXJzZWN0aW9uUG9pbnQsIGZyb20sIHRvLCBkMik7IC8vIGZyb20ubGVycCh0bywgZDIsIGludGVyc2VjdGlvblBvaW50KTtcblxuICAgICAgICB2ZWMyLnN1Yihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBwb3NpdGlvbik7IC8vIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCxub3JtYWwpOyAvL25vcm1hbC5ub3JtYWxpemUoKTtcblxuICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBzaGFwZSwgYm9keSwgLTEpO1xuICAgIH1cbn07XG5SYXkucHJvdG90eXBlW1NoYXBlLkNJUkNMRV0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdENpcmNsZTtcblxuLyoqXG4gKiBHZXQgdGhlIEFBQkIgb2YgdGhlIHJheS5cbiAqIEBtZXRob2QgZ2V0QUFCQlxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICovXG5SYXkucHJvdG90eXBlLmdldEFBQkIgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHZhciB0byA9IHRoaXMudG87XG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XG4gICAgcmVzdWx0Lmxvd2VyQm91bmRbMF0gPSBNYXRoLm1pbih0b1swXSwgZnJvbVswXSk7XG4gICAgcmVzdWx0Lmxvd2VyQm91bmRbMV0gPSBNYXRoLm1pbih0b1sxXSwgZnJvbVsxXSk7XG4gICAgcmVzdWx0LnVwcGVyQm91bmRbMF0gPSBNYXRoLm1heCh0b1swXSwgZnJvbVswXSk7XG4gICAgcmVzdWx0LnVwcGVyQm91bmRbMV0gPSBNYXRoLm1heCh0b1sxXSwgZnJvbVsxXSk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgcmVwb3J0SW50ZXJzZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7YXJyYXl9IG5vcm1hbFxuICogQHBhcmFtICB7YXJyYXl9IGhpdFBvaW50V29ybGRcbiAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxuICogQHBhcmFtICB7Qm9keX0gYm9keVxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgaW50ZXJzZWN0aW9ucyBzaG91bGQgY29udGludWVcbiAqL1xuUmF5LnByb3RvdHlwZS5yZXBvcnRJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihub3JtYWwsIGhpdFBvaW50V29ybGQsIHNoYXBlLCBib2R5LCBoaXRGYWNlSW5kZXgpe1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuICAgIHZhciB0byA9IHRoaXMudG87XG4gICAgdmFyIGRpc3RhbmNlID0gdmVjMi5kaXN0YW5jZShmcm9tLCBoaXRQb2ludFdvcmxkKTsgLy8gZnJvbS5kaXN0YW5jZVRvKGhpdFBvaW50V29ybGQpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdDtcblxuICAgIC8vIFNraXAgYmFjayBmYWNlcz9cbiAgICBpZih0aGlzLnNraXBCYWNrZmFjZXMgJiYgLyogbm9ybWFsLmRvdCh0aGlzLl9kaXJlY3Rpb24pICovIHZlYzIuZG90KG5vcm1hbCwgdGhpcy5fZGlyZWN0aW9uKSA+IDApe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVzdWx0LmhpdEZhY2VJbmRleCA9IHR5cGVvZihoaXRGYWNlSW5kZXgpICE9PSAndW5kZWZpbmVkJyA/IGhpdEZhY2VJbmRleCA6IC0xO1xuXG4gICAgc3dpdGNoKHRoaXMubW9kZSl7XG4gICAgY2FzZSBSYXkuQUxMOlxuICAgICAgICB0aGlzLmhhc0hpdCA9IHRydWU7XG4gICAgICAgIHJlc3VsdC5zZXQoXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICBoaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgZGlzdGFuY2VcbiAgICAgICAgKTtcbiAgICAgICAgcmVzdWx0Lmhhc0hpdCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFJheS5DTE9TRVNUOlxuXG4gICAgICAgIC8vIFN0b3JlIGlmIGNsb3NlciB0aGFuIGN1cnJlbnQgY2xvc2VzdFxuICAgICAgICBpZihkaXN0YW5jZSA8IHJlc3VsdC5kaXN0YW5jZSB8fCAhcmVzdWx0Lmhhc0hpdCl7XG4gICAgICAgICAgICB0aGlzLmhhc0hpdCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoXG4gICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICAgICAgaGl0UG9pbnRXb3JsZCxcbiAgICAgICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBSYXkuQU5ZOlxuXG4gICAgICAgIC8vIFJlcG9ydCBhbmQgc3RvcC5cbiAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlO1xuICAgICAgICByZXN1bHQuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0LnNldChcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIG5vcm1hbCxcbiAgICAgICAgICAgIGhpdFBvaW50V29ybGQsXG4gICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBkaXN0YW5jZVxuICAgICAgICApO1xuICAgICAgICByZXN1bHQuX3Nob3VsZFN0b3AgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG52YXIgdjAgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGludGVyc2VjdCA9IHZlYzIuY3JlYXRlKCk7XG5mdW5jdGlvbiBkaXN0YW5jZUZyb21JbnRlcnNlY3Rpb24oZnJvbSwgZGlyZWN0aW9uLCBwb3NpdGlvbikge1xuXG4gICAgLy8gdjAgaXMgdmVjdG9yIGZyb20gZnJvbSB0byBwb3NpdGlvblxuICAgIHZlYzIuc3ViKHYwLCBwb3NpdGlvbiwgZnJvbSk7IC8vIHBvc2l0aW9uLnZzdWIoZnJvbSx2MCk7XG4gICAgdmFyIGRvdCA9IHZlYzIuZG90KHYwLCBkaXJlY3Rpb24pOyAvLyB2MC5kb3QoZGlyZWN0aW9uKTtcblxuICAgIC8vIGludGVyc2VjdCA9IGRpcmVjdGlvbipkb3QgKyBmcm9tXG4gICAgdmVjMi5zY2FsZShpbnRlcnNlY3QsIGRpcmVjdGlvbiwgZG90KTsgLy9kaXJlY3Rpb24ubXVsdChkb3QsaW50ZXJzZWN0KTtcbiAgICB2ZWMyLmFkZChpbnRlcnNlY3QsIGludGVyc2VjdCwgZnJvbSk7IC8vIGludGVyc2VjdC52YWRkKGZyb20sIGludGVyc2VjdCk7XG5cbiAgICB2YXIgZGlzdGFuY2UgPSB2ZWMyLmRpc3RhbmNlKHBvc2l0aW9uLCBpbnRlcnNlY3QpOyAvLyBwb3NpdGlvbi5kaXN0YW5jZVRvKGludGVyc2VjdCk7XG5cbiAgICByZXR1cm4gZGlzdGFuY2U7XG59XG5cblxufSx7XCIuLi9jb2xsaXNpb24vQUFCQlwiOjcsXCIuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjEzLFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi9zaGFwZXMvU2hhcGVcIjo0NX1dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmF5Y2FzdFJlc3VsdDtcblxuLyoqXG4gKiBTdG9yYWdlIGZvciBSYXkgY2FzdGluZyBkYXRhLlxuICogQGNsYXNzIFJheWNhc3RSZXN1bHRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSYXljYXN0UmVzdWx0KCl7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7YXJyYXl9IHJheUZyb21Xb3JsZFxuXHQgKi9cblx0dGhpcy5yYXlGcm9tV29ybGQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge2FycmF5fSByYXlUb1dvcmxkXG5cdCAqL1xuXHR0aGlzLnJheVRvV29ybGQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge2FycmF5fSBoaXROb3JtYWxXb3JsZFxuXHQgKi9cblx0dGhpcy5oaXROb3JtYWxXb3JsZCA9IHZlYzIuY3JlYXRlKCk7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7YXJyYXl9IGhpdFBvaW50V29ybGRcblx0ICovXG5cdHRoaXMuaGl0UG9pbnRXb3JsZCA9IHZlYzIuY3JlYXRlKCk7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGFzSGl0XG5cdCAqL1xuXHR0aGlzLmhhc0hpdCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBUaGUgaGl0IHNoYXBlLCBvciBudWxsLlxuXHQgKiBAcHJvcGVydHkge1NoYXBlfSBzaGFwZVxuXHQgKi9cblx0dGhpcy5zaGFwZSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFRoZSBoaXQgYm9keSwgb3IgbnVsbC5cblx0ICogQHByb3BlcnR5IHtCb2R5fSBib2R5XG5cdCAqL1xuXHR0aGlzLmJvZHkgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBUaGUgaW5kZXggb2YgdGhlIGhpdCB0cmlhbmdsZSwgaWYgdGhlIGhpdCBzaGFwZSB3YXMgYSB0cmltZXNoLlxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gaGl0RmFjZUluZGV4XG5cdCAqIEBkZWZhdWx0IC0xXG5cdCAqL1xuXHR0aGlzLmhpdEZhY2VJbmRleCA9IC0xO1xuXG5cdC8qKlxuXHQgKiBEaXN0YW5jZSB0byB0aGUgaGl0LiBXaWxsIGJlIHNldCB0byAtMSBpZiB0aGVyZSB3YXMgbm8gaGl0LlxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gZGlzdGFuY2Vcblx0ICogQGRlZmF1bHQgLTFcblx0ICovXG5cdHRoaXMuZGlzdGFuY2UgPSAtMTtcblxuXHQvKipcblx0ICogSWYgdGhlIHJheSBzaG91bGQgc3RvcCB0cmF2ZXJzaW5nIHRoZSBib2RpZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gX3Nob3VsZFN0b3Bcblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICovXG5cdHRoaXMuX3Nob3VsZFN0b3AgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXNldCBhbGwgcmVzdWx0IGRhdGEuXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXHR2ZWMyLnNldCh0aGlzLnJheUZyb21Xb3JsZCwgMCwgMCk7XG5cdHZlYzIuc2V0KHRoaXMucmF5VG9Xb3JsZCwgMCwgMCk7XG5cdHZlYzIuc2V0KHRoaXMuaGl0Tm9ybWFsV29ybGQsIDAsIDApO1xuXHR2ZWMyLnNldCh0aGlzLmhpdFBvaW50V29ybGQsIDAsIDApO1xuXHR0aGlzLmhhc0hpdCA9IGZhbHNlO1xuXHR0aGlzLnNoYXBlID0gbnVsbDtcblx0dGhpcy5ib2R5ID0gbnVsbDtcblx0dGhpcy5oaXRGYWNlSW5kZXggPSAtMTtcblx0dGhpcy5kaXN0YW5jZSA9IC0xO1xuXHR0aGlzLl9zaG91bGRTdG9wID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgYWJvcnRcbiAqL1xuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1xuXHR0aGlzLl9zaG91bGRTdG9wID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7YXJyYXl9IHJheUZyb21Xb3JsZFxuICogQHBhcmFtIHthcnJheX0gcmF5VG9Xb3JsZFxuICogQHBhcmFtIHthcnJheX0gaGl0Tm9ybWFsV29ybGRcbiAqIEBwYXJhbSB7YXJyYXl9IGhpdFBvaW50V29ybGRcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICovXG5SYXljYXN0UmVzdWx0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihcblx0cmF5RnJvbVdvcmxkLFxuXHRyYXlUb1dvcmxkLFxuXHRoaXROb3JtYWxXb3JsZCxcblx0aGl0UG9pbnRXb3JsZCxcblx0c2hhcGUsXG5cdGJvZHksXG5cdGRpc3RhbmNlXG4pe1xuXHR2ZWMyLmNvcHkodGhpcy5yYXlGcm9tV29ybGQsIHJheUZyb21Xb3JsZCk7XG5cdHZlYzIuY29weSh0aGlzLnJheVRvV29ybGQsIHJheVRvV29ybGQpO1xuXHR2ZWMyLmNvcHkodGhpcy5oaXROb3JtYWxXb3JsZCwgaGl0Tm9ybWFsV29ybGQpO1xuXHR2ZWMyLmNvcHkodGhpcy5oaXRQb2ludFdvcmxkLCBoaXRQb2ludFdvcmxkKTtcblx0dGhpcy5zaGFwZSA9IHNoYXBlO1xuXHR0aGlzLmJvZHkgPSBib2R5O1xuXHR0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG59O1xufSx7XCIuLi9tYXRoL3ZlYzJcIjozMX1dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJylcbiwgICBCcm9hZHBoYXNlID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTQVBCcm9hZHBoYXNlO1xuXG4vKipcbiAqIFN3ZWVwIGFuZCBwcnVuZSBicm9hZHBoYXNlIGFsb25nIG9uZSBheGlzLlxuICpcbiAqIEBjbGFzcyBTQVBCcm9hZHBoYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEJyb2FkcGhhc2VcbiAqL1xuZnVuY3Rpb24gU0FQQnJvYWRwaGFzZSgpe1xuICAgIEJyb2FkcGhhc2UuY2FsbCh0aGlzLEJyb2FkcGhhc2UuU0FQKTtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgYm9kaWVzIGN1cnJlbnRseSBpbiB0aGUgYnJvYWRwaGFzZS5cbiAgICAgKiBAcHJvcGVydHkgYXhpc0xpc3RcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5heGlzTGlzdCA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGF4aXMgdG8gc29ydCBhbG9uZy4gMCBtZWFucyB4LWF4aXMgYW5kIDEgeS1heGlzLiBJZiB5b3VyIGJvZGllcyBhcmUgbW9yZSBzcHJlYWQgb3V0IG92ZXIgdGhlIFggYXhpcywgc2V0IGF4aXNJbmRleCB0byAwLCBhbmQgeW91IHdpbGwgZ2FpbiBzb21lIHBlcmZvcm1hbmNlLlxuICAgICAqIEBwcm9wZXJ0eSBheGlzSW5kZXhcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYXhpc0luZGV4ID0gMDtcblxuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGlzLl9hZGRCb2R5SGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICB0aGF0LmF4aXNMaXN0LnB1c2goZS5ib2R5KTtcbiAgICB9O1xuXG4gICAgdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gbGlzdFxuICAgICAgICB2YXIgaWR4ID0gdGhhdC5heGlzTGlzdC5pbmRleE9mKGUuYm9keSk7XG4gICAgICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICAgICAgdGhhdC5heGlzTGlzdC5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlID0gbmV3IEJyb2FkcGhhc2UoKTtcblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU0FQQnJvYWRwaGFzZTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIHdvcmxkXG4gKiBAbWV0aG9kIHNldFdvcmxkXG4gKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxuICovXG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5zZXRXb3JsZCA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICAvLyBDbGVhciB0aGUgb2xkIGF4aXMgYXJyYXlcbiAgICB0aGlzLmF4aXNMaXN0Lmxlbmd0aCA9IDA7XG5cbiAgICAvLyBBZGQgYWxsIGJvZGllcyBmcm9tIHRoZSBuZXcgd29ybGRcbiAgICBVdGlscy5hcHBlbmRBcnJheSh0aGlzLmF4aXNMaXN0LCB3b3JsZC5ib2RpZXMpO1xuXG4gICAgLy8gUmVtb3ZlIG9sZCBoYW5kbGVycywgaWYgYW55XG4gICAgd29ybGRcbiAgICAgICAgLm9mZihcImFkZEJvZHlcIix0aGlzLl9hZGRCb2R5SGFuZGxlcilcbiAgICAgICAgLm9mZihcInJlbW92ZUJvZHlcIix0aGlzLl9yZW1vdmVCb2R5SGFuZGxlcik7XG5cbiAgICAvLyBBZGQgaGFuZGxlcnMgdG8gdXBkYXRlIHRoZSBsaXN0IG9mIGJvZGllcy5cbiAgICB3b3JsZC5vbihcImFkZEJvZHlcIix0aGlzLl9hZGRCb2R5SGFuZGxlcikub24oXCJyZW1vdmVCb2R5XCIsdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIpO1xuXG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xufTtcblxuLyoqXG4gKiBTb3J0cyBib2RpZXMgYWxvbmcgYW4gYXhpcy5cbiAqIEBtZXRob2Qgc29ydEF4aXNMaXN0XG4gKiBAcGFyYW0ge0FycmF5fSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYXhpc0luZGV4XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuU0FQQnJvYWRwaGFzZS5zb3J0QXhpc0xpc3QgPSBmdW5jdGlvbihhLCBheGlzSW5kZXgpe1xuICAgIGF4aXNJbmRleCA9IGF4aXNJbmRleHwwO1xuICAgIGZvcih2YXIgaT0xLGw9YS5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgIHZhciB2ID0gYVtpXTtcbiAgICAgICAgZm9yKHZhciBqPWkgLSAxO2o+PTA7ai0tKSB7XG4gICAgICAgICAgICBpZihhW2pdLmFhYmIubG93ZXJCb3VuZFtheGlzSW5kZXhdIDw9IHYuYWFiYi5sb3dlckJvdW5kW2F4aXNJbmRleF0pe1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYVtqKzFdID0gYVtqXTtcbiAgICAgICAgfVxuICAgICAgICBhW2orMV0gPSB2O1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG5cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLnNvcnRMaXN0ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5heGlzTGlzdCxcbiAgICBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleDtcblxuICAgIC8vIFNvcnQgdGhlIGxpc3RzXG4gICAgU0FQQnJvYWRwaGFzZS5zb3J0QXhpc0xpc3QoYm9kaWVzLCBheGlzSW5kZXgpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvbGxpZGluZyBwYWlyc1xuICogQG1ldGhvZCBnZXRDb2xsaXNpb25QYWlyc1xuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuZ2V0Q29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIGJvZGllcyA9IHRoaXMuYXhpc0xpc3QsXG4gICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0LFxuICAgICAgICBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleDtcblxuICAgIHJlc3VsdC5sZW5ndGggPSAwO1xuXG4gICAgLy8gVXBkYXRlIGFsbCBBQUJCcyBpZiBuZWVkZWRcbiAgICB2YXIgbCA9IGJvZGllcy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGIgPSBib2RpZXNbbF07XG4gICAgICAgIGlmKGIuYWFiYk5lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgIGIudXBkYXRlQUFCQigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU29ydCB0aGUgbGlzdHNcbiAgICB0aGlzLnNvcnRMaXN0KCk7XG5cbiAgICAvLyBMb29rIHRocm91Z2ggdGhlIFggbGlzdFxuICAgIGZvcih2YXIgaT0wLCBOPWJvZGllcy5sZW5ndGh8MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcblxuICAgICAgICBmb3IodmFyIGo9aSsxOyBqPE47IGorKyl7XG4gICAgICAgICAgICB2YXIgYmogPSBib2RpZXNbal07XG5cbiAgICAgICAgICAgIC8vIEJvdW5kcyBvdmVybGFwP1xuICAgICAgICAgICAgdmFyIG92ZXJsYXBzID0gKGJqLmFhYmIubG93ZXJCb3VuZFtheGlzSW5kZXhdIDw9IGJpLmFhYmIudXBwZXJCb3VuZFtheGlzSW5kZXhdKTtcbiAgICAgICAgICAgIGlmKCFvdmVybGFwcyl7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKEJyb2FkcGhhc2UuY2FuQ29sbGlkZShiaSxiaikgJiYgdGhpcy5ib3VuZGluZ1ZvbHVtZUNoZWNrKGJpLGJqKSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmksYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gYW4gQUFCQi5cbiAqIEBtZXRob2QgYWFiYlF1ZXJ5XG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uKHdvcmxkLCBhYWJiLCByZXN1bHQpe1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcblxuICAgIHRoaXMuc29ydExpc3QoKTtcblxuICAgIHZhciBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleDtcbiAgICB2YXIgYXhpcyA9ICd4JztcbiAgICBpZihheGlzSW5kZXggPT09IDEpeyBheGlzID0gJ3knOyB9XG4gICAgaWYoYXhpc0luZGV4ID09PSAyKXsgYXhpcyA9ICd6JzsgfVxuXG4gICAgdmFyIGF4aXNMaXN0ID0gdGhpcy5heGlzTGlzdDtcbiAgICB2YXIgbG93ZXIgPSBhYWJiLmxvd2VyQm91bmRbYXhpc107XG4gICAgdmFyIHVwcGVyID0gYWFiYi51cHBlckJvdW5kW2F4aXNdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBheGlzTGlzdC5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBiID0gYXhpc0xpc3RbaV07XG5cbiAgICAgICAgaWYoYi5hYWJiTmVlZHNVcGRhdGUpe1xuICAgICAgICAgICAgYi51cGRhdGVBQUJCKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihiLmFhYmIub3ZlcmxhcHMoYWFiYikpe1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbn0se1wiLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2VcIjo4LFwiLi4vdXRpbHMvVXRpbHNcIjo1MH1dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gQ29uc3RyYWludDtcblxudmFyIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxuLyoqXG4gKiBCYXNlIGNvbnN0cmFpbnQgY2xhc3MuXG4gKlxuICogQGNsYXNzIENvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jb2xsaWRlQ29ubmVjdGVkPXRydWVdXG4gKi9cbmZ1bmN0aW9uIENvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB0eXBlLCBvcHRpb25zKXtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIGNvbnN0cmFpbnQuIE1heSBiZSBvbmUgb2YgQ29uc3RyYWludC5ESVNUQU5DRSwgQ29uc3RyYWludC5HRUFSLCBDb25zdHJhaW50LkxPQ0ssIENvbnN0cmFpbnQuUFJJU01BVElDIG9yIENvbnN0cmFpbnQuUkVWT0xVVEUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHR5cGVcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMse1xuICAgICAgICBjb2xsaWRlQ29ubmVjdGVkIDogdHJ1ZSxcbiAgICAgICAgd2FrZVVwQm9kaWVzIDogdHJ1ZSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEVxdWF0aW9ucyB0byBiZSBzb2x2ZWQgaW4gdGhpcyBjb25zdHJhaW50XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZXF1YXRpb25zXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuZXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNvbnN0cmFpbnQuXG4gICAgICogQHByb3BlcnR5IGJvZHlBXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xuXG4gICAgLyoqXG4gICAgICogU2Vjb25kIGJvZHkgcGFydGljaXBhdGluZyBpbiB0aGUgY29uc3RyYWludC5cbiAgICAgKiBAcHJvcGVydHkgYm9keUJcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlCID0gYm9keUI7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0aGUgY29ubmVjdGVkIGJvZGllcyB0byBjb2xsaWRlLlxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaWRlQ29ubmVjdGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlkZUNvbm5lY3RlZCA9IG9wdGlvbnMuY29sbGlkZUNvbm5lY3RlZDtcblxuICAgIC8vIFdha2UgdXAgYm9kaWVzIHdoZW4gY29ubmVjdGVkXG4gICAgaWYob3B0aW9ucy53YWtlVXBCb2RpZXMpe1xuICAgICAgICBpZihib2R5QSl7XG4gICAgICAgICAgICBib2R5QS53YWtlVXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpZihib2R5Qil7XG4gICAgICAgICAgICBib2R5Qi53YWtlVXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBjb25zdHJhaW50IHBhcmFtZXRlcnMgYmVmb3JlIHNvbHZlLlxuICogQG1ldGhvZCB1cGRhdGVcbiAqL1xuQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtZXRob2QgdXBkYXRlKCkgbm90IGltcGxtZW1lbnRlZCBpbiB0aGlzIENvbnN0cmFpbnQgc3ViY2xhc3MhXCIpO1xufTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gRElTVEFOQ0VcbiAqL1xuQ29uc3RyYWludC5ESVNUQU5DRSA9IDE7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IEdFQVJcbiAqL1xuQ29uc3RyYWludC5HRUFSID0gMjtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gTE9DS1xuICovXG5Db25zdHJhaW50LkxPQ0sgPSAzO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBQUklTTUFUSUNcbiAqL1xuQ29uc3RyYWludC5QUklTTUFUSUMgPSA0O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBSRVZPTFVURVxuICovXG5Db25zdHJhaW50LlJFVk9MVVRFID0gNTtcblxuLyoqXG4gKiBTZXQgc3RpZmZuZXNzIGZvciB0aGlzIGNvbnN0cmFpbnQuXG4gKiBAbWV0aG9kIHNldFN0aWZmbmVzc1xuICogQHBhcmFtIHtOdW1iZXJ9IHN0aWZmbmVzc1xuICovXG5Db25zdHJhaW50LnByb3RvdHlwZS5zZXRTdGlmZm5lc3MgPSBmdW5jdGlvbihzdGlmZm5lc3Mpe1xuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gZXFzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGVxID0gZXFzW2ldO1xuICAgICAgICBlcS5zdGlmZm5lc3MgPSBzdGlmZm5lc3M7XG4gICAgICAgIGVxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCByZWxheGF0aW9uIGZvciB0aGlzIGNvbnN0cmFpbnQuXG4gKiBAbWV0aG9kIHNldFJlbGF4YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSByZWxheGF0aW9uXG4gKi9cbkNvbnN0cmFpbnQucHJvdG90eXBlLnNldFJlbGF4YXRpb24gPSBmdW5jdGlvbihyZWxheGF0aW9uKXtcbiAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnM7XG4gICAgZm9yKHZhciBpPTA7IGkgIT09IGVxcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBlcSA9IGVxc1tpXTtcbiAgICAgICAgZXEucmVsYXhhdGlvbiA9IHJlbGF4YXRpb247XG4gICAgICAgIGVxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG59O1xuXG59LHtcIi4uL3V0aWxzL1V0aWxzXCI6NTB9XSwxNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4vQ29uc3RyYWludCcpXG4sICAgRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvRXF1YXRpb24nKVxuLCAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaXN0YW5jZUNvbnN0cmFpbnQ7XG5cbi8qKlxuICogQ29uc3RyYWludCB0aGF0IHRyaWVzIHRvIGtlZXAgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGJvZGllcyBjb25zdGFudC5cbiAqXG4gKiBAY2xhc3MgRGlzdGFuY2VDb25zdHJhaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kaXN0YW5jZV0gVGhlIGRpc3RhbmNlIHRvIGtlZXAgYmV0d2VlbiB0aGUgYW5jaG9yIHBvaW50cy4gRGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm9kaWVzLlxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubG9jYWxBbmNob3JBXSBUaGUgYW5jaG9yIHBvaW50IGZvciBib2R5QSwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBIGZyYW1lLiBEZWZhdWx0cyB0byBbMCwwXS5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmxvY2FsQW5jaG9yQl0gVGhlIGFuY2hvciBwb2ludCBmb3IgYm9keUIsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5QiBmcmFtZS4gRGVmYXVsdHMgdG8gWzAsMF0uXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMubWF4Rm9yY2U9TnVtYmVyLk1BWF9WQUxVRV0gTWF4aW11bSBmb3JjZSB0byBhcHBseS5cbiAqIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIElmIGRpc3RhbmNlIGlzIG5vdCBnaXZlbiBhcyBhbiBvcHRpb24sIHRoZW4gdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm9kaWVzIGlzIHVzZWQuXG4gKiAgICAgLy8gSW4gdGhpcyBleGFtcGxlLCB0aGUgYm9kaWVzIHdpbGwgYmUgY29uc3RyYWluZWQgdG8gaGF2ZSBhIGRpc3RhbmNlIG9mIDIgYmV0d2VlbiB0aGVpciBjZW50ZXJzLlxuICogICAgIHZhciBib2R5QSA9IG5ldyBCb2R5KHsgbWFzczogMSwgcG9zaXRpb246IFstMSwgMF0gfSk7XG4gKiAgICAgdmFyIGJvZHlCID0gbmV3IEJvZHkoeyBtYXNzOiAxLCBwb3NpdGlvbjogWzEsIDBdIH0pO1xuICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IERpc3RhbmNlQ29uc3RyYWludChib2R5QSwgYm9keUIpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgRGlzdGFuY2VDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwge1xuICogICAgICAgICBkaXN0YW5jZTogMSwgICAgICAgICAgLy8gRGlzdGFuY2UgdG8ga2VlcCBiZXR3ZWVuIHRoZSBwb2ludHNcbiAqICAgICAgICAgbG9jYWxBbmNob3JBOiBbMSwgMF0sIC8vIFBvaW50IG9uIGJvZHlBXG4gKiAgICAgICAgIGxvY2FsQW5jaG9yQjogWy0xLCAwXSAvLyBQb2ludCBvbiBib2R5QlxuICogICAgIH0pO1xuICovXG5mdW5jdGlvbiBEaXN0YW5jZUNvbnN0cmFpbnQoYm9keUEsYm9keUIsb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMse1xuICAgICAgICBsb2NhbEFuY2hvckE6WzAsMF0sXG4gICAgICAgIGxvY2FsQW5jaG9yQjpbMCwwXVxuICAgIH0pO1xuXG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsYm9keUEsYm9keUIsQ29uc3RyYWludC5ESVNUQU5DRSxvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIExvY2FsIGFuY2hvciBpbiBib2R5IEEuXG4gICAgICogQHByb3BlcnR5IGxvY2FsQW5jaG9yQVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IHZlYzIuZnJvbVZhbHVlcyhvcHRpb25zLmxvY2FsQW5jaG9yQVswXSwgb3B0aW9ucy5sb2NhbEFuY2hvckFbMV0pO1xuXG4gICAgLyoqXG4gICAgICogTG9jYWwgYW5jaG9yIGluIGJvZHkgQi5cbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JCXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxBbmNob3JCID0gdmVjMi5mcm9tVmFsdWVzKG9wdGlvbnMubG9jYWxBbmNob3JCWzBdLCBvcHRpb25zLmxvY2FsQW5jaG9yQlsxXSk7XG5cbiAgICB2YXIgbG9jYWxBbmNob3JBID0gdGhpcy5sb2NhbEFuY2hvckE7XG4gICAgdmFyIGxvY2FsQW5jaG9yQiA9IHRoaXMubG9jYWxBbmNob3JCO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRpc3RhbmNlIHRvIGtlZXAuXG4gICAgICogQHByb3BlcnR5IGRpc3RhbmNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRpc3RhbmNlID0gMDtcblxuICAgIGlmKHR5cGVvZihvcHRpb25zLmRpc3RhbmNlKSA9PT0gJ251bWJlcicpe1xuICAgICAgICB0aGlzLmRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2UgdGhlIGN1cnJlbnQgd29ybGQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgd29ybGQgYW5jaG9yIHBvaW50cy5cbiAgICAgICAgdmFyIHdvcmxkQW5jaG9yQSA9IHZlYzIuY3JlYXRlKCksXG4gICAgICAgICAgICB3b3JsZEFuY2hvckIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgICAgICAgICAgciA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtIGxvY2FsIGFuY2hvcnMgdG8gd29ybGRcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRBbmNob3JBLCBsb2NhbEFuY2hvckEsIGJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRBbmNob3JCLCBsb2NhbEFuY2hvckIsIGJvZHlCLmFuZ2xlKTtcblxuICAgICAgICB2ZWMyLmFkZChyLCBib2R5Qi5wb3NpdGlvbiwgd29ybGRBbmNob3JCKTtcbiAgICAgICAgdmVjMi5zdWIociwgciwgd29ybGRBbmNob3JBKTtcbiAgICAgICAgdmVjMi5zdWIociwgciwgYm9keUEucG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSB2ZWMyLmxlbmd0aChyKTtcbiAgICB9XG5cbiAgICB2YXIgbWF4Rm9yY2U7XG4gICAgaWYodHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpPT09XCJ1bmRlZmluZWRcIiApe1xuICAgICAgICBtYXhGb3JjZSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbWF4Rm9yY2UgPSBvcHRpb25zLm1heEZvcmNlO1xuICAgIH1cblxuICAgIHZhciBub3JtYWwgPSBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKTsgLy8gSnVzdCBpbiB0aGUgbm9ybWFsIGRpcmVjdGlvblxuICAgIHRoaXMuZXF1YXRpb25zID0gWyBub3JtYWwgXTtcblxuICAgIC8qKlxuICAgICAqIE1heCBmb3JjZSB0byBhcHBseS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4Rm9yY2VcbiAgICAgKi9cbiAgICB0aGlzLm1heEZvcmNlID0gbWF4Rm9yY2U7XG5cbiAgICAvLyBnID0gKHhpIC0geGopLmRvdChuKVxuICAgIC8vIGRnL2R0ID0gKHZpIC0gdmopLmRvdChuKSA9IEcqVyA9IFtuIDAgLW4gMF0gKiBbdmkgd2kgdmogd2pdJ1xuXG4gICAgLy8gLi4uYW5kIGlmIHdlIHdlcmUgdG8gaW5jbHVkZSBvZmZzZXQgcG9pbnRzIChUT0RPIGZvciBub3cpOlxuICAgIC8vIGcgPVxuICAgIC8vICAgICAgKHhqICsgcmogLSB4aSAtIHJpKS5kb3QobikgLSBkaXN0YW5jZVxuICAgIC8vXG4gICAgLy8gZGcvZHQgPVxuICAgIC8vICAgICAgKHZqICsgd2ogeCByaiAtIHZpIC0gd2kgeCByaSkuZG90KG4pID1cbiAgICAvLyAgICAgIHsgdGVybSAyIGlzIG5lYXIgemVybyB9ID1cbiAgICAvLyAgICAgIFstbiAgIC1yaSB4IG4gICBuICAgcmogeCBuXSAqIFt2aSB3aSB2aiB3al0nID1cbiAgICAvLyAgICAgIEcgKiBXXG4gICAgLy9cbiAgICAvLyA9PiBHID0gWy1uIC1yaXhuIG4gcmp4bl1cblxuICAgIHZhciByID0gdmVjMi5jcmVhdGUoKTtcbiAgICB2YXIgcmkgPSB2ZWMyLmNyZWF0ZSgpOyAvLyB3b3JsZEFuY2hvckFcbiAgICB2YXIgcmogPSB2ZWMyLmNyZWF0ZSgpOyAvLyB3b3JsZEFuY2hvckJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgbm9ybWFsLmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgICAgICB4aSA9IGJvZHlBLnBvc2l0aW9uLFxuICAgICAgICAgICAgeGogPSBib2R5Qi5wb3NpdGlvbjtcblxuICAgICAgICAvLyBUcmFuc2Zvcm0gbG9jYWwgYW5jaG9ycyB0byB3b3JsZFxuICAgICAgICB2ZWMyLnJvdGF0ZShyaSwgbG9jYWxBbmNob3JBLCBib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHJqLCBsb2NhbEFuY2hvckIsIGJvZHlCLmFuZ2xlKTtcblxuICAgICAgICB2ZWMyLmFkZChyLCB4aiwgcmopO1xuICAgICAgICB2ZWMyLnN1YihyLCByLCByaSk7XG4gICAgICAgIHZlYzIuc3ViKHIsIHIsIHhpKTtcblxuICAgICAgICAvL3ZlYzIuc3ViKHIsIGJvZHlCLnBvc2l0aW9uLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHJldHVybiB2ZWMyLmxlbmd0aChyKSAtIHRoYXQuZGlzdGFuY2U7XG4gICAgfTtcblxuICAgIC8vIE1ha2UgdGhlIGNvbnRhY3QgY29uc3RyYWludCBiaWxhdGVyYWxcbiAgICB0aGlzLnNldE1heEZvcmNlKG1heEZvcmNlKTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSB1cHBlciBsaW1pdCBpcyBlbmFibGVkIG9yIG5vdC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHVwcGVyTGltaXRFbmFibGVkXG4gICAgICovXG4gICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHVwcGVyIGNvbnN0cmFpbnQgbGltaXQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHVwcGVyTGltaXRcbiAgICAgKi9cbiAgICB0aGlzLnVwcGVyTGltaXQgPSAxO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGxvd2VyIGxpbWl0IGlzIGVuYWJsZWQgb3Igbm90LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbG93ZXJMaW1pdEVuYWJsZWRcbiAgICAgKi9cbiAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG93ZXIgY29uc3RyYWludCBsaW1pdC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbG93ZXJMaW1pdFxuICAgICAqL1xuICAgIHRoaXMubG93ZXJMaW1pdCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGNvbnN0cmFpbnQgcG9zaXRpb24uIFRoaXMgaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgd29ybGQgYW5jaG9yIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcG9zaXRpb25cbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gMDtcbn1cbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuRGlzdGFuY2VDb25zdHJhaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERpc3RhbmNlQ29uc3RyYWludDtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGNvbnN0cmFpbnQgZXF1YXRpb25zLiBTaG91bGQgYmUgZG9uZSBpZiBhbnkgb2YgdGhlIGJvZGllcyBjaGFuZ2VkIHBvc2l0aW9uLCBiZWZvcmUgc29sdmluZy5cbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cbnZhciBuID0gdmVjMi5jcmVhdGUoKTtcbnZhciByaSA9IHZlYzIuY3JlYXRlKCk7IC8vIHdvcmxkQW5jaG9yQVxudmFyIHJqID0gdmVjMi5jcmVhdGUoKTsgLy8gd29ybGRBbmNob3JCXG5EaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIG5vcm1hbCA9IHRoaXMuZXF1YXRpb25zWzBdLFxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcbiAgICAgICAgZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlLFxuICAgICAgICB4aSA9IGJvZHlBLnBvc2l0aW9uLFxuICAgICAgICB4aiA9IGJvZHlCLnBvc2l0aW9uLFxuICAgICAgICBub3JtYWxFcXVhdGlvbiA9IHRoaXMuZXF1YXRpb25zWzBdLFxuICAgICAgICBHID0gbm9ybWFsLkc7XG5cbiAgICAvLyBUcmFuc2Zvcm0gbG9jYWwgYW5jaG9ycyB0byB3b3JsZFxuICAgIHZlYzIucm90YXRlKHJpLCB0aGlzLmxvY2FsQW5jaG9yQSwgYm9keUEuYW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHJqLCB0aGlzLmxvY2FsQW5jaG9yQiwgYm9keUIuYW5nbGUpO1xuXG4gICAgLy8gR2V0IHdvcmxkIGFuY2hvciBwb2ludHMgYW5kIG5vcm1hbFxuICAgIHZlYzIuYWRkKG4sIHhqLCByaik7XG4gICAgdmVjMi5zdWIobiwgbiwgcmkpO1xuICAgIHZlYzIuc3ViKG4sIG4sIHhpKTtcbiAgICB0aGlzLnBvc2l0aW9uID0gdmVjMi5sZW5ndGgobik7XG5cbiAgICB2YXIgdmlvbGF0aW5nID0gZmFsc2U7XG4gICAgaWYodGhpcy51cHBlckxpbWl0RW5hYmxlZCl7XG4gICAgICAgIGlmKHRoaXMucG9zaXRpb24gPiB0aGlzLnVwcGVyTGltaXQpe1xuICAgICAgICAgICAgbm9ybWFsRXF1YXRpb24ubWF4Rm9yY2UgPSAwO1xuICAgICAgICAgICAgbm9ybWFsRXF1YXRpb24ubWluRm9yY2UgPSAtdGhpcy5tYXhGb3JjZTtcbiAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSB0aGlzLnVwcGVyTGltaXQ7XG4gICAgICAgICAgICB2aW9sYXRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5sb3dlckxpbWl0RW5hYmxlZCl7XG4gICAgICAgIGlmKHRoaXMucG9zaXRpb24gPCB0aGlzLmxvd2VyTGltaXQpe1xuICAgICAgICAgICAgbm9ybWFsRXF1YXRpb24ubWF4Rm9yY2UgPSB0aGlzLm1heEZvcmNlO1xuICAgICAgICAgICAgbm9ybWFsRXF1YXRpb24ubWluRm9yY2UgPSAwO1xuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IHRoaXMubG93ZXJMaW1pdDtcbiAgICAgICAgICAgIHZpb2xhdGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZigodGhpcy5sb3dlckxpbWl0RW5hYmxlZCB8fCB0aGlzLnVwcGVyTGltaXRFbmFibGVkKSAmJiAhdmlvbGF0aW5nKXtcbiAgICAgICAgLy8gTm8gY29uc3RyYWludCBuZWVkZWQuXG4gICAgICAgIG5vcm1hbEVxdWF0aW9uLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5vcm1hbEVxdWF0aW9uLmVuYWJsZWQgPSB0cnVlO1xuXG4gICAgdmVjMi5ub3JtYWxpemUobixuKTtcblxuICAgIC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0c1xuICAgIHZhciByaXhuID0gdmVjMi5jcm9zc0xlbmd0aChyaSwgbiksXG4gICAgICAgIHJqeG4gPSB2ZWMyLmNyb3NzTGVuZ3RoKHJqLCBuKTtcblxuICAgIC8vIEcgPSBbLW4gLXJpeG4gbiByanhuXVxuICAgIEdbMF0gPSAtblswXTtcbiAgICBHWzFdID0gLW5bMV07XG4gICAgR1syXSA9IC1yaXhuO1xuICAgIEdbM10gPSBuWzBdO1xuICAgIEdbNF0gPSBuWzFdO1xuICAgIEdbNV0gPSByanhuO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heCBmb3JjZSB0byBiZSB1c2VkXG4gKiBAbWV0aG9kIHNldE1heEZvcmNlXG4gKiBAcGFyYW0ge051bWJlcn0gZlxuICovXG5EaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlLnNldE1heEZvcmNlID0gZnVuY3Rpb24oZil7XG4gICAgdmFyIG5vcm1hbCA9IHRoaXMuZXF1YXRpb25zWzBdO1xuICAgIG5vcm1hbC5taW5Gb3JjZSA9IC1mO1xuICAgIG5vcm1hbC5tYXhGb3JjZSA9ICBmO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1heCBmb3JjZVxuICogQG1ldGhvZCBnZXRNYXhGb3JjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5EaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlLmdldE1heEZvcmNlID0gZnVuY3Rpb24oZil7XG4gICAgdmFyIG5vcm1hbCA9IHRoaXMuZXF1YXRpb25zWzBdO1xuICAgIHJldHVybiBub3JtYWwubWF4Rm9yY2U7XG59O1xuXG59LHtcIi4uL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIzLFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi91dGlscy9VdGlsc1wiOjUwLFwiLi9Db25zdHJhaW50XCI6MTV9XSwxNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4vQ29uc3RyYWludCcpXG4sICAgRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvRXF1YXRpb24nKVxuLCAgIEFuZ2xlTG9ja0VxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0FuZ2xlTG9ja0VxdWF0aW9uJylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gR2VhckNvbnN0cmFpbnQ7XG5cbi8qKlxuICogQ29ubmVjdHMgdHdvIGJvZGllcyBhdCBnaXZlbiBvZmZzZXQgcG9pbnRzLCBsZXR0aW5nIHRoZW0gcm90YXRlIHJlbGF0aXZlIHRvIGVhY2ggb3RoZXIgYXJvdW5kIHRoaXMgcG9pbnQuXG4gKiBAY2xhc3MgR2VhckNvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSAgICAgICAgICAgIGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9ICAgICAgICAgICAgYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICBbb3B0aW9ucy5hbmdsZT0wXSBSZWxhdGl2ZSBhbmdsZSBiZXR3ZWVuIHRoZSBib2RpZXMuIFdpbGwgYmUgc2V0IHRvIHRoZSBjdXJyZW50IGFuZ2xlIGJldHdlZW4gdGhlIGJvZGllcyAodGhlIGdlYXIgcmF0aW8gaXMgYWNjb3VudGVkIGZvcikuXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgW29wdGlvbnMucmF0aW89MV0gR2VhciByYXRpby5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICBbb3B0aW9ucy5tYXhUb3JxdWVdIE1heGltdW0gdG9ycXVlIHRvIGFwcGx5LlxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICogQHRvZG8gQWJpbGl0eSB0byBzcGVjaWZ5IHdvcmxkIHBvaW50c1xuICovXG5mdW5jdGlvbiBHZWFyQ29uc3RyYWludChib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsIGJvZHlBLCBib2R5QiwgQ29uc3RyYWludC5HRUFSLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBnZWFyIHJhdGlvLlxuICAgICAqIEBwcm9wZXJ0eSByYXRpb1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yYXRpbyA9IHR5cGVvZihvcHRpb25zLnJhdGlvKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMucmF0aW8gOiAxO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlbGF0aXZlIGFuZ2xlXG4gICAgICogQHByb3BlcnR5IGFuZ2xlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFuZ2xlID0gdHlwZW9mKG9wdGlvbnMuYW5nbGUpID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5hbmdsZSA6IGJvZHlCLmFuZ2xlIC0gdGhpcy5yYXRpbyAqIGJvZHlBLmFuZ2xlO1xuXG4gICAgLy8gU2VuZCBzYW1lIHBhcmFtZXRlcnMgdG8gdGhlIGVxdWF0aW9uXG4gICAgb3B0aW9ucy5hbmdsZSA9IHRoaXMuYW5nbGU7XG4gICAgb3B0aW9ucy5yYXRpbyA9IHRoaXMucmF0aW87XG5cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtcbiAgICAgICAgbmV3IEFuZ2xlTG9ja0VxdWF0aW9uKGJvZHlBLGJvZHlCLG9wdGlvbnMpLFxuICAgIF07XG5cbiAgICAvLyBTZXQgbWF4IHRvcnF1ZVxuICAgIGlmKHR5cGVvZihvcHRpb25zLm1heFRvcnF1ZSkgPT09IFwibnVtYmVyXCIpe1xuICAgICAgICB0aGlzLnNldE1heFRvcnF1ZShvcHRpb25zLm1heFRvcnF1ZSk7XG4gICAgfVxufVxuR2VhckNvbnN0cmFpbnQucHJvdG90eXBlID0gbmV3IENvbnN0cmFpbnQoKTtcbkdlYXJDb25zdHJhaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlYXJDb25zdHJhaW50O1xuXG5HZWFyQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZXEgPSB0aGlzLmVxdWF0aW9uc1swXTtcbiAgICBpZihlcS5yYXRpbyAhPT0gdGhpcy5yYXRpbyl7XG4gICAgICAgIGVxLnNldFJhdGlvKHRoaXMucmF0aW8pO1xuICAgIH1cbiAgICBlcS5hbmdsZSA9IHRoaXMuYW5nbGU7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4IHRvcnF1ZSBmb3IgdGhlIGNvbnN0cmFpbnQuXG4gKiBAbWV0aG9kIHNldE1heFRvcnF1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcnF1ZVxuICovXG5HZWFyQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TWF4VG9ycXVlID0gZnVuY3Rpb24odG9ycXVlKXtcbiAgICB0aGlzLmVxdWF0aW9uc1swXS5zZXRNYXhUb3JxdWUodG9ycXVlKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBtYXggdG9ycXVlIGZvciB0aGUgY29uc3RyYWludC5cbiAqIEBtZXRob2QgZ2V0TWF4VG9ycXVlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkdlYXJDb25zdHJhaW50LnByb3RvdHlwZS5nZXRNYXhUb3JxdWUgPSBmdW5jdGlvbih0b3JxdWUpe1xuICAgIHJldHVybiB0aGlzLmVxdWF0aW9uc1swXS5tYXhGb3JjZTtcbn07XG59LHtcIi4uL2VxdWF0aW9ucy9BbmdsZUxvY2tFcXVhdGlvblwiOjIxLFwiLi4vZXF1YXRpb25zL0VxdWF0aW9uXCI6MjMsXCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4vQ29uc3RyYWludFwiOjE1fV0sMTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIENvbnN0cmFpbnQgPSBfZGVyZXFfKCcuL0NvbnN0cmFpbnQnKVxuLCAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0VxdWF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTG9ja0NvbnN0cmFpbnQ7XG5cbi8qKlxuICogTG9ja3MgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGJldHdlZW4gdHdvIGJvZGllcy5cbiAqXG4gKiBAY2xhc3MgTG9ja0NvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLmxvY2FsT2Zmc2V0Ql0gVGhlIG9mZnNldCBvZiBib2R5QiBpbiBib2R5QSdzIGZyYW1lLiBJZiBub3QgZ2l2ZW4gdGhlIG9mZnNldCBpcyBjb21wdXRlZCBmcm9tIGN1cnJlbnQgcG9zaXRpb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxvY2FsQW5nbGVCXSBUaGUgYW5nbGUgb2YgYm9keUIgaW4gYm9keUEncyBmcmFtZS4gSWYgbm90IGdpdmVuLCB0aGUgYW5nbGUgaXMgY29tcHV0ZWQgZnJvbSBjdXJyZW50IGFuZ2xlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhGb3JjZV1cbiAqIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqL1xuZnVuY3Rpb24gTG9ja0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLGJvZHlBLGJvZHlCLENvbnN0cmFpbnQuTE9DSyxvcHRpb25zKTtcblxuICAgIHZhciBtYXhGb3JjZSA9ICggdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpPT09XCJ1bmRlZmluZWRcIiA/IE51bWJlci5NQVhfVkFMVUUgOiBvcHRpb25zLm1heEZvcmNlICk7XG5cbiAgICB2YXIgbG9jYWxBbmdsZUIgPSBvcHRpb25zLmxvY2FsQW5nbGVCIHx8IDA7XG5cbiAgICAvLyBVc2UgMyBlcXVhdGlvbnM6XG4gICAgLy8gZ3ggPSAgICh4aiAtIHhpIC0gbCkgKiB4aGF0ID0gMFxuICAgIC8vIGd5ID0gICAoeGogLSB4aSAtIGwpICogeWhhdCA9IDBcbiAgICAvLyBnciA9ICAgKHhpIC0geGogKyByKSAqIHRoYXQgPSAwXG4gICAgLy9cbiAgICAvLyAuLi53aGVyZTpcbiAgICAvLyAgIGwgaXMgdGhlIGxvY2FsT2Zmc2V0QiB2ZWN0b3Igcm90YXRlZCB0byB3b3JsZCBpbiBib2R5QSBmcmFtZVxuICAgIC8vICAgciBpcyB0aGUgc2FtZSB2ZWN0b3IgYnV0IHJldmVyc2VkIGFuZCByb3RhdGVkIGZyb20gYm9keUIgZnJhbWVcbiAgICAvLyAgIHhoYXQsIHloYXQgYXJlIHdvcmxkIGF4aXMgdmVjdG9yc1xuICAgIC8vICAgdGhhdCBpcyB0aGUgdGFuZ2VudCBvZiByXG4gICAgLy9cbiAgICAvLyBGb3IgdGhlIGZpcnN0IHR3byBjb25zdHJhaW50cywgd2UgZ2V0XG4gICAgLy8gRypXID0gKHZqIC0gdmkgLSBsZG90ICApICogeGhhdFxuICAgIC8vICAgICA9ICh2aiAtIHZpIC0gd2kgeCBsKSAqIHhoYXRcbiAgICAvL1xuICAgIC8vIFNpbmNlICh3aSB4IGwpICogeGhhdCA9IChsIHggeGhhdCkgKiB3aSwgd2UgZ2V0XG4gICAgLy8gRypXID0gWyAtMSAgIDAgICAoLWwgeCB4aGF0KSAgMSAgIDAgICAwXSAqIFt2aSB3aSB2aiB3al1cbiAgICAvL1xuICAgIC8vIFRoZSBsYXN0IGNvbnN0cmFpbnQgZ2l2ZXNcbiAgICAvLyBHVyA9ICh2aSAtIHZqICsgd2ogeCByKSAqIHRoYXRcbiAgICAvLyAgICA9IFsgIHRoYXQgICAwICAtdGhhdCAgKHIgeCB0KSBdXG5cbiAgICB2YXIgeCA9ICAgICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKSxcbiAgICAgICAgeSA9ICAgICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKSxcbiAgICAgICAgcm90ID0gICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKTtcblxuICAgIHZhciBsID0gdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgZyA9IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIHRoYXQgPSB0aGlzO1xuICAgIHguY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmVjMi5yb3RhdGUobCwgdGhhdC5sb2NhbE9mZnNldEIsIGJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5zdWIoZywgYm9keUIucG9zaXRpb24sIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIoZywgZywgbCk7XG4gICAgICAgIHJldHVybiBnWzBdO1xuICAgIH07XG4gICAgeS5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2ZWMyLnJvdGF0ZShsLCB0aGF0LmxvY2FsT2Zmc2V0QiwgYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnN1YihnLCBib2R5Qi5wb3NpdGlvbiwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1YihnLCBnLCBsKTtcbiAgICAgICAgcmV0dXJuIGdbMV07XG4gICAgfTtcbiAgICB2YXIgciA9IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIHQgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIHJvdC5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2ZWMyLnJvdGF0ZShyLCB0aGF0LmxvY2FsT2Zmc2V0QiwgYm9keUIuYW5nbGUgLSB0aGF0LmxvY2FsQW5nbGVCKTtcbiAgICAgICAgdmVjMi5zY2FsZShyLHIsLTEpO1xuICAgICAgICB2ZWMyLnN1YihnLGJvZHlBLnBvc2l0aW9uLGJvZHlCLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5hZGQoZyxnLHIpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh0LHIsLU1hdGguUEkvMik7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKHQsdCk7XG4gICAgICAgIHJldHVybiB2ZWMyLmRvdChnLHQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2Zmc2V0IG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gbG9jYWxPZmZzZXRCXG4gICAgICovXG4gICAgdGhpcy5sb2NhbE9mZnNldEIgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIGlmKG9wdGlvbnMubG9jYWxPZmZzZXRCKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMubG9jYWxPZmZzZXRCLCBvcHRpb25zLmxvY2FsT2Zmc2V0Qik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29uc3RydWN0IGZyb20gY3VycmVudCBwb3NpdGlvbnNcbiAgICAgICAgdmVjMi5zdWIodGhpcy5sb2NhbE9mZnNldEIsIGJvZHlCLnBvc2l0aW9uLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIucm90YXRlKHRoaXMubG9jYWxPZmZzZXRCLCB0aGlzLmxvY2FsT2Zmc2V0QiwgLWJvZHlBLmFuZ2xlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2Zmc2V0IGFuZ2xlIG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxvY2FsQW5nbGVCXG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuZ2xlQiA9IDA7XG4gICAgaWYodHlwZW9mKG9wdGlvbnMubG9jYWxBbmdsZUIpID09PSAnbnVtYmVyJyl7XG4gICAgICAgIHRoaXMubG9jYWxBbmdsZUIgPSBvcHRpb25zLmxvY2FsQW5nbGVCO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbnN0cnVjdFxuICAgICAgICB0aGlzLmxvY2FsQW5nbGVCID0gYm9keUIuYW5nbGUgLSBib2R5QS5hbmdsZTtcbiAgICB9XG5cbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHgsIHksIHJvdCk7XG4gICAgdGhpcy5zZXRNYXhGb3JjZShtYXhGb3JjZSk7XG59XG5Mb2NrQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9ja0NvbnN0cmFpbnQ7XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGZvcmNlIHRvIGJlIGFwcGxpZWQuXG4gKiBAbWV0aG9kIHNldE1heEZvcmNlXG4gKiBAcGFyYW0ge051bWJlcn0gZm9yY2VcbiAqL1xuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLnNldE1heEZvcmNlID0gZnVuY3Rpb24oZm9yY2Upe1xuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLmVxdWF0aW9ucy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGVxc1tpXS5tYXhGb3JjZSA9ICBmb3JjZTtcbiAgICAgICAgZXFzW2ldLm1pbkZvcmNlID0gLWZvcmNlO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBtYXggZm9yY2UuXG4gKiBAbWV0aG9kIGdldE1heEZvcmNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkxvY2tDb25zdHJhaW50LnByb3RvdHlwZS5nZXRNYXhGb3JjZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZXF1YXRpb25zWzBdLm1heEZvcmNlO1xufTtcblxudmFyIGwgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHIgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHhBeGlzID0gdmVjMi5mcm9tVmFsdWVzKDEsMCk7XG52YXIgeUF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwxKTtcbkxvY2tDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciB4ID0gICB0aGlzLmVxdWF0aW9uc1swXSxcbiAgICAgICAgeSA9ICAgdGhpcy5lcXVhdGlvbnNbMV0sXG4gICAgICAgIHJvdCA9IHRoaXMuZXF1YXRpb25zWzJdLFxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QjtcblxuICAgIHZlYzIucm90YXRlKGwsdGhpcy5sb2NhbE9mZnNldEIsYm9keUEuYW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHIsdGhpcy5sb2NhbE9mZnNldEIsYm9keUIuYW5nbGUgLSB0aGlzLmxvY2FsQW5nbGVCKTtcbiAgICB2ZWMyLnNjYWxlKHIsciwtMSk7XG5cbiAgICB2ZWMyLnJvdGF0ZSh0LHIsTWF0aC5QSS8yKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZSh0LHQpO1xuXG4gICAgeC5HWzBdID0gLTE7XG4gICAgeC5HWzFdID0gIDA7XG4gICAgeC5HWzJdID0gLXZlYzIuY3Jvc3NMZW5ndGgobCx4QXhpcyk7XG4gICAgeC5HWzNdID0gIDE7XG5cbiAgICB5LkdbMF0gPSAgMDtcbiAgICB5LkdbMV0gPSAtMTtcbiAgICB5LkdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aChsLHlBeGlzKTtcbiAgICB5LkdbNF0gPSAgMTtcblxuICAgIHJvdC5HWzBdID0gIC10WzBdO1xuICAgIHJvdC5HWzFdID0gIC10WzFdO1xuICAgIHJvdC5HWzNdID0gIHRbMF07XG4gICAgcm90LkdbNF0gPSAgdFsxXTtcbiAgICByb3QuR1s1XSA9ICB2ZWMyLmNyb3NzTGVuZ3RoKHIsdCk7XG59O1xuXG59LHtcIi4uL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIzLFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL0NvbnN0cmFpbnRcIjoxNX1dLDE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50JylcbiwgICBDb250YWN0RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJylcbiwgICBFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpXG4sICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgUm90YXRpb25hbExvY2tFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTG9ja0VxdWF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJpc21hdGljQ29uc3RyYWludDtcblxuLyoqXG4gKiBDb25zdHJhaW50IHRoYXQgb25seSBhbGxvd3MgYm9kaWVzIHRvIG1vdmUgYWxvbmcgYSBsaW5lLCByZWxhdGl2ZSB0byBlYWNoIG90aGVyLiBTZWUgPGEgaHJlZj1cImh0dHA6Ly93d3cuaWZvcmNlMmQubmV0L2IyZHR1dC9qb2ludHMtcHJpc21hdGljXCI+dGhpcyB0dXRvcmlhbDwvYT4uXG4gKlxuICogQGNsYXNzIFByaXNtYXRpY0NvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSAgICBib2R5QVxuICogQHBhcmFtIHtCb2R5fSAgICBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9ICBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSAgW29wdGlvbnMubWF4Rm9yY2VdICAgICAgICAgICAgICAgIE1heCBmb3JjZSB0byBiZSBhcHBsaWVkIGJ5IHRoZSBjb25zdHJhaW50XG4gKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLmxvY2FsQW5jaG9yQV0gICAgICAgICAgICBCb2R5IEEncyBhbmNob3IgcG9pbnQsIGRlZmluZWQgaW4gaXRzIG93biBsb2NhbCBmcmFtZS5cbiAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMubG9jYWxBbmNob3JCXSAgICAgICAgICAgIEJvZHkgQidzIGFuY2hvciBwb2ludCwgZGVmaW5lZCBpbiBpdHMgb3duIGxvY2FsIGZyYW1lLlxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb2NhbEF4aXNBXSAgICAgICAgICAgICAgQW4gYXhpcywgZGVmaW5lZCBpbiBib2R5IEEgZnJhbWUsIHRoYXQgYm9keSBCJ3MgYW5jaG9yIHBvaW50IG1heSBzbGlkZSBhbG9uZy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZGlzYWJsZVJvdGF0aW9uYWxMb2NrXSAgIElmIHNldCB0byB0cnVlLCBib2R5QiB3aWxsIGJlIGZyZWUgdG8gcm90YXRlIGFyb3VuZCBpdHMgYW5jaG9yIHBvaW50LlxuICogQHBhcmFtIHtOdW1iZXJ9ICBbb3B0aW9ucy51cHBlckxpbWl0XVxuICogQHBhcmFtIHtOdW1iZXJ9ICBbb3B0aW9ucy5sb3dlckxpbWl0XVxuICogQHRvZG8gQWJpbGl0eSB0byBjcmVhdGUgdXNpbmcgb25seSBhIHBvaW50IGFuZCBhIHdvcmxkQXhpc1xuICovXG5mdW5jdGlvbiBQcmlzbWF0aWNDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsYm9keUEsYm9keUIsQ29uc3RyYWludC5QUklTTUFUSUMsb3B0aW9ucyk7XG5cbiAgICAvLyBHZXQgYW5jaG9yc1xuICAgIHZhciBsb2NhbEFuY2hvckEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICAgICAgbG9jYWxBeGlzQSA9IHZlYzIuZnJvbVZhbHVlcygxLDApLFxuICAgICAgICBsb2NhbEFuY2hvckIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcbiAgICBpZihvcHRpb25zLmxvY2FsQW5jaG9yQSl7IHZlYzIuY29weShsb2NhbEFuY2hvckEsIG9wdGlvbnMubG9jYWxBbmNob3JBKTsgfVxuICAgIGlmKG9wdGlvbnMubG9jYWxBeGlzQSl7IHZlYzIuY29weShsb2NhbEF4aXNBLCAgIG9wdGlvbnMubG9jYWxBeGlzQSk7IH1cbiAgICBpZihvcHRpb25zLmxvY2FsQW5jaG9yQil7IHZlYzIuY29weShsb2NhbEFuY2hvckIsIG9wdGlvbnMubG9jYWxBbmNob3JCKTsgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGxvY2FsQW5jaG9yQVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IGxvY2FsQW5jaG9yQTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEFuY2hvckJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckIgPSBsb2NhbEFuY2hvckI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBeGlzQVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQXhpc0EgPSBsb2NhbEF4aXNBO1xuXG4gICAgLypcblxuICAgIFRoZSBjb25zdHJhaW50IHZpb2xhdGlvbiBmb3IgdGhlIGNvbW1vbiBheGlzIHBvaW50IGlzXG5cbiAgICAgICAgZyA9ICggeGogKyByaiAtIHhpIC0gcmkgKSAqIHQgICA6PSAgZ2cqdFxuXG4gICAgd2hlcmUgciBhcmUgYm9keS1sb2NhbCBhbmNob3IgcG9pbnRzLCBhbmQgdCBpcyBhIHRhbmdlbnQgdG8gdGhlIGNvbnN0cmFpbnQgYXhpcyBkZWZpbmVkIGluIGJvZHkgaSBmcmFtZS5cblxuICAgICAgICBnZG90ID0gICggdmogKyB3aiB4IHJqIC0gdmkgLSB3aSB4IHJpICkgKiB0ICsgKCB4aiArIHJqIC0geGkgLSByaSApICogKCB3aSB4IHQgKVxuXG4gICAgTm90ZSB0aGUgdXNlIG9mIHRoZSBjaGFpbiBydWxlLiBOb3cgd2UgaWRlbnRpZnkgdGhlIGphY29iaWFuXG5cbiAgICAgICAgRypXID0gWyAtdCAgICAgIC1yaSB4IHQgKyB0IHggZ2cgICAgIHQgICAgcmogeCB0IF0gKiBbdmkgd2kgdmogd2pdXG5cbiAgICBUaGUgcm90YXRpb25hbCBwYXJ0IGlzIGp1c3QgYSByb3RhdGlvbiBsb2NrLlxuXG4gICAgICovXG5cbiAgICB2YXIgbWF4Rm9yY2UgPSB0aGlzLm1heEZvcmNlID0gdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpIT09XCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMubWF4Rm9yY2UgOiBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgLy8gVHJhbnNsYXRpb25hbCBwYXJ0XG4gICAgdmFyIHRyYW5zID0gbmV3IEVxdWF0aW9uKGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSk7XG4gICAgdmFyIHJpID0gbmV3IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIHJqID0gbmV3IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIGdnID0gbmV3IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIHQgPSAgbmV3IHZlYzIuY3JlYXRlKCk7XG4gICAgdHJhbnMuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gZyA9ICggeGogKyByaiAtIHhpIC0gcmkgKSAqIHRcbiAgICAgICAgcmV0dXJuIHZlYzIuZG90KGdnLHQpO1xuICAgIH07XG4gICAgdHJhbnMudXBkYXRlSmFjb2JpYW4gPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgRyA9IHRoaXMuRyxcbiAgICAgICAgICAgIHhpID0gYm9keUEucG9zaXRpb24sXG4gICAgICAgICAgICB4aiA9IGJvZHlCLnBvc2l0aW9uO1xuICAgICAgICB2ZWMyLnJvdGF0ZShyaSxsb2NhbEFuY2hvckEsYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZShyaixsb2NhbEFuY2hvckIsYm9keUIuYW5nbGUpO1xuICAgICAgICB2ZWMyLmFkZChnZyx4aixyaik7XG4gICAgICAgIHZlYzIuc3ViKGdnLGdnLHhpKTtcbiAgICAgICAgdmVjMi5zdWIoZ2csZ2cscmkpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh0LGxvY2FsQXhpc0EsYm9keUEuYW5nbGUrTWF0aC5QSS8yKTtcblxuICAgICAgICBHWzBdID0gLXRbMF07XG4gICAgICAgIEdbMV0gPSAtdFsxXTtcbiAgICAgICAgR1syXSA9IC12ZWMyLmNyb3NzTGVuZ3RoKHJpLHQpICsgdmVjMi5jcm9zc0xlbmd0aCh0LGdnKTtcbiAgICAgICAgR1szXSA9IHRbMF07XG4gICAgICAgIEdbNF0gPSB0WzFdO1xuICAgICAgICBHWzVdID0gdmVjMi5jcm9zc0xlbmd0aChyaix0KTtcbiAgICB9O1xuICAgIHRoaXMuZXF1YXRpb25zLnB1c2godHJhbnMpO1xuXG4gICAgLy8gUm90YXRpb25hbCBwYXJ0XG4gICAgaWYoIW9wdGlvbnMuZGlzYWJsZVJvdGF0aW9uYWxMb2NrKXtcbiAgICAgICAgdmFyIHJvdCA9IG5ldyBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uKGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSk7XG4gICAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2gocm90KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgYW5jaG9yIEEgcmVsYXRpdmUgdG8gYW5jaG9yIEIsIGFsb25nIHRoZSBjb25zdHJhaW50IGF4aXMuXG4gICAgICogQHByb3BlcnR5IHBvc2l0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gMDtcblxuICAgIC8vIElzIHRoaXMgb25lIHVzZWQgYXQgYWxsP1xuICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIGxvd2VyIGxpbWl0LlxuICAgICAqIEBwcm9wZXJ0eSBsb3dlckxpbWl0RW5hYmxlZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSB0eXBlb2Yob3B0aW9ucy5sb3dlckxpbWl0KSE9PVwidW5kZWZpbmVkXCIgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgdXBwZXIgbGltaXQuXG4gICAgICogQHByb3BlcnR5IHVwcGVyTGltaXRFbmFibGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IHR5cGVvZihvcHRpb25zLnVwcGVyTGltaXQpIT09XCJ1bmRlZmluZWRcIiA/IHRydWUgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIExvd2VyIGNvbnN0cmFpbnQgbGltaXQuIFRoZSBjb25zdHJhaW50IHBvc2l0aW9uIGlzIGZvcmNlZCB0byBiZSBsYXJnZXIgdGhhbiB0aGlzIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSBsb3dlckxpbWl0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxvd2VyTGltaXQgPSB0eXBlb2Yob3B0aW9ucy5sb3dlckxpbWl0KSE9PVwidW5kZWZpbmVkXCIgPyBvcHRpb25zLmxvd2VyTGltaXQgOiAwO1xuXG4gICAgLyoqXG4gICAgICogVXBwZXIgY29uc3RyYWludCBsaW1pdC4gVGhlIGNvbnN0cmFpbnQgcG9zaXRpb24gaXMgZm9yY2VkIHRvIGJlIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB1cHBlckxpbWl0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnVwcGVyTGltaXQgPSB0eXBlb2Yob3B0aW9ucy51cHBlckxpbWl0KSE9PVwidW5kZWZpbmVkXCIgPyBvcHRpb25zLnVwcGVyTGltaXQgOiAxO1xuXG4gICAgLy8gRXF1YXRpb25zIHVzZWQgZm9yIGxpbWl0c1xuICAgIHRoaXMudXBwZXJMaW1pdEVxdWF0aW9uID0gbmV3IENvbnRhY3RFcXVhdGlvbihib2R5QSxib2R5Qik7XG4gICAgdGhpcy5sb3dlckxpbWl0RXF1YXRpb24gPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcblxuICAgIC8vIFNldCBtYXgvbWluIGZvcmNlc1xuICAgIHRoaXMudXBwZXJMaW1pdEVxdWF0aW9uLm1pbkZvcmNlID0gdGhpcy5sb3dlckxpbWl0RXF1YXRpb24ubWluRm9yY2UgPSAwO1xuICAgIHRoaXMudXBwZXJMaW1pdEVxdWF0aW9uLm1heEZvcmNlID0gdGhpcy5sb3dlckxpbWl0RXF1YXRpb24ubWF4Rm9yY2UgPSBtYXhGb3JjZTtcblxuICAgIC8qKlxuICAgICAqIEVxdWF0aW9uIHVzZWQgZm9yIHRoZSBtb3Rvci5cbiAgICAgKiBAcHJvcGVydHkgbW90b3JFcXVhdGlvblxuICAgICAqIEB0eXBlIHtFcXVhdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLm1vdG9yRXF1YXRpb24gPSBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgbW90b3Igc3RhdGUuIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBtb3RvciB1c2luZyAuZW5hYmxlTW90b3JcbiAgICAgKiBAcHJvcGVydHkgbW90b3JFbmFibGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5tb3RvckVuYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdGFyZ2V0IHNwZWVkIGZvciB0aGUgbW90b3IuXG4gICAgICogQHByb3BlcnR5IG1vdG9yU3BlZWRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubW90b3JTcGVlZCA9IDA7XG5cbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIG1vdG9yRXF1YXRpb24gPSB0aGlzLm1vdG9yRXF1YXRpb247XG4gICAgdmFyIG9sZCA9IG1vdG9yRXF1YXRpb24uY29tcHV0ZUdXO1xuICAgIG1vdG9yRXF1YXRpb24uY29tcHV0ZUdxID0gZnVuY3Rpb24oKXsgcmV0dXJuIDA7IH07XG4gICAgbW90b3JFcXVhdGlvbi5jb21wdXRlR1cgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgRyA9IHRoaXMuRyxcbiAgICAgICAgICAgIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgICAgIHZpID0gYmkudmVsb2NpdHksXG4gICAgICAgICAgICB2aiA9IGJqLnZlbG9jaXR5LFxuICAgICAgICAgICAgd2kgPSBiaS5hbmd1bGFyVmVsb2NpdHksXG4gICAgICAgICAgICB3aiA9IGJqLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ211bHQoRyx2aSx3aSx2aix3aikgKyB0aGF0Lm1vdG9yU3BlZWQ7XG4gICAgfTtcbn1cblxuUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQcmlzbWF0aWNDb25zdHJhaW50O1xuXG52YXIgd29ybGRBeGlzQSA9IHZlYzIuY3JlYXRlKCksXG4gICAgd29ybGRBbmNob3JBID0gdmVjMi5jcmVhdGUoKSxcbiAgICB3b3JsZEFuY2hvckIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIG9yaWVudGVkQW5jaG9yQSA9IHZlYzIuY3JlYXRlKCksXG4gICAgb3JpZW50ZWRBbmNob3JCID0gdmVjMi5jcmVhdGUoKSxcbiAgICB0bXAgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgY29uc3RyYWludCBlcXVhdGlvbnMuIFNob3VsZCBiZSBkb25lIGlmIGFueSBvZiB0aGUgYm9kaWVzIGNoYW5nZWQgcG9zaXRpb24sIGJlZm9yZSBzb2x2aW5nLlxuICogQG1ldGhvZCB1cGRhdGVcbiAqL1xuUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnMsXG4gICAgICAgIHRyYW5zID0gZXFzWzBdLFxuICAgICAgICB1cHBlckxpbWl0ID0gdGhpcy51cHBlckxpbWl0LFxuICAgICAgICBsb3dlckxpbWl0ID0gdGhpcy5sb3dlckxpbWl0LFxuICAgICAgICB1cHBlckxpbWl0RXF1YXRpb24gPSB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbixcbiAgICAgICAgbG93ZXJMaW1pdEVxdWF0aW9uID0gdGhpcy5sb3dlckxpbWl0RXF1YXRpb24sXG4gICAgICAgIGJvZHlBID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICBsb2NhbEF4aXNBID0gdGhpcy5sb2NhbEF4aXNBLFxuICAgICAgICBsb2NhbEFuY2hvckEgPSB0aGlzLmxvY2FsQW5jaG9yQSxcbiAgICAgICAgbG9jYWxBbmNob3JCID0gdGhpcy5sb2NhbEFuY2hvckI7XG5cbiAgICB0cmFucy51cGRhdGVKYWNvYmlhbigpO1xuXG4gICAgLy8gVHJhbnNmb3JtIGxvY2FsIHRoaW5ncyB0byB3b3JsZFxuICAgIHZlYzIucm90YXRlKHdvcmxkQXhpc0EsICAgICAgbG9jYWxBeGlzQSwgICAgICBib2R5QS5hbmdsZSk7XG4gICAgdmVjMi5yb3RhdGUob3JpZW50ZWRBbmNob3JBLCBsb2NhbEFuY2hvckEsICAgIGJvZHlBLmFuZ2xlKTtcbiAgICB2ZWMyLmFkZCh3b3JsZEFuY2hvckEsICAgICAgIG9yaWVudGVkQW5jaG9yQSwgYm9keUEucG9zaXRpb24pO1xuICAgIHZlYzIucm90YXRlKG9yaWVudGVkQW5jaG9yQiwgbG9jYWxBbmNob3JCLCAgICBib2R5Qi5hbmdsZSk7XG4gICAgdmVjMi5hZGQod29ybGRBbmNob3JCLCAgICAgICBvcmllbnRlZEFuY2hvckIsIGJvZHlCLnBvc2l0aW9uKTtcblxuICAgIHZhciByZWxQb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gPSB2ZWMyLmRvdCh3b3JsZEFuY2hvckIsd29ybGRBeGlzQSkgLSB2ZWMyLmRvdCh3b3JsZEFuY2hvckEsd29ybGRBeGlzQSk7XG5cbiAgICAvLyBNb3RvclxuICAgIGlmKHRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgLy8gRyA9IFsgYSAgICAgYSB4IHJpICAgLWEgICAtYSB4IHJqIF1cbiAgICAgICAgdmFyIEcgPSB0aGlzLm1vdG9yRXF1YXRpb24uRztcbiAgICAgICAgR1swXSA9IHdvcmxkQXhpc0FbMF07XG4gICAgICAgIEdbMV0gPSB3b3JsZEF4aXNBWzFdO1xuICAgICAgICBHWzJdID0gdmVjMi5jcm9zc0xlbmd0aCh3b3JsZEF4aXNBLG9yaWVudGVkQW5jaG9yQik7XG4gICAgICAgIEdbM10gPSAtd29ybGRBeGlzQVswXTtcbiAgICAgICAgR1s0XSA9IC13b3JsZEF4aXNBWzFdO1xuICAgICAgICBHWzVdID0gLXZlYzIuY3Jvc3NMZW5ndGgod29ybGRBeGlzQSxvcmllbnRlZEFuY2hvckEpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICAgIExpbWl0cyBzdHJhdGVneTpcbiAgICAgICAgQWRkIGNvbnRhY3QgZXF1YXRpb24sIHdpdGggbm9ybWFsIGFsb25nIHRoZSBjb25zdHJhaW50IGF4aXMuXG4gICAgICAgIG1pbi9tYXhGb3JjZSBpcyBzZXQgc28gdGhlIGNvbnN0cmFpbnQgaXMgcmVwdWxzaXZlIGluIHRoZSBjb3JyZWN0IGRpcmVjdGlvbi5cbiAgICAgICAgU29tZSBvZmZzZXQgaXMgYWRkZWQgdG8gZWl0aGVyIGVxdWF0aW9uLmNvbnRhY3RQb2ludEEgb3IgLmNvbnRhY3RQb2ludEIgdG8gZ2V0IHRoZSBjb3JyZWN0IHVwcGVyL2xvd2VyIGxpbWl0LlxuXG4gICAgICAgICAgICAgICAgIF5cbiAgICAgICAgICAgICAgICAgfFxuICAgICAgdXBwZXJMaW1pdCB4XG4gICAgICAgICAgICAgICAgIHwgICAgLS0tLS0tXG4gICAgICAgICBhbmNob3JCIHg8LS0tfCAgQiB8XG4gICAgICAgICAgICAgICAgIHwgICAgfCAgICB8XG4gICAgICAgIC0tLS0tLSAgIHwgICAgLS0tLS0tXG4gICAgICAgIHwgICAgfCAgIHxcbiAgICAgICAgfCAgQSB8LS0+eCBhbmNob3JBXG4gICAgICAgIC0tLS0tLSAgIHxcbiAgICAgICAgICAgICAgICAgeCBsb3dlckxpbWl0XG4gICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICBheGlzXG4gICAgICovXG5cblxuICAgIGlmKHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgJiYgcmVsUG9zaXRpb24gPiB1cHBlckxpbWl0KXtcbiAgICAgICAgLy8gVXBkYXRlIGNvbnRhY3QgY29uc3RyYWludCBub3JtYWwsIGV0Y1xuICAgICAgICB2ZWMyLnNjYWxlKHVwcGVyTGltaXRFcXVhdGlvbi5ub3JtYWxBLCB3b3JsZEF4aXNBLCAtMSk7XG4gICAgICAgIHZlYzIuc3ViKHVwcGVyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRBLCB3b3JsZEFuY2hvckEsIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIodXBwZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEIsIHdvcmxkQW5jaG9yQiwgYm9keUIucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnNjYWxlKHRtcCx3b3JsZEF4aXNBLHVwcGVyTGltaXQpO1xuICAgICAgICB2ZWMyLmFkZCh1cHBlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50QSx1cHBlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50QSx0bXApO1xuICAgICAgICBpZihlcXMuaW5kZXhPZih1cHBlckxpbWl0RXF1YXRpb24pID09PSAtMSl7XG4gICAgICAgICAgICBlcXMucHVzaCh1cHBlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlkeCA9IGVxcy5pbmRleE9mKHVwcGVyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICAgICAgZXFzLnNwbGljZShpZHgsMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0aGlzLmxvd2VyTGltaXRFbmFibGVkICYmIHJlbFBvc2l0aW9uIDwgbG93ZXJMaW1pdCl7XG4gICAgICAgIC8vIFVwZGF0ZSBjb250YWN0IGNvbnN0cmFpbnQgbm9ybWFsLCBldGNcbiAgICAgICAgdmVjMi5zY2FsZShsb3dlckxpbWl0RXF1YXRpb24ubm9ybWFsQSwgd29ybGRBeGlzQSwgMSk7XG4gICAgICAgIHZlYzIuc3ViKGxvd2VyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRBLCB3b3JsZEFuY2hvckEsIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIobG93ZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEIsIHdvcmxkQW5jaG9yQiwgYm9keUIucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnNjYWxlKHRtcCx3b3JsZEF4aXNBLGxvd2VyTGltaXQpO1xuICAgICAgICB2ZWMyLnN1Yihsb3dlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50Qixsb3dlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50Qix0bXApO1xuICAgICAgICBpZihlcXMuaW5kZXhPZihsb3dlckxpbWl0RXF1YXRpb24pID09PSAtMSl7XG4gICAgICAgICAgICBlcXMucHVzaChsb3dlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlkeCA9IGVxcy5pbmRleE9mKGxvd2VyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICAgICAgZXFzLnNwbGljZShpZHgsMSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEVuYWJsZSB0aGUgbW90b3JcbiAqIEBtZXRob2QgZW5hYmxlTW90b3JcbiAqL1xuUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUuZW5hYmxlTW90b3IgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHRoaXMubW90b3JFcXVhdGlvbik7XG4gICAgdGhpcy5tb3RvckVuYWJsZWQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlIHRoZSByb3RhdGlvbmFsIG1vdG9yXG4gKiBAbWV0aG9kIGRpc2FibGVNb3RvclxuICovXG5QcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS5kaXNhYmxlTW90b3IgPSBmdW5jdGlvbigpe1xuICAgIGlmKCF0aGlzLm1vdG9yRW5hYmxlZCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmVxdWF0aW9ucy5pbmRleE9mKHRoaXMubW90b3JFcXVhdGlvbik7XG4gICAgdGhpcy5lcXVhdGlvbnMuc3BsaWNlKGksMSk7XG4gICAgdGhpcy5tb3RvckVuYWJsZWQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb25zdHJhaW50IGxpbWl0cy5cbiAqIEBtZXRob2Qgc2V0TGltaXRzXG4gKiBAcGFyYW0ge251bWJlcn0gbG93ZXIgTG93ZXIgbGltaXQuXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVXBwZXIgbGltaXQuXG4gKi9cblByaXNtYXRpY0NvbnN0cmFpbnQucHJvdG90eXBlLnNldExpbWl0cyA9IGZ1bmN0aW9uIChsb3dlciwgdXBwZXIpIHtcbiAgICBpZih0eXBlb2YobG93ZXIpID09PSAnbnVtYmVyJyl7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdCA9IGxvd2VyO1xuICAgICAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvd2VyTGltaXQgPSBsb3dlcjtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmKHR5cGVvZih1cHBlcikgPT09ICdudW1iZXInKXtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0ID0gdXBwZXI7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdCA9IHVwcGVyO1xuICAgICAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gZmFsc2U7XG4gICAgfVxufTtcblxuXG59LHtcIi4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb25cIjoyMixcIi4uL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIzLFwiLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxMb2NrRXF1YXRpb25cIjoyNSxcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9Db25zdHJhaW50XCI6MTV9XSwyMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4vQ29uc3RyYWludCcpXG4sICAgRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvRXF1YXRpb24nKVxuLCAgIFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uJylcbiwgICBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxMb2NrRXF1YXRpb24nKVxuLCAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZXZvbHV0ZUNvbnN0cmFpbnQ7XG5cbnZhciB3b3JsZFBpdm90QSA9IHZlYzIuY3JlYXRlKCksXG4gICAgd29ybGRQaXZvdEIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHhBeGlzID0gdmVjMi5mcm9tVmFsdWVzKDEsMCksXG4gICAgeUF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwxKSxcbiAgICBnID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBDb25uZWN0cyB0d28gYm9kaWVzIGF0IGdpdmVuIG9mZnNldCBwb2ludHMsIGxldHRpbmcgdGhlbSByb3RhdGUgcmVsYXRpdmUgdG8gZWFjaCBvdGhlciBhcm91bmQgdGhpcyBwb2ludC5cbiAqIEBjbGFzcyBSZXZvbHV0ZUNvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSAgICBib2R5QVxuICogQHBhcmFtIHtCb2R5fSAgICBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9ICBbb3B0aW9uc11cbiAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMud29ybGRQaXZvdF0gQSBwaXZvdCBwb2ludCBnaXZlbiBpbiB3b3JsZCBjb29yZGluYXRlcy4gSWYgc3BlY2lmaWVkLCBsb2NhbFBpdm90QSBhbmQgbG9jYWxQaXZvdEIgYXJlIGF1dG9tYXRpY2FsbHkgY29tcHV0ZWQgZnJvbSB0aGlzIHZhbHVlLlxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb2NhbFBpdm90QV0gVGhlIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyBvZiBib2R5QSB3aGljaCBib2R5QSBpcyBjb25zdHJhaW5lZCB0by5cbiAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMubG9jYWxQaXZvdEJdIFNlZSBsb2NhbFBpdm90QS5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgW29wdGlvbnMubWF4Rm9yY2VdIFRoZSBtYXhpbXVtIGZvcmNlIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gY29uc3RyYWluIHRoZSBib2RpZXMuXG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgcmV2b2x1dGUgY29uc3RyYWludCBiZXR3ZWVuIHR3byBib2RpZXMgd2l0aCBwaXZvdCBwb2ludCBpbiBiZXR3ZWVuIHRoZW0uXG4gKiAgICAgdmFyIGJvZHlBID0gbmV3IEJvZHkoeyBtYXNzOiAxLCBwb3NpdGlvbjogWy0xLCAwXSB9KTtcbiAqICAgICB2YXIgYm9keUIgPSBuZXcgQm9keSh7IG1hc3M6IDEsIHBvc2l0aW9uOiBbMSwgMF0gfSk7XG4gKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgUmV2b2x1dGVDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwge1xuICogICAgICAgICB3b3JsZFBpdm90OiBbMCwgMF1cbiAqICAgICB9KTtcbiAqICAgICB3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnQpO1xuICpcbiAqICAgICAvLyBVc2luZyBib2R5LWxvY2FsIHBpdm90IHBvaW50cywgdGhlIGNvbnN0cmFpbnQgY291bGQgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkIGxpa2UgdGhpczpcbiAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBSZXZvbHV0ZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB7XG4gKiAgICAgICAgIGxvY2FsUGl2b3RBOiBbMSwgMF0sXG4gKiAgICAgICAgIGxvY2FsUGl2b3RCOiBbLTEsIDBdXG4gKiAgICAgfSk7XG4gKi9cbmZ1bmN0aW9uIFJldm9sdXRlQ29uc3RyYWludChib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLGJvZHlBLGJvZHlCLENvbnN0cmFpbnQuUkVWT0xVVEUsb3B0aW9ucyk7XG5cbiAgICB2YXIgbWF4Rm9yY2UgPSB0aGlzLm1heEZvcmNlID0gdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5tYXhGb3JjZSA6IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBwaXZvdEFcbiAgICAgKi9cbiAgICB0aGlzLnBpdm90QSA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBwaXZvdEJcbiAgICAgKi9cbiAgICB0aGlzLnBpdm90QiA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICBpZihvcHRpb25zLndvcmxkUGl2b3Qpe1xuICAgICAgICAvLyBDb21wdXRlIHBpdm90QSBhbmQgcGl2b3RCXG4gICAgICAgIHZlYzIuc3ViKHRoaXMucGl2b3RBLCBvcHRpb25zLndvcmxkUGl2b3QsIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIodGhpcy5waXZvdEIsIG9wdGlvbnMud29ybGRQaXZvdCwgYm9keUIucG9zaXRpb24pO1xuICAgICAgICAvLyBSb3RhdGUgdG8gbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgICAgdmVjMi5yb3RhdGUodGhpcy5waXZvdEEsIHRoaXMucGl2b3RBLCAtYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh0aGlzLnBpdm90QiwgdGhpcy5waXZvdEIsIC1ib2R5Qi5hbmdsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gR2V0IHBpdm90QSBhbmQgcGl2b3RCXG4gICAgICAgIHZlYzIuY29weSh0aGlzLnBpdm90QSwgb3B0aW9ucy5sb2NhbFBpdm90QSk7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLnBpdm90Qiwgb3B0aW9ucy5sb2NhbFBpdm90Qik7XG4gICAgfVxuXG4gICAgLy8gRXF1YXRpb25zIHRvIGJlIGZlZCB0byB0aGUgc29sdmVyXG4gICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zID0gW1xuICAgICAgICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKSxcbiAgICAgICAgbmV3IEVxdWF0aW9uKGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSksXG4gICAgXTtcblxuICAgIHZhciB4ID0gZXFzWzBdO1xuICAgIHZhciB5ID0gZXFzWzFdO1xuICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgIHguY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQaXZvdEEsIHRoYXQucGl2b3RBLCBib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkUGl2b3RCLCB0aGF0LnBpdm90QiwgYm9keUIuYW5nbGUpO1xuICAgICAgICB2ZWMyLmFkZChnLCBib2R5Qi5wb3NpdGlvbiwgd29ybGRQaXZvdEIpO1xuICAgICAgICB2ZWMyLnN1YihnLCBnLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc3ViKGcsIGcsIHdvcmxkUGl2b3RBKTtcbiAgICAgICAgcmV0dXJuIHZlYzIuZG90KGcseEF4aXMpO1xuICAgIH07XG5cbiAgICB5LmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkUGl2b3RBLCB0aGF0LnBpdm90QSwgYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBpdm90QiwgdGhhdC5waXZvdEIsIGJvZHlCLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5hZGQoZywgYm9keUIucG9zaXRpb24sIHdvcmxkUGl2b3RCKTtcbiAgICAgICAgdmVjMi5zdWIoZywgZywgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1YihnLCBnLCB3b3JsZFBpdm90QSk7XG4gICAgICAgIHJldHVybiB2ZWMyLmRvdChnLHlBeGlzKTtcbiAgICB9O1xuXG4gICAgeS5taW5Gb3JjZSA9IHgubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG4gICAgeS5tYXhGb3JjZSA9IHgubWF4Rm9yY2UgPSAgbWF4Rm9yY2U7XG5cbiAgICB0aGlzLm1vdG9yRXF1YXRpb24gPSBuZXcgUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24oYm9keUEsYm9keUIpO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1vdG9yIGlzIGVuYWJsZWQuIFVzZSAuZW5hYmxlTW90b3IoKSB0byBlbmFibGUgdGhlIGNvbnN0cmFpbnQgbW90b3IuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBtb3RvckVuYWJsZWRcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLm1vdG9yRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cmFpbnQgcG9zaXRpb24uXG4gICAgICogQHByb3BlcnR5IGFuZ2xlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmFuZ2xlID0gMDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGVuYWJsZSBsb3dlciBsaW1pdFxuICAgICAqIEBwcm9wZXJ0eSBsb3dlckxpbWl0RW5hYmxlZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGVuYWJsZSB1cHBlciBsaW1pdFxuICAgICAqIEBwcm9wZXJ0eSB1cHBlckxpbWl0RW5hYmxlZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb3dlciBsaW1pdCBvbiB0aGUgY29uc3RyYWludCBhbmdsZS5cbiAgICAgKiBAcHJvcGVydHkgbG93ZXJMaW1pdFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubG93ZXJMaW1pdCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdXBwZXIgbGltaXQgb24gdGhlIGNvbnN0cmFpbnQgYW5nbGUuXG4gICAgICogQHByb3BlcnR5IHVwcGVyTGltaXRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVwcGVyTGltaXQgPSAwO1xuXG4gICAgdGhpcy51cHBlckxpbWl0RXF1YXRpb24gPSBuZXcgUm90YXRpb25hbExvY2tFcXVhdGlvbihib2R5QSxib2R5Qik7XG4gICAgdGhpcy5sb3dlckxpbWl0RXF1YXRpb24gPSBuZXcgUm90YXRpb25hbExvY2tFcXVhdGlvbihib2R5QSxib2R5Qik7XG4gICAgdGhpcy51cHBlckxpbWl0RXF1YXRpb24ubWluRm9yY2UgPSAwO1xuICAgIHRoaXMubG93ZXJMaW1pdEVxdWF0aW9uLm1heEZvcmNlID0gMDtcbn1cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJldm9sdXRlQ29uc3RyYWludDtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbnN0cmFpbnQgYW5nbGUgbGltaXRzLlxuICogQG1ldGhvZCBzZXRMaW1pdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBMb3dlciBhbmdsZSBsaW1pdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBVcHBlciBhbmdsZSBsaW1pdC5cbiAqL1xuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS5zZXRMaW1pdHMgPSBmdW5jdGlvbiAobG93ZXIsIHVwcGVyKSB7XG4gICAgaWYodHlwZW9mKGxvd2VyKSA9PT0gJ251bWJlcicpe1xuICAgICAgICB0aGlzLmxvd2VyTGltaXQgPSBsb3dlcjtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0ID0gbG93ZXI7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZih0eXBlb2YodXBwZXIpID09PSAnbnVtYmVyJyl7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdCA9IHVwcGVyO1xuICAgICAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVwcGVyTGltaXQgPSB1cHBlcjtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYm9keUEgPSAgdGhpcy5ib2R5QSxcbiAgICAgICAgYm9keUIgPSAgdGhpcy5ib2R5QixcbiAgICAgICAgcGl2b3RBID0gdGhpcy5waXZvdEEsXG4gICAgICAgIHBpdm90QiA9IHRoaXMucGl2b3RCLFxuICAgICAgICBlcXMgPSAgICB0aGlzLmVxdWF0aW9ucyxcbiAgICAgICAgbm9ybWFsID0gZXFzWzBdLFxuICAgICAgICB0YW5nZW50PSBlcXNbMV0sXG4gICAgICAgIHggPSBlcXNbMF0sXG4gICAgICAgIHkgPSBlcXNbMV0sXG4gICAgICAgIHVwcGVyTGltaXQgPSB0aGlzLnVwcGVyTGltaXQsXG4gICAgICAgIGxvd2VyTGltaXQgPSB0aGlzLmxvd2VyTGltaXQsXG4gICAgICAgIHVwcGVyTGltaXRFcXVhdGlvbiA9IHRoaXMudXBwZXJMaW1pdEVxdWF0aW9uLFxuICAgICAgICBsb3dlckxpbWl0RXF1YXRpb24gPSB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbjtcblxuICAgIHZhciByZWxBbmdsZSA9IHRoaXMuYW5nbGUgPSBib2R5Qi5hbmdsZSAtIGJvZHlBLmFuZ2xlO1xuXG4gICAgaWYodGhpcy51cHBlckxpbWl0RW5hYmxlZCAmJiByZWxBbmdsZSA+IHVwcGVyTGltaXQpe1xuICAgICAgICB1cHBlckxpbWl0RXF1YXRpb24uYW5nbGUgPSB1cHBlckxpbWl0O1xuICAgICAgICBpZihlcXMuaW5kZXhPZih1cHBlckxpbWl0RXF1YXRpb24pID09PSAtMSl7XG4gICAgICAgICAgICBlcXMucHVzaCh1cHBlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlkeCA9IGVxcy5pbmRleE9mKHVwcGVyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICAgICAgZXFzLnNwbGljZShpZHgsMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0aGlzLmxvd2VyTGltaXRFbmFibGVkICYmIHJlbEFuZ2xlIDwgbG93ZXJMaW1pdCl7XG4gICAgICAgIGxvd2VyTGltaXRFcXVhdGlvbi5hbmdsZSA9IGxvd2VyTGltaXQ7XG4gICAgICAgIGlmKGVxcy5pbmRleE9mKGxvd2VyTGltaXRFcXVhdGlvbikgPT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5wdXNoKGxvd2VyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaWR4ID0gZXFzLmluZGV4T2YobG93ZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSl7XG4gICAgICAgICAgICBlcXMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG5cbiAgICBUaGUgY29uc3RyYWludCB2aW9sYXRpb24gaXNcblxuICAgICAgICBnID0geGogKyByaiAtIHhpIC0gcmlcblxuICAgIC4uLndoZXJlIHhpIGFuZCB4aiBhcmUgdGhlIGJvZHkgcG9zaXRpb25zIGFuZCByaSBhbmQgcmogd29ybGQtb3JpZW50ZWQgb2Zmc2V0IHZlY3RvcnMuIERpZmZlcmVudGlhdGU6XG5cbiAgICAgICAgZ2RvdCA9IHZqICsgd2ogeCByaiAtIHZpIC0gd2kgeCByaVxuXG4gICAgV2Ugc3BsaXQgdGhpcyBpbnRvIHggYW5kIHkgZGlyZWN0aW9ucy4gKGxldCB4IGFuZCB5IGJlIHVuaXQgdmVjdG9ycyBhbG9uZyB0aGUgcmVzcGVjdGl2ZSBheGVzKVxuXG4gICAgICAgIGdkb3QgKiB4ID0gKCB2aiArIHdqIHggcmogLSB2aSAtIHdpIHggcmkgKSAqIHhcbiAgICAgICAgICAgICAgICAgPSAoIHZqKnggKyAod2ogeCByaikqeCAtdmkqeCAtKHdpIHggcmkpKnhcbiAgICAgICAgICAgICAgICAgPSAoIHZqKnggKyAocmogeCB4KSp3aiAtdmkqeCAtKHJpIHggeCkqd2lcbiAgICAgICAgICAgICAgICAgPSBbIC14ICAgLShyaSB4IHgpICAgeCAgIChyaiB4IHgpXSAqIFt2aSB3aSB2aiB3al1cbiAgICAgICAgICAgICAgICAgPSBHKldcblxuICAgIC4uLmFuZCBzaW1pbGFyIGZvciB5LiBXZSBoYXZlIHRoZW4gaWRlbnRpZmllZCB0aGUgamFjb2JpYW4gZW50cmllcyBmb3IgeCBhbmQgeSBkaXJlY3Rpb25zOlxuXG4gICAgICAgIEd4ID0gWyB4ICAgKHJqIHggeCkgICAteCAgIC0ocmkgeCB4KV1cbiAgICAgICAgR3kgPSBbIHkgICAocmogeCB5KSAgIC15ICAgLShyaSB4IHkpXVxuXG4gICAgICovXG5cbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBpdm90QSwgcGl2b3RBLCBib2R5QS5hbmdsZSk7XG4gICAgdmVjMi5yb3RhdGUod29ybGRQaXZvdEIsIHBpdm90QiwgYm9keUIuYW5nbGUpO1xuXG4gICAgLy8gdG9kbzogdGhlc2UgYXJlIGEgYml0IHNwYXJzZS4gV2UgY291bGQgc2F2ZSBzb21lIGNvbXB1dGF0aW9ucyBvbiBtYWtpbmcgY3VzdG9tIGVxLmNvbXB1dGVHVyBmdW5jdGlvbnMsIGV0Y1xuXG4gICAgeC5HWzBdID0gLTE7XG4gICAgeC5HWzFdID0gIDA7XG4gICAgeC5HWzJdID0gLXZlYzIuY3Jvc3NMZW5ndGgod29ybGRQaXZvdEEseEF4aXMpO1xuICAgIHguR1szXSA9ICAxO1xuICAgIHguR1s0XSA9ICAwO1xuICAgIHguR1s1XSA9ICB2ZWMyLmNyb3NzTGVuZ3RoKHdvcmxkUGl2b3RCLHhBeGlzKTtcblxuICAgIHkuR1swXSA9ICAwO1xuICAgIHkuR1sxXSA9IC0xO1xuICAgIHkuR1syXSA9IC12ZWMyLmNyb3NzTGVuZ3RoKHdvcmxkUGl2b3RBLHlBeGlzKTtcbiAgICB5LkdbM10gPSAgMDtcbiAgICB5LkdbNF0gPSAgMTtcbiAgICB5LkdbNV0gPSAgdmVjMi5jcm9zc0xlbmd0aCh3b3JsZFBpdm90Qix5QXhpcyk7XG59O1xuXG4vKipcbiAqIEVuYWJsZSB0aGUgcm90YXRpb25hbCBtb3RvclxuICogQG1ldGhvZCBlbmFibGVNb3RvclxuICovXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLmVuYWJsZU1vdG9yID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLm1vdG9yRW5hYmxlZCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaCh0aGlzLm1vdG9yRXF1YXRpb24pO1xuICAgIHRoaXMubW90b3JFbmFibGVkID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogRGlzYWJsZSB0aGUgcm90YXRpb25hbCBtb3RvclxuICogQG1ldGhvZCBkaXNhYmxlTW90b3JcbiAqL1xuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS5kaXNhYmxlTW90b3IgPSBmdW5jdGlvbigpe1xuICAgIGlmKCF0aGlzLm1vdG9yRW5hYmxlZCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmVxdWF0aW9ucy5pbmRleE9mKHRoaXMubW90b3JFcXVhdGlvbik7XG4gICAgdGhpcy5lcXVhdGlvbnMuc3BsaWNlKGksMSk7XG4gICAgdGhpcy5tb3RvckVuYWJsZWQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIG1vdG9yIGlzIGVuYWJsZWQuXG4gKiBAbWV0aG9kIG1vdG9ySXNFbmFibGVkXG4gKiBAZGVwcmVjYXRlZCB1c2UgcHJvcGVydHkgbW90b3JFbmFibGVkIGluc3RlYWQuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLm1vdG9ySXNFbmFibGVkID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gISF0aGlzLm1vdG9yRW5hYmxlZDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzcGVlZCBvZiB0aGUgcm90YXRpb25hbCBjb25zdHJhaW50IG1vdG9yXG4gKiBAbWV0aG9kIHNldE1vdG9yU3BlZWRcbiAqIEBwYXJhbSAge051bWJlcn0gc3BlZWRcbiAqL1xuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS5zZXRNb3RvclNwZWVkID0gZnVuY3Rpb24oc3BlZWQpe1xuICAgIGlmKCF0aGlzLm1vdG9yRW5hYmxlZCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmVxdWF0aW9ucy5pbmRleE9mKHRoaXMubW90b3JFcXVhdGlvbik7XG4gICAgdGhpcy5lcXVhdGlvbnNbaV0ucmVsYXRpdmVWZWxvY2l0eSA9IHNwZWVkO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNwZWVkIG9mIHRoZSByb3RhdGlvbmFsIGNvbnN0cmFpbnQgbW90b3JcbiAqIEBtZXRob2QgZ2V0TW90b3JTcGVlZFxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgY3VycmVudCBzcGVlZCwgb3IgZmFsc2UgaWYgdGhlIG1vdG9yIGlzIG5vdCBlbmFibGVkLlxuICovXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLmdldE1vdG9yU3BlZWQgPSBmdW5jdGlvbigpe1xuICAgIGlmKCF0aGlzLm1vdG9yRW5hYmxlZCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubW90b3JFcXVhdGlvbi5yZWxhdGl2ZVZlbG9jaXR5O1xufTtcblxufSx7XCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIjoyMyxcIi4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTG9ja0VxdWF0aW9uXCI6MjUsXCIuLi9lcXVhdGlvbnMvUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb25cIjoyNixcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9Db25zdHJhaW50XCI6MTV9XSwyMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgRXF1YXRpb24gPSBfZGVyZXFfKFwiLi9FcXVhdGlvblwiKSxcbiAgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQW5nbGVMb2NrRXF1YXRpb247XG5cbi8qKlxuICogTG9ja3MgdGhlIHJlbGF0aXZlIGFuZ2xlIGJldHdlZW4gdHdvIGJvZGllcy4gVGhlIGNvbnN0cmFpbnQgdHJpZXMgdG8ga2VlcCB0aGUgZG90IHByb2R1Y3QgYmV0d2VlbiB0d28gdmVjdG9ycywgbG9jYWwgaW4gZWFjaCBib2R5LCB0byB6ZXJvLiBUaGUgbG9jYWwgYW5nbGUgaW4gYm9keSBpIGlzIGEgcGFyYW1ldGVyLlxuICpcbiAqIEBjbGFzcyBBbmdsZUxvY2tFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ2xlXSBBbmdsZSB0byBhZGQgdG8gdGhlIGxvY2FsIHZlY3RvciBpbiBib2R5IEEuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmF0aW9dIEdlYXIgcmF0aW9cbiAqL1xuZnVuY3Rpb24gQW5nbGVMb2NrRXF1YXRpb24oYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsYm9keUEsYm9keUIsLU51bWJlci5NQVhfVkFMVUUsTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgdGhpcy5hbmdsZSA9IG9wdGlvbnMuYW5nbGUgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBnZWFyIHJhdGlvLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByYXRpb1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSBzZXRSYXRpb1xuICAgICAqL1xuICAgIHRoaXMucmF0aW8gPSB0eXBlb2Yob3B0aW9ucy5yYXRpbyk9PT1cIm51bWJlclwiID8gb3B0aW9ucy5yYXRpbyA6IDE7XG5cbiAgICB0aGlzLnNldFJhdGlvKHRoaXMucmF0aW8pO1xufVxuQW5nbGVMb2NrRXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XG5BbmdsZUxvY2tFcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBbmdsZUxvY2tFcXVhdGlvbjtcblxuQW5nbGVMb2NrRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMucmF0aW8gKiB0aGlzLmJvZHlBLmFuZ2xlIC0gdGhpcy5ib2R5Qi5hbmdsZSArIHRoaXMuYW5nbGU7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgZ2VhciByYXRpbyBmb3IgdGhpcyBlcXVhdGlvblxuICogQG1ldGhvZCBzZXRSYXRpb1xuICogQHBhcmFtIHtOdW1iZXJ9IHJhdGlvXG4gKi9cbkFuZ2xlTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5zZXRSYXRpbyA9IGZ1bmN0aW9uKHJhdGlvKXtcbiAgICB2YXIgRyA9IHRoaXMuRztcbiAgICBHWzJdID0gIHJhdGlvO1xuICAgIEdbNV0gPSAtMTtcbiAgICB0aGlzLnJhdGlvID0gcmF0aW87XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4IGZvcmNlIGZvciB0aGUgZXF1YXRpb24uXG4gKiBAbWV0aG9kIHNldE1heFRvcnF1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcnF1ZVxuICovXG5BbmdsZUxvY2tFcXVhdGlvbi5wcm90b3R5cGUuc2V0TWF4VG9ycXVlID0gZnVuY3Rpb24odG9ycXVlKXtcbiAgICB0aGlzLm1heEZvcmNlID0gIHRvcnF1ZTtcbiAgICB0aGlzLm1pbkZvcmNlID0gLXRvcnF1ZTtcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL0VxdWF0aW9uXCI6MjN9XSwyMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgRXF1YXRpb24gPSBfZGVyZXFfKFwiLi9FcXVhdGlvblwiKSxcbiAgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFjdEVxdWF0aW9uO1xuXG4vKipcbiAqIE5vbi1wZW5ldHJhdGlvbiBjb25zdHJhaW50IGVxdWF0aW9uLiBUcmllcyB0byBtYWtlIHRoZSBjb250YWN0UG9pbnRBIGFuZCBjb250YWN0UG9pbnRCIHZlY3RvcnMgY29pbmNpZGUsIHdoaWxlIGtlZXBpbmcgdGhlIGFwcGxpZWQgZm9yY2UgcmVwdWxzaXZlLlxuICpcbiAqIEBjbGFzcyBDb250YWN0RXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRXF1YXRpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqL1xuZnVuY3Rpb24gQ29udGFjdEVxdWF0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIDAsIE51bWJlci5NQVhfVkFMVUUpO1xuXG4gICAgLyoqXG4gICAgICogVmVjdG9yIGZyb20gYm9keSBpIGNlbnRlciBvZiBtYXNzIHRvIHRoZSBjb250YWN0IHBvaW50LlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0UG9pbnRBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdFBvaW50QSA9IHZlYzIuY3JlYXRlKCk7XG4gICAgdGhpcy5wZW5ldHJhdGlvblZlYyA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBXb3JsZC1vcmllbnRlZCB2ZWN0b3IgZnJvbSBib2R5IEEgY2VudGVyIG9mIG1hc3MgdG8gdGhlIGNvbnRhY3QgcG9pbnQuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RQb2ludEJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0UG9pbnRCID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBub3JtYWwgdmVjdG9yLCBwb2ludGluZyBvdXQgb2YgYm9keSBpXG4gICAgICogQHByb3BlcnR5IG5vcm1hbEFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5ub3JtYWxBID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN0aXR1dGlvbiB0byB1c2UgKDA9bm8gYm91bmNpbmVzcywgMT1tYXggYm91bmNpbmVzcykuXG4gICAgICogQHByb3BlcnR5IHJlc3RpdHV0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RpdHV0aW9uID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgcHJvcGVydHkgaXMgc2V0IHRvIHRydWUgaWYgdGhpcyBpcyB0aGUgZmlyc3QgaW1wYWN0IGJldHdlZW4gdGhlIGJvZGllcyAobm90IHBlcnNpc3RhbnQgY29udGFjdCkuXG4gICAgICogQHByb3BlcnR5IGZpcnN0SW1wYWN0XG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5maXJzdEltcGFjdCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNoYXBlIGluIGJvZHkgaSB0aGF0IHRyaWdnZXJlZCB0aGlzIGNvbnRhY3QuXG4gICAgICogQHByb3BlcnR5IHNoYXBlQVxuICAgICAqIEB0eXBlIHtTaGFwZX1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlQSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2hhcGUgaW4gYm9keSBqIHRoYXQgdHJpZ2dlcmVkIHRoaXMgY29udGFjdC5cbiAgICAgKiBAcHJvcGVydHkgc2hhcGVCXG4gICAgICogQHR5cGUge1NoYXBlfVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVCID0gbnVsbDtcbn1cbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb250YWN0RXF1YXRpb247XG5Db250YWN0RXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24oYSxiLGgpe1xuICAgIHZhciBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgcmkgPSB0aGlzLmNvbnRhY3RQb2ludEEsXG4gICAgICAgIHJqID0gdGhpcy5jb250YWN0UG9pbnRCLFxuICAgICAgICB4aSA9IGJpLnBvc2l0aW9uLFxuICAgICAgICB4aiA9IGJqLnBvc2l0aW9uO1xuXG4gICAgdmFyIHBlbmV0cmF0aW9uVmVjID0gdGhpcy5wZW5ldHJhdGlvblZlYyxcbiAgICAgICAgbiA9IHRoaXMubm9ybWFsQSxcbiAgICAgICAgRyA9IHRoaXMuRztcblxuICAgIC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0c1xuICAgIHZhciByaXhuID0gdmVjMi5jcm9zc0xlbmd0aChyaSxuKSxcbiAgICAgICAgcmp4biA9IHZlYzIuY3Jvc3NMZW5ndGgocmosbik7XG5cbiAgICAvLyBHID0gWy1uIC1yaXhuIG4gcmp4bl1cbiAgICBHWzBdID0gLW5bMF07XG4gICAgR1sxXSA9IC1uWzFdO1xuICAgIEdbMl0gPSAtcml4bjtcbiAgICBHWzNdID0gblswXTtcbiAgICBHWzRdID0gblsxXTtcbiAgICBHWzVdID0gcmp4bjtcblxuICAgIC8vIENhbGN1bGF0ZSBxID0geGorcmogLSh4aStyaSkgaS5lLiB0aGUgcGVuZXRyYXRpb24gdmVjdG9yXG4gICAgdmVjMi5hZGQocGVuZXRyYXRpb25WZWMseGoscmopO1xuICAgIHZlYzIuc3ViKHBlbmV0cmF0aW9uVmVjLHBlbmV0cmF0aW9uVmVjLHhpKTtcbiAgICB2ZWMyLnN1YihwZW5ldHJhdGlvblZlYyxwZW5ldHJhdGlvblZlYyxyaSk7XG5cbiAgICAvLyBDb21wdXRlIGl0ZXJhdGlvblxuICAgIHZhciBHVywgR3E7XG4gICAgaWYodGhpcy5maXJzdEltcGFjdCAmJiB0aGlzLnJlc3RpdHV0aW9uICE9PSAwKXtcbiAgICAgICAgR3EgPSAwO1xuICAgICAgICBHVyA9ICgxL2IpKigxK3RoaXMucmVzdGl0dXRpb24pICogdGhpcy5jb21wdXRlR1coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBHcSA9IHZlYzIuZG90KG4scGVuZXRyYXRpb25WZWMpICsgdGhpcy5vZmZzZXQ7XG4gICAgICAgIEdXID0gdGhpcy5jb21wdXRlR1coKTtcbiAgICB9XG5cbiAgICB2YXIgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcbiAgICB2YXIgQiA9IC0gR3EgKiBhIC0gR1cgKiBiIC0gaCpHaU1mO1xuXG4gICAgcmV0dXJuIEI7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9FcXVhdGlvblwiOjIzfV0sMjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBFcXVhdGlvbjtcblxudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKSxcbiAgICBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyksXG4gICAgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGNvbnN0cmFpbnQgZXF1YXRpb25zLlxuICogQGNsYXNzIEVxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUEgRmlyc3QgYm9keSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBlcXVhdGlvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QiBTZWNvbmQgYm9keSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBlcXVhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IG1pbkZvcmNlIE1pbmltdW0gZm9yY2UgdG8gYXBwbHkuIERlZmF1bHQ6IC1OdW1iZXIuTUFYX1ZBTFVFXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4Rm9yY2UgTWF4aW11bSBmb3JjZSB0byBhcHBseS4gRGVmYXVsdDogTnVtYmVyLk1BWF9WQUxVRVxuICovXG5mdW5jdGlvbiBFcXVhdGlvbihib2R5QSwgYm9keUIsIG1pbkZvcmNlLCBtYXhGb3JjZSl7XG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGZvcmNlIHRvIGFwcGx5IHdoZW4gc29sdmluZy5cbiAgICAgKiBAcHJvcGVydHkgbWluRm9yY2VcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWluRm9yY2UgPSB0eXBlb2YobWluRm9yY2UpPT09XCJ1bmRlZmluZWRcIiA/IC1OdW1iZXIuTUFYX1ZBTFVFIDogbWluRm9yY2U7XG5cbiAgICAvKipcbiAgICAgKiBNYXggZm9yY2UgdG8gYXBwbHkgd2hlbiBzb2x2aW5nLlxuICAgICAqIEBwcm9wZXJ0eSBtYXhGb3JjZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhGb3JjZSA9IHR5cGVvZihtYXhGb3JjZSk9PT1cInVuZGVmaW5lZFwiID8gTnVtYmVyLk1BWF9WQUxVRSA6IG1heEZvcmNlO1xuXG4gICAgLyoqXG4gICAgICogRmlyc3QgYm9keSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb25zdHJhaW50XG4gICAgICogQHByb3BlcnR5IGJvZHlBXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xuXG4gICAgLyoqXG4gICAgICogU2Vjb25kIGJvZHkgcGFydGljaXBhdGluZyBpbiB0aGUgY29uc3RyYWludFxuICAgICAqIEBwcm9wZXJ0eSBib2R5QlxuICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAqL1xuICAgIHRoaXMuYm9keUIgPSBib2R5QjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGlmZm5lc3Mgb2YgdGhpcyBlcXVhdGlvbi4gVHlwaWNhbGx5IGNob3NlbiB0byBhIGxhcmdlIG51bWJlciAofjFlNyksIGJ1dCBjYW4gYmUgY2hvc2VuIHNvbWV3aGF0IGZyZWVseSB0byBnZXQgYSBzdGFibGUgc2ltdWxhdGlvbi5cbiAgICAgKiBAcHJvcGVydHkgc3RpZmZuZXNzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnN0aWZmbmVzcyA9IEVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiB0aW1lIHN0ZXBzIG5lZWRlZCB0byBzdGFiaWxpemUgdGhlIGNvbnN0cmFpbnQgZXF1YXRpb24uIFR5cGljYWxseSBiZXR3ZWVuIDMgYW5kIDUgdGltZSBzdGVwcy5cbiAgICAgKiBAcHJvcGVydHkgcmVsYXhhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZWxheGF0aW9uID0gRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OO1xuXG4gICAgLyoqXG4gICAgICogVGhlIEphY29iaWFuIGVudHJ5IG9mIHRoaXMgZXF1YXRpb24uIDYgbnVtYmVycywgMyBwZXIgYm9keSAoeCx5LGFuZ2xlKS5cbiAgICAgKiBAcHJvcGVydHkgR1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLkcgPSBuZXcgVXRpbHMuQVJSQVlfVFlQRSg2KTtcbiAgICBmb3IodmFyIGk9MDsgaTw2OyBpKyspe1xuICAgICAgICB0aGlzLkdbaV09MDtcbiAgICB9XG5cbiAgICB0aGlzLm9mZnNldCA9IDA7XG5cbiAgICB0aGlzLmEgPSAwO1xuICAgIHRoaXMuYiA9IDA7XG4gICAgdGhpcy5lcHNpbG9uID0gMDtcbiAgICB0aGlzLnRpbWVTdGVwID0gMS82MDtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiBzdGlmZm5lc3Mgb3IgcmVsYXhhdGlvbiB3YXMgY2hhbmdlZC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IG5lZWRzVXBkYXRlXG4gICAgICovXG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdWx0aW5nIGNvbnN0cmFpbnQgbXVsdGlwbGllciBmcm9tIHRoZSBsYXN0IHNvbHZlLiBUaGlzIGlzIG1vc3RseSBlcXVpdmFsZW50IHRvIHRoZSBmb3JjZSBwcm9kdWNlZCBieSB0aGUgY29uc3RyYWludC5cbiAgICAgKiBAcHJvcGVydHkgbXVsdGlwbGllclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tdWx0aXBsaWVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIFJlbGF0aXZlIHZlbG9jaXR5LlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByZWxhdGl2ZVZlbG9jaXR5XG4gICAgICovXG4gICAgdGhpcy5yZWxhdGl2ZVZlbG9jaXR5ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBlcXVhdGlvbiBpcyBlbmFibGVkIG9yIG5vdC4gSWYgdHJ1ZSwgaXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgc29sdmVyLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgICAqL1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG59XG5FcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFcXVhdGlvbjtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzdGlmZm5lc3Mgd2hlbiBjcmVhdGluZyBhIG5ldyBFcXVhdGlvbi5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBERUZBVUxUX1NUSUZGTkVTU1xuICogQGRlZmF1bHQgMWU2XG4gKi9cbkVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTID0gMWU2O1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHJlbGF4YXRpb24gd2hlbiBjcmVhdGluZyBhIG5ldyBFcXVhdGlvbi5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBERUZBVUxUX1JFTEFYQVRJT05cbiAqIEBkZWZhdWx0IDRcbiAqL1xuRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OID0gNDtcblxuLyoqXG4gKiBDb21wdXRlIFNQT09LIHBhcmFtZXRlcnMgLmEsIC5iIGFuZCAuZXBzaWxvbiBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFyYW1ldGVycy4gU2VlIGVxdWF0aW9ucyA5LCAxMCBhbmQgMTEgaW4gdGhlIDxhIGhyZWY9XCJodHRwOi8vd3d3OC5jcy51bXUuc2Uva3Vyc2VyLzVEVjA1OC9WVDA5L2xlY3R1cmVzL3Nwb29rbm90ZXMucGRmXCI+U1BPT0sgbm90ZXM8L2E+LlxuICogQG1ldGhvZCB1cGRhdGVcbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGsgPSB0aGlzLnN0aWZmbmVzcyxcbiAgICAgICAgZCA9IHRoaXMucmVsYXhhdGlvbixcbiAgICAgICAgaCA9IHRoaXMudGltZVN0ZXA7XG5cbiAgICB0aGlzLmEgPSA0LjAgLyAoaCAqICgxICsgNCAqIGQpKTtcbiAgICB0aGlzLmIgPSAoNC4wICogZCkgLyAoMSArIDQgKiBkKTtcbiAgICB0aGlzLmVwc2lsb24gPSA0LjAgLyAoaCAqIGggKiBrICogKDEgKyA0ICogZCkpO1xuXG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSBhIGphY29iaWFuIGVudHJ5IHdpdGggY29ycmVzcG9uZGluZyBwb3NpdGlvbnMgb3IgdmVsb2NpdGllc1xuICogQG1ldGhvZCBnbXVsdFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuZ211bHQgPSBmdW5jdGlvbihHLHZpLHdpLHZqLHdqKXtcbiAgICByZXR1cm4gIEdbMF0gKiB2aVswXSArXG4gICAgICAgICAgICBHWzFdICogdmlbMV0gK1xuICAgICAgICAgICAgR1syXSAqIHdpICtcbiAgICAgICAgICAgIEdbM10gKiB2alswXSArXG4gICAgICAgICAgICBHWzRdICogdmpbMV0gK1xuICAgICAgICAgICAgR1s1XSAqIHdqO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUkhTIG9mIHRoZSBTUE9PSyBlcXVhdGlvblxuICogQG1ldGhvZCBjb21wdXRlQlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihhLGIsaCl7XG4gICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKTtcbiAgICB2YXIgR3EgPSB0aGlzLmNvbXB1dGVHcSgpO1xuICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuICAgIHJldHVybiAtIEdxICogYSAtIEdXICogYiAtIEdpTWYqaDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgR1xcKnEsIHdoZXJlIHEgYXJlIHRoZSBnZW5lcmFsaXplZCBib2R5IGNvb3JkaW5hdGVzXG4gKiBAbWV0aG9kIGNvbXB1dGVHcVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG52YXIgcWkgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHFqID0gdmVjMi5jcmVhdGUoKTtcbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgIHZhciBHID0gdGhpcy5HLFxuICAgICAgICBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgeGkgPSBiaS5wb3NpdGlvbixcbiAgICAgICAgeGogPSBiai5wb3NpdGlvbixcbiAgICAgICAgYWkgPSBiaS5hbmdsZSxcbiAgICAgICAgYWogPSBiai5hbmdsZTtcblxuICAgIHJldHVybiB0aGlzLmdtdWx0KEcsIHFpLCBhaSwgcWosIGFqKSArIHRoaXMub2Zmc2V0O1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyBHXFwqVywgd2hlcmUgVyBhcmUgdGhlIGJvZHkgdmVsb2NpdGllc1xuICogQG1ldGhvZCBjb21wdXRlR1dcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHVyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIEcgPSB0aGlzLkcsXG4gICAgICAgIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICB2aSA9IGJpLnZlbG9jaXR5LFxuICAgICAgICB2aiA9IGJqLnZlbG9jaXR5LFxuICAgICAgICB3aSA9IGJpLmFuZ3VsYXJWZWxvY2l0eSxcbiAgICAgICAgd2ogPSBiai5hbmd1bGFyVmVsb2NpdHk7XG4gICAgcmV0dXJuIHRoaXMuZ211bHQoRyx2aSx3aSx2aix3aikgKyB0aGlzLnJlbGF0aXZlVmVsb2NpdHk7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIEdcXCpXbGFtYmRhLCB3aGVyZSBXIGFyZSB0aGUgYm9keSB2ZWxvY2l0aWVzXG4gKiBAbWV0aG9kIGNvbXB1dGVHV2xhbWJkYVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdXbGFtYmRhID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgRyA9IHRoaXMuRyxcbiAgICAgICAgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHZpID0gYmkudmxhbWJkYSxcbiAgICAgICAgdmogPSBiai52bGFtYmRhLFxuICAgICAgICB3aSA9IGJpLndsYW1iZGEsXG4gICAgICAgIHdqID0gYmoud2xhbWJkYTtcbiAgICByZXR1cm4gdGhpcy5nbXVsdChHLHZpLHdpLHZqLHdqKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgR1xcKmludihNKVxcKmYsIHdoZXJlIE0gaXMgdGhlIG1hc3MgbWF0cml4IHdpdGggZGlhZ29uYWwgYmxvY2tzIGZvciBlYWNoIGJvZHksIGFuZCBmIGFyZSB0aGUgZm9yY2VzIG9uIHRoZSBib2RpZXMuXG4gKiBAbWV0aG9kIGNvbXB1dGVHaU1mXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZhciBpTWZpID0gdmVjMi5jcmVhdGUoKSxcbiAgICBpTWZqID0gdmVjMi5jcmVhdGUoKTtcbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR2lNZiA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICBmaSA9IGJpLmZvcmNlLFxuICAgICAgICB0aSA9IGJpLmFuZ3VsYXJGb3JjZSxcbiAgICAgICAgZmogPSBiai5mb3JjZSxcbiAgICAgICAgdGogPSBiai5hbmd1bGFyRm9yY2UsXG4gICAgICAgIGludk1hc3NpID0gYmkuaW52TWFzc1NvbHZlLFxuICAgICAgICBpbnZNYXNzaiA9IGJqLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52SWkgPSBiaS5pbnZJbmVydGlhU29sdmUsXG4gICAgICAgIGludklqID0gYmouaW52SW5lcnRpYVNvbHZlLFxuICAgICAgICBHID0gdGhpcy5HO1xuXG4gICAgdmVjMi5zY2FsZShpTWZpLCBmaSxpbnZNYXNzaSk7XG4gICAgdmVjMi5zY2FsZShpTWZqLCBmaixpbnZNYXNzaik7XG5cbiAgICByZXR1cm4gdGhpcy5nbXVsdChHLGlNZmksdGkqaW52SWksaU1maix0aippbnZJaik7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIEdcXCppbnYoTSlcXCpHJ1xuICogQG1ldGhvZCBjb21wdXRlR2lNR3RcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHaU1HdCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICBpbnZNYXNzaSA9IGJpLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludklpID0gYmkuaW52SW5lcnRpYVNvbHZlLFxuICAgICAgICBpbnZJaiA9IGJqLmludkluZXJ0aWFTb2x2ZSxcbiAgICAgICAgRyA9IHRoaXMuRztcblxuICAgIHJldHVybiAgR1swXSAqIEdbMF0gKiBpbnZNYXNzaSArXG4gICAgICAgICAgICBHWzFdICogR1sxXSAqIGludk1hc3NpICtcbiAgICAgICAgICAgIEdbMl0gKiBHWzJdICogICAgaW52SWkgK1xuICAgICAgICAgICAgR1szXSAqIEdbM10gKiBpbnZNYXNzaiArXG4gICAgICAgICAgICBHWzRdICogR1s0XSAqIGludk1hc3NqICtcbiAgICAgICAgICAgIEdbNV0gKiBHWzVdICogICAgaW52SWo7XG59O1xuXG52YXIgYWRkVG9XbGFtYmRhX3RlbXAgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFkZFRvV2xhbWJkYV9HaSA9IHZlYzIuY3JlYXRlKCksXG4gICAgYWRkVG9XbGFtYmRhX0dqID0gdmVjMi5jcmVhdGUoKSxcbiAgICBhZGRUb1dsYW1iZGFfcmkgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFkZFRvV2xhbWJkYV9yaiA9IHZlYzIuY3JlYXRlKCksXG4gICAgYWRkVG9XbGFtYmRhX01kaWFnID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBBZGQgY29uc3RyYWludCB2ZWxvY2l0eSB0byB0aGUgYm9kaWVzLlxuICogQG1ldGhvZCBhZGRUb1dsYW1iZGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YWxhbWJkYVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuYWRkVG9XbGFtYmRhID0gZnVuY3Rpb24oZGVsdGFsYW1iZGEpe1xuICAgIHZhciBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgdGVtcCA9IGFkZFRvV2xhbWJkYV90ZW1wLFxuICAgICAgICBHaSA9IGFkZFRvV2xhbWJkYV9HaSxcbiAgICAgICAgR2ogPSBhZGRUb1dsYW1iZGFfR2osXG4gICAgICAgIHJpID0gYWRkVG9XbGFtYmRhX3JpLFxuICAgICAgICByaiA9IGFkZFRvV2xhbWJkYV9yaixcbiAgICAgICAgaW52TWFzc2kgPSBiaS5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludk1hc3NqID0gYmouaW52TWFzc1NvbHZlLFxuICAgICAgICBpbnZJaSA9IGJpLmludkluZXJ0aWFTb2x2ZSxcbiAgICAgICAgaW52SWogPSBiai5pbnZJbmVydGlhU29sdmUsXG4gICAgICAgIE1kaWFnID0gYWRkVG9XbGFtYmRhX01kaWFnLFxuICAgICAgICBHID0gdGhpcy5HO1xuXG4gICAgR2lbMF0gPSBHWzBdO1xuICAgIEdpWzFdID0gR1sxXTtcbiAgICBHalswXSA9IEdbM107XG4gICAgR2pbMV0gPSBHWzRdO1xuXG4gICAgLy8gQWRkIHRvIGxpbmVhciB2ZWxvY2l0eVxuICAgIC8vIHZfbGFtYmRhICs9IGludihNKSAqIGRlbHRhX2xhbWJhICogR1xuICAgIHZlYzIuc2NhbGUodGVtcCwgR2ksIGludk1hc3NpKmRlbHRhbGFtYmRhKTtcbiAgICB2ZWMyLmFkZCggYmkudmxhbWJkYSwgYmkudmxhbWJkYSwgdGVtcCk7XG4gICAgLy8gVGhpcyBpbXB1bHNlIGlzIGluIHRoZSBvZmZzZXQgZnJhbWVcbiAgICAvLyBBbHNvIGFkZCBjb250cmlidXRpb24gdG8gYW5ndWxhclxuICAgIC8vYmkud2xhbWJkYSAtPSB2ZWMyLmNyb3NzTGVuZ3RoKHRlbXAscmkpO1xuICAgIGJpLndsYW1iZGEgKz0gaW52SWkgKiBHWzJdICogZGVsdGFsYW1iZGE7XG5cblxuICAgIHZlYzIuc2NhbGUodGVtcCwgR2osIGludk1hc3NqKmRlbHRhbGFtYmRhKTtcbiAgICB2ZWMyLmFkZCggYmoudmxhbWJkYSwgYmoudmxhbWJkYSwgdGVtcCk7XG4gICAgLy9iai53bGFtYmRhIC09IHZlYzIuY3Jvc3NMZW5ndGgodGVtcCxyaik7XG4gICAgYmoud2xhbWJkYSArPSBpbnZJaiAqIEdbNV0gKiBkZWx0YWxhbWJkYTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgZGVub21pbmF0b3IgcGFydCBvZiB0aGUgU1BPT0sgZXF1YXRpb246IEMgPSBHXFwqaW52KE0pXFwqRycgKyBlcHNcbiAqIEBtZXRob2QgY29tcHV0ZUludkNcbiAqIEBwYXJhbSAge051bWJlcn0gZXBzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlSW52QyA9IGZ1bmN0aW9uKGVwcyl7XG4gICAgcmV0dXJuIDEuMCAvICh0aGlzLmNvbXB1dGVHaU1HdCgpICsgZXBzKTtcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi9vYmplY3RzL0JvZHlcIjozMixcIi4uL3V0aWxzL1V0aWxzXCI6NTB9XSwyNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgRXF1YXRpb24gPSBfZGVyZXFfKCcuL0VxdWF0aW9uJylcbiwgICBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnJpY3Rpb25FcXVhdGlvbjtcblxuLyoqXG4gKiBDb25zdHJhaW5zIHRoZSBzbGlwcGluZyBpbiBhIGNvbnRhY3QgYWxvbmcgYSB0YW5nZW50XG4gKlxuICogQGNsYXNzIEZyaWN0aW9uRXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtOdW1iZXJ9IHNsaXBGb3JjZVxuICogQGV4dGVuZHMgRXF1YXRpb25cbiAqL1xuZnVuY3Rpb24gRnJpY3Rpb25FcXVhdGlvbihib2R5QSwgYm9keUIsIHNsaXBGb3JjZSl7XG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIC1zbGlwRm9yY2UsIHNsaXBGb3JjZSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWxhdGl2ZSB2ZWN0b3IgZnJvbSBjZW50ZXIgb2YgYm9keSBBIHRvIHRoZSBjb250YWN0IHBvaW50LCB3b3JsZCBvcmllbnRlZC5cbiAgICAgKiBAcHJvcGVydHkgY29udGFjdFBvaW50QVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RQb2ludEEgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogUmVsYXRpdmUgdmVjdG9yIGZyb20gY2VudGVyIG9mIGJvZHkgQiB0byB0aGUgY29udGFjdCBwb2ludCwgd29ybGQgb3JpZW50ZWQuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RQb2ludEJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0UG9pbnRCID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIFRhbmdlbnQgdmVjdG9yIHRoYXQgdGhlIGZyaWN0aW9uIGZvcmNlIHdpbGwgYWN0IGFsb25nLiBXb3JsZCBvcmllbnRlZC5cbiAgICAgKiBAcHJvcGVydHkgdFxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogQSBDb250YWN0RXF1YXRpb24gY29ubmVjdGVkIHRvIHRoaXMgZnJpY3Rpb24uIFRoZSBjb250YWN0IGVxdWF0aW9ucyBjYW4gYmUgdXNlZCB0byByZXNjYWxlIHRoZSBtYXggZm9yY2UgZm9yIHRoZSBmcmljdGlvbi4gSWYgbW9yZSB0aGFuIG9uZSBjb250YWN0IGVxdWF0aW9uIGlzIGdpdmVuLCB0aGVuIHRoZSBtYXggZm9yY2UgY2FuIGJlIHNldCB0byB0aGUgYXZlcmFnZS5cbiAgICAgKiBAcHJvcGVydHkgY29udGFjdEVxdWF0aW9uc1xuICAgICAqIEB0eXBlIHtDb250YWN0RXF1YXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2hhcGUgaW4gYm9keSBpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnJpY3Rpb24uXG4gICAgICogQHByb3BlcnR5IHNoYXBlQVxuICAgICAqIEB0eXBlIHtTaGFwZX1cbiAgICAgKiBAdG9kbyBOZWVkZWQ/IFRoZSBzaGFwZSBjYW4gYmUgbG9va2VkIHVwIHZpYSBjb250YWN0RXF1YXRpb24uc2hhcGVBLi4uXG4gICAgICovXG4gICAgdGhpcy5zaGFwZUEgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNoYXBlIGluIGJvZHkgaiB0aGF0IHRyaWdnZXJlZCB0aGlzIGZyaWN0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZUJcbiAgICAgKiBAdHlwZSB7U2hhcGV9XG4gICAgICogQHRvZG8gTmVlZGVkPyBUaGUgc2hhcGUgY2FuIGJlIGxvb2tlZCB1cCB2aWEgY29udGFjdEVxdWF0aW9uLnNoYXBlQi4uLlxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVCID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmljdGlvbiBjb2VmZmljaWVudCB0byB1c2UuXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uQ29lZmZpY2llbnRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25Db2VmZmljaWVudCA9IDAuMztcbn1cbkZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZyaWN0aW9uRXF1YXRpb247XG5cbi8qKlxuICogU2V0IHRoZSBzbGlwcGluZyBjb25kaXRpb24gZm9yIHRoZSBjb25zdHJhaW50LiBUaGUgZnJpY3Rpb24gZm9yY2UgY2Fubm90IGJlXG4gKiBsYXJnZXIgdGhhbiB0aGlzIHZhbHVlLlxuICogQG1ldGhvZCBzZXRTbGlwRm9yY2VcbiAqIEBwYXJhbSAge051bWJlcn0gc2xpcEZvcmNlXG4gKi9cbkZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlLnNldFNsaXBGb3JjZSA9IGZ1bmN0aW9uKHNsaXBGb3JjZSl7XG4gICAgdGhpcy5tYXhGb3JjZSA9IHNsaXBGb3JjZTtcbiAgICB0aGlzLm1pbkZvcmNlID0gLXNsaXBGb3JjZTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBtYXggZm9yY2UgZm9yIHRoZSBjb25zdHJhaW50LlxuICogQG1ldGhvZCBnZXRTbGlwRm9yY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUuZ2V0U2xpcEZvcmNlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5tYXhGb3JjZTtcbn07XG5cbkZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24oYSxiLGgpe1xuICAgIHZhciBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgcmkgPSB0aGlzLmNvbnRhY3RQb2ludEEsXG4gICAgICAgIHJqID0gdGhpcy5jb250YWN0UG9pbnRCLFxuICAgICAgICB0ID0gdGhpcy50LFxuICAgICAgICBHID0gdGhpcy5HO1xuXG4gICAgLy8gRyA9IFstdCAtcml4dCB0IHJqeHRdXG4gICAgLy8gQW5kIHJlbWVtYmVyLCB0aGlzIGlzIGEgcHVyZSB2ZWxvY2l0eSBjb25zdHJhaW50LCBnIGlzIGFsd2F5cyB6ZXJvIVxuICAgIEdbMF0gPSAtdFswXTtcbiAgICBHWzFdID0gLXRbMV07XG4gICAgR1syXSA9IC12ZWMyLmNyb3NzTGVuZ3RoKHJpLHQpO1xuICAgIEdbM10gPSB0WzBdO1xuICAgIEdbNF0gPSB0WzFdO1xuICAgIEdbNV0gPSB2ZWMyLmNyb3NzTGVuZ3RoKHJqLHQpO1xuXG4gICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKSxcbiAgICAgICAgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcblxuICAgIHZhciBCID0gLyogLSBnICogYSAgKi8gLSBHVyAqIGIgLSBoKkdpTWY7XG5cbiAgICByZXR1cm4gQjtcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi91dGlscy9VdGlsc1wiOjUwLFwiLi9FcXVhdGlvblwiOjIzfV0sMjU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIEVxdWF0aW9uID0gX2RlcmVxXyhcIi4vRXF1YXRpb25cIiksXG4gICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0aW9uYWxMb2NrRXF1YXRpb247XG5cbi8qKlxuICogTG9ja3MgdGhlIHJlbGF0aXZlIGFuZ2xlIGJldHdlZW4gdHdvIGJvZGllcy4gVGhlIGNvbnN0cmFpbnQgdHJpZXMgdG8ga2VlcCB0aGUgZG90IHByb2R1Y3QgYmV0d2VlbiB0d28gdmVjdG9ycywgbG9jYWwgaW4gZWFjaCBib2R5LCB0byB6ZXJvLiBUaGUgbG9jYWwgYW5nbGUgaW4gYm9keSBpIGlzIGEgcGFyYW1ldGVyLlxuICpcbiAqIEBjbGFzcyBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEVxdWF0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYW5nbGVdIEFuZ2xlIHRvIGFkZCB0byB0aGUgbG9jYWwgdmVjdG9yIGluIGJvZHlBLlxuICovXG5mdW5jdGlvbiBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIC1OdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhbmdsZVxuICAgICAqL1xuICAgIHRoaXMuYW5nbGUgPSBvcHRpb25zLmFuZ2xlIHx8IDA7XG5cbiAgICB2YXIgRyA9IHRoaXMuRztcbiAgICBHWzJdID0gIDE7XG4gICAgR1s1XSA9IC0xO1xufVxuUm90YXRpb25hbExvY2tFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcblJvdGF0aW9uYWxMb2NrRXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm90YXRpb25hbExvY2tFcXVhdGlvbjtcblxudmFyIHdvcmxkVmVjdG9yQSA9IHZlYzIuY3JlYXRlKCksXG4gICAgd29ybGRWZWN0b3JCID0gdmVjMi5jcmVhdGUoKSxcbiAgICB4QXhpcyA9IHZlYzIuZnJvbVZhbHVlcygxLDApLFxuICAgIHlBeGlzID0gdmVjMi5mcm9tVmFsdWVzKDAsMSk7XG5Sb3RhdGlvbmFsTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgIHZlYzIucm90YXRlKHdvcmxkVmVjdG9yQSx4QXhpcyx0aGlzLmJvZHlBLmFuZ2xlK3RoaXMuYW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHdvcmxkVmVjdG9yQix5QXhpcyx0aGlzLmJvZHlCLmFuZ2xlKTtcbiAgICByZXR1cm4gdmVjMi5kb3Qod29ybGRWZWN0b3JBLHdvcmxkVmVjdG9yQik7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9FcXVhdGlvblwiOjIzfV0sMjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIEVxdWF0aW9uID0gX2RlcmVxXyhcIi4vRXF1YXRpb25cIiksXG4gICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uO1xuXG4vKipcbiAqIFN5bmNzIHJvdGF0aW9uYWwgdmVsb2NpdHkgb2YgdHdvIGJvZGllcywgb3Igc2V0cyBhIHJlbGF0aXZlIHZlbG9jaXR5IChtb3RvcikuXG4gKlxuICogQGNsYXNzIFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEVxdWF0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKi9cbmZ1bmN0aW9uIFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIC1OdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICB0aGlzLnJlbGF0aXZlVmVsb2NpdHkgPSAxO1xuICAgIHRoaXMucmF0aW8gPSAxO1xufVxuUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XG5Sb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbjtcblJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGEsYixoKXtcbiAgICB2YXIgRyA9IHRoaXMuRztcbiAgICBHWzJdID0gLTE7XG4gICAgR1s1XSA9IHRoaXMucmF0aW87XG5cbiAgICB2YXIgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcbiAgICB2YXIgR1cgPSB0aGlzLmNvbXB1dGVHVygpO1xuICAgIHZhciBCID0gLSBHVyAqIGIgLSBoKkdpTWY7XG5cbiAgICByZXR1cm4gQjtcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL0VxdWF0aW9uXCI6MjN9XSwyNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIG9iamVjdHMgdGhhdCBkaXNwYXRjaGVzIGV2ZW50cy5cbiAqIEBjbGFzcyBFdmVudEVtaXR0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRXZlbnRFbWl0dGVyID0gZnVuY3Rpb24gKCkge307XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBFdmVudEVtaXR0ZXIsXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgKiBAbWV0aG9kIG9uXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7RXZlbnRFbWl0dGVyfSBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIsIGNvbnRleHQgKSB7XG4gICAgICAgIGxpc3RlbmVyLmNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXM7XG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApID09PSAtIDEgKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXS5wdXNoKCBsaXN0ZW5lciApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbiBldmVudCBsaXN0ZW5lciBpcyBhZGRlZFxuICAgICAqIEBtZXRob2QgaGFzXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXM6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgICBpZihsaXN0ZW5lcil7XG4gICAgICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgKiBAbWV0aG9kIG9mZlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4ge0V2ZW50RW1pdHRlcn0gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKTtcbiAgICAgICAgaWYgKCBpbmRleCAhPT0gLSAxICkge1xuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0uc3BsaWNlKCBpbmRleCwgMSApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbWl0IGFuIGV2ZW50LlxuICAgICAqIEBtZXRob2QgZW1pdFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZXZlbnRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGV2ZW50LnR5cGVcbiAgICAgKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cbiAgICAgKi9cbiAgICBlbWl0OiBmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgICB2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdO1xuICAgICAgICBpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lckFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBcnJheVsgaSBdO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwoIGxpc3RlbmVyLmNvbnRleHQsIGV2ZW50ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxufSx7fV0sMjg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIE1hdGVyaWFsID0gX2RlcmVxXygnLi9NYXRlcmlhbCcpO1xudmFyIEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0VxdWF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFjdE1hdGVyaWFsO1xuXG4vKipcbiAqIERlZmluZXMgd2hhdCBoYXBwZW5zIHdoZW4gdHdvIG1hdGVyaWFscyBtZWV0LCBzdWNoIGFzIHdoYXQgZnJpY3Rpb24gY29lZmZpY2llbnQgdG8gdXNlLiBZb3UgY2FuIGFsc28gc2V0IG90aGVyIHRoaW5ncyBzdWNoIGFzIHJlc3RpdHV0aW9uLCBzdXJmYWNlIHZlbG9jaXR5IGFuZCBjb25zdHJhaW50IHBhcmFtZXRlcnMuXG4gKiBAY2xhc3MgQ29udGFjdE1hdGVyaWFsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1hdGVyaWFsQVxuICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWxCXG4gKiBAcGFyYW0ge09iamVjdH0gICBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLmZyaWN0aW9uPTAuM10gICAgICAgRnJpY3Rpb24gY29lZmZpY2llbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5yZXN0aXR1dGlvbj0wXSAgICAgIFJlc3RpdHV0aW9uIGNvZWZmaWNpZW50IGFrYSBcImJvdW5jaW5lc3NcIi5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLnN0aWZmbmVzc10gICAgICAgICAgQ29udGFjdEVxdWF0aW9uIHN0aWZmbmVzcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLnJlbGF4YXRpb25dICAgICAgICAgQ29udGFjdEVxdWF0aW9uIHJlbGF4YXRpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5mcmljdGlvblN0aWZmbmVzc10gIEZyaWN0aW9uRXF1YXRpb24gc3RpZmZuZXNzLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMuZnJpY3Rpb25SZWxheGF0aW9uXSBGcmljdGlvbkVxdWF0aW9uIHJlbGF4YXRpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5zdXJmYWNlVmVsb2NpdHk9MF0gIFN1cmZhY2UgdmVsb2NpdHkuXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKi9cbmZ1bmN0aW9uIENvbnRhY3RNYXRlcmlhbChtYXRlcmlhbEEsIG1hdGVyaWFsQiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZighKG1hdGVyaWFsQSBpbnN0YW5jZW9mIE1hdGVyaWFsKSB8fCAhKG1hdGVyaWFsQiBpbnN0YW5jZW9mIE1hdGVyaWFsKSl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpcnN0IHR3byBhcmd1bWVudHMgbXVzdCBiZSBNYXRlcmlhbCBpbnN0YW5jZXMuXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250YWN0IG1hdGVyaWFsIGlkZW50aWZpZXJcbiAgICAgKiBAcHJvcGVydHkgaWRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBDb250YWN0TWF0ZXJpYWwuaWRDb3VudGVyKys7XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCBtYXRlcmlhbCBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb250YWN0IG1hdGVyaWFsXG4gICAgICogQHByb3BlcnR5IG1hdGVyaWFsQVxuICAgICAqIEB0eXBlIHtNYXRlcmlhbH1cbiAgICAgKi9cbiAgICB0aGlzLm1hdGVyaWFsQSA9IG1hdGVyaWFsQTtcblxuICAgIC8qKlxuICAgICAqIFNlY29uZCBtYXRlcmlhbCBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb250YWN0IG1hdGVyaWFsXG4gICAgICogQHByb3BlcnR5IG1hdGVyaWFsQlxuICAgICAqIEB0eXBlIHtNYXRlcmlhbH1cbiAgICAgKi9cbiAgICB0aGlzLm1hdGVyaWFsQiA9IG1hdGVyaWFsQjtcblxuICAgIC8qKlxuICAgICAqIEZyaWN0aW9uIHRvIHVzZSBpbiB0aGUgY29udGFjdCBvZiB0aGVzZSB0d28gbWF0ZXJpYWxzXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uICAgID0gIHR5cGVvZihvcHRpb25zLmZyaWN0aW9uKSAgICAhPT0gXCJ1bmRlZmluZWRcIiA/ICAgTnVtYmVyKG9wdGlvbnMuZnJpY3Rpb24pICAgIDogMC4zO1xuXG4gICAgLyoqXG4gICAgICogUmVzdGl0dXRpb24gdG8gdXNlIGluIHRoZSBjb250YWN0IG9mIHRoZXNlIHR3byBtYXRlcmlhbHNcbiAgICAgKiBAcHJvcGVydHkgcmVzdGl0dXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzdGl0dXRpb24gPSAgdHlwZW9mKG9wdGlvbnMucmVzdGl0dXRpb24pICE9PSBcInVuZGVmaW5lZFwiID8gICBOdW1iZXIob3B0aW9ucy5yZXN0aXR1dGlvbikgOiAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBTdGlmZm5lc3Mgb2YgdGhlIHJlc3VsdGluZyBDb250YWN0RXF1YXRpb24gdGhhdCB0aGlzIENvbnRhY3RNYXRlcmlhbCBnZW5lcmF0ZVxuICAgICAqIEBwcm9wZXJ0eSBzdGlmZm5lc3NcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RpZmZuZXNzID0gICAgICAgICAgICB0eXBlb2Yob3B0aW9ucy5zdGlmZm5lc3MpICAgICAgICAgICAhPT0gXCJ1bmRlZmluZWRcIiA/ICAgTnVtYmVyKG9wdGlvbnMuc3RpZmZuZXNzKSAgIDogRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1M7XG5cbiAgICAvKipcbiAgICAgKiBSZWxheGF0aW9uIG9mIHRoZSByZXN1bHRpbmcgQ29udGFjdEVxdWF0aW9uIHRoYXQgdGhpcyBDb250YWN0TWF0ZXJpYWwgZ2VuZXJhdGVcbiAgICAgKiBAcHJvcGVydHkgcmVsYXhhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZWxheGF0aW9uID0gICAgICAgICAgIHR5cGVvZihvcHRpb25zLnJlbGF4YXRpb24pICAgICAgICAgICE9PSBcInVuZGVmaW5lZFwiID8gICBOdW1iZXIob3B0aW9ucy5yZWxheGF0aW9uKSAgOiBFcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT047XG5cbiAgICAvKipcbiAgICAgKiBTdGlmZm5lc3Mgb2YgdGhlIHJlc3VsdGluZyBGcmljdGlvbkVxdWF0aW9uIHRoYXQgdGhpcyBDb250YWN0TWF0ZXJpYWwgZ2VuZXJhdGVcbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25TdGlmZm5lc3NcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25TdGlmZm5lc3MgPSAgICB0eXBlb2Yob3B0aW9ucy5mcmljdGlvblN0aWZmbmVzcykgICAhPT0gXCJ1bmRlZmluZWRcIiA/ICAgTnVtYmVyKG9wdGlvbnMuZnJpY3Rpb25TdGlmZm5lc3MpICAgOiBFcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTUztcblxuICAgIC8qKlxuICAgICAqIFJlbGF4YXRpb24gb2YgdGhlIHJlc3VsdGluZyBGcmljdGlvbkVxdWF0aW9uIHRoYXQgdGhpcyBDb250YWN0TWF0ZXJpYWwgZ2VuZXJhdGVcbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25SZWxheGF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uUmVsYXhhdGlvbiA9ICAgdHlwZW9mKG9wdGlvbnMuZnJpY3Rpb25SZWxheGF0aW9uKSAgIT09IFwidW5kZWZpbmVkXCIgPyAgIE51bWJlcihvcHRpb25zLmZyaWN0aW9uUmVsYXhhdGlvbikgIDogRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OO1xuXG4gICAgLyoqXG4gICAgICogV2lsbCBhZGQgc3VyZmFjZSB2ZWxvY2l0eSB0byB0aGlzIG1hdGVyaWFsLiBJZiBib2R5QSByZXN0cyBvbiB0b3AgaWYgYm9keUIsIGFuZCB0aGUgc3VyZmFjZSB2ZWxvY2l0eSBpcyBwb3NpdGl2ZSwgYm9keUEgd2lsbCBzbGlkZSB0byB0aGUgcmlnaHQuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHN1cmZhY2VWZWxvY2l0eVxuICAgICAqL1xuICAgIHRoaXMuc3VyZmFjZVZlbG9jaXR5ID0gdHlwZW9mKG9wdGlvbnMuc3VyZmFjZVZlbG9jaXR5KSAgICAhPT0gXCJ1bmRlZmluZWRcIiA/ICAgTnVtYmVyKG9wdGlvbnMuc3VyZmFjZVZlbG9jaXR5KSAgICA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBPZmZzZXQgdG8gYmUgc2V0IG9uIENvbnRhY3RFcXVhdGlvbnMuIEEgcG9zaXRpdmUgdmFsdWUgd2lsbCBtYWtlIHRoZSBib2RpZXMgcGVuZXRyYXRlIG1vcmUgaW50byBlYWNoIG90aGVyLiBDYW4gYmUgdXNlZnVsIGluIHNjZW5lcyB3aGVyZSBjb250YWN0cyBuZWVkIHRvIGJlIG1vcmUgcGVyc2lzdGVudCwgZm9yIGV4YW1wbGUgd2hlbiBzdGFja2luZy4gQWthIFwiY3VyZSBmb3IgbmVydm91cyBjb250YWN0c1wiLlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0U2tpblNpemVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdFNraW5TaXplID0gMC4wMDU7XG59XG5cbkNvbnRhY3RNYXRlcmlhbC5pZENvdW50ZXIgPSAwO1xuXG59LHtcIi4uL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIzLFwiLi9NYXRlcmlhbFwiOjI5fV0sMjk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBNYXRlcmlhbDtcblxuLyoqXG4gKiBEZWZpbmVzIGEgcGh5c2ljcyBtYXRlcmlhbC5cbiAqIEBjbGFzcyBNYXRlcmlhbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgTWF0ZXJpYWwgaWRlbnRpZmllclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICovXG5mdW5jdGlvbiBNYXRlcmlhbChpZCl7XG4gICAgLyoqXG4gICAgICogVGhlIG1hdGVyaWFsIGlkZW50aWZpZXJcbiAgICAgKiBAcHJvcGVydHkgaWRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBpZCB8fCBNYXRlcmlhbC5pZENvdW50ZXIrKztcbn1cblxuTWF0ZXJpYWwuaWRDb3VudGVyID0gMDtcblxufSx7fV0sMzA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG4gICAgLypcbiAgICAgICAgUG9seUsgbGlicmFyeVxuICAgICAgICB1cmw6IGh0dHA6Ly9wb2x5ay5pdmFuay5uZXRcbiAgICAgICAgUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2VuY2UuXG5cbiAgICAgICAgQ29weXJpZ2h0IChjKSAyMDEyIEl2YW4gS3Vja2lyXG5cbiAgICAgICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICAgICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAgICAgICAgZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gICAgICAgIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICAgICAgICBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICAgICBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAgICAgICAgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgY29uZGl0aW9uczpcblxuICAgICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICAgICAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgICAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAgICAgICAgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgICAgICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAgICAgICAgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gICAgICAgIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICAgICAgICBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gICAgICAgIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAgICAqL1xuXG4gICAgdmFyIFBvbHlLID0ge307XG5cbiAgICAvKlxuICAgICAgICBJcyBQb2x5Z29uIHNlbGYtaW50ZXJzZWN0aW5nP1xuXG4gICAgICAgIE8obl4yKVxuICAgICovXG4gICAgLypcbiAgICBQb2x5Sy5Jc1NpbXBsZSA9IGZ1bmN0aW9uKHApXG4gICAge1xuICAgICAgICB2YXIgbiA9IHAubGVuZ3RoPj4xO1xuICAgICAgICBpZihuPDQpIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgYTEgPSBuZXcgUG9seUsuX1AoKSwgYTIgPSBuZXcgUG9seUsuX1AoKTtcbiAgICAgICAgdmFyIGIxID0gbmV3IFBvbHlLLl9QKCksIGIyID0gbmV3IFBvbHlLLl9QKCk7XG4gICAgICAgIHZhciBjID0gbmV3IFBvbHlLLl9QKCk7XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bjsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBhMS54ID0gcFsyKmkgIF07XG4gICAgICAgICAgICBhMS55ID0gcFsyKmkrMV07XG4gICAgICAgICAgICBpZihpPT1uLTEpICB7IGEyLnggPSBwWzAgICAgXTsgIGEyLnkgPSBwWzEgICAgXTsgfVxuICAgICAgICAgICAgZWxzZSAgICAgICAgeyBhMi54ID0gcFsyKmkrMl07ICBhMi55ID0gcFsyKmkrM107IH1cblxuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8bjsgaisrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmKE1hdGguYWJzKGktaikgPCAyKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZihqPT1uLTEgJiYgaT09MCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYoaT09bi0xICYmIGo9PTApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgYjEueCA9IHBbMipqICBdO1xuICAgICAgICAgICAgICAgIGIxLnkgPSBwWzIqaisxXTtcbiAgICAgICAgICAgICAgICBpZihqPT1uLTEpICB7IGIyLnggPSBwWzAgICAgXTsgIGIyLnkgPSBwWzEgICAgXTsgfVxuICAgICAgICAgICAgICAgIGVsc2UgICAgICAgIHsgYjIueCA9IHBbMipqKzJdOyAgYjIueSA9IHBbMipqKzNdOyB9XG5cbiAgICAgICAgICAgICAgICBpZihQb2x5Sy5fR2V0TGluZUludGVyc2VjdGlvbihhMSxhMixiMSxiMixjKSAhPSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgUG9seUsuSXNDb252ZXggPSBmdW5jdGlvbihwKVxuICAgIHtcbiAgICAgICAgaWYocC5sZW5ndGg8NikgcmV0dXJuIHRydWU7XG4gICAgICAgIHZhciBsID0gcC5sZW5ndGggLSA0O1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxsOyBpKz0yKVxuICAgICAgICAgICAgaWYoIVBvbHlLLl9jb252ZXgocFtpXSwgcFtpKzFdLCBwW2krMl0sIHBbaSszXSwgcFtpKzRdLCBwW2krNV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmKCFQb2x5Sy5fY29udmV4KHBbbCAgXSwgcFtsKzFdLCBwW2wrMl0sIHBbbCszXSwgcFswXSwgcFsxXSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYoIVBvbHlLLl9jb252ZXgocFtsKzJdLCBwW2wrM10sIHBbMCAgXSwgcFsxICBdLCBwWzJdLCBwWzNdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgKi9cbiAgICBQb2x5Sy5HZXRBcmVhID0gZnVuY3Rpb24ocClcbiAgICB7XG4gICAgICAgIGlmKHAubGVuZ3RoIDw2KSByZXR1cm4gMDtcbiAgICAgICAgdmFyIGwgPSBwLmxlbmd0aCAtIDI7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxsOyBpKz0yKVxuICAgICAgICAgICAgc3VtICs9IChwW2krMl0tcFtpXSkgKiAocFtpKzFdK3BbaSszXSk7XG4gICAgICAgIHN1bSArPSAocFswXS1wW2xdKSAqIChwW2wrMV0rcFsxXSk7XG4gICAgICAgIHJldHVybiAtIHN1bSAqIDAuNTtcbiAgICB9XG4gICAgLypcbiAgICBQb2x5Sy5HZXRBQUJCID0gZnVuY3Rpb24ocClcbiAgICB7XG4gICAgICAgIHZhciBtaW54ID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBtaW55ID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBtYXh4ID0gLW1pbng7XG4gICAgICAgIHZhciBtYXh5ID0gLW1pbnk7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHAubGVuZ3RoOyBpKz0yKVxuICAgICAgICB7XG4gICAgICAgICAgICBtaW54ID0gTWF0aC5taW4obWlueCwgcFtpICBdKTtcbiAgICAgICAgICAgIG1heHggPSBNYXRoLm1heChtYXh4LCBwW2kgIF0pO1xuICAgICAgICAgICAgbWlueSA9IE1hdGgubWluKG1pbnksIHBbaSsxXSk7XG4gICAgICAgICAgICBtYXh5ID0gTWF0aC5tYXgobWF4eSwgcFtpKzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge3g6bWlueCwgeTptaW55LCB3aWR0aDptYXh4LW1pbngsIGhlaWdodDptYXh5LW1pbnl9O1xuICAgIH1cbiAgICAqL1xuXG4gICAgUG9seUsuVHJpYW5ndWxhdGUgPSBmdW5jdGlvbihwKVxuICAgIHtcbiAgICAgICAgdmFyIG4gPSBwLmxlbmd0aD4+MTtcbiAgICAgICAgaWYobjwzKSByZXR1cm4gW107XG4gICAgICAgIHZhciB0Z3MgPSBbXTtcbiAgICAgICAgdmFyIGF2bCA9IFtdO1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspIGF2bC5wdXNoKGkpO1xuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGFsID0gbjtcbiAgICAgICAgd2hpbGUoYWwgPiAzKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaTAgPSBhdmxbKGkrMCklYWxdO1xuICAgICAgICAgICAgdmFyIGkxID0gYXZsWyhpKzEpJWFsXTtcbiAgICAgICAgICAgIHZhciBpMiA9IGF2bFsoaSsyKSVhbF07XG5cbiAgICAgICAgICAgIHZhciBheCA9IHBbMippMF0sICBheSA9IHBbMippMCsxXTtcbiAgICAgICAgICAgIHZhciBieCA9IHBbMippMV0sICBieSA9IHBbMippMSsxXTtcbiAgICAgICAgICAgIHZhciBjeCA9IHBbMippMl0sICBjeSA9IHBbMippMisxXTtcblxuICAgICAgICAgICAgdmFyIGVhckZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBpZihQb2x5Sy5fY29udmV4KGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGVhckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGo9MDsgajxhbDsgaisrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpID0gYXZsW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZih2aT09aTAgfHwgdmk9PWkxIHx8IHZpPT1pMikgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmKFBvbHlLLl9Qb2ludEluVHJpYW5nbGUocFsyKnZpXSwgcFsyKnZpKzFdLCBheCwgYXksIGJ4LCBieSwgY3gsIGN5KSkge2VhckZvdW5kID0gZmFsc2U7IGJyZWFrO31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihlYXJGb3VuZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0Z3MucHVzaChpMCwgaTEsIGkyKTtcbiAgICAgICAgICAgICAgICBhdmwuc3BsaWNlKChpKzEpJWFsLCAxKTtcbiAgICAgICAgICAgICAgICBhbC0tO1xuICAgICAgICAgICAgICAgIGk9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGkrKyA+IDMqYWwpIGJyZWFrOyAgICAgIC8vIG5vIGNvbnZleCBhbmdsZXMgOihcbiAgICAgICAgfVxuICAgICAgICB0Z3MucHVzaChhdmxbMF0sIGF2bFsxXSwgYXZsWzJdKTtcbiAgICAgICAgcmV0dXJuIHRncztcbiAgICB9XG4gICAgLypcbiAgICBQb2x5Sy5Db250YWluc1BvaW50ID0gZnVuY3Rpb24ocCwgcHgsIHB5KVxuICAgIHtcbiAgICAgICAgdmFyIG4gPSBwLmxlbmd0aD4+MTtcbiAgICAgICAgdmFyIGF4LCBheSwgYnggPSBwWzIqbi0yXS1weCwgYnkgPSBwWzIqbi0xXS1weTtcbiAgICAgICAgdmFyIGRlcHRoID0gMDtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bjsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBheCA9IGJ4OyAgYXkgPSBieTtcbiAgICAgICAgICAgIGJ4ID0gcFsyKmkgIF0gLSBweDtcbiAgICAgICAgICAgIGJ5ID0gcFsyKmkrMV0gLSBweTtcbiAgICAgICAgICAgIGlmKGF5PCAwICYmIGJ5PCAwKSBjb250aW51ZTsgICAgLy8gYm90aCBcInVwXCIgb3IgYm90aCBcImRvbndcIlxuICAgICAgICAgICAgaWYoYXk+PTAgJiYgYnk+PTApIGNvbnRpbnVlOyAgICAvLyBib3RoIFwidXBcIiBvciBib3RoIFwiZG9ud1wiXG4gICAgICAgICAgICBpZihheDwgMCAmJiBieDwgMCkgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciBseCA9IGF4ICsgKGJ4LWF4KSooLWF5KS8oYnktYXkpO1xuICAgICAgICAgICAgaWYobHg+MCkgZGVwdGgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGRlcHRoICYgMSkgPT0gMTtcbiAgICB9XG5cbiAgICBQb2x5Sy5TbGljZSA9IGZ1bmN0aW9uKHAsIGF4LCBheSwgYngsIGJ5KVxuICAgIHtcbiAgICAgICAgaWYoUG9seUsuQ29udGFpbnNQb2ludChwLCBheCwgYXkpIHx8IFBvbHlLLkNvbnRhaW5zUG9pbnQocCwgYngsIGJ5KSkgcmV0dXJuIFtwLnNsaWNlKDApXTtcblxuICAgICAgICB2YXIgYSA9IG5ldyBQb2x5Sy5fUChheCwgYXkpO1xuICAgICAgICB2YXIgYiA9IG5ldyBQb2x5Sy5fUChieCwgYnkpO1xuICAgICAgICB2YXIgaXNjcyA9IFtdOyAgLy8gaW50ZXJzZWN0aW9uc1xuICAgICAgICB2YXIgcHMgPSBbXTsgICAgLy8gcG9pbnRzXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHAubGVuZ3RoOyBpKz0yKSBwcy5wdXNoKG5ldyBQb2x5Sy5fUChwW2ldLCBwW2krMV0pKTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxwcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGlzYyA9IG5ldyBQb2x5Sy5fUCgwLDApO1xuICAgICAgICAgICAgaXNjID0gUG9seUsuX0dldExpbmVJbnRlcnNlY3Rpb24oYSwgYiwgcHNbaV0sIHBzWyhpKzEpJXBzLmxlbmd0aF0sIGlzYyk7XG5cbiAgICAgICAgICAgIGlmKGlzYylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpc2MuZmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaXNjcy5wdXNoKGlzYyk7XG4gICAgICAgICAgICAgICAgcHMuc3BsaWNlKGkrMSwwLGlzYyk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGlzY3MubGVuZ3RoID09IDApIHJldHVybiBbcC5zbGljZSgwKV07XG4gICAgICAgIHZhciBjb21wID0gZnVuY3Rpb24odSx2KSB7cmV0dXJuIFBvbHlLLl9QLmRpc3QoYSx1KSAtIFBvbHlLLl9QLmRpc3QoYSx2KTsgfVxuICAgICAgICBpc2NzLnNvcnQoY29tcCk7XG5cbiAgICAgICAgdmFyIHBncyA9IFtdO1xuICAgICAgICB2YXIgZGlyID0gMDtcbiAgICAgICAgd2hpbGUoaXNjcy5sZW5ndGggPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbiA9IHBzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpMCA9IGlzY3NbMF07XG4gICAgICAgICAgICB2YXIgaTEgPSBpc2NzWzFdO1xuICAgICAgICAgICAgdmFyIGluZDAgPSBwcy5pbmRleE9mKGkwKTtcbiAgICAgICAgICAgIHZhciBpbmQxID0gcHMuaW5kZXhPZihpMSk7XG4gICAgICAgICAgICB2YXIgc29sdmVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmKFBvbHlLLl9maXJzdFdpdGhGbGFnKHBzLCBpbmQwKSA9PSBpbmQxKSBzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGkwID0gaXNjc1sxXTtcbiAgICAgICAgICAgICAgICBpMSA9IGlzY3NbMF07XG4gICAgICAgICAgICAgICAgaW5kMCA9IHBzLmluZGV4T2YoaTApO1xuICAgICAgICAgICAgICAgIGluZDEgPSBwcy5pbmRleE9mKGkxKTtcbiAgICAgICAgICAgICAgICBpZihQb2x5Sy5fZmlyc3RXaXRoRmxhZyhwcywgaW5kMCkgPT0gaW5kMSkgc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHNvbHZlZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkaXItLTtcbiAgICAgICAgICAgICAgICB2YXIgcGduID0gUG9seUsuX2dldFBvaW50cyhwcywgaW5kMCwgaW5kMSk7XG4gICAgICAgICAgICAgICAgcGdzLnB1c2gocGduKTtcbiAgICAgICAgICAgICAgICBwcyA9IFBvbHlLLl9nZXRQb2ludHMocHMsIGluZDEsIGluZDApO1xuICAgICAgICAgICAgICAgIGkwLmZsYWcgPSBpMS5mbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaXNjcy5zcGxpY2UoMCwyKTtcbiAgICAgICAgICAgICAgICBpZihpc2NzLmxlbmd0aCA9PSAwKSBwZ3MucHVzaChwcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgZGlyKys7IGlzY3MucmV2ZXJzZSgpOyB9XG4gICAgICAgICAgICBpZihkaXI+MSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxwZ3MubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwZyA9IHBnc1tpXTtcbiAgICAgICAgICAgIHZhciBucGcgPSBbXTtcbiAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPHBnLmxlbmd0aDsgaisrKSBucGcucHVzaChwZ1tqXS54LCBwZ1tqXS55KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5wZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBQb2x5Sy5SYXljYXN0ID0gZnVuY3Rpb24ocCwgeCwgeSwgZHgsIGR5LCBpc2MpXG4gICAge1xuICAgICAgICB2YXIgbCA9IHAubGVuZ3RoIC0gMjtcbiAgICAgICAgdmFyIHRwID0gUG9seUsuX3RwO1xuICAgICAgICB2YXIgYTEgPSB0cFswXSwgYTIgPSB0cFsxXSxcbiAgICAgICAgYjEgPSB0cFsyXSwgYjIgPSB0cFszXSwgYyA9IHRwWzRdO1xuICAgICAgICBhMS54ID0geDsgYTEueSA9IHk7XG4gICAgICAgIGEyLnggPSB4K2R4OyBhMi55ID0geStkeTtcblxuICAgICAgICBpZihpc2M9PW51bGwpIGlzYyA9IHtkaXN0OjAsIGVkZ2U6MCwgbm9ybTp7eDowLCB5OjB9LCByZWZsOnt4OjAsIHk6MH19O1xuICAgICAgICBpc2MuZGlzdCA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGIxLnggPSBwW2kgIF07ICBiMS55ID0gcFtpKzFdO1xuICAgICAgICAgICAgYjIueCA9IHBbaSsyXTsgIGIyLnkgPSBwW2krM107XG4gICAgICAgICAgICB2YXIgbmlzYyA9IFBvbHlLLl9SYXlMaW5lSW50ZXJzZWN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKTtcbiAgICAgICAgICAgIGlmKG5pc2MpIFBvbHlLLl91cGRhdGVJU0MoZHgsIGR5LCBhMSwgYjEsIGIyLCBjLCBpLzIsIGlzYyk7XG4gICAgICAgIH1cbiAgICAgICAgYjEueCA9IGIyLng7ICBiMS55ID0gYjIueTtcbiAgICAgICAgYjIueCA9IHBbMF07ICBiMi55ID0gcFsxXTtcbiAgICAgICAgdmFyIG5pc2MgPSBQb2x5Sy5fUmF5TGluZUludGVyc2VjdGlvbihhMSwgYTIsIGIxLCBiMiwgYyk7XG4gICAgICAgIGlmKG5pc2MpIFBvbHlLLl91cGRhdGVJU0MoZHgsIGR5LCBhMSwgYjEsIGIyLCBjLCBwLmxlbmd0aC8yLCBpc2MpO1xuXG4gICAgICAgIHJldHVybiAoaXNjLmRpc3QgIT0gSW5maW5pdHkpID8gaXNjIDogbnVsbDtcbiAgICB9XG5cbiAgICBQb2x5Sy5DbG9zZXN0RWRnZSA9IGZ1bmN0aW9uKHAsIHgsIHksIGlzYylcbiAgICB7XG4gICAgICAgIHZhciBsID0gcC5sZW5ndGggLSAyO1xuICAgICAgICB2YXIgdHAgPSBQb2x5Sy5fdHA7XG4gICAgICAgIHZhciBhMSA9IHRwWzBdLFxuICAgICAgICBiMSA9IHRwWzJdLCBiMiA9IHRwWzNdLCBjID0gdHBbNF07XG4gICAgICAgIGExLnggPSB4OyBhMS55ID0geTtcblxuICAgICAgICBpZihpc2M9PW51bGwpIGlzYyA9IHtkaXN0OjAsIGVkZ2U6MCwgcG9pbnQ6e3g6MCwgeTowfSwgbm9ybTp7eDowLCB5OjB9fTtcbiAgICAgICAgaXNjLmRpc3QgPSBJbmZpbml0eTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxsOyBpKz0yKVxuICAgICAgICB7XG4gICAgICAgICAgICBiMS54ID0gcFtpICBdOyAgYjEueSA9IHBbaSsxXTtcbiAgICAgICAgICAgIGIyLnggPSBwW2krMl07ICBiMi55ID0gcFtpKzNdO1xuICAgICAgICAgICAgUG9seUsuX3BvaW50TGluZURpc3QoYTEsIGIxLCBiMiwgaT4+MSwgaXNjKTtcbiAgICAgICAgfVxuICAgICAgICBiMS54ID0gYjIueDsgIGIxLnkgPSBiMi55O1xuICAgICAgICBiMi54ID0gcFswXTsgIGIyLnkgPSBwWzFdO1xuICAgICAgICBQb2x5Sy5fcG9pbnRMaW5lRGlzdChhMSwgYjEsIGIyLCBsPj4xLCBpc2MpO1xuXG4gICAgICAgIHZhciBpZHN0ID0gMS9pc2MuZGlzdDtcbiAgICAgICAgaXNjLm5vcm0ueCA9ICh4LWlzYy5wb2ludC54KSppZHN0O1xuICAgICAgICBpc2Mubm9ybS55ID0gKHktaXNjLnBvaW50LnkpKmlkc3Q7XG4gICAgICAgIHJldHVybiBpc2M7XG4gICAgfVxuXG4gICAgUG9seUsuX3BvaW50TGluZURpc3QgPSBmdW5jdGlvbihwLCBhLCBiLCBlZGdlLCBpc2MpXG4gICAge1xuICAgICAgICB2YXIgeCA9IHAueCwgeSA9IHAueSwgeDEgPSBhLngsIHkxID0gYS55LCB4MiA9IGIueCwgeTIgPSBiLnk7XG5cbiAgICAgICAgdmFyIEEgPSB4IC0geDE7XG4gICAgICAgIHZhciBCID0geSAtIHkxO1xuICAgICAgICB2YXIgQyA9IHgyIC0geDE7XG4gICAgICAgIHZhciBEID0geTIgLSB5MTtcblxuICAgICAgICB2YXIgZG90ID0gQSAqIEMgKyBCICogRDtcbiAgICAgICAgdmFyIGxlbl9zcSA9IEMgKiBDICsgRCAqIEQ7XG4gICAgICAgIHZhciBwYXJhbSA9IGRvdCAvIGxlbl9zcTtcblxuICAgICAgICB2YXIgeHgsIHl5O1xuXG4gICAgICAgIGlmIChwYXJhbSA8IDAgfHwgKHgxID09IHgyICYmIHkxID09IHkyKSkge1xuICAgICAgICAgICAgeHggPSB4MTtcbiAgICAgICAgICAgIHl5ID0geTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW0gPiAxKSB7XG4gICAgICAgICAgICB4eCA9IHgyO1xuICAgICAgICAgICAgeXkgPSB5MjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHh4ID0geDEgKyBwYXJhbSAqIEM7XG4gICAgICAgICAgICB5eSA9IHkxICsgcGFyYW0gKiBEO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR4ID0geCAtIHh4O1xuICAgICAgICB2YXIgZHkgPSB5IC0geXk7XG4gICAgICAgIHZhciBkc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICBpZihkc3Q8aXNjLmRpc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlzYy5kaXN0ID0gZHN0O1xuICAgICAgICAgICAgaXNjLmVkZ2UgPSBlZGdlO1xuICAgICAgICAgICAgaXNjLnBvaW50LnggPSB4eDtcbiAgICAgICAgICAgIGlzYy5wb2ludC55ID0geXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBQb2x5Sy5fdXBkYXRlSVNDID0gZnVuY3Rpb24oZHgsIGR5LCBhMSwgYjEsIGIyLCBjLCBlZGdlLCBpc2MpXG4gICAge1xuICAgICAgICB2YXIgbnJsID0gUG9seUsuX1AuZGlzdChhMSwgYyk7XG4gICAgICAgIGlmKG5ybDxpc2MuZGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGlibCA9IDEvUG9seUsuX1AuZGlzdChiMSwgYjIpO1xuICAgICAgICAgICAgdmFyIG54ID0gLShiMi55LWIxLnkpKmlibDtcbiAgICAgICAgICAgIHZhciBueSA9ICAoYjIueC1iMS54KSppYmw7XG4gICAgICAgICAgICB2YXIgZGRvdCA9IDIqKGR4Km54K2R5Km55KTtcbiAgICAgICAgICAgIGlzYy5kaXN0ID0gbnJsO1xuICAgICAgICAgICAgaXNjLm5vcm0ueCA9IG54O1xuICAgICAgICAgICAgaXNjLm5vcm0ueSA9IG55O1xuICAgICAgICAgICAgaXNjLnJlZmwueCA9IC1kZG90Km54K2R4O1xuICAgICAgICAgICAgaXNjLnJlZmwueSA9IC1kZG90Km55K2R5O1xuICAgICAgICAgICAgaXNjLmVkZ2UgPSBlZGdlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgUG9seUsuX2dldFBvaW50cyA9IGZ1bmN0aW9uKHBzLCBpbmQwLCBpbmQxKVxuICAgIHtcbiAgICAgICAgdmFyIG4gPSBwcy5sZW5ndGg7XG4gICAgICAgIHZhciBucHMgPSBbXTtcbiAgICAgICAgaWYoaW5kMTxpbmQwKSBpbmQxICs9IG47XG4gICAgICAgIGZvcih2YXIgaT1pbmQwOyBpPD0gaW5kMTsgaSsrKSBucHMucHVzaChwc1tpJW5dKTtcbiAgICAgICAgcmV0dXJuIG5wcztcbiAgICB9XG5cbiAgICBQb2x5Sy5fZmlyc3RXaXRoRmxhZyA9IGZ1bmN0aW9uKHBzLCBpbmQpXG4gICAge1xuICAgICAgICB2YXIgbiA9IHBzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUodHJ1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaW5kID0gKGluZCsxKSVuO1xuICAgICAgICAgICAgaWYocHNbaW5kXS5mbGFnKSByZXR1cm4gaW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgICovXG4gICAgUG9seUsuX1BvaW50SW5UcmlhbmdsZSA9IGZ1bmN0aW9uKHB4LCBweSwgYXgsIGF5LCBieCwgYnksIGN4LCBjeSlcbiAgICB7XG4gICAgICAgIHZhciB2MHggPSBjeC1heDtcbiAgICAgICAgdmFyIHYweSA9IGN5LWF5O1xuICAgICAgICB2YXIgdjF4ID0gYngtYXg7XG4gICAgICAgIHZhciB2MXkgPSBieS1heTtcbiAgICAgICAgdmFyIHYyeCA9IHB4LWF4O1xuICAgICAgICB2YXIgdjJ5ID0gcHktYXk7XG5cbiAgICAgICAgdmFyIGRvdDAwID0gdjB4KnYweCt2MHkqdjB5O1xuICAgICAgICB2YXIgZG90MDEgPSB2MHgqdjF4K3YweSp2MXk7XG4gICAgICAgIHZhciBkb3QwMiA9IHYweCp2MngrdjB5KnYyeTtcbiAgICAgICAgdmFyIGRvdDExID0gdjF4KnYxeCt2MXkqdjF5O1xuICAgICAgICB2YXIgZG90MTIgPSB2MXgqdjJ4K3YxeSp2Mnk7XG5cbiAgICAgICAgdmFyIGludkRlbm9tID0gMSAvIChkb3QwMCAqIGRvdDExIC0gZG90MDEgKiBkb3QwMSk7XG4gICAgICAgIHZhciB1ID0gKGRvdDExICogZG90MDIgLSBkb3QwMSAqIGRvdDEyKSAqIGludkRlbm9tO1xuICAgICAgICB2YXIgdiA9IChkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMikgKiBpbnZEZW5vbTtcblxuICAgICAgICAvLyBDaGVjayBpZiBwb2ludCBpcyBpbiB0cmlhbmdsZVxuICAgICAgICByZXR1cm4gKHUgPj0gMCkgJiYgKHYgPj0gMCkgJiYgKHUgKyB2IDwgMSk7XG4gICAgfVxuICAgIC8qXG4gICAgUG9seUsuX1JheUxpbmVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhMSwgYTIsIGIxLCBiMiwgYylcbiAgICB7XG4gICAgICAgIHZhciBkYXggPSAoYTEueC1hMi54KSwgZGJ4ID0gKGIxLngtYjIueCk7XG4gICAgICAgIHZhciBkYXkgPSAoYTEueS1hMi55KSwgZGJ5ID0gKGIxLnktYjIueSk7XG5cbiAgICAgICAgdmFyIERlbiA9IGRheCpkYnkgLSBkYXkqZGJ4O1xuICAgICAgICBpZiAoRGVuID09IDApIHJldHVybiBudWxsOyAgLy8gcGFyYWxsZWxcblxuICAgICAgICB2YXIgQSA9IChhMS54ICogYTIueSAtIGExLnkgKiBhMi54KTtcbiAgICAgICAgdmFyIEIgPSAoYjEueCAqIGIyLnkgLSBiMS55ICogYjIueCk7XG5cbiAgICAgICAgdmFyIEkgPSBjO1xuICAgICAgICB2YXIgaURlbiA9IDEvRGVuO1xuICAgICAgICBJLnggPSAoIEEqZGJ4IC0gZGF4KkIgKSAqIGlEZW47XG4gICAgICAgIEkueSA9ICggQSpkYnkgLSBkYXkqQiApICogaURlbjtcblxuICAgICAgICBpZighUG9seUsuX0luUmVjdChJLCBiMSwgYjIpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYoKGRheT4wICYmIEkueT5hMS55KSB8fCAoZGF5PDAgJiYgSS55PGExLnkpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYoKGRheD4wICYmIEkueD5hMS54KSB8fCAoZGF4PDAgJiYgSS54PGExLngpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIEk7XG4gICAgfVxuXG4gICAgUG9seUsuX0dldExpbmVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhMSwgYTIsIGIxLCBiMiwgYylcbiAgICB7XG4gICAgICAgIHZhciBkYXggPSAoYTEueC1hMi54KSwgZGJ4ID0gKGIxLngtYjIueCk7XG4gICAgICAgIHZhciBkYXkgPSAoYTEueS1hMi55KSwgZGJ5ID0gKGIxLnktYjIueSk7XG5cbiAgICAgICAgdmFyIERlbiA9IGRheCpkYnkgLSBkYXkqZGJ4O1xuICAgICAgICBpZiAoRGVuID09IDApIHJldHVybiBudWxsOyAgLy8gcGFyYWxsZWxcblxuICAgICAgICB2YXIgQSA9IChhMS54ICogYTIueSAtIGExLnkgKiBhMi54KTtcbiAgICAgICAgdmFyIEIgPSAoYjEueCAqIGIyLnkgLSBiMS55ICogYjIueCk7XG5cbiAgICAgICAgdmFyIEkgPSBjO1xuICAgICAgICBJLnggPSAoIEEqZGJ4IC0gZGF4KkIgKSAvIERlbjtcbiAgICAgICAgSS55ID0gKCBBKmRieSAtIGRheSpCICkgLyBEZW47XG5cbiAgICAgICAgaWYoUG9seUsuX0luUmVjdChJLCBhMSwgYTIpICYmIFBvbHlLLl9JblJlY3QoSSwgYjEsIGIyKSkgcmV0dXJuIEk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIFBvbHlLLl9JblJlY3QgPSBmdW5jdGlvbihhLCBiLCBjKVxuICAgIHtcbiAgICAgICAgaWYgIChiLnggPT0gYy54KSByZXR1cm4gKGEueT49TWF0aC5taW4oYi55LCBjLnkpICYmIGEueTw9TWF0aC5tYXgoYi55LCBjLnkpKTtcbiAgICAgICAgaWYgIChiLnkgPT0gYy55KSByZXR1cm4gKGEueD49TWF0aC5taW4oYi54LCBjLngpICYmIGEueDw9TWF0aC5tYXgoYi54LCBjLngpKTtcblxuICAgICAgICBpZihhLnggPj0gTWF0aC5taW4oYi54LCBjLngpICYmIGEueCA8PSBNYXRoLm1heChiLngsIGMueClcbiAgICAgICAgJiYgYS55ID49IE1hdGgubWluKGIueSwgYy55KSAmJiBhLnkgPD0gTWF0aC5tYXgoYi55LCBjLnkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAqL1xuICAgIFBvbHlLLl9jb252ZXggPSBmdW5jdGlvbihheCwgYXksIGJ4LCBieSwgY3gsIGN5KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIChheS1ieSkqKGN4LWJ4KSArIChieC1heCkqKGN5LWJ5KSA+PSAwO1xuICAgIH1cbiAgICAvKlxuICAgIFBvbHlLLl9QID0gZnVuY3Rpb24oeCx5KVxuICAgIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy5mbGFnID0gZmFsc2U7XG4gICAgfVxuICAgIFBvbHlLLl9QLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKClcbiAgICB7XG4gICAgICAgIHJldHVybiBcIlBvaW50IFtcIit0aGlzLngrXCIsIFwiK3RoaXMueStcIl1cIjtcbiAgICB9XG4gICAgUG9seUsuX1AuZGlzdCA9IGZ1bmN0aW9uKGEsYilcbiAgICB7XG4gICAgICAgIHZhciBkeCA9IGIueC1hLng7XG4gICAgICAgIHZhciBkeSA9IGIueS1hLnk7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHgqZHggKyBkeSpkeSk7XG4gICAgfVxuXG4gICAgUG9seUsuX3RwID0gW107XG4gICAgZm9yKHZhciBpPTA7IGk8MTA7IGkrKykgUG9seUsuX3RwLnB1c2gobmV3IFBvbHlLLl9QKDAsMCkpO1xuICAgICAgICAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbHlLO1xuXG59LHt9XSwzMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBUaGUgdmVjMiBvYmplY3QgZnJvbSBnbE1hdHJpeCwgd2l0aCBzb21lIGV4dGVuc2lvbnMgYW5kIHNvbWUgcmVtb3ZlZCBtZXRob2RzLiBTZWUgaHR0cDovL2dsbWF0cml4Lm5ldC5cbiAqIEBjbGFzcyB2ZWMyXG4gKi9cblxudmFyIHZlYzIgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG4vKipcbiAqIE1ha2UgYSBjcm9zcyBwcm9kdWN0IGFuZCBvbmx5IHJldHVybiB0aGUgeiBjb21wb25lbnRcbiAqIEBtZXRob2QgY3Jvc3NMZW5ndGhcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG52ZWMyLmNyb3NzTGVuZ3RoID0gZnVuY3Rpb24oYSxiKXtcbiAgICByZXR1cm4gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbn07XG5cbi8qKlxuICogQ3Jvc3MgcHJvZHVjdCBiZXR3ZWVuIGEgdmVjdG9yIGFuZCB0aGUgWiBjb21wb25lbnQgb2YgYSB2ZWN0b3JcbiAqIEBtZXRob2QgY3Jvc3NWWlxuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7QXJyYXl9IHZlY1xuICogQHBhcmFtICB7TnVtYmVyfSB6Y29tcFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG52ZWMyLmNyb3NzVlogPSBmdW5jdGlvbihvdXQsIHZlYywgemNvbXApe1xuICAgIHZlYzIucm90YXRlKG91dCx2ZWMsLU1hdGguUEkvMik7Ly8gUm90YXRlIGFjY29yZGluZyB0byB0aGUgcmlnaHQgaGFuZCBydWxlXG4gICAgdmVjMi5zY2FsZShvdXQsb3V0LHpjb21wKTsgICAgICAvLyBTY2FsZSB3aXRoIHpcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcm9zcyBwcm9kdWN0IGJldHdlZW4gYSB2ZWN0b3IgYW5kIHRoZSBaIGNvbXBvbmVudCBvZiBhIHZlY3RvclxuICogQG1ldGhvZCBjcm9zc1pWXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHpjb21wXG4gKiBAcGFyYW0gIHtBcnJheX0gdmVjXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZlYzIuY3Jvc3NaViA9IGZ1bmN0aW9uKG91dCwgemNvbXAsIHZlYyl7XG4gICAgdmVjMi5yb3RhdGUob3V0LHZlYyxNYXRoLlBJLzIpOyAvLyBSb3RhdGUgYWNjb3JkaW5nIHRvIHRoZSByaWdodCBoYW5kIHJ1bGVcbiAgICB2ZWMyLnNjYWxlKG91dCxvdXQsemNvbXApOyAgICAgIC8vIFNjYWxlIHdpdGggelxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSBhbiBhbmdsZVxuICogQG1ldGhvZCByb3RhdGVcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbnZlYzIucm90YXRlID0gZnVuY3Rpb24ob3V0LGEsYW5nbGUpe1xuICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICBzID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgeCA9IGFbMF0sXG4gICAgICAgICAgICB5ID0gYVsxXTtcbiAgICAgICAgb3V0WzBdID0gYyp4IC1zKnk7XG4gICAgICAgIG91dFsxXSA9IHMqeCArYyp5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbMV07XG4gICAgfVxufTtcblxuLyoqXG4gKiBSb3RhdGUgYSB2ZWN0b3IgOTAgZGVncmVlcyBjbG9ja3dpc2VcbiAqIEBtZXRob2Qgcm90YXRlOTBjd1xuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xudmVjMi5yb3RhdGU5MGN3ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdO1xuICAgIHZhciB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSB5O1xuICAgIG91dFsxXSA9IC14O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBwb2ludCBwb3NpdGlvbiB0byBsb2NhbCBmcmFtZS5cbiAqIEBtZXRob2QgdG9Mb2NhbEZyYW1lXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gd29ybGRQb2ludFxuICogQHBhcmFtICB7QXJyYXl9IGZyYW1lUG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gZnJhbWVBbmdsZVxuICovXG52ZWMyLnRvTG9jYWxGcmFtZSA9IGZ1bmN0aW9uKG91dCwgd29ybGRQb2ludCwgZnJhbWVQb3NpdGlvbiwgZnJhbWVBbmdsZSl7XG4gICAgdmVjMi5jb3B5KG91dCwgd29ybGRQb2ludCk7XG4gICAgdmVjMi5zdWIob3V0LCBvdXQsIGZyYW1lUG9zaXRpb24pO1xuICAgIHZlYzIucm90YXRlKG91dCwgb3V0LCAtZnJhbWVBbmdsZSk7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHBvaW50IHBvc2l0aW9uIHRvIGdsb2JhbCBmcmFtZS5cbiAqIEBtZXRob2QgdG9HbG9iYWxGcmFtZVxuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7QXJyYXl9IGxvY2FsUG9pbnRcbiAqIEBwYXJhbSAge0FycmF5fSBmcmFtZVBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGZyYW1lQW5nbGVcbiAqL1xudmVjMi50b0dsb2JhbEZyYW1lID0gZnVuY3Rpb24ob3V0LCBsb2NhbFBvaW50LCBmcmFtZVBvc2l0aW9uLCBmcmFtZUFuZ2xlKXtcbiAgICB2ZWMyLmNvcHkob3V0LCBsb2NhbFBvaW50KTtcbiAgICB2ZWMyLnJvdGF0ZShvdXQsIG91dCwgZnJhbWVBbmdsZSk7XG4gICAgdmVjMi5hZGQob3V0LCBvdXQsIGZyYW1lUG9zaXRpb24pO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIGNlbnRyb2lkIG9mIGEgdHJpYW5nbGUgc3Bhbm5lZCBieSB2ZWN0b3JzIGEsYixjLiBTZWUgaHR0cDovL2Vhc3ljYWxjdWxhdGlvbi5jb20vYW5hbHl0aWNhbC9sZWFybi1jZW50cm9pZC5waHBcbiAqIEBtZXRob2QgY2VudHJvaWRcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHBhcmFtICB7QXJyYXl9IGNcbiAqIEByZXR1cm4gIHtBcnJheX0gVGhlIG91dCBvYmplY3RcbiAqL1xudmVjMi5jZW50cm9pZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG4gICAgdmVjMi5hZGQob3V0LCBhLCBiKTtcbiAgICB2ZWMyLmFkZChvdXQsIG91dCwgYyk7XG4gICAgdmVjMi5zY2FsZShvdXQsIG91dCwgMS8zKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNyZWF0ZVxuICogQHJldHVybiB7QXJyYXl9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgVXRpbHMuQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNsb25lXG4gKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybiB7QXJyYXl9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgVXRpbHMuQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBmcm9tVmFsdWVzXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBvdXQgPSBuZXcgVXRpbHMuQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxuICogQHN0YXRpY1xuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzInc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBhZGRcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdHdvIHZlYzInc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBzdWJ0cmFjdFxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHZlYzIuc3VidHJhY3RcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3ViXG4gKi9cbnZlYzIuc3ViID0gdmVjMi5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbXVsdGlwbHlcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLm11bHRpcGx5XG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIG11bFxuICovXG52ZWMyLm11bCA9IHZlYzIubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGRpdmlkZVxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLmRpdmlkZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBkaXZcbiAqL1xudmVjMi5kaXYgPSB2ZWMyLmRpdmlkZTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzY2FsZVxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGRpc3RhbmNlXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMi5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgdmVjMi5kaXN0YW5jZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBkaXN0XG4gKi9cbnZlYzIuZGlzdCA9IHZlYzIuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHNxdWFyZWREaXN0YW5jZVxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMi5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLnNxdWFyZWREaXN0YW5jZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzcXJEaXN0XG4gKi9cbnZlYzIuc3FyRGlzdCA9IHZlYzIuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbGVuZ3RoXG4gKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzIubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHZlYzIubGVuZ3RoXG4gKiBAbWV0aG9kIGxlblxuICogQHN0YXRpY1xuICovXG52ZWMyLmxlbiA9IHZlYzIubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzcXVhcmVkTGVuZ3RoXG4gKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm4ge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWMyLnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHZlYzIuc3F1YXJlZExlbmd0aFxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzcXJMZW5cbiAqL1xudmVjMi5zcXJMZW4gPSB2ZWMyLnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbmVnYXRlXG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgbm9ybWFsaXplXG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeTtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZG90XG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybiB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzIuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzdHJcbiAqIEBwYXJhbSB7QXJyYXl9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzIuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcpJztcbn07XG5cbnZlYzIubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV07XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbn0se1wiLi4vdXRpbHMvVXRpbHNcIjo1MH1dLDMyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBkZWNvbXAgPSBfZGVyZXFfKCdwb2x5LWRlY29tcCcpXG4sICAgQ29udmV4ID0gX2RlcmVxXygnLi4vc2hhcGVzL0NvbnZleCcpXG4sICAgQUFCQiA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9BQUJCJylcbiwgICBFdmVudEVtaXR0ZXIgPSBfZGVyZXFfKCcuLi9ldmVudHMvRXZlbnRFbWl0dGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQm9keTtcblxuLyoqXG4gKiBBIHJpZ2lkIGJvZHkuIEhhcyBnb3QgYSBjZW50ZXIgb2YgbWFzcywgcG9zaXRpb24sIHZlbG9jaXR5IGFuZCBhIG51bWJlciBvZlxuICogc2hhcGVzIHRoYXQgYXJlIHVzZWQgZm9yIGNvbGxpc2lvbnMuXG4gKlxuICogQGNsYXNzIEJvZHlcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgIFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgICBbb3B0aW9ucy5tYXNzPTBdICAgIEEgbnVtYmVyID49IDAuIElmIHplcm8sIHRoZSAudHlwZSB3aWxsIGJlIHNldCB0byBCb2R5LlNUQVRJQy5cbiAqIEBwYXJhbSB7QXJyYXl9ICAgICAgICAgICAgICAgW29wdGlvbnMucG9zaXRpb25dXG4gKiBAcGFyYW0ge0FycmF5fSAgICAgICAgICAgICAgIFtvcHRpb25zLnZlbG9jaXR5XVxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgICBbb3B0aW9ucy5hbmdsZT0wXVxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgICBbb3B0aW9ucy5hbmd1bGFyVmVsb2NpdHk9MF1cbiAqIEBwYXJhbSB7QXJyYXl9ICAgICAgICAgICAgICAgW29wdGlvbnMuZm9yY2VdXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgIFtvcHRpb25zLmFuZ3VsYXJGb3JjZT0wXVxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgICBbb3B0aW9ucy5maXhlZFJvdGF0aW9uPWZhbHNlXVxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgICBbb3B0aW9ucy5jY2RTcGVlZFRocmVzaG9sZD0tMV1cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgW29wdGlvbnMuY2NkSXRlcmF0aW9ucz0xMF1cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAvLyBDcmVhdGUgYSB0eXBpY2FsIGR5bmFtaWMgYm9keVxuICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoe1xuICogICAgICAgICBtYXNzOiAxLFxuICogICAgICAgICBwb3NpdGlvbjogWzAsIDBdLFxuICogICAgICAgICBhbmdsZTogMCxcbiAqICAgICAgICAgdmVsb2NpdHk6IFswLCAwXSxcbiAqICAgICAgICAgYW5ndWxhclZlbG9jaXR5OiAwXG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIEFkZCBhIGNpcmN1bGFyIHNoYXBlIHRvIHRoZSBib2R5XG4gKiAgICAgYm9keS5hZGRTaGFwZShuZXcgQ2lyY2xlKDEpKTtcbiAqXG4gKiAgICAgLy8gQWRkIHRoZSBib2R5IHRvIHRoZSB3b3JsZFxuICogICAgIHdvcmxkLmFkZEJvZHkoYm9keSk7XG4gKi9cbmZ1bmN0aW9uIEJvZHkob3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBib2R5IGlkZW50aWZ5ZXJcbiAgICAgKiBAcHJvcGVydHkgaWRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSArK0JvZHkuX2lkQ291bnRlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3b3JsZCB0aGF0IHRoaXMgYm9keSBpcyBhZGRlZCB0by4gVGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gTlVMTCBpZiB0aGUgYm9keSBpcyBub3QgYWRkZWQgdG8gYW55IHdvcmxkLlxuICAgICAqIEBwcm9wZXJ0eSB3b3JsZFxuICAgICAqIEB0eXBlIHtXb3JsZH1cbiAgICAgKi9cbiAgICB0aGlzLndvcmxkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFwZXMgb2YgdGhlIGJvZHkuIFRoZSBsb2NhbCB0cmFuc2Zvcm0gb2YgdGhlIHNoYXBlIGluIC5zaGFwZXNbaV0gaXNcbiAgICAgKiBkZWZpbmVkIGJ5IC5zaGFwZU9mZnNldHNbaV0gYW5kIC5zaGFwZUFuZ2xlc1tpXS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5zaGFwZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhbCBzaGFwZSBvZmZzZXRzLCByZWxhdGl2ZSB0byB0aGUgYm9keSBjZW50ZXIgb2YgbWFzcy4gVGhpcyBpcyBhblxuICAgICAqIGFycmF5IG9mIEFycmF5LlxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZU9mZnNldHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5zaGFwZU9mZnNldHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBib2R5LWxvY2FsIHNoYXBlIGFuZ2xlIHRyYW5zZm9ybXMuIFRoaXMgaXMgYW4gYXJyYXkgb2YgbnVtYmVycyAoYW5nbGVzKS5cbiAgICAgKiBAcHJvcGVydHkgc2hhcGVBbmdsZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5zaGFwZUFuZ2xlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1hc3Mgb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IG1hc3NcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWFzcyA9IG9wdGlvbnMubWFzcyB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2UgbWFzcyBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgaW52TWFzc1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbnZNYXNzID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmVydGlhIG9mIHRoZSBib2R5IGFyb3VuZCB0aGUgWiBheGlzLlxuICAgICAqIEBwcm9wZXJ0eSBpbmVydGlhXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmluZXJ0aWEgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2UgaW5lcnRpYSBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgaW52SW5lcnRpYVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbnZJbmVydGlhID0gMDtcblxuICAgIHRoaXMuaW52TWFzc1NvbHZlID0gMDtcbiAgICB0aGlzLmludkluZXJ0aWFTb2x2ZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBmaXggdGhlIHJvdGF0aW9uIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBmaXhlZFJvdGF0aW9uXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5maXhlZFJvdGF0aW9uID0gISFvcHRpb25zLmZpeGVkUm90YXRpb247XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGJvZHlcbiAgICAgKiBAcHJvcGVydHkgcG9zaXRpb25cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuICAgIGlmKG9wdGlvbnMucG9zaXRpb24pe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy5wb3NpdGlvbiwgb3B0aW9ucy5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVycG9sYXRlZCBwb3NpdGlvbiBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgaW50ZXJwb2xhdGVkUG9zaXRpb25cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5pbnRlcnBvbGF0ZWRQb3NpdGlvbiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVycG9sYXRlZCBhbmdsZSBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgaW50ZXJwb2xhdGVkQW5nbGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJwb2xhdGVkQW5nbGUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZXZpb3VzIHBvc2l0aW9uIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBwcmV2aW91c1Bvc2l0aW9uXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZXZpb3VzIGFuZ2xlIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBwcmV2aW91c0FuZ2xlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnByZXZpb3VzQW5nbGUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZlbG9jaXR5IG9mIHRoZSBib2R5XG4gICAgICogQHByb3BlcnR5IHZlbG9jaXR5XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudmVsb2NpdHkgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcbiAgICBpZihvcHRpb25zLnZlbG9jaXR5KXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMudmVsb2NpdHksIG9wdGlvbnMudmVsb2NpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnN0cmFpbnQgdmVsb2NpdHkgdGhhdCB3YXMgYWRkZWQgdG8gdGhlIGJvZHkgZHVyaW5nIHRoZSBsYXN0IHN0ZXAuXG4gICAgICogQHByb3BlcnR5IHZsYW1iZGFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy52bGFtYmRhID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbiAgICAvKipcbiAgICAgKiBBbmd1bGFyIGNvbnN0cmFpbnQgdmVsb2NpdHkgdGhhdCB3YXMgYWRkZWQgdG8gdGhlIGJvZHkgZHVyaW5nIGxhc3Qgc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgd2xhbWJkYVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLndsYW1iZGEgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFuZ2xlIG9mIHRoZSBib2R5LCBpbiByYWRpYW5zLlxuICAgICAqIEBwcm9wZXJ0eSBhbmdsZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gVGhlIGFuZ2xlIHByb3BlcnR5IGlzIG5vdCBub3JtYWxpemVkIHRvIHRoZSBpbnRlcnZhbCAwIHRvIDIqcGksIGl0IGNhbiBiZSBhbnkgdmFsdWUuXG4gICAgICogICAgIC8vIElmIHlvdSBuZWVkIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAyKnBpLCB1c2UgdGhlIGZvbGxvd2luZyBmdW5jdGlvbiB0byBub3JtYWxpemUgaXQuXG4gICAgICogICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUFuZ2xlKGFuZ2xlKXtcbiAgICAgKiAgICAgICAgIGFuZ2xlID0gYW5nbGUgJSAoMipNYXRoLlBJKTtcbiAgICAgKiAgICAgICAgIGlmKGFuZ2xlIDwgMCl7XG4gICAgICogICAgICAgICAgICAgYW5nbGUgKz0gKDIqTWF0aC5QSSk7XG4gICAgICogICAgICAgICB9XG4gICAgICogICAgICAgICByZXR1cm4gYW5nbGU7XG4gICAgICogICAgIH1cbiAgICAgKi9cbiAgICB0aGlzLmFuZ2xlID0gb3B0aW9ucy5hbmdsZSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIGJvZHksIGluIHJhZGlhbnMgcGVyIHNlY29uZC5cbiAgICAgKiBAcHJvcGVydHkgYW5ndWxhclZlbG9jaXR5XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IG9wdGlvbnMuYW5ndWxhclZlbG9jaXR5IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9yY2UgYWN0aW5nIG9uIHRoZSBib2R5LiBTaW5jZSB0aGUgYm9keSBmb3JjZSAoYW5kIHt7I2Nyb3NzTGluayBcIkJvZHkvYW5ndWxhckZvcmNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319KSB3aWxsIGJlIHplcm9lZCBhZnRlciBlYWNoIHN0ZXAsIHNvIHlvdSBuZWVkIHRvIHNldCB0aGUgZm9yY2UgYmVmb3JlIGVhY2ggc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgZm9yY2VcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBUaGlzIHByb2R1Y2VzIGEgZm9yY2VmaWVsZCBvZiAxIE5ld3RvbiBpbiB0aGUgcG9zaXRpdmUgeCBkaXJlY3Rpb24uXG4gICAgICogICAgIGZvcih2YXIgaT0wOyBpPG51bVN0ZXBzOyBpKyspe1xuICAgICAqICAgICAgICAgYm9keS5mb3JjZVswXSA9IDE7XG4gICAgICogICAgICAgICB3b3JsZC5zdGVwKDEvNjApO1xuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBUaGlzIHdpbGwgYXBwbHkgYSByb3RhdGlvbmFsIGZvcmNlIG9uIHRoZSBib2R5XG4gICAgICogICAgIGZvcih2YXIgaT0wOyBpPG51bVN0ZXBzOyBpKyspe1xuICAgICAqICAgICAgICAgYm9keS5hbmd1bGFyRm9yY2UgPSAtMztcbiAgICAgKiAgICAgICAgIHdvcmxkLnN0ZXAoMS82MCk7XG4gICAgICogICAgIH1cbiAgICAgKi9cbiAgICB0aGlzLmZvcmNlID0gdmVjMi5jcmVhdGUoKTtcbiAgICBpZihvcHRpb25zLmZvcmNlKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMuZm9yY2UsIG9wdGlvbnMuZm9yY2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBhbmd1bGFyIGZvcmNlIGFjdGluZyBvbiB0aGUgYm9keS4gU2VlIHt7I2Nyb3NzTGluayBcIkJvZHkvZm9yY2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IGFuZ3VsYXJGb3JjZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hbmd1bGFyRm9yY2UgPSBvcHRpb25zLmFuZ3VsYXJGb3JjZSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxpbmVhciBkYW1waW5nIGFjdGluZyBvbiB0aGUgYm9keSBpbiB0aGUgdmVsb2NpdHkgZGlyZWN0aW9uLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHByb3BlcnR5IGRhbXBpbmdcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDAuMVxuICAgICAqL1xuICAgIHRoaXMuZGFtcGluZyA9IHR5cGVvZihvcHRpb25zLmRhbXBpbmcpID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5kYW1waW5nIDogMC4xO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFuZ3VsYXIgZm9yY2UgYWN0aW5nIG9uIHRoZSBib2R5LiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHByb3BlcnR5IGFuZ3VsYXJEYW1waW5nXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwLjFcbiAgICAgKi9cbiAgICB0aGlzLmFuZ3VsYXJEYW1waW5nID0gdHlwZW9mKG9wdGlvbnMuYW5ndWxhckRhbXBpbmcpID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5hbmd1bGFyRGFtcGluZyA6IDAuMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIG1vdGlvbiB0aGlzIGJvZHkgaGFzLiBTaG91bGQgYmUgb25lIG9mOiB7eyNjcm9zc0xpbmsgXCJCb2R5L1NUQVRJQzpwcm9wZXJ0eVwifX1Cb2R5LlNUQVRJQ3t7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJCb2R5L0RZTkFNSUM6cHJvcGVydHlcIn19Qm9keS5EWU5BTUlDe3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkJvZHkvS0lORU1BVElDOnByb3BlcnR5XCJ9fUJvZHkuS0lORU1BVElDe3svY3Jvc3NMaW5rfX0uXG4gICAgICpcbiAgICAgKiAqIFN0YXRpYyBib2RpZXMgZG8gbm90IG1vdmUsIGFuZCB0aGV5IGRvIG5vdCByZXNwb25kIHRvIGZvcmNlcyBvciBjb2xsaXNpb24uXG4gICAgICogKiBEeW5hbWljIGJvZGllcyBib2R5IGNhbiBtb3ZlIGFuZCByZXNwb25kIHRvIGNvbGxpc2lvbnMgYW5kIGZvcmNlcy5cbiAgICAgKiAqIEtpbmVtYXRpYyBib2RpZXMgb25seSBtb3ZlcyBhY2NvcmRpbmcgdG8gaXRzIC52ZWxvY2l0eSwgYW5kIGRvZXMgbm90IHJlc3BvbmQgdG8gY29sbGlzaW9ucyBvciBmb3JjZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIEJvZGllcyBhcmUgc3RhdGljIGJ5IGRlZmF1bHQuIFN0YXRpYyBib2RpZXMgd2lsbCBuZXZlciBtb3ZlLlxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KCk7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGJvZHkudHlwZSA9PSBCb2R5LlNUQVRJQyk7IC8vIHRydWVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIEJ5IHNldHRpbmcgdGhlIG1hc3Mgb2YgYSBib2R5IHRvIGEgbm9uemVybyBudW1iZXIsIHRoZSBib2R5XG4gICAgICogICAgIC8vIHdpbGwgYmVjb21lIGR5bmFtaWMgYW5kIHdpbGwgbW92ZSBhbmQgaW50ZXJhY3Qgd2l0aCBvdGhlciBib2RpZXMuXG4gICAgICogICAgIHZhciBkeW5hbWljQm9keSA9IG5ldyBCb2R5KHtcbiAgICAgKiAgICAgICAgIG1hc3MgOiAxXG4gICAgICogICAgIH0pO1xuICAgICAqICAgICBjb25zb2xlLmxvZyhkeW5hbWljQm9keS50eXBlID09IEJvZHkuRFlOQU1JQyk7IC8vIHRydWVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIEtpbmVtYXRpYyBib2RpZXMgd2lsbCBvbmx5IG1vdmUgaWYgeW91IGNoYW5nZSB0aGVpciB2ZWxvY2l0eS5cbiAgICAgKiAgICAgdmFyIGtpbmVtYXRpY0JvZHkgPSBuZXcgQm9keSh7XG4gICAgICogICAgICAgICB0eXBlOiBCb2R5LktJTkVNQVRJQyAvLyBUeXBlIGNhbiBiZSBzZXQgdmlhIHRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiAgICAgfSk7XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gQm9keS5TVEFUSUM7XG5cbiAgICBpZih0eXBlb2Yob3B0aW9ucy50eXBlKSAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgfSBlbHNlIGlmKCFvcHRpb25zLm1hc3Mpe1xuICAgICAgICB0aGlzLnR5cGUgPSBCb2R5LlNUQVRJQztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnR5cGUgPSBCb2R5LkRZTkFNSUM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQm91bmRpbmcgY2lyY2xlIHJhZGl1cy5cbiAgICAgKiBAcHJvcGVydHkgYm91bmRpbmdSYWRpdXNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQm91bmRpbmcgYm94IG9mIHRoaXMgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgYWFiYlxuICAgICAqIEB0eXBlIHtBQUJCfVxuICAgICAqL1xuICAgIHRoaXMuYWFiYiA9IG5ldyBBQUJCKCk7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIEFBQkIgbmVlZHMgdXBkYXRlLiBVcGRhdGUgaXQgd2l0aCB7eyNjcm9zc0xpbmsgXCJCb2R5L3VwZGF0ZUFBQkI6bWV0aG9kXCJ9fS51cGRhdGVBQUJCKCl7ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkgYWFiYk5lZWRzVXBkYXRlXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHNlZSB1cGRhdGVBQUJCXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBGb3JjZSB1cGRhdGUgdGhlIEFBQkJcbiAgICAgKiAgICAgYm9keS5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAqICAgICBib2R5LnVwZGF0ZUFBQkIoKTtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYm9keS5hYWJiTmVlZHNVcGRhdGUpOyAvLyBmYWxzZVxuICAgICAqL1xuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBib2R5IHdpbGwgYXV0b21hdGljYWxseSBmYWxsIHRvIHNsZWVwLiBOb3RlIHRoYXQgeW91IG5lZWQgdG8gZW5hYmxlIHNsZWVwaW5nIGluIHRoZSB7eyNjcm9zc0xpbmsgXCJXb3JsZFwifX17ey9jcm9zc0xpbmt9fSBiZWZvcmUgYW55dGhpbmcgd2lsbCBoYXBwZW4uXG4gICAgICogQHByb3BlcnR5IGFsbG93U2xlZXBcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5hbGxvd1NsZWVwID0gdHJ1ZTtcblxuICAgIHRoaXMud2FudHNUb1NsZWVwID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBPbmUgb2Yge3sjY3Jvc3NMaW5rIFwiQm9keS9BV0FLRTpwcm9wZXJ0eVwifX1Cb2R5LkFXQUtFe3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIkJvZHkvU0xFRVBZOnByb3BlcnR5XCJ9fUJvZHkuU0xFRVBZe3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkJvZHkvU0xFRVBJTkc6cHJvcGVydHlcIn19Qm9keS5TTEVFUElOR3t7L2Nyb3NzTGlua319LlxuICAgICAqXG4gICAgICogVGhlIGJvZHkgaXMgaW5pdGlhbGx5IEJvZHkuQVdBS0UuIElmIGl0cyB2ZWxvY2l0eSBub3JtIGlzIGJlbG93IC5zbGVlcFNwZWVkTGltaXQsIHRoZSBzbGVlcFN0YXRlIHdpbGwgYmVjb21lIEJvZHkuU0xFRVBZLiBJZiB0aGUgYm9keSBjb250aW51ZXMgdG8gYmUgQm9keS5TTEVFUFkgZm9yIC5zbGVlcFRpbWVMaW1pdCBzZWNvbmRzLCBpdCB3aWxsIGZhbGwgYXNsZWVwIChCb2R5LlNMRUVQWSkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc2xlZXBTdGF0ZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgQm9keS5BV0FLRVxuICAgICAqL1xuICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuQVdBS0U7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgc3BlZWQgKHRoZSBub3JtIG9mIHRoZSB2ZWxvY2l0eSkgaXMgc21hbGxlciB0aGFuIHRoaXMgdmFsdWUsIHRoZSBib2R5IGlzIGNvbnNpZGVyZWQgc2xlZXB5LlxuICAgICAqIEBwcm9wZXJ0eSBzbGVlcFNwZWVkTGltaXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDAuMlxuICAgICAqL1xuICAgIHRoaXMuc2xlZXBTcGVlZExpbWl0ID0gMC4yO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGJvZHkgaGFzIGJlZW4gc2xlZXB5IGZvciB0aGlzIHNsZWVwVGltZUxpbWl0IHNlY29uZHMsIGl0IGlzIGNvbnNpZGVyZWQgc2xlZXBpbmcuXG4gICAgICogQHByb3BlcnR5IHNsZWVwVGltZUxpbWl0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5zbGVlcFRpbWVMaW1pdCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBHcmF2aXR5IHNjYWxpbmcgZmFjdG9yLiBJZiB5b3Ugd2FudCB0aGUgYm9keSB0byBpZ25vcmUgZ3Jhdml0eSwgc2V0IHRoaXMgdG8gemVyby4gSWYgeW91IHdhbnQgdG8gcmV2ZXJzZSBncmF2aXR5LCBzZXQgaXQgdG8gLTEuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGdyYXZpdHlTY2FsZVxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cbiAgICB0aGlzLmdyYXZpdHlTY2FsZSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHByb2R1Y2UgY29udGFjdCBmb3JjZXMgd2hlbiBpbiBjb250YWN0IHdpdGggb3RoZXIgYm9kaWVzLiBOb3RlIHRoYXQgY29udGFjdHMgd2lsbCBiZSBnZW5lcmF0ZWQsIGJ1dCB0aGV5IHdpbGwgYmUgZGlzYWJsZWQuIFRoYXQgbWVhbnMgdGhhdCB0aGlzIGJvZHkgd2lsbCBtb3ZlIHRocm91Z2ggb3RoZXIgYm9kaWVzLCBidXQgaXQgd2lsbCBzdGlsbCB0cmlnZ2VyIGNvbnRhY3QgZXZlbnRzLCBldGMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBjb2xsaXNpb25SZXNwb25zZVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogSG93IGxvbmcgdGhlIGJvZHkgaGFzIGJlZW4gc2xlZXBpbmcuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGlkbGVUaW1lXG4gICAgICovXG4gICAgdGhpcy5pZGxlVGltZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCB0aW1lIHdoZW4gdGhlIGJvZHkgd2VudCB0byBTTEVFUFkgc3RhdGUuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHRpbWVMYXN0U2xlZXB5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRpbWVMYXN0U2xlZXB5ID0gMDtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBib2R5IHNwZWVkIGV4Y2VlZHMgdGhpcyB0aHJlc2hvbGQsIENDRCAoY29udGludW91cyBjb2xsaXNpb24gZGV0ZWN0aW9uKSB3aWxsIGJlIGVuYWJsZWQuIFNldCBpdCB0byBhIG5lZ2F0aXZlIG51bWJlciB0byBkaXNhYmxlIENDRCBjb21wbGV0ZWx5IGZvciB0aGlzIGJvZHkuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNjZFNwZWVkVGhyZXNob2xkXG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKi9cbiAgICB0aGlzLmNjZFNwZWVkVGhyZXNob2xkID0gb3B0aW9ucy5jY2RTcGVlZFRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jY2RTcGVlZFRocmVzaG9sZCA6IC0xO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRoYXQgc2hvdWxkIGJlIHVzZWQgd2hlbiBzZWFyY2hpbmcgZm9yIHRoZSB0aW1lIG9mIGltcGFjdCBkdXJpbmcgQ0NELiBBIGxhcmdlciBudW1iZXIgd2lsbCBhc3N1cmUgdGhhdCB0aGVyZSdzIGEgc21hbGwgcGVuZXRyYXRpb24gb24gQ0NEIGNvbGxpc2lvbiwgYnV0IGEgc21hbGwgbnVtYmVyIHdpbGwgZ2l2ZSBtb3JlIHBlcmZvcm1hbmNlLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjY2RJdGVyYXRpb25zXG4gICAgICogQGRlZmF1bHQgMTBcbiAgICAgKi9cbiAgICB0aGlzLmNjZEl0ZXJhdGlvbnMgPSBvcHRpb25zLmNjZEl0ZXJhdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2NkSXRlcmF0aW9ucyA6IDEwO1xuXG4gICAgdGhpcy5jb25jYXZlUGF0aCA9IG51bGw7XG5cbiAgICB0aGlzLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7XG5cbiAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG59XG5Cb2R5LnByb3RvdHlwZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbkJvZHkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm9keTtcblxuQm9keS5faWRDb3VudGVyID0gMDtcblxuQm9keS5wcm90b3R5cGUudXBkYXRlU29sdmVNYXNzUHJvcGVydGllcyA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HIHx8IHRoaXMudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpe1xuICAgICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IDA7XG4gICAgICAgIHRoaXMuaW52SW5lcnRpYVNvbHZlID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IHRoaXMuaW52TWFzcztcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSB0aGlzLmludkluZXJ0aWE7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXQgdGhlIHRvdGFsIGRlbnNpdHkgb2YgdGhlIGJvZHlcbiAqIEBtZXRob2Qgc2V0RGVuc2l0eVxuICovXG5Cb2R5LnByb3RvdHlwZS5zZXREZW5zaXR5ID0gZnVuY3Rpb24oZGVuc2l0eSkge1xuICAgIHZhciB0b3RhbEFyZWEgPSB0aGlzLmdldEFyZWEoKTtcbiAgICB0aGlzLm1hc3MgPSB0b3RhbEFyZWEgKiBkZW5zaXR5O1xuICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB0b3RhbCBhcmVhIG9mIGFsbCBzaGFwZXMgaW4gdGhlIGJvZHlcbiAqIEBtZXRob2QgZ2V0QXJlYVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Cb2R5LnByb3RvdHlwZS5nZXRBcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRvdGFsQXJlYSA9IDA7XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5zaGFwZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB0b3RhbEFyZWEgKz0gdGhpcy5zaGFwZXNbaV0uYXJlYTtcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsQXJlYTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBBQUJCIGZyb20gdGhlIGJvZHkuIFRoZSBBQUJCIGlzIHVwZGF0ZWQgaWYgbmVjZXNzYXJ5LlxuICogQG1ldGhvZCBnZXRBQUJCXG4gKi9cbkJvZHkucHJvdG90eXBlLmdldEFBQkIgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMuYWFiYk5lZWRzVXBkYXRlKXtcbiAgICAgICAgdGhpcy51cGRhdGVBQUJCKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFhYmI7XG59O1xuXG52YXIgc2hhcGVBQUJCID0gbmV3IEFBQkIoKSxcbiAgICB0bXAgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIEFBQkIgb2YgdGhlIEJvZHlcbiAqIEBtZXRob2QgdXBkYXRlQUFCQlxuICovXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVBQUJCID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNoYXBlcyA9IHRoaXMuc2hhcGVzLFxuICAgICAgICBzaGFwZU9mZnNldHMgPSB0aGlzLnNoYXBlT2Zmc2V0cyxcbiAgICAgICAgc2hhcGVBbmdsZXMgPSB0aGlzLnNoYXBlQW5nbGVzLFxuICAgICAgICBOID0gc2hhcGVzLmxlbmd0aCxcbiAgICAgICAgb2Zmc2V0ID0gdG1wLFxuICAgICAgICBib2R5QW5nbGUgPSB0aGlzLmFuZ2xlO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV0sXG4gICAgICAgICAgICBhbmdsZSA9IHNoYXBlQW5nbGVzW2ldICsgYm9keUFuZ2xlO1xuXG4gICAgICAgIC8vIEdldCBzaGFwZSB3b3JsZCBvZmZzZXRcbiAgICAgICAgdmVjMi5yb3RhdGUob2Zmc2V0LCBzaGFwZU9mZnNldHNbaV0sIGJvZHlBbmdsZSk7XG4gICAgICAgIHZlYzIuYWRkKG9mZnNldCwgb2Zmc2V0LCB0aGlzLnBvc2l0aW9uKTtcblxuICAgICAgICAvLyBHZXQgc2hhcGUgQUFCQlxuICAgICAgICBzaGFwZS5jb21wdXRlQUFCQihzaGFwZUFBQkIsIG9mZnNldCwgYW5nbGUpO1xuXG4gICAgICAgIGlmKGk9PT0wKXtcbiAgICAgICAgICAgIHRoaXMuYWFiYi5jb3B5KHNoYXBlQUFCQik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFhYmIuZXh0ZW5kKHNoYXBlQUFCQik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0aGUgYm9keS4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBzaGFwZXNcbiAqIGFyZSBjaGFuZ2VkLlxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICovXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHNoYXBlcyA9IHRoaXMuc2hhcGVzLFxuICAgICAgICBzaGFwZU9mZnNldHMgPSB0aGlzLnNoYXBlT2Zmc2V0cyxcbiAgICAgICAgTiA9IHNoYXBlcy5sZW5ndGgsXG4gICAgICAgIHJhZGl1cyA9IDA7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tpXSxcbiAgICAgICAgICAgIG9mZnNldCA9IHZlYzIubGVuZ3RoKHNoYXBlT2Zmc2V0c1tpXSksXG4gICAgICAgICAgICByID0gc2hhcGUuYm91bmRpbmdSYWRpdXM7XG4gICAgICAgIGlmKG9mZnNldCArIHIgPiByYWRpdXMpe1xuICAgICAgICAgICAgcmFkaXVzID0gb2Zmc2V0ICsgcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSByYWRpdXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIHNoYXBlIHRvIHRoZSBib2R5LiBZb3UgY2FuIHBhc3MgYSBsb2NhbCB0cmFuc2Zvcm0gd2hlbiBhZGRpbmcgYSBzaGFwZSxcbiAqIHNvIHRoYXQgdGhlIHNoYXBlIGdldHMgYW4gb2Zmc2V0IGFuZCBhbmdsZSByZWxhdGl2ZSB0byB0aGUgYm9keSBjZW50ZXIgb2YgbWFzcy5cbiAqIFdpbGwgYXV0b21hdGljYWxseSB1cGRhdGUgdGhlIG1hc3MgcHJvcGVydGllcyBhbmQgYm91bmRpbmcgcmFkaXVzLlxuICpcbiAqIEBtZXRob2QgYWRkU2hhcGVcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgICAgICAgICAgc2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBbb2Zmc2V0XSBMb2NhbCBib2R5IG9mZnNldCBvZiB0aGUgc2hhcGUuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICAgICAgIFthbmdsZV0gIExvY2FsIGJvZHkgYW5nbGUuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KCksXG4gKiAgICAgICAgIHNoYXBlID0gbmV3IENpcmNsZSgpO1xuICpcbiAqICAgICAvLyBBZGQgdGhlIHNoYXBlIHRvIHRoZSBib2R5LCBwb3NpdGlvbmVkIGluIHRoZSBjZW50ZXJcbiAqICAgICBib2R5LmFkZFNoYXBlKHNoYXBlKTtcbiAqXG4gKiAgICAgLy8gQWRkIGFub3RoZXIgc2hhcGUgdG8gdGhlIGJvZHksIHBvc2l0aW9uZWQgMSB1bml0IGxlbmd0aCBmcm9tIHRoZSBib2R5IGNlbnRlciBvZiBtYXNzIGFsb25nIHRoZSBsb2NhbCB4LWF4aXMuXG4gKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSxbMSwwXSk7XG4gKlxuICogICAgIC8vIEFkZCBhbm90aGVyIHNoYXBlIHRvIHRoZSBib2R5LCBwb3NpdGlvbmVkIDEgdW5pdCBsZW5ndGggZnJvbSB0aGUgYm9keSBjZW50ZXIgb2YgbWFzcyBhbG9uZyB0aGUgbG9jYWwgeS1heGlzLCBhbmQgcm90YXRlZCA5MCBkZWdyZWVzIENDVy5cbiAqICAgICBib2R5LmFkZFNoYXBlKHNoYXBlLFswLDFdLE1hdGguUEkvMik7XG4gKi9cbkJvZHkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24oc2hhcGUsb2Zmc2V0LGFuZ2xlKXtcbiAgICBhbmdsZSA9IGFuZ2xlIHx8IDAuMDtcblxuICAgIC8vIENvcHkgdGhlIG9mZnNldCB2ZWN0b3JcbiAgICBpZihvZmZzZXQpe1xuICAgICAgICBvZmZzZXQgPSB2ZWMyLmZyb21WYWx1ZXMob2Zmc2V0WzBdLG9mZnNldFsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG4gICAgfVxuXG4gICAgdGhpcy5zaGFwZXMgICAgICAucHVzaChzaGFwZSk7XG4gICAgdGhpcy5zaGFwZU9mZnNldHMucHVzaChvZmZzZXQpO1xuICAgIHRoaXMuc2hhcGVBbmdsZXMgLnB1c2goYW5nbGUpO1xuICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XG5cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHNoYXBlXG4gKiBAbWV0aG9kIHJlbW92ZVNoYXBlXG4gKiBAcGFyYW0gIHtTaGFwZX0gIHNoYXBlXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICBUcnVlIGlmIHRoZSBzaGFwZSB3YXMgZm91bmQgYW5kIHJlbW92ZWQsIGVsc2UgZmFsc2UuXG4gKi9cbkJvZHkucHJvdG90eXBlLnJlbW92ZVNoYXBlID0gZnVuY3Rpb24oc2hhcGUpe1xuICAgIHZhciBpZHggPSB0aGlzLnNoYXBlcy5pbmRleE9mKHNoYXBlKTtcblxuICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICB0aGlzLnNoYXBlcy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB0aGlzLnNoYXBlT2Zmc2V0cy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB0aGlzLnNoYXBlQW5nbGVzLnNwbGljZShpZHgsMSk7XG4gICAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbi8qKlxuICogVXBkYXRlcyAuaW5lcnRpYSwgLmludk1hc3MsIC5pbnZJbmVydGlhIGZvciB0aGlzIEJvZHkuIFNob3VsZCBiZSBjYWxsZWQgd2hlblxuICogY2hhbmdpbmcgdGhlIHN0cnVjdHVyZSBvciBtYXNzIG9mIHRoZSBCb2R5LlxuICpcbiAqIEBtZXRob2QgdXBkYXRlTWFzc1Byb3BlcnRpZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIGJvZHkubWFzcyArPSAxO1xuICogICAgIGJvZHkudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbiAqL1xuQm9keS5wcm90b3R5cGUudXBkYXRlTWFzc1Byb3BlcnRpZXMgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMudHlwZSA9PT0gQm9keS5TVEFUSUMgfHwgdGhpcy50eXBlID09PSBCb2R5LktJTkVNQVRJQyl7XG5cbiAgICAgICAgdGhpcy5tYXNzID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdGhpcy5pbnZNYXNzID0gMDtcbiAgICAgICAgdGhpcy5pbmVydGlhID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhID0gMDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdmFyIHNoYXBlcyA9IHRoaXMuc2hhcGVzLFxuICAgICAgICAgICAgTiA9IHNoYXBlcy5sZW5ndGgsXG4gICAgICAgICAgICBtID0gdGhpcy5tYXNzIC8gTixcbiAgICAgICAgICAgIEkgPSAwO1xuXG4gICAgICAgIGlmKCF0aGlzLmZpeGVkUm90YXRpb24pe1xuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8TjsgaSsrKXtcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgIHIyID0gdmVjMi5zcXVhcmVkTGVuZ3RoKHRoaXMuc2hhcGVPZmZzZXRzW2ldKSxcbiAgICAgICAgICAgICAgICAgICAgSWNtID0gc2hhcGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYShtKTtcbiAgICAgICAgICAgICAgICBJICs9IEljbSArIG0qcjI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluZXJ0aWEgPSBJO1xuICAgICAgICAgICAgdGhpcy5pbnZJbmVydGlhID0gST4wID8gMS9JIDogMDtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbmVydGlhID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIHRoaXMuaW52SW5lcnRpYSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnZlcnNlIG1hc3MgcHJvcGVydGllcyBhcmUgZWFzeVxuICAgICAgICB0aGlzLmludk1hc3MgPSAxL3RoaXMubWFzczsvLyA+IDAgPyAxL3RoaXMubWFzcyA6IDA7XG4gICAgfVxufTtcblxudmFyIEJvZHlfYXBwbHlGb3JjZV9yID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBBcHBseSBmb3JjZSB0byBhIHdvcmxkIHBvaW50LiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIGEgcG9pbnQgb24gdGhlIFJpZ2lkQm9keSBzdXJmYWNlLiBBcHBseWluZyBmb3JjZSB0aGlzIHdheSB3aWxsIGFkZCB0byBCb2R5LmZvcmNlIGFuZCBCb2R5LmFuZ3VsYXJGb3JjZS5cbiAqIEBtZXRob2QgYXBwbHlGb3JjZVxuICogQHBhcmFtIHtBcnJheX0gZm9yY2UgVGhlIGZvcmNlIHRvIGFkZC5cbiAqIEBwYXJhbSB7QXJyYXl9IHdvcmxkUG9pbnQgQSB3b3JsZCBwb2ludCB0byBhcHBseSB0aGUgZm9yY2Ugb24uXG4gKi9cbkJvZHkucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbihmb3JjZSx3b3JsZFBvaW50KXtcbiAgICAvLyBDb21wdXRlIHBvaW50IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBib2R5IGNlbnRlclxuICAgIHZhciByID0gQm9keV9hcHBseUZvcmNlX3I7XG4gICAgdmVjMi5zdWIocix3b3JsZFBvaW50LHRoaXMucG9zaXRpb24pO1xuXG4gICAgLy8gQWRkIGxpbmVhciBmb3JjZVxuICAgIHZlYzIuYWRkKHRoaXMuZm9yY2UsdGhpcy5mb3JjZSxmb3JjZSk7XG5cbiAgICAvLyBDb21wdXRlIHByb2R1Y2VkIHJvdGF0aW9uYWwgZm9yY2VcbiAgICB2YXIgcm90Rm9yY2UgPSB2ZWMyLmNyb3NzTGVuZ3RoKHIsZm9yY2UpO1xuXG4gICAgLy8gQWRkIHJvdGF0aW9uYWwgZm9yY2VcbiAgICB0aGlzLmFuZ3VsYXJGb3JjZSArPSByb3RGb3JjZTtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgd29ybGQgcG9pbnQgdG8gbG9jYWwgYm9keSBmcmFtZS5cbiAqIEBtZXRob2QgdG9Mb2NhbEZyYW1lXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0ICAgICAgICAgIFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpblxuICogQHBhcmFtICB7QXJyYXl9IHdvcmxkUG9pbnQgICBUaGUgaW5wdXQgd29ybGQgdmVjdG9yXG4gKi9cbkJvZHkucHJvdG90eXBlLnRvTG9jYWxGcmFtZSA9IGZ1bmN0aW9uKG91dCwgd29ybGRQb2ludCl7XG4gICAgdmVjMi50b0xvY2FsRnJhbWUob3V0LCB3b3JsZFBvaW50LCB0aGlzLnBvc2l0aW9uLCB0aGlzLmFuZ2xlKTtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgbG9jYWwgcG9pbnQgdG8gd29ybGQgZnJhbWUuXG4gKiBAbWV0aG9kIHRvV29ybGRGcmFtZVxuICogQHBhcmFtICB7QXJyYXl9IG91dCAgICAgICAgICBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW5cbiAqIEBwYXJhbSAge0FycmF5fSBsb2NhbFBvaW50ICAgVGhlIGlucHV0IGxvY2FsIHZlY3RvclxuICovXG5Cb2R5LnByb3RvdHlwZS50b1dvcmxkRnJhbWUgPSBmdW5jdGlvbihvdXQsIGxvY2FsUG9pbnQpe1xuICAgIHZlYzIudG9HbG9iYWxGcmFtZShvdXQsIGxvY2FsUG9pbnQsIHRoaXMucG9zaXRpb24sIHRoaXMuYW5nbGUpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHBvbHlnb24gc2hhcGUgcGF0aCwgYW5kIGFzc2VtYmxlcyBjb252ZXggc2hhcGVzIGZyb20gdGhhdCBhbmQgcHV0cyB0aGVtIGF0IHByb3BlciBvZmZzZXQgcG9pbnRzLlxuICogQG1ldGhvZCBmcm9tUG9seWdvblxuICogQHBhcmFtIHtBcnJheX0gcGF0aCBBbiBhcnJheSBvZiAyZCB2ZWN0b3JzLCBlLmcuIFtbMCwwXSxbMCwxXSwuLi5dIHRoYXQgcmVzZW1ibGVzIGEgY29uY2F2ZSBvciBjb252ZXggcG9seWdvbi4gVGhlIHNoYXBlIG11c3QgYmUgc2ltcGxlIGFuZCB3aXRob3V0IGhvbGVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vcHRpbWFsRGVjb21wPWZhbHNlXSAgIFNldCB0byB0cnVlIGlmIHlvdSBuZWVkIG9wdGltYWwgZGVjb21wb3NpdGlvbi4gV2FybmluZzogdmVyeSBzbG93IGZvciBwb2x5Z29ucyB3aXRoIG1vcmUgdGhhbiAxMCB2ZXJ0aWNlcy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFNpbXBsZUNoZWNrPWZhbHNlXSBTZXQgdG8gdHJ1ZSBpZiB5b3UgYWxyZWFkeSBrbm93IHRoYXQgdGhlIHBhdGggaXMgbm90IGludGVyc2VjdGluZyBpdHNlbGYuXG4gKiBAcGFyYW0ge0Jvb2xlYW58TnVtYmVyfSBbb3B0aW9ucy5yZW1vdmVDb2xsaW5lYXJQb2ludHM9ZmFsc2VdIFNldCB0byBhIG51bWJlciAoYW5nbGUgdGhyZXNob2xkIHZhbHVlKSB0byByZW1vdmUgY29sbGluZWFyIHBvaW50cywgb3IgZmFsc2UgdG8ga2VlcCBhbGwgcG9pbnRzLlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLCBlbHNlIGZhbHNlLlxuICovXG5Cb2R5LnByb3RvdHlwZS5mcm9tUG9seWdvbiA9IGZ1bmN0aW9uKHBhdGgsb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBSZW1vdmUgYWxsIHNoYXBlc1xuICAgIGZvcih2YXIgaT10aGlzLnNoYXBlcy5sZW5ndGg7IGk+PTA7IC0taSl7XG4gICAgICAgIHRoaXMucmVtb3ZlU2hhcGUodGhpcy5zaGFwZXNbaV0pO1xuICAgIH1cblxuICAgIHZhciBwID0gbmV3IGRlY29tcC5Qb2x5Z29uKCk7XG4gICAgcC52ZXJ0aWNlcyA9IHBhdGg7XG5cbiAgICAvLyBNYWtlIGl0IGNvdW50ZXItY2xvY2t3aXNlXG4gICAgcC5tYWtlQ0NXKCk7XG5cbiAgICBpZih0eXBlb2Yob3B0aW9ucy5yZW1vdmVDb2xsaW5lYXJQb2ludHMpID09PSBcIm51bWJlclwiKXtcbiAgICAgICAgcC5yZW1vdmVDb2xsaW5lYXJQb2ludHMob3B0aW9ucy5yZW1vdmVDb2xsaW5lYXJQb2ludHMpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFueSBsaW5lIHNlZ21lbnQgaW50ZXJzZWN0cyB0aGUgcGF0aCBpdHNlbGZcbiAgICBpZih0eXBlb2Yob3B0aW9ucy5za2lwU2ltcGxlQ2hlY2spID09PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgaWYoIXAuaXNTaW1wbGUoKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTYXZlIHRoaXMgcGF0aCBmb3IgbGF0ZXJcbiAgICB0aGlzLmNvbmNhdmVQYXRoID0gcC52ZXJ0aWNlcy5zbGljZSgwKTtcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLmNvbmNhdmVQYXRoLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSBbMCwwXTtcbiAgICAgICAgdmVjMi5jb3B5KHYsdGhpcy5jb25jYXZlUGF0aFtpXSk7XG4gICAgICAgIHRoaXMuY29uY2F2ZVBhdGhbaV0gPSB2O1xuICAgIH1cblxuICAgIC8vIFNsb3cgb3IgZmFzdCBkZWNvbXA/XG4gICAgdmFyIGNvbnZleGVzO1xuICAgIGlmKG9wdGlvbnMub3B0aW1hbERlY29tcCl7XG4gICAgICAgIGNvbnZleGVzID0gcC5kZWNvbXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb252ZXhlcyA9IHAucXVpY2tEZWNvbXAoKTtcbiAgICB9XG5cbiAgICB2YXIgY20gPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLy8gQWRkIGNvbnZleGVzXG4gICAgZm9yKHZhciBpPTA7IGkhPT1jb252ZXhlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIC8vIENyZWF0ZSBjb252ZXhcbiAgICAgICAgdmFyIGMgPSBuZXcgQ29udmV4KGNvbnZleGVzW2ldLnZlcnRpY2VzKTtcblxuICAgICAgICAvLyBNb3ZlIGFsbCB2ZXJ0aWNlcyBzbyBpdHMgY2VudGVyIG9mIG1hc3MgaXMgaW4gdGhlIGxvY2FsIGNlbnRlciBvZiB0aGUgY29udmV4XG4gICAgICAgIGZvcih2YXIgaj0wOyBqIT09Yy52ZXJ0aWNlcy5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICB2YXIgdiA9IGMudmVydGljZXNbal07XG4gICAgICAgICAgICB2ZWMyLnN1Yih2LHYsYy5jZW50ZXJPZk1hc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmVjMi5zY2FsZShjbSxjLmNlbnRlck9mTWFzcywxKTtcbiAgICAgICAgYy51cGRhdGVUcmlhbmdsZXMoKTtcbiAgICAgICAgYy51cGRhdGVDZW50ZXJPZk1hc3MoKTtcbiAgICAgICAgYy51cGRhdGVCb3VuZGluZ1JhZGl1cygpO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgc2hhcGVcbiAgICAgICAgdGhpcy5hZGRTaGFwZShjLGNtKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkanVzdENlbnRlck9mTWFzcygpO1xuXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMiA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgIGFkanVzdENlbnRlck9mTWFzc190bXAzID0gdmVjMi5mcm9tVmFsdWVzKDAsMCksXG4gICAgYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDQgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuLyoqXG4gKiBNb3ZlcyB0aGUgc2hhcGUgb2Zmc2V0cyBzbyB0aGVpciBjZW50ZXIgb2YgbWFzcyBiZWNvbWVzIHRoZSBib2R5IGNlbnRlciBvZiBtYXNzLlxuICogQG1ldGhvZCBhZGp1c3RDZW50ZXJPZk1hc3NcbiAqL1xuQm9keS5wcm90b3R5cGUuYWRqdXN0Q2VudGVyT2ZNYXNzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgb2Zmc2V0X3RpbWVzX2FyZWEgPSBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMixcbiAgICAgICAgc3VtID0gICAgICAgICAgICAgICBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMyxcbiAgICAgICAgY20gPSAgICAgICAgICAgICAgICBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wNCxcbiAgICAgICAgdG90YWxBcmVhID0gICAgICAgICAwO1xuICAgIHZlYzIuc2V0KHN1bSwwLDApO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT10aGlzLnNoYXBlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBzID0gdGhpcy5zaGFwZXNbaV0sXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNoYXBlT2Zmc2V0c1tpXTtcbiAgICAgICAgdmVjMi5zY2FsZShvZmZzZXRfdGltZXNfYXJlYSxvZmZzZXQscy5hcmVhKTtcbiAgICAgICAgdmVjMi5hZGQoc3VtLHN1bSxvZmZzZXRfdGltZXNfYXJlYSk7XG4gICAgICAgIHRvdGFsQXJlYSArPSBzLmFyZWE7XG4gICAgfVxuXG4gICAgdmVjMi5zY2FsZShjbSxzdW0sMS90b3RhbEFyZWEpO1xuXG4gICAgLy8gTm93IG1vdmUgYWxsIHNoYXBlc1xuICAgIGZvcih2YXIgaT0wOyBpIT09dGhpcy5zaGFwZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgcyA9IHRoaXMuc2hhcGVzW2ldLFxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5zaGFwZU9mZnNldHNbaV07XG5cbiAgICAgICAgLy8gT2Zmc2V0IG1heSBiZSB1bmRlZmluZWQuIEZpeCB0aGF0LlxuICAgICAgICBpZighb2Zmc2V0KXtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuc2hhcGVPZmZzZXRzW2ldID0gdmVjMi5jcmVhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZlYzIuc3ViKG9mZnNldCxvZmZzZXQsY20pO1xuICAgIH1cblxuICAgIC8vIE1vdmUgdGhlIGJvZHkgcG9zaXRpb24gdG9vXG4gICAgdmVjMi5hZGQodGhpcy5wb3NpdGlvbix0aGlzLnBvc2l0aW9uLGNtKTtcblxuICAgIC8vIEFuZCBjb25jYXZlIHBhdGhcbiAgICBmb3IodmFyIGk9MDsgdGhpcy5jb25jYXZlUGF0aCAmJiBpPHRoaXMuY29uY2F2ZVBhdGgubGVuZ3RoOyBpKyspe1xuICAgICAgICB2ZWMyLnN1Yih0aGlzLmNvbmNhdmVQYXRoW2ldLCB0aGlzLmNvbmNhdmVQYXRoW2ldLCBjbSk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgZm9yY2Ugb24gdGhlIGJvZHkgdG8gemVyby5cbiAqIEBtZXRob2Qgc2V0WmVyb0ZvcmNlXG4gKi9cbkJvZHkucHJvdG90eXBlLnNldFplcm9Gb3JjZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmVjMi5zZXQodGhpcy5mb3JjZSwwLjAsMC4wKTtcbiAgICB0aGlzLmFuZ3VsYXJGb3JjZSA9IDAuMDtcbn07XG5cbkJvZHkucHJvdG90eXBlLnJlc2V0Q29uc3RyYWludFZlbG9jaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgIHZsYW1iZGEgPSBiLnZsYW1iZGE7XG4gICAgdmVjMi5zZXQodmxhbWJkYSwwLDApO1xuICAgIGIud2xhbWJkYSA9IDA7XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5hZGRDb25zdHJhaW50VmVsb2NpdHkgPSBmdW5jdGlvbigpe1xuICAgIHZhciBiID0gdGhpcyxcbiAgICAgICAgdiA9IGIudmVsb2NpdHk7XG4gICAgdmVjMi5hZGQoIHYsIHYsIGIudmxhbWJkYSk7XG4gICAgYi5hbmd1bGFyVmVsb2NpdHkgKz0gYi53bGFtYmRhO1xufTtcblxuLyoqXG4gKiBBcHBseSBkYW1waW5nLCBzZWUgPGEgaHJlZj1cImh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9idWxsZXQvaXNzdWVzL2RldGFpbD9pZD03NFwiPnRoaXM8L2E+IGZvciBkZXRhaWxzLlxuICogQG1ldGhvZCBhcHBseURhbXBpbmdcbiAqIEBwYXJhbSAge251bWJlcn0gZHQgQ3VycmVudCB0aW1lIHN0ZXBcbiAqL1xuQm9keS5wcm90b3R5cGUuYXBwbHlEYW1waW5nID0gZnVuY3Rpb24oZHQpe1xuICAgIGlmKHRoaXMudHlwZSA9PT0gQm9keS5EWU5BTUlDKXsgLy8gT25seSBmb3IgZHluYW1pYyBib2RpZXNcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZlbG9jaXR5O1xuICAgICAgICB2ZWMyLnNjYWxlKHYsIHYsIE1hdGgucG93KDEuMCAtIHRoaXMuZGFtcGluZyxkdCkpO1xuICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSAqPSBNYXRoLnBvdygxLjAgLSB0aGlzLmFuZ3VsYXJEYW1waW5nLGR0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFdha2UgdGhlIGJvZHkgdXAuIE5vcm1hbGx5IHlvdSBzaG91bGQgbm90IG5lZWQgdGhpcywgYXMgdGhlIGJvZHkgaXMgYXV0b21hdGljYWxseSBhd29rZW4gYXQgZXZlbnRzIHN1Y2ggYXMgY29sbGlzaW9ucy5cbiAqIFNldHMgdGhlIHNsZWVwU3RhdGUgdG8ge3sjY3Jvc3NMaW5rIFwiQm9keS9BV0FLRTpwcm9wZXJ0eVwifX1Cb2R5LkFXQUtFe3svY3Jvc3NMaW5rfX0gYW5kIGVtaXRzIHRoZSB3YWtlVXAgZXZlbnQgaWYgdGhlIGJvZHkgd2Fzbid0IGF3YWtlIGJlZm9yZS5cbiAqIEBtZXRob2Qgd2FrZVVwXG4gKi9cbkJvZHkucHJvdG90eXBlLndha2VVcCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHMgPSB0aGlzLnNsZWVwU3RhdGU7XG4gICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5BV0FLRTtcbiAgICB0aGlzLmlkbGVUaW1lID0gMDtcbiAgICBpZihzICE9PSBCb2R5LkFXQUtFKXtcbiAgICAgICAgdGhpcy5lbWl0KEJvZHkud2FrZVVwRXZlbnQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRm9yY2UgYm9keSBzbGVlcFxuICogQG1ldGhvZCBzbGVlcFxuICovXG5Cb2R5LnByb3RvdHlwZS5zbGVlcCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUElORztcbiAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IDA7XG4gICAgdGhpcy5hbmd1bGFyRm9yY2UgPSAwO1xuICAgIHZlYzIuc2V0KHRoaXMudmVsb2NpdHksMCwwKTtcbiAgICB2ZWMyLnNldCh0aGlzLmZvcmNlLDAsMCk7XG4gICAgdGhpcy5lbWl0KEJvZHkuc2xlZXBFdmVudCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBldmVyeSB0aW1lc3RlcCB0byB1cGRhdGUgaW50ZXJuYWwgc2xlZXAgdGltZXIgYW5kIGNoYW5nZSBzbGVlcCBzdGF0ZSBpZiBuZWVkZWQuXG4gKiBAbWV0aG9kIHNsZWVwVGlja1xuICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgVGhlIHdvcmxkIHRpbWUgaW4gc2Vjb25kc1xuICogQHBhcmFtIHtib29sZWFufSBkb250U2xlZXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdFxuICovXG5Cb2R5LnByb3RvdHlwZS5zbGVlcFRpY2sgPSBmdW5jdGlvbih0aW1lLCBkb250U2xlZXAsIGR0KXtcbiAgICBpZighdGhpcy5hbGxvd1NsZWVwIHx8IHRoaXMudHlwZSA9PT0gQm9keS5TTEVFUElORyl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLndhbnRzVG9TbGVlcCA9IGZhbHNlO1xuXG4gICAgdmFyIHNsZWVwU3RhdGUgPSB0aGlzLnNsZWVwU3RhdGUsXG4gICAgICAgIHNwZWVkU3F1YXJlZCA9IHZlYzIuc3F1YXJlZExlbmd0aCh0aGlzLnZlbG9jaXR5KSArIE1hdGgucG93KHRoaXMuYW5ndWxhclZlbG9jaXR5LDIpLFxuICAgICAgICBzcGVlZExpbWl0U3F1YXJlZCA9IE1hdGgucG93KHRoaXMuc2xlZXBTcGVlZExpbWl0LDIpO1xuXG4gICAgLy8gQWRkIHRvIGlkbGUgdGltZVxuICAgIGlmKHNwZWVkU3F1YXJlZCA+PSBzcGVlZExpbWl0U3F1YXJlZCl7XG4gICAgICAgIHRoaXMuaWRsZVRpbWUgPSAwO1xuICAgICAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LkFXQUtFO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaWRsZVRpbWUgKz0gZHQ7XG4gICAgICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuU0xFRVBZO1xuICAgIH1cbiAgICBpZih0aGlzLmlkbGVUaW1lID4gdGhpcy5zbGVlcFRpbWVMaW1pdCl7XG4gICAgICAgIGlmKCFkb250U2xlZXApe1xuICAgICAgICAgICAgdGhpcy5zbGVlcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53YW50c1RvU2xlZXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICBpZihzbGVlcFN0YXRlPT09Qm9keS5BV0FLRSAmJiBzcGVlZFNxdWFyZWQgPCBzcGVlZExpbWl0U3F1YXJlZCl7XG4gICAgICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuU0xFRVBZOyAvLyBTbGVlcHlcbiAgICAgICAgdGhpcy50aW1lTGFzdFNsZWVweSA9IHRpbWU7XG4gICAgICAgIHRoaXMuZW1pdChCb2R5LnNsZWVweUV2ZW50KTtcbiAgICB9IGVsc2UgaWYoc2xlZXBTdGF0ZT09PUJvZHkuU0xFRVBZICYmIHNwZWVkU3F1YXJlZCA+PSBzcGVlZExpbWl0U3F1YXJlZCl7XG4gICAgICAgIHRoaXMud2FrZVVwKCk7IC8vIFdha2UgdXBcbiAgICB9IGVsc2UgaWYoc2xlZXBTdGF0ZT09PUJvZHkuU0xFRVBZICYmICh0aW1lIC0gdGhpcy50aW1lTGFzdFNsZWVweSApID4gdGhpcy5zbGVlcFRpbWVMaW1pdCl7XG4gICAgICAgIHRoaXMud2FudHNUb1NsZWVwID0gdHJ1ZTtcbiAgICAgICAgaWYoIWRvbnRTbGVlcCl7XG4gICAgICAgICAgICB0aGlzLnNsZWVwKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKi9cbn07XG5cbkJvZHkucHJvdG90eXBlLmdldFZlbG9jaXR5RnJvbVBvc2l0aW9uID0gZnVuY3Rpb24oc3RvcmUsIHRpbWVTdGVwKXtcbiAgICBzdG9yZSA9IHN0b3JlIHx8IHZlYzIuY3JlYXRlKCk7XG4gICAgdmVjMi5zdWIoc3RvcmUsIHRoaXMucG9zaXRpb24sIHRoaXMucHJldmlvdXNQb3NpdGlvbik7XG4gICAgdmVjMi5zY2FsZShzdG9yZSwgc3RvcmUsIDEvdGltZVN0ZXApO1xuICAgIHJldHVybiBzdG9yZTtcbn07XG5cbkJvZHkucHJvdG90eXBlLmdldEFuZ3VsYXJWZWxvY2l0eUZyb21Qb3NpdGlvbiA9IGZ1bmN0aW9uKHRpbWVTdGVwKXtcbiAgICByZXR1cm4gKHRoaXMuYW5nbGUgLSB0aGlzLnByZXZpb3VzQW5nbGUpIC8gdGltZVN0ZXA7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBib2R5IGlzIG92ZXJsYXBwaW5nIGFub3RoZXIgYm9keS4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIG9ubHkgd29ya3MgaWYgdGhlIGJvZHkgd2FzIGFkZGVkIHRvIGEgV29ybGQgYW5kIGlmIGF0IGxlYXN0IG9uZSBzdGVwIHdhcyB0YWtlbi5cbiAqIEBtZXRob2Qgb3ZlcmxhcHNcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkJvZHkucHJvdG90eXBlLm92ZXJsYXBzID0gZnVuY3Rpb24oYm9keSl7XG4gICAgcmV0dXJuIHRoaXMud29ybGQub3ZlcmxhcEtlZXBlci5ib2RpZXNBcmVPdmVybGFwcGluZyh0aGlzLCBib2R5KTtcbn07XG5cbnZhciBpbnRlZ3JhdGVfZmhNaW52ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlZ3JhdGVfdmVsb2R0ID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBNb3ZlIHRoZSBib2R5IGZvcndhcmQgaW4gdGltZSBnaXZlbiBpdHMgY3VycmVudCB2ZWxvY2l0eS5cbiAqIEBtZXRob2QgaW50ZWdyYXRlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGR0XG4gKi9cbkJvZHkucHJvdG90eXBlLmludGVncmF0ZSA9IGZ1bmN0aW9uKGR0KXtcbiAgICB2YXIgbWludiA9IHRoaXMuaW52TWFzcyxcbiAgICAgICAgZiA9IHRoaXMuZm9yY2UsXG4gICAgICAgIHBvcyA9IHRoaXMucG9zaXRpb24sXG4gICAgICAgIHZlbG8gPSB0aGlzLnZlbG9jaXR5O1xuXG4gICAgLy8gU2F2ZSBvbGQgcG9zaXRpb25cbiAgICB2ZWMyLmNvcHkodGhpcy5wcmV2aW91c1Bvc2l0aW9uLCB0aGlzLnBvc2l0aW9uKTtcbiAgICB0aGlzLnByZXZpb3VzQW5nbGUgPSB0aGlzLmFuZ2xlO1xuXG4gICAgLy8gVmVsb2NpdHkgdXBkYXRlXG4gICAgaWYoIXRoaXMuZml4ZWRSb3RhdGlvbil7XG4gICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ICs9IHRoaXMuYW5ndWxhckZvcmNlICogdGhpcy5pbnZJbmVydGlhICogZHQ7XG4gICAgfVxuICAgIHZlYzIuc2NhbGUoaW50ZWdyYXRlX2ZoTWludiwgZiwgZHQgKiBtaW52KTtcbiAgICB2ZWMyLmFkZCh2ZWxvLCBpbnRlZ3JhdGVfZmhNaW52LCB2ZWxvKTtcblxuICAgIC8vIENDRFxuICAgIGlmKCF0aGlzLmludGVncmF0ZVRvVGltZU9mSW1wYWN0KGR0KSl7XG5cbiAgICAgICAgLy8gUmVndWxhciBwb3NpdGlvbiB1cGRhdGVcbiAgICAgICAgdmVjMi5zY2FsZShpbnRlZ3JhdGVfdmVsb2R0LCB2ZWxvLCBkdCk7XG4gICAgICAgIHZlYzIuYWRkKHBvcywgcG9zLCBpbnRlZ3JhdGVfdmVsb2R0KTtcbiAgICAgICAgaWYoIXRoaXMuZml4ZWRSb3RhdGlvbil7XG4gICAgICAgICAgICB0aGlzLmFuZ2xlICs9IHRoaXMuYW5ndWxhclZlbG9jaXR5ICogZHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG59O1xuXG52YXIgZGlyZWN0aW9uID0gdmVjMi5jcmVhdGUoKTtcbnZhciBlbmQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHN0YXJ0VG9FbmQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHJlbWVtYmVyUG9zaXRpb24gPSB2ZWMyLmNyZWF0ZSgpO1xuQm9keS5wcm90b3R5cGUuaW50ZWdyYXRlVG9UaW1lT2ZJbXBhY3QgPSBmdW5jdGlvbihkdCl7XG5cbiAgICBpZih0aGlzLmNjZFNwZWVkVGhyZXNob2xkIDwgMCB8fCB2ZWMyLnNxdWFyZWRMZW5ndGgodGhpcy52ZWxvY2l0eSkgPCBNYXRoLnBvdyh0aGlzLmNjZFNwZWVkVGhyZXNob2xkLCAyKSl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2ZWMyLm5vcm1hbGl6ZShkaXJlY3Rpb24sIHRoaXMudmVsb2NpdHkpO1xuXG4gICAgdmVjMi5zY2FsZShlbmQsIHRoaXMudmVsb2NpdHksIGR0KTtcbiAgICB2ZWMyLmFkZChlbmQsIGVuZCwgdGhpcy5wb3NpdGlvbik7XG5cbiAgICB2ZWMyLnN1YihzdGFydFRvRW5kLCBlbmQsIHRoaXMucG9zaXRpb24pO1xuICAgIHZhciBzdGFydFRvRW5kQW5nbGUgPSB0aGlzLmFuZ3VsYXJWZWxvY2l0eSAqIGR0O1xuICAgIHZhciBsZW4gPSB2ZWMyLmxlbmd0aChzdGFydFRvRW5kKTtcblxuICAgIHZhciB0aW1lT2ZJbXBhY3QgPSAxO1xuXG4gICAgdmFyIGhpdDtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhpcy53b3JsZC5yYXljYXN0QWxsKHRoaXMucG9zaXRpb24sIGVuZCwge30sIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYocmVzdWx0LmJvZHkgPT09IHRoYXQpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGhpdCA9IHJlc3VsdC5ib2R5O1xuICAgICAgICB2ZWMyLmNvcHkoZW5kLCByZXN1bHQuaGl0UG9pbnRXb3JsZCk7XG4gICAgICAgIHZlYzIuc3ViKHN0YXJ0VG9FbmQsIHJlc3VsdC5oaXRQb2ludFdvcmxkLCB0aGF0LnBvc2l0aW9uKTtcbiAgICAgICAgdGltZU9mSW1wYWN0ID0gdmVjMi5sZW5ndGgoc3RhcnRUb0VuZCkgLyBsZW47XG4gICAgICAgIHJlc3VsdC5hYm9ydCgpO1xuICAgIH0pO1xuXG4gICAgaWYoIWhpdCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcmVtZW1iZXJBbmdsZSA9IHRoaXMuYW5nbGU7XG4gICAgdmVjMi5jb3B5KHJlbWVtYmVyUG9zaXRpb24sIHRoaXMucG9zaXRpb24pO1xuXG4gICAgLy8gR290IGEgc3RhcnQgYW5kIGVuZCBwb2ludC4gQXBwcm94aW1hdGUgdGltZSBvZiBpbXBhY3QgdXNpbmcgYmluYXJ5IHNlYXJjaFxuICAgIHZhciBpdGVyID0gMDtcbiAgICB2YXIgdG1pbiA9IDA7XG4gICAgdmFyIHRtaWQgPSAwO1xuICAgIHZhciB0bWF4ID0gdGltZU9mSW1wYWN0O1xuICAgIHdoaWxlICh0bWF4ID49IHRtaW4gJiYgaXRlciA8IHRoaXMuY2NkSXRlcmF0aW9ucykge1xuICAgICAgICBpdGVyKys7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBtaWRwb2ludFxuICAgICAgICB0bWlkID0gKHRtYXggLSB0bWluKSAvIDI7XG5cbiAgICAgICAgLy8gTW92ZSB0aGUgYm9keSB0byB0aGF0IHBvaW50XG4gICAgICAgIHZlYzIuc2NhbGUoaW50ZWdyYXRlX3ZlbG9kdCwgc3RhcnRUb0VuZCwgdGltZU9mSW1wYWN0KTtcbiAgICAgICAgdmVjMi5hZGQodGhpcy5wb3NpdGlvbiwgcmVtZW1iZXJQb3NpdGlvbiwgaW50ZWdyYXRlX3ZlbG9kdCk7XG4gICAgICAgIHRoaXMuYW5nbGUgPSByZW1lbWJlckFuZ2xlICsgc3RhcnRUb0VuZEFuZ2xlICogdGltZU9mSW1wYWN0O1xuICAgICAgICB0aGlzLnVwZGF0ZUFBQkIoKTtcblxuICAgICAgICAvLyBjaGVjayBvdmVybGFwXG4gICAgICAgIHZhciBvdmVybGFwcyA9IHRoaXMuYWFiYi5vdmVybGFwcyhoaXQuYWFiYikgJiYgdGhpcy53b3JsZC5uYXJyb3dwaGFzZS5ib2RpZXNPdmVybGFwKHRoaXMsIGhpdCk7XG5cbiAgICAgICAgaWYgKG92ZXJsYXBzKSB7XG4gICAgICAgICAgICAvLyBjaGFuZ2UgbWluIHRvIHNlYXJjaCB1cHBlciBpbnRlcnZhbFxuICAgICAgICAgICAgdG1pbiA9IHRtaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjaGFuZ2UgbWF4IHRvIHNlYXJjaCBsb3dlciBpbnRlcnZhbFxuICAgICAgICAgICAgdG1heCA9IHRtaWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aW1lT2ZJbXBhY3QgPSB0bWlkO1xuXG4gICAgdmVjMi5jb3B5KHRoaXMucG9zaXRpb24sIHJlbWVtYmVyUG9zaXRpb24pO1xuICAgIHRoaXMuYW5nbGUgPSByZW1lbWJlckFuZ2xlO1xuXG4gICAgLy8gbW92ZSB0byBUT0lcbiAgICB2ZWMyLnNjYWxlKGludGVncmF0ZV92ZWxvZHQsIHN0YXJ0VG9FbmQsIHRpbWVPZkltcGFjdCk7XG4gICAgdmVjMi5hZGQodGhpcy5wb3NpdGlvbiwgdGhpcy5wb3NpdGlvbiwgaW50ZWdyYXRlX3ZlbG9kdCk7XG4gICAgaWYoIXRoaXMuZml4ZWRSb3RhdGlvbil7XG4gICAgICAgIHRoaXMuYW5nbGUgKz0gc3RhcnRUb0VuZEFuZ2xlICogdGltZU9mSW1wYWN0O1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAZXZlbnQgc2xlZXB5XG4gKi9cbkJvZHkuc2xlZXB5RXZlbnQgPSB7XG4gICAgdHlwZTogXCJzbGVlcHlcIlxufTtcblxuLyoqXG4gKiBAZXZlbnQgc2xlZXBcbiAqL1xuQm9keS5zbGVlcEV2ZW50ID0ge1xuICAgIHR5cGU6IFwic2xlZXBcIlxufTtcblxuLyoqXG4gKiBAZXZlbnQgd2FrZXVwXG4gKi9cbkJvZHkud2FrZVVwRXZlbnQgPSB7XG4gICAgdHlwZTogXCJ3YWtldXBcIlxufTtcblxuLyoqXG4gKiBEeW5hbWljIGJvZHkuXG4gKiBAcHJvcGVydHkgRFlOQU1JQ1xuICogQHR5cGUge051bWJlcn1cbiAqIEBzdGF0aWNcbiAqL1xuQm9keS5EWU5BTUlDID0gMTtcblxuLyoqXG4gKiBTdGF0aWMgYm9keS5cbiAqIEBwcm9wZXJ0eSBTVEFUSUNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAc3RhdGljXG4gKi9cbkJvZHkuU1RBVElDID0gMjtcblxuLyoqXG4gKiBLaW5lbWF0aWMgYm9keS5cbiAqIEBwcm9wZXJ0eSBLSU5FTUFUSUNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAc3RhdGljXG4gKi9cbkJvZHkuS0lORU1BVElDID0gNDtcblxuLyoqXG4gKiBAcHJvcGVydHkgQVdBS0VcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAc3RhdGljXG4gKi9cbkJvZHkuQVdBS0UgPSAwO1xuXG4vKipcbiAqIEBwcm9wZXJ0eSBTTEVFUFlcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAc3RhdGljXG4gKi9cbkJvZHkuU0xFRVBZID0gMTtcblxuLyoqXG4gKiBAcHJvcGVydHkgU0xFRVBJTkdcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAc3RhdGljXG4gKi9cbkJvZHkuU0xFRVBJTkcgPSAyO1xuXG5cbn0se1wiLi4vY29sbGlzaW9uL0FBQkJcIjo3LFwiLi4vZXZlbnRzL0V2ZW50RW1pdHRlclwiOjI3LFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi9zaGFwZXMvQ29udmV4XCI6MzksXCJwb2x5LWRlY29tcFwiOjV9XSwzMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xudmFyIFNwcmluZyA9IF9kZXJlcV8oJy4vU3ByaW5nJyk7XG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVhclNwcmluZztcblxuLyoqXG4gKiBBIHNwcmluZywgY29ubmVjdGluZyB0d28gYm9kaWVzLlxuICpcbiAqIFRoZSBTcHJpbmcgZXhwbGljaXRseSBhZGRzIGZvcmNlIGFuZCBhbmd1bGFyRm9yY2UgdG8gdGhlIGJvZGllcy5cbiAqXG4gKiBAY2xhc3MgTGluZWFyU3ByaW5nXG4gKiBAZXh0ZW5kcyBTcHJpbmdcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlc3RMZW5ndGhdICAgQSBudW1iZXIgPiAwLiBEZWZhdWx0IGlzIHRoZSBjdXJyZW50IGRpc3RhbmNlIGJldHdlZW4gdGhlIHdvcmxkIGFuY2hvciBwb2ludHMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RpZmZuZXNzPTEwMF0gIFNwcmluZyBjb25zdGFudCAoc2VlIEhvb2tlcyBMYXcpLiBBIG51bWJlciA+PSAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmc9MV0gICAgICBBIG51bWJlciA+PSAwLiBEZWZhdWx0OiAxXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMud29ybGRBbmNob3JBXSAgIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIHdvcmxkIGNvb3JkaW5hdGVzLiBPdmVycmlkZXMgdGhlIG9wdGlvbiBcImxvY2FsQW5jaG9yQVwiIGlmIGdpdmVuLlxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLndvcmxkQW5jaG9yQl1cbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5sb2NhbEFuY2hvckFdICAgV2hlcmUgdG8gaG9vayB0aGUgc3ByaW5nIHRvIGJvZHkgQSwgaW4gbG9jYWwgYm9keSBjb29yZGluYXRlcy4gRGVmYXVsdHMgdG8gdGhlIGJvZHkgY2VudGVyLlxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLmxvY2FsQW5jaG9yQl1cbiAqL1xuZnVuY3Rpb24gTGluZWFyU3ByaW5nKGJvZHlBLGJvZHlCLG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgU3ByaW5nLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEFuY2hvciBmb3IgYm9keUEgaW4gbG9jYWwgYm9keUEgY29vcmRpbmF0ZXMuXG4gICAgICogQHByb3BlcnR5IGxvY2FsQW5jaG9yQVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4gICAgLyoqXG4gICAgICogQW5jaG9yIGZvciBib2R5QiBpbiBsb2NhbCBib2R5QiBjb29yZGluYXRlcy5cbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JCXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxBbmNob3JCID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbiAgICBpZihvcHRpb25zLmxvY2FsQW5jaG9yQSl7IHZlYzIuY29weSh0aGlzLmxvY2FsQW5jaG9yQSwgb3B0aW9ucy5sb2NhbEFuY2hvckEpOyB9XG4gICAgaWYob3B0aW9ucy5sb2NhbEFuY2hvckIpeyB2ZWMyLmNvcHkodGhpcy5sb2NhbEFuY2hvckIsIG9wdGlvbnMubG9jYWxBbmNob3JCKTsgfVxuICAgIGlmKG9wdGlvbnMud29ybGRBbmNob3JBKXsgdGhpcy5zZXRXb3JsZEFuY2hvckEob3B0aW9ucy53b3JsZEFuY2hvckEpOyB9XG4gICAgaWYob3B0aW9ucy53b3JsZEFuY2hvckIpeyB0aGlzLnNldFdvcmxkQW5jaG9yQihvcHRpb25zLndvcmxkQW5jaG9yQik7IH1cblxuICAgIHZhciB3b3JsZEFuY2hvckEgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIHZhciB3b3JsZEFuY2hvckIgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIHRoaXMuZ2V0V29ybGRBbmNob3JBKHdvcmxkQW5jaG9yQSk7XG4gICAgdGhpcy5nZXRXb3JsZEFuY2hvckIod29ybGRBbmNob3JCKTtcbiAgICB2YXIgd29ybGREaXN0YW5jZSA9IHZlYzIuZGlzdGFuY2Uod29ybGRBbmNob3JBLCB3b3JsZEFuY2hvckIpO1xuXG4gICAgLyoqXG4gICAgICogUmVzdCBsZW5ndGggb2YgdGhlIHNwcmluZy5cbiAgICAgKiBAcHJvcGVydHkgcmVzdExlbmd0aFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXN0TGVuZ3RoID0gdHlwZW9mKG9wdGlvbnMucmVzdExlbmd0aCkgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zLnJlc3RMZW5ndGggOiB3b3JsZERpc3RhbmNlO1xufVxuTGluZWFyU3ByaW5nLnByb3RvdHlwZSA9IG5ldyBTcHJpbmcoKTtcbkxpbmVhclNwcmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lYXJTcHJpbmc7XG5cbi8qKlxuICogU2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBBLCB1c2luZyB3b3JsZCBjb29yZGluYXRlcy5cbiAqIEBtZXRob2Qgc2V0V29ybGRBbmNob3JBXG4gKiBAcGFyYW0ge0FycmF5fSB3b3JsZEFuY2hvckFcbiAqL1xuTGluZWFyU3ByaW5nLnByb3RvdHlwZS5zZXRXb3JsZEFuY2hvckEgPSBmdW5jdGlvbih3b3JsZEFuY2hvckEpe1xuICAgIHRoaXMuYm9keUEudG9Mb2NhbEZyYW1lKHRoaXMubG9jYWxBbmNob3JBLCB3b3JsZEFuY2hvckEpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEIsIHVzaW5nIHdvcmxkIGNvb3JkaW5hdGVzLlxuICogQG1ldGhvZCBzZXRXb3JsZEFuY2hvckJcbiAqIEBwYXJhbSB7QXJyYXl9IHdvcmxkQW5jaG9yQlxuICovXG5MaW5lYXJTcHJpbmcucHJvdG90eXBlLnNldFdvcmxkQW5jaG9yQiA9IGZ1bmN0aW9uKHdvcmxkQW5jaG9yQil7XG4gICAgdGhpcy5ib2R5Qi50b0xvY2FsRnJhbWUodGhpcy5sb2NhbEFuY2hvckIsIHdvcmxkQW5jaG9yQik7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQSwgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIGdldFdvcmxkQW5jaG9yQVxuICogQHBhcmFtIHtBcnJheX0gcmVzdWx0IFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cbiAqL1xuTGluZWFyU3ByaW5nLnByb3RvdHlwZS5nZXRXb3JsZEFuY2hvckEgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHRoaXMuYm9keUEudG9Xb3JsZEZyYW1lKHJlc3VsdCwgdGhpcy5sb2NhbEFuY2hvckEpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEIsIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICogQG1ldGhvZCBnZXRXb3JsZEFuY2hvckJcbiAqIEBwYXJhbSB7QXJyYXl9IHJlc3VsdCBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXG4gKi9cbkxpbmVhclNwcmluZy5wcm90b3R5cGUuZ2V0V29ybGRBbmNob3JCID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB0aGlzLmJvZHlCLnRvV29ybGRGcmFtZShyZXN1bHQsIHRoaXMubG9jYWxBbmNob3JCKTtcbn07XG5cbnZhciBhcHBseUZvcmNlX3IgPSAgICAgICAgICAgICAgdmVjMi5jcmVhdGUoKSxcbiAgICBhcHBseUZvcmNlX3JfdW5pdCA9ICAgICAgICAgdmVjMi5jcmVhdGUoKSxcbiAgICBhcHBseUZvcmNlX3UgPSAgICAgICAgICAgICAgdmVjMi5jcmVhdGUoKSxcbiAgICBhcHBseUZvcmNlX2YgPSAgICAgICAgICAgICAgdmVjMi5jcmVhdGUoKSxcbiAgICBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQSA9ICAgdmVjMi5jcmVhdGUoKSxcbiAgICBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQiA9ICAgdmVjMi5jcmVhdGUoKSxcbiAgICBhcHBseUZvcmNlX3JpID0gICAgICAgICAgICAgdmVjMi5jcmVhdGUoKSxcbiAgICBhcHBseUZvcmNlX3JqID0gICAgICAgICAgICAgdmVjMi5jcmVhdGUoKSxcbiAgICBhcHBseUZvcmNlX3RtcCA9ICAgICAgICAgICAgdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBBcHBseSB0aGUgc3ByaW5nIGZvcmNlIHRvIHRoZSBjb25uZWN0ZWQgYm9kaWVzLlxuICogQG1ldGhvZCBhcHBseUZvcmNlXG4gKi9cbkxpbmVhclNwcmluZy5wcm90b3R5cGUuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGsgPSB0aGlzLnN0aWZmbmVzcyxcbiAgICAgICAgZCA9IHRoaXMuZGFtcGluZyxcbiAgICAgICAgbCA9IHRoaXMucmVzdExlbmd0aCxcbiAgICAgICAgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHIgPSBhcHBseUZvcmNlX3IsXG4gICAgICAgIHJfdW5pdCA9IGFwcGx5Rm9yY2Vfcl91bml0LFxuICAgICAgICB1ID0gYXBwbHlGb3JjZV91LFxuICAgICAgICBmID0gYXBwbHlGb3JjZV9mLFxuICAgICAgICB0bXAgPSBhcHBseUZvcmNlX3RtcDtcblxuICAgIHZhciB3b3JsZEFuY2hvckEgPSBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQSxcbiAgICAgICAgd29ybGRBbmNob3JCID0gYXBwbHlGb3JjZV93b3JsZEFuY2hvckIsXG4gICAgICAgIHJpID0gYXBwbHlGb3JjZV9yaSxcbiAgICAgICAgcmogPSBhcHBseUZvcmNlX3JqO1xuXG4gICAgLy8gR2V0IHdvcmxkIGFuY2hvcnNcbiAgICB0aGlzLmdldFdvcmxkQW5jaG9yQSh3b3JsZEFuY2hvckEpO1xuICAgIHRoaXMuZ2V0V29ybGRBbmNob3JCKHdvcmxkQW5jaG9yQik7XG5cbiAgICAvLyBHZXQgb2Zmc2V0IHBvaW50c1xuICAgIHZlYzIuc3ViKHJpLCB3b3JsZEFuY2hvckEsIGJvZHlBLnBvc2l0aW9uKTtcbiAgICB2ZWMyLnN1Yihyaiwgd29ybGRBbmNob3JCLCBib2R5Qi5wb3NpdGlvbik7XG5cbiAgICAvLyBDb21wdXRlIGRpc3RhbmNlIHZlY3RvciBiZXR3ZWVuIHdvcmxkIGFuY2hvciBwb2ludHNcbiAgICB2ZWMyLnN1YihyLCB3b3JsZEFuY2hvckIsIHdvcmxkQW5jaG9yQSk7XG4gICAgdmFyIHJsZW4gPSB2ZWMyLmxlbihyKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZShyX3VuaXQscik7XG5cbiAgICAvL2NvbnNvbGUubG9nKHJsZW4pXG4gICAgLy9jb25zb2xlLmxvZyhcIkFcIix2ZWMyLnN0cih3b3JsZEFuY2hvckEpLFwiQlwiLHZlYzIuc3RyKHdvcmxkQW5jaG9yQikpXG5cbiAgICAvLyBDb21wdXRlIHJlbGF0aXZlIHZlbG9jaXR5IG9mIHRoZSBhbmNob3IgcG9pbnRzLCB1XG4gICAgdmVjMi5zdWIodSwgYm9keUIudmVsb2NpdHksIGJvZHlBLnZlbG9jaXR5KTtcbiAgICB2ZWMyLmNyb3NzWlYodG1wLCBib2R5Qi5hbmd1bGFyVmVsb2NpdHksIHJqKTtcbiAgICB2ZWMyLmFkZCh1LCB1LCB0bXApO1xuICAgIHZlYzIuY3Jvc3NaVih0bXAsIGJvZHlBLmFuZ3VsYXJWZWxvY2l0eSwgcmkpO1xuICAgIHZlYzIuc3ViKHUsIHUsIHRtcCk7XG5cbiAgICAvLyBGID0gLSBrICogKCB4IC0gTCApIC0gRCAqICggdSApXG4gICAgdmVjMi5zY2FsZShmLCByX3VuaXQsIC1rKihybGVuLWwpIC0gZCp2ZWMyLmRvdCh1LHJfdW5pdCkpO1xuXG4gICAgLy8gQWRkIGZvcmNlcyB0byBib2RpZXNcbiAgICB2ZWMyLnN1YiggYm9keUEuZm9yY2UsIGJvZHlBLmZvcmNlLCBmKTtcbiAgICB2ZWMyLmFkZCggYm9keUIuZm9yY2UsIGJvZHlCLmZvcmNlLCBmKTtcblxuICAgIC8vIEFuZ3VsYXIgZm9yY2VcbiAgICB2YXIgcmlfeF9mID0gdmVjMi5jcm9zc0xlbmd0aChyaSwgZik7XG4gICAgdmFyIHJqX3hfZiA9IHZlYzIuY3Jvc3NMZW5ndGgocmosIGYpO1xuICAgIGJvZHlBLmFuZ3VsYXJGb3JjZSAtPSByaV94X2Y7XG4gICAgYm9keUIuYW5ndWxhckZvcmNlICs9IHJqX3hfZjtcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi91dGlscy9VdGlsc1wiOjUwLFwiLi9TcHJpbmdcIjozNX1dLDM0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG52YXIgU3ByaW5nID0gX2RlcmVxXygnLi9TcHJpbmcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsU3ByaW5nO1xuXG4vKipcbiAqIEEgcm90YXRpb25hbCBzcHJpbmcsIGNvbm5lY3RpbmcgdHdvIGJvZGllcyByb3RhdGlvbi4gVGhpcyBzcHJpbmcgZXhwbGljaXRseSBhZGRzIGFuZ3VsYXJGb3JjZSAodG9ycXVlKSB0byB0aGUgYm9kaWVzLlxuICpcbiAqIFRoZSBzcHJpbmcgY2FuIGJlIGNvbWJpbmVkIHdpdGggYSB7eyNjcm9zc0xpbmsgXCJSZXZvbHV0ZUNvbnN0cmFpbnRcIn19e3svY3Jvc3NMaW5rfX0gdG8gbWFrZSwgZm9yIGV4YW1wbGUsIGEgbW91c2UgdHJhcC5cbiAqXG4gKiBAY2xhc3MgUm90YXRpb25hbFNwcmluZ1xuICogQGV4dGVuZHMgU3ByaW5nXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXN0QW5nbGVdIFRoZSByZWxhdGl2ZSBhbmdsZSBvZiBib2RpZXMgYXQgd2hpY2ggdGhlIHNwcmluZyBpcyBhdCByZXN0LiBJZiBub3QgZ2l2ZW4sIGl0J3Mgc2V0IHRvIHRoZSBjdXJyZW50IHJlbGF0aXZlIGFuZ2xlIGJldHdlZW4gdGhlIGJvZGllcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGlmZm5lc3M9MTAwXSBTcHJpbmcgY29uc3RhbnQgKHNlZSBIb29rZXMgTGF3KS4gQSBudW1iZXIgPj0gMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kYW1waW5nPTFdIEEgbnVtYmVyID49IDAuXG4gKi9cbmZ1bmN0aW9uIFJvdGF0aW9uYWxTcHJpbmcoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIFNwcmluZy5jYWxsKHRoaXMsIGJvZHlBLCBib2R5Qiwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXN0IGFuZ2xlIG9mIHRoZSBzcHJpbmcuXG4gICAgICogQHByb3BlcnR5IHJlc3RBbmdsZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXN0QW5nbGUgPSB0eXBlb2Yob3B0aW9ucy5yZXN0QW5nbGUpID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5yZXN0QW5nbGUgOiBib2R5Qi5hbmdsZSAtIGJvZHlBLmFuZ2xlO1xufVxuUm90YXRpb25hbFNwcmluZy5wcm90b3R5cGUgPSBuZXcgU3ByaW5nKCk7XG5Sb3RhdGlvbmFsU3ByaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJvdGF0aW9uYWxTcHJpbmc7XG5cbi8qKlxuICogQXBwbHkgdGhlIHNwcmluZyBmb3JjZSB0byB0aGUgY29ubmVjdGVkIGJvZGllcy5cbiAqIEBtZXRob2QgYXBwbHlGb3JjZVxuICovXG5Sb3RhdGlvbmFsU3ByaW5nLnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgayA9IHRoaXMuc3RpZmZuZXNzLFxuICAgICAgICBkID0gdGhpcy5kYW1waW5nLFxuICAgICAgICBsID0gdGhpcy5yZXN0QW5nbGUsXG4gICAgICAgIGJvZHlBID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICB4ID0gYm9keUIuYW5nbGUgLSBib2R5QS5hbmdsZSxcbiAgICAgICAgdSA9IGJvZHlCLmFuZ3VsYXJWZWxvY2l0eSAtIGJvZHlBLmFuZ3VsYXJWZWxvY2l0eTtcblxuICAgIHZhciB0b3JxdWUgPSAtIGsgKiAoeCAtIGwpIC0gZCAqIHUgKiAwO1xuXG4gICAgYm9keUEuYW5ndWxhckZvcmNlIC09IHRvcnF1ZTtcbiAgICBib2R5Qi5hbmd1bGFyRm9yY2UgKz0gdG9ycXVlO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4vU3ByaW5nXCI6MzV9XSwzNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpO1xudmFyIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcHJpbmc7XG5cbi8qKlxuICogQSBzcHJpbmcsIGNvbm5lY3RpbmcgdHdvIGJvZGllcy4gVGhlIFNwcmluZyBleHBsaWNpdGx5IGFkZHMgZm9yY2UgYW5kIGFuZ3VsYXJGb3JjZSB0byB0aGUgYm9kaWVzIGFuZCBkb2VzIHRoZXJlZm9yZSBub3QgcHV0IGxvYWQgb24gdGhlIGNvbnN0cmFpbnQgc29sdmVyLlxuICpcbiAqIEBjbGFzcyBTcHJpbmdcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0aWZmbmVzcz0xMDBdICBTcHJpbmcgY29uc3RhbnQgKHNlZSBIb29rZXMgTGF3KS4gQSBudW1iZXIgPj0gMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kYW1waW5nPTFdICAgICAgQSBudW1iZXIgPj0gMC4gRGVmYXVsdDogMVxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLmxvY2FsQW5jaG9yQV0gICBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiBsb2NhbCBib2R5IGNvb3JkaW5hdGVzLiBEZWZhdWx0cyB0byB0aGUgYm9keSBjZW50ZXIuXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxBbmNob3JCXVxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLndvcmxkQW5jaG9yQV0gICBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiB3b3JsZCBjb29yZGluYXRlcy4gT3ZlcnJpZGVzIHRoZSBvcHRpb24gXCJsb2NhbEFuY2hvckFcIiBpZiBnaXZlbi5cbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy53b3JsZEFuY2hvckJdXG4gKi9cbmZ1bmN0aW9uIFNwcmluZyhib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLHtcbiAgICAgICAgc3RpZmZuZXNzOiAxMDAsXG4gICAgICAgIGRhbXBpbmc6IDEsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTdGlmZm5lc3Mgb2YgdGhlIHNwcmluZy5cbiAgICAgKiBAcHJvcGVydHkgc3RpZmZuZXNzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnN0aWZmbmVzcyA9IG9wdGlvbnMuc3RpZmZuZXNzO1xuXG4gICAgLyoqXG4gICAgICogRGFtcGluZyBvZiB0aGUgc3ByaW5nLlxuICAgICAqIEBwcm9wZXJ0eSBkYW1waW5nXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRhbXBpbmcgPSBvcHRpb25zLmRhbXBpbmc7XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCBjb25uZWN0ZWQgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgYm9keUFcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG5cbiAgICAvKipcbiAgICAgKiBTZWNvbmQgY29ubmVjdGVkIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGJvZHlCXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xufVxuXG4vKipcbiAqIEFwcGx5IHRoZSBzcHJpbmcgZm9yY2UgdG8gdGhlIGNvbm5lY3RlZCBib2RpZXMuXG4gKiBAbWV0aG9kIGFwcGx5Rm9yY2VcbiAqL1xuU3ByaW5nLnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24oKXtcbiAgICAvLyBUbyBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzXG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vdXRpbHMvVXRpbHNcIjo1MH1dLDM2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIEV4cG9ydCBwMiBjbGFzc2VzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBBQUJCIDogICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29sbGlzaW9uL0FBQkInKSxcbiAgICBBbmdsZUxvY2tFcXVhdGlvbiA6ICAgICAgICAgICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL0FuZ2xlTG9ja0VxdWF0aW9uJyksXG4gICAgQm9keSA6ICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL29iamVjdHMvQm9keScpLFxuICAgIEJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpLFxuICAgIENhcHN1bGUgOiAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvQ2Fwc3VsZScpLFxuICAgIENpcmNsZSA6ICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvQ2lyY2xlJyksXG4gICAgQ29uc3RyYWludCA6ICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKSxcbiAgICBDb250YWN0RXF1YXRpb24gOiAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpLFxuICAgIENvbnRhY3RNYXRlcmlhbCA6ICAgICAgICAgICAgICAgX2RlcmVxXygnLi9tYXRlcmlhbC9Db250YWN0TWF0ZXJpYWwnKSxcbiAgICBDb252ZXggOiAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL0NvbnZleCcpLFxuICAgIERpc3RhbmNlQ29uc3RyYWludCA6ICAgICAgICAgICAgX2RlcmVxXygnLi9jb25zdHJhaW50cy9EaXN0YW5jZUNvbnN0cmFpbnQnKSxcbiAgICBFcXVhdGlvbiA6ICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL0VxdWF0aW9uJyksXG4gICAgRXZlbnRFbWl0dGVyIDogICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2V2ZW50cy9FdmVudEVtaXR0ZXInKSxcbiAgICBGcmljdGlvbkVxdWF0aW9uIDogICAgICAgICAgICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKSxcbiAgICBHZWFyQ29uc3RyYWludCA6ICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29uc3RyYWludHMvR2VhckNvbnN0cmFpbnQnKSxcbiAgICBHcmlkQnJvYWRwaGFzZSA6ICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29sbGlzaW9uL0dyaWRCcm9hZHBoYXNlJyksXG4gICAgR1NTb2x2ZXIgOiAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NvbHZlci9HU1NvbHZlcicpLFxuICAgIEhlaWdodGZpZWxkIDogICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvSGVpZ2h0ZmllbGQnKSxcbiAgICBMaW5lIDogICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL0xpbmUnKSxcbiAgICBMb2NrQ29uc3RyYWludCA6ICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29uc3RyYWludHMvTG9ja0NvbnN0cmFpbnQnKSxcbiAgICBNYXRlcmlhbCA6ICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vbWF0ZXJpYWwvTWF0ZXJpYWwnKSxcbiAgICBOYXJyb3dwaGFzZSA6ICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29sbGlzaW9uL05hcnJvd3BoYXNlJyksXG4gICAgTmFpdmVCcm9hZHBoYXNlIDogICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2UnKSxcbiAgICBQYXJ0aWNsZSA6ICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL1BhcnRpY2xlJyksXG4gICAgUGxhbmUgOiAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9QbGFuZScpLFxuICAgIFJldm9sdXRlQ29uc3RyYWludCA6ICAgICAgICAgICAgX2RlcmVxXygnLi9jb25zdHJhaW50cy9SZXZvbHV0ZUNvbnN0cmFpbnQnKSxcbiAgICBQcmlzbWF0aWNDb25zdHJhaW50IDogICAgICAgICAgIF9kZXJlcV8oJy4vY29uc3RyYWludHMvUHJpc21hdGljQ29uc3RyYWludCcpLFxuICAgIFJheSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vUmF5JyksXG4gICAgUmF5Y2FzdFJlc3VsdCA6ICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0JyksXG4gICAgUmVjdGFuZ2xlIDogICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9SZWN0YW5nbGUnKSxcbiAgICBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbiA6ICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL1JvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uJyksXG4gICAgU0FQQnJvYWRwaGFzZSA6ICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlJyksXG4gICAgU2hhcGUgOiAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NoYXBlcy9TaGFwZScpLFxuICAgIFNvbHZlciA6ICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zb2x2ZXIvU29sdmVyJyksXG4gICAgU3ByaW5nIDogICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL29iamVjdHMvU3ByaW5nJyksXG4gICAgTGluZWFyU3ByaW5nIDogICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL29iamVjdHMvTGluZWFyU3ByaW5nJyksXG4gICAgUm90YXRpb25hbFNwcmluZyA6ICAgICAgICAgICAgICBfZGVyZXFfKCcuL29iamVjdHMvUm90YXRpb25hbFNwcmluZycpLFxuICAgIFV0aWxzIDogICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi91dGlscy9VdGlscycpLFxuICAgIFdvcmxkIDogICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi93b3JsZC9Xb3JsZCcpLFxuICAgIHZlYzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9tYXRoL3ZlYzInKSxcbiAgICB2ZXJzaW9uIDogICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb24sXG59O1xuXG59LHtcIi4uL3BhY2thZ2UuanNvblwiOjYsXCIuL2NvbGxpc2lvbi9BQUJCXCI6NyxcIi4vY29sbGlzaW9uL0Jyb2FkcGhhc2VcIjo4LFwiLi9jb2xsaXNpb24vR3JpZEJyb2FkcGhhc2VcIjo5LFwiLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlXCI6MTAsXCIuL2NvbGxpc2lvbi9OYXJyb3dwaGFzZVwiOjExLFwiLi9jb2xsaXNpb24vUmF5XCI6MTIsXCIuL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0XCI6MTMsXCIuL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlXCI6MTQsXCIuL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnRcIjoxNSxcIi4vY29uc3RyYWludHMvRGlzdGFuY2VDb25zdHJhaW50XCI6MTYsXCIuL2NvbnN0cmFpbnRzL0dlYXJDb25zdHJhaW50XCI6MTcsXCIuL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50XCI6MTgsXCIuL2NvbnN0cmFpbnRzL1ByaXNtYXRpY0NvbnN0cmFpbnRcIjoxOSxcIi4vY29uc3RyYWludHMvUmV2b2x1dGVDb25zdHJhaW50XCI6MjAsXCIuL2VxdWF0aW9ucy9BbmdsZUxvY2tFcXVhdGlvblwiOjIxLFwiLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uXCI6MjIsXCIuL2VxdWF0aW9ucy9FcXVhdGlvblwiOjIzLFwiLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvblwiOjI0LFwiLi9lcXVhdGlvbnMvUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb25cIjoyNixcIi4vZXZlbnRzL0V2ZW50RW1pdHRlclwiOjI3LFwiLi9tYXRlcmlhbC9Db250YWN0TWF0ZXJpYWxcIjoyOCxcIi4vbWF0ZXJpYWwvTWF0ZXJpYWxcIjoyOSxcIi4vbWF0aC92ZWMyXCI6MzEsXCIuL29iamVjdHMvQm9keVwiOjMyLFwiLi9vYmplY3RzL0xpbmVhclNwcmluZ1wiOjMzLFwiLi9vYmplY3RzL1JvdGF0aW9uYWxTcHJpbmdcIjozNCxcIi4vb2JqZWN0cy9TcHJpbmdcIjozNSxcIi4vc2hhcGVzL0NhcHN1bGVcIjozNyxcIi4vc2hhcGVzL0NpcmNsZVwiOjM4LFwiLi9zaGFwZXMvQ29udmV4XCI6MzksXCIuL3NoYXBlcy9IZWlnaHRmaWVsZFwiOjQwLFwiLi9zaGFwZXMvTGluZVwiOjQxLFwiLi9zaGFwZXMvUGFydGljbGVcIjo0MixcIi4vc2hhcGVzL1BsYW5lXCI6NDMsXCIuL3NoYXBlcy9SZWN0YW5nbGVcIjo0NCxcIi4vc2hhcGVzL1NoYXBlXCI6NDUsXCIuL3NvbHZlci9HU1NvbHZlclwiOjQ2LFwiLi9zb2x2ZXIvU29sdmVyXCI6NDcsXCIuL3V0aWxzL1V0aWxzXCI6NTAsXCIuL3dvcmxkL1dvcmxkXCI6NTR9XSwzNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2Fwc3VsZTtcblxuLyoqXG4gKiBDYXBzdWxlIHNoYXBlIGNsYXNzLlxuICogQGNsYXNzIENhcHN1bGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbGVuZ3RoPTFdIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBlbmQgcG9pbnRzXG4gKiBAcGFyYW0ge051bWJlcn0gW3JhZGl1cz0xXSBSYWRpdXMgb2YgdGhlIGNhcHN1bGVcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIHJhZGl1cyA9IDE7XG4gKiAgICAgdmFyIGxlbmd0aCA9IDI7XG4gKiAgICAgdmFyIGNhcHN1bGVTaGFwZSA9IG5ldyBDYXBzdWxlKGxlbmd0aCwgcmFkaXVzKTtcbiAqICAgICBib2R5LmFkZFNoYXBlKGNhcHN1bGVTaGFwZSk7XG4gKi9cbmZ1bmN0aW9uIENhcHN1bGUobGVuZ3RoLCByYWRpdXMpe1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGVuZCBwb2ludHMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxlbmd0aFxuICAgICAqL1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoIHx8IDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmFkaXVzIG9mIHRoZSBjYXBzdWxlLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByYWRpdXNcbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cyB8fCAxO1xuXG4gICAgU2hhcGUuY2FsbCh0aGlzLFNoYXBlLkNBUFNVTEUpO1xufVxuQ2Fwc3VsZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbkNhcHN1bGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2Fwc3VsZTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBtYXNzIG1vbWVudCBvZiBpbmVydGlhIG9mIHRoZSBDYXBzdWxlLlxuICogQG1ldGhvZCBjb25wdXRlTW9tZW50T2ZJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEB0b2RvXG4gKi9cbkNhcHN1bGUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIHJlY3RhbmdsZVxuICAgIHZhciByID0gdGhpcy5yYWRpdXMsXG4gICAgICAgIHcgPSB0aGlzLmxlbmd0aCArIHIsIC8vIDIqciBpcyB0b28gbXVjaCwgMCBpcyB0b28gbGl0dGxlXG4gICAgICAgIGggPSByKjI7XG4gICAgcmV0dXJuIG1hc3MgKiAoaCpoICsgdyp3KSAvIDEyO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXG4gKi9cbkNhcHN1bGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gdGhpcy5yYWRpdXMgKyB0aGlzLmxlbmd0aC8yO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHVwZGF0ZUFyZWFcbiAqL1xuQ2Fwc3VsZS5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5hcmVhID0gTWF0aC5QSSAqIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKyB0aGlzLnJhZGl1cyAqIDIgKiB0aGlzLmxlbmd0aDtcbn07XG5cbnZhciByID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuQ2Fwc3VsZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgdmFyIHJhZGl1cyA9IHRoaXMucmFkaXVzO1xuXG4gICAgLy8gQ29tcHV0ZSBjZW50ZXIgcG9zaXRpb24gb2Ygb25lIG9mIHRoZSB0aGUgY2lyY2xlcywgd29ybGQgb3JpZW50ZWQsIGJ1dCB3aXRoIGxvY2FsIG9mZnNldFxuICAgIHZlYzIuc2V0KHIsdGhpcy5sZW5ndGggLyAyLDApO1xuICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgdmVjMi5yb3RhdGUocixyLGFuZ2xlKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgYm91bmRzXG4gICAgdmVjMi5zZXQob3V0LnVwcGVyQm91bmQsICBNYXRoLm1heChyWzBdK3JhZGl1cywgLXJbMF0rcmFkaXVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHJbMV0rcmFkaXVzLCAtclsxXStyYWRpdXMpKTtcbiAgICB2ZWMyLnNldChvdXQubG93ZXJCb3VuZCwgIE1hdGgubWluKHJbMF0tcmFkaXVzLCAtclswXS1yYWRpdXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oclsxXS1yYWRpdXMsIC1yWzFdLXJhZGl1cykpO1xuXG4gICAgLy8gQWRkIG9mZnNldFxuICAgIHZlYzIuYWRkKG91dC5sb3dlckJvdW5kLCBvdXQubG93ZXJCb3VuZCwgcG9zaXRpb24pO1xuICAgIHZlYzIuYWRkKG91dC51cHBlckJvdW5kLCBvdXQudXBwZXJCb3VuZCwgcG9zaXRpb24pO1xufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4vU2hhcGVcIjo0NX1dLDM4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKVxuLCAgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlO1xuXG4vKipcbiAqIENpcmNsZSBzaGFwZSBjbGFzcy5cbiAqIEBjbGFzcyBDaXJjbGVcbiAqIEBleHRlbmRzIFNoYXBlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXVzPTFdIFRoZSByYWRpdXMgb2YgdGhpcyBjaXJjbGVcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciByYWRpdXMgPSAxO1xuICogICAgIHZhciBjaXJjbGVTaGFwZSA9IG5ldyBDaXJjbGUocmFkaXVzKTtcbiAqICAgICBib2R5LmFkZFNoYXBlKGNpcmNsZVNoYXBlKTtcbiAqL1xuZnVuY3Rpb24gQ2lyY2xlKHJhZGl1cyl7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUuXG4gICAgICogQHByb3BlcnR5IHJhZGl1c1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXMgfHwgMTtcblxuICAgIFNoYXBlLmNhbGwodGhpcyxTaGFwZS5DSVJDTEUpO1xufVxuQ2lyY2xlLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuQ2lyY2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENpcmNsZTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5DaXJjbGUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICB2YXIgciA9IHRoaXMucmFkaXVzO1xuICAgIHJldHVybiBtYXNzICogciAqIHIgLyAyO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkNpcmNsZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSB0aGlzLnJhZGl1cztcbn07XG5cbi8qKlxuICogQG1ldGhvZCB1cGRhdGVBcmVhXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkNpcmNsZS5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5hcmVhID0gTWF0aC5QSSAqIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXM7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0ICAgICAgVGhlIHJlc3VsdGluZyBBQUJCLlxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5DaXJjbGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciByID0gdGhpcy5yYWRpdXM7XG4gICAgdmVjMi5zZXQob3V0LnVwcGVyQm91bmQsICByLCAgcik7XG4gICAgdmVjMi5zZXQob3V0Lmxvd2VyQm91bmQsIC1yLCAtcik7XG4gICAgaWYocG9zaXRpb24pe1xuICAgICAgICB2ZWMyLmFkZChvdXQubG93ZXJCb3VuZCwgb3V0Lmxvd2VyQm91bmQsIHBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5hZGQob3V0LnVwcGVyQm91bmQsIG91dC51cHBlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgfVxufTtcblxufSx7XCIuLi9tYXRoL3ZlYzJcIjozMSxcIi4vU2hhcGVcIjo0NX1dLDM5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKVxuLCAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIHBvbHlrID0gX2RlcmVxXygnLi4vbWF0aC9wb2x5aycpXG4sICAgZGVjb21wID0gX2RlcmVxXygncG9seS1kZWNvbXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb252ZXg7XG5cbi8qKlxuICogQ29udmV4IHNoYXBlIGNsYXNzLlxuICogQGNsYXNzIENvbnZleFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICogQHBhcmFtIHtBcnJheX0gdmVydGljZXMgQW4gYXJyYXkgb2YgdmVydGljZXMgdGhhdCBzcGFuIHRoaXMgc2hhcGUuIFZlcnRpY2VzIGFyZSBnaXZlbiBpbiBjb3VudGVyLWNsb2Nrd2lzZSAoQ0NXKSBkaXJlY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXhlc10gQW4gYXJyYXkgb2YgdW5pdCBsZW5ndGggdmVjdG9ycywgcmVwcmVzZW50aW5nIHRoZSBzeW1tZXRyeSBheGVzIGluIHRoZSBjb252ZXguXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIENyZWF0ZSBhIGJveFxuICogICAgIHZhciB2ZXJ0aWNlcyA9IFtbLTEsLTFdLCBbMSwtMV0sIFsxLDFdLCBbLTEsMV1dO1xuICogICAgIHZhciBjb252ZXhTaGFwZSA9IG5ldyBDb252ZXgodmVydGljZXMpO1xuICogICAgIGJvZHkuYWRkU2hhcGUoY29udmV4U2hhcGUpO1xuICovXG5mdW5jdGlvbiBDb252ZXgodmVydGljZXMsIGF4ZXMpe1xuXG4gICAgLyoqXG4gICAgICogVmVydGljZXMgZGVmaW5lZCBpbiB0aGUgbG9jYWwgZnJhbWUuXG4gICAgICogQHByb3BlcnR5IHZlcnRpY2VzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudmVydGljZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEF4ZXMgZGVmaW5lZCBpbiB0aGUgbG9jYWwgZnJhbWUuXG4gICAgICogQHByb3BlcnR5IGF4ZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5heGVzID0gW107XG5cbiAgICAvLyBDb3B5IHRoZSB2ZXJ0c1xuICAgIGZvcih2YXIgaT0wOyBpPHZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgICAgICB2ZWMyLmNvcHkodix2ZXJ0aWNlc1tpXSk7XG4gICAgICAgIHRoaXMudmVydGljZXMucHVzaCh2KTtcbiAgICB9XG5cbiAgICBpZihheGVzKXtcbiAgICAgICAgLy8gQ29weSB0aGUgYXhlc1xuICAgICAgICBmb3IodmFyIGk9MDsgaSA8IGF4ZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGF4aXMgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgdmVjMi5jb3B5KGF4aXMsIGF4ZXNbaV0pO1xuICAgICAgICAgICAgdGhpcy5heGVzLnB1c2goYXhpcyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb25zdHJ1Y3QgYXhlcyBmcm9tIHRoZSB2ZXJ0ZXggZGF0YVxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgLy8gR2V0IHRoZSB3b3JsZCBlZGdlXG4gICAgICAgICAgICB2YXIgd29ybGRQb2ludDAgPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIHZhciB3b3JsZFBvaW50MSA9IHZlcnRpY2VzWyhpKzEpICUgdmVydGljZXMubGVuZ3RoXTtcblxuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IHZlYzIuY3JlYXRlKCk7XG4gICAgICAgICAgICB2ZWMyLnN1Yihub3JtYWwsIHdvcmxkUG9pbnQxLCB3b3JsZFBvaW50MCk7XG5cbiAgICAgICAgICAgIC8vIEdldCBub3JtYWwgLSBqdXN0IHJvdGF0ZSA5MCBkZWdyZWVzIHNpbmNlIHZlcnRpY2VzIGFyZSBnaXZlbiBpbiBDQ1dcbiAgICAgICAgICAgIHZlYzIucm90YXRlOTBjdyhub3JtYWwsIG5vcm1hbCk7XG4gICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShub3JtYWwsIG5vcm1hbCk7XG5cbiAgICAgICAgICAgIHRoaXMuYXhlcy5wdXNoKG5vcm1hbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2VudGVyIG9mIG1hc3Mgb2YgdGhlIENvbnZleFxuICAgICAqIEBwcm9wZXJ0eSBjZW50ZXJPZk1hc3NcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jZW50ZXJPZk1hc3MgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuICAgIC8qKlxuICAgICAqIFRyaWFuZ3VsYXRlZCB2ZXJzaW9uIG9mIHRoaXMgY29udmV4LiBUaGUgc3RydWN0dXJlIGlzIEFycmF5IG9mIDMtQXJyYXlzLCBhbmQgZWFjaCBzdWJhcnJheSBjb250YWlucyAzIGludGVnZXJzLCByZWZlcmVuY2luZyB0aGUgdmVydGljZXMuXG4gICAgICogQHByb3BlcnR5IHRyaWFuZ2xlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWFuZ2xlcyA9IFtdO1xuXG4gICAgaWYodGhpcy52ZXJ0aWNlcy5sZW5ndGgpe1xuICAgICAgICB0aGlzLnVwZGF0ZVRyaWFuZ2xlcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNlbnRlck9mTWFzcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBib3VuZGluZyByYWRpdXMgb2YgdGhlIGNvbnZleFxuICAgICAqIEBwcm9wZXJ0eSBib3VuZGluZ1JhZGl1c1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7XG5cbiAgICBTaGFwZS5jYWxsKHRoaXMsIFNoYXBlLkNPTlZFWCk7XG5cbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XG4gICAgdGhpcy51cGRhdGVBcmVhKCk7XG4gICAgaWYodGhpcy5hcmVhIDwgMCl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnZleCB2ZXJ0aWNlcyBtdXN0IGJlIGdpdmVuIGluIGNvbnRlci1jbG9ja3dpc2Ugd2luZGluZy5cIik7XG4gICAgfVxufVxuQ29udmV4LnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuQ29udmV4LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnZleDtcblxudmFyIHRtcFZlYzEgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHRtcFZlYzIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIFByb2plY3QgYSBDb252ZXggb250byBhIHdvcmxkLW9yaWVudGVkIGF4aXNcbiAqIEBtZXRob2QgcHJvamVjdE9udG9BeGlzXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gb2Zmc2V0XG4gKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxBeGlzXG4gKiBAcGFyYW0gIHtBcnJheX0gcmVzdWx0XG4gKi9cbkNvbnZleC5wcm90b3R5cGUucHJvamVjdE9udG9Mb2NhbEF4aXMgPSBmdW5jdGlvbihsb2NhbEF4aXMsIHJlc3VsdCl7XG4gICAgdmFyIG1heD1udWxsLFxuICAgICAgICBtaW49bnVsbCxcbiAgICAgICAgdixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGxvY2FsQXhpcyA9IHRtcFZlYzE7XG5cbiAgICAvLyBHZXQgcHJvamVjdGVkIHBvc2l0aW9uIG9mIGFsbCB2ZXJ0aWNlc1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMudmVydGljZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlc1tpXTtcbiAgICAgICAgdmFsdWUgPSB2ZWMyLmRvdCh2LCBsb2NhbEF4aXMpO1xuICAgICAgICBpZihtYXggPT09IG51bGwgfHwgdmFsdWUgPiBtYXgpe1xuICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYobWluID09PSBudWxsIHx8IHZhbHVlIDwgbWluKXtcbiAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYobWluID4gbWF4KXtcbiAgICAgICAgdmFyIHQgPSBtaW47XG4gICAgICAgIG1pbiA9IG1heDtcbiAgICAgICAgbWF4ID0gdDtcbiAgICB9XG5cbiAgICB2ZWMyLnNldChyZXN1bHQsIG1pbiwgbWF4KTtcbn07XG5cbkNvbnZleC5wcm90b3R5cGUucHJvamVjdE9udG9Xb3JsZEF4aXMgPSBmdW5jdGlvbihsb2NhbEF4aXMsIHNoYXBlT2Zmc2V0LCBzaGFwZUFuZ2xlLCByZXN1bHQpe1xuICAgIHZhciB3b3JsZEF4aXMgPSB0bXBWZWMyO1xuXG4gICAgdGhpcy5wcm9qZWN0T250b0xvY2FsQXhpcyhsb2NhbEF4aXMsIHJlc3VsdCk7XG5cbiAgICAvLyBQcm9qZWN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgYm9keSBvbnRvIHRoZSBheGlzIC0gbmVlZCB0byBhZGQgdGhpcyB0byB0aGUgcmVzdWx0XG4gICAgaWYoc2hhcGVBbmdsZSAhPT0gMCl7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkQXhpcywgbG9jYWxBeGlzLCBzaGFwZUFuZ2xlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3b3JsZEF4aXMgPSBsb2NhbEF4aXM7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSB2ZWMyLmRvdChzaGFwZU9mZnNldCwgd29ybGRBeGlzKTtcblxuICAgIHZlYzIuc2V0KHJlc3VsdCwgcmVzdWx0WzBdICsgb2Zmc2V0LCByZXN1bHRbMV0gKyBvZmZzZXQpO1xufTtcblxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgLnRyaWFuZ2xlcyBwcm9wZXJ0eVxuICogQG1ldGhvZCB1cGRhdGVUcmlhbmdsZXNcbiAqL1xuQ29udmV4LnByb3RvdHlwZS51cGRhdGVUcmlhbmdsZXMgPSBmdW5jdGlvbigpe1xuXG4gICAgdGhpcy50cmlhbmdsZXMubGVuZ3RoID0gMDtcblxuICAgIC8vIFJld3JpdGUgb24gcG9seWsgbm90YXRpb24sIGFycmF5IG9mIG51bWJlcnNcbiAgICB2YXIgcG9seWtWZXJ0cyA9IFtdO1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMudmVydGljZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdiA9IHRoaXMudmVydGljZXNbaV07XG4gICAgICAgIHBvbHlrVmVydHMucHVzaCh2WzBdLHZbMV0pO1xuICAgIH1cblxuICAgIC8vIFRyaWFuZ3VsYXRlXG4gICAgdmFyIHRyaWFuZ2xlcyA9IHBvbHlrLlRyaWFuZ3VsYXRlKHBvbHlrVmVydHMpO1xuXG4gICAgLy8gTG9vcCBvdmVyIGFsbCB0cmlhbmdsZXMsIGFkZCB0aGVpciBpbmVydGlhIGNvbnRyaWJ1dGlvbnMgdG8gSVxuICAgIGZvcih2YXIgaT0wOyBpPHRyaWFuZ2xlcy5sZW5ndGg7IGkrPTMpe1xuICAgICAgICB2YXIgaWQxID0gdHJpYW5nbGVzW2ldLFxuICAgICAgICAgICAgaWQyID0gdHJpYW5nbGVzW2krMV0sXG4gICAgICAgICAgICBpZDMgPSB0cmlhbmdsZXNbaSsyXTtcblxuICAgICAgICAvLyBBZGQgdG8gdHJpYW5nbGVzXG4gICAgICAgIHRoaXMudHJpYW5nbGVzLnB1c2goW2lkMSxpZDIsaWQzXSk7XG4gICAgfVxufTtcblxudmFyIHVwZGF0ZUNlbnRlck9mTWFzc19jZW50cm9pZCA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX2NlbnRyb2lkX3RpbWVzX21hc3MgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19hID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfYiA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX2MgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19hYyA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX2NhID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfY2IgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19uID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIC5jZW50ZXJPZk1hc3MgcHJvcGVydHkuXG4gKiBAbWV0aG9kIHVwZGF0ZUNlbnRlck9mTWFzc1xuICovXG5Db252ZXgucHJvdG90eXBlLnVwZGF0ZUNlbnRlck9mTWFzcyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHRyaWFuZ2xlcyA9IHRoaXMudHJpYW5nbGVzLFxuICAgICAgICB2ZXJ0cyA9IHRoaXMudmVydGljZXMsXG4gICAgICAgIGNtID0gdGhpcy5jZW50ZXJPZk1hc3MsXG4gICAgICAgIGNlbnRyb2lkID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2NlbnRyb2lkLFxuICAgICAgICBuID0gdXBkYXRlQ2VudGVyT2ZNYXNzX24sXG4gICAgICAgIGEgPSB1cGRhdGVDZW50ZXJPZk1hc3NfYSxcbiAgICAgICAgYiA9IHVwZGF0ZUNlbnRlck9mTWFzc19iLFxuICAgICAgICBjID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2MsXG4gICAgICAgIGFjID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2FjLFxuICAgICAgICBjYSA9IHVwZGF0ZUNlbnRlck9mTWFzc19jYSxcbiAgICAgICAgY2IgPSB1cGRhdGVDZW50ZXJPZk1hc3NfY2IsXG4gICAgICAgIGNlbnRyb2lkX3RpbWVzX21hc3MgPSB1cGRhdGVDZW50ZXJPZk1hc3NfY2VudHJvaWRfdGltZXNfbWFzcztcblxuICAgIHZlYzIuc2V0KGNtLDAsMCk7XG4gICAgdmFyIHRvdGFsQXJlYSA9IDA7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PXRyaWFuZ2xlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB0ID0gdHJpYW5nbGVzW2ldLFxuICAgICAgICAgICAgYSA9IHZlcnRzW3RbMF1dLFxuICAgICAgICAgICAgYiA9IHZlcnRzW3RbMV1dLFxuICAgICAgICAgICAgYyA9IHZlcnRzW3RbMl1dO1xuXG4gICAgICAgIHZlYzIuY2VudHJvaWQoY2VudHJvaWQsYSxiLGMpO1xuXG4gICAgICAgIC8vIEdldCBtYXNzIGZvciB0aGUgdHJpYW5nbGUgKGRlbnNpdHk9MSBpbiB0aGlzIGNhc2UpXG4gICAgICAgIC8vIGh0dHA6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy84MDE5OC9hcmVhLW9mLXRyaWFuZ2xlLXZpYS12ZWN0b3JzXG4gICAgICAgIHZhciBtID0gQ29udmV4LnRyaWFuZ2xlQXJlYShhLGIsYyk7XG4gICAgICAgIHRvdGFsQXJlYSArPSBtO1xuXG4gICAgICAgIC8vIEFkZCB0byBjZW50ZXIgb2YgbWFzc1xuICAgICAgICB2ZWMyLnNjYWxlKGNlbnRyb2lkX3RpbWVzX21hc3MsIGNlbnRyb2lkLCBtKTtcbiAgICAgICAgdmVjMi5hZGQoY20sIGNtLCBjZW50cm9pZF90aW1lc19tYXNzKTtcbiAgICB9XG5cbiAgICB2ZWMyLnNjYWxlKGNtLGNtLDEvdG90YWxBcmVhKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbWFzcyBtb21lbnQgb2YgaW5lcnRpYSBvZiB0aGUgQ29udmV4LlxuICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBzZWUgaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC90b3BpYy8zNDI4MjItbW9tZW50LW9mLWluZXJ0aWEtb2YtYS1wb2x5Z29uLTJkL1xuICovXG5Db252ZXgucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICB2YXIgZGVub20gPSAwLjAsXG4gICAgICAgIG51bWVyID0gMC4wLFxuICAgICAgICBOID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgZm9yKHZhciBqID0gTi0xLCBpID0gMDsgaSA8IE47IGogPSBpLCBpICsrKXtcbiAgICAgICAgdmFyIHAwID0gdGhpcy52ZXJ0aWNlc1tqXTtcbiAgICAgICAgdmFyIHAxID0gdGhpcy52ZXJ0aWNlc1tpXTtcbiAgICAgICAgdmFyIGEgPSBNYXRoLmFicyh2ZWMyLmNyb3NzTGVuZ3RoKHAwLHAxKSk7XG4gICAgICAgIHZhciBiID0gdmVjMi5kb3QocDEscDEpICsgdmVjMi5kb3QocDEscDApICsgdmVjMi5kb3QocDAscDApO1xuICAgICAgICBkZW5vbSArPSBhICogYjtcbiAgICAgICAgbnVtZXIgKz0gYTtcbiAgICB9XG4gICAgcmV0dXJuIChtYXNzIC8gNi4wKSAqIChkZW5vbSAvIG51bWVyKTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgLmJvdW5kaW5nUmFkaXVzIHByb3BlcnR5XG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXG4gKi9cbkNvbnZleC5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciB2ZXJ0cyA9IHRoaXMudmVydGljZXMsXG4gICAgICAgIHIyID0gMDtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09dmVydHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgbDIgPSB2ZWMyLnNxdWFyZWRMZW5ndGgodmVydHNbaV0pO1xuICAgICAgICBpZihsMiA+IHIyKXtcbiAgICAgICAgICAgIHIyID0gbDI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gTWF0aC5zcXJ0KHIyKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhcmVhIG9mIHRoZSB0cmlhbmdsZSBzcGFubmVkIGJ5IHRoZSB0aHJlZSBwb2ludHMgYSwgYiwgYy4gVGhlIGFyZWEgaXMgcG9zaXRpdmUgaWYgdGhlIHBvaW50cyBhcmUgZ2l2ZW4gaW4gY291bnRlci1jbG9ja3dpc2Ugb3JkZXIsIG90aGVyd2lzZSBuZWdhdGl2ZS5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgdHJpYW5nbGVBcmVhXG4gKiBAcGFyYW0ge0FycmF5fSBhXG4gKiBAcGFyYW0ge0FycmF5fSBiXG4gKiBAcGFyYW0ge0FycmF5fSBjXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkNvbnZleC50cmlhbmdsZUFyZWEgPSBmdW5jdGlvbihhLGIsYyl7XG4gICAgcmV0dXJuICgoKGJbMF0gLSBhWzBdKSooY1sxXSAtIGFbMV0pKS0oKGNbMF0gLSBhWzBdKSooYlsxXSAtIGFbMV0pKSkgKiAwLjU7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgLmFyZWFcbiAqIEBtZXRob2QgdXBkYXRlQXJlYVxuICovXG5Db252ZXgucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMudXBkYXRlVHJpYW5nbGVzKCk7XG4gICAgdGhpcy5hcmVhID0gMDtcblxuICAgIHZhciB0cmlhbmdsZXMgPSB0aGlzLnRyaWFuZ2xlcyxcbiAgICAgICAgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIGZvcih2YXIgaT0wOyBpIT09dHJpYW5nbGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHQgPSB0cmlhbmdsZXNbaV0sXG4gICAgICAgICAgICBhID0gdmVydHNbdFswXV0sXG4gICAgICAgICAgICBiID0gdmVydHNbdFsxXV0sXG4gICAgICAgICAgICBjID0gdmVydHNbdFsyXV07XG5cbiAgICAgICAgLy8gR2V0IG1hc3MgZm9yIHRoZSB0cmlhbmdsZSAoZGVuc2l0eT0xIGluIHRoaXMgY2FzZSlcbiAgICAgICAgdmFyIG0gPSBDb252ZXgudHJpYW5nbGVBcmVhKGEsYixjKTtcbiAgICAgICAgdGhpcy5hcmVhICs9IG07XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dFxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5Db252ZXgucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIG91dC5zZXRGcm9tUG9pbnRzKHRoaXMudmVydGljZXMsIHBvc2l0aW9uLCBhbmdsZSwgMCk7XG59O1xuXG59LHtcIi4uL21hdGgvcG9seWtcIjozMCxcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi9TaGFwZVwiOjQ1LFwicG9seS1kZWNvbXBcIjo1fV0sNDA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpXG4sICAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgICBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSGVpZ2h0ZmllbGQ7XG5cbi8qKlxuICogSGVpZ2h0ZmllbGQgc2hhcGUgY2xhc3MuIEhlaWdodCBkYXRhIGlzIGdpdmVuIGFzIGFuIGFycmF5LiBUaGVzZSBkYXRhIHBvaW50cyBhcmUgc3ByZWFkIG91dCBldmVubHkgd2l0aCBhIGRpc3RhbmNlIFwiZWxlbWVudFdpZHRoXCIuXG4gKiBAY2xhc3MgSGVpZ2h0ZmllbGRcbiAqIEBleHRlbmRzIFNoYXBlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgQW4gYXJyYXkgb2YgWSB2YWx1ZXMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gY29uc3RydWN0IHRoZSB0ZXJyYWluLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5WYWx1ZV0gTWluaW11bSB2YWx1ZSBvZiB0aGUgZGF0YSBwb2ludHMgaW4gdGhlIGRhdGEgYXJyYXkuIFdpbGwgYmUgY29tcHV0ZWQgYXV0b21hdGljYWxseSBpZiBub3QgZ2l2ZW4uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4VmFsdWVdIE1heGltdW0gdmFsdWUuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZWxlbWVudFdpZHRoPTAuMV0gV29ybGQgc3BhY2luZyBiZXR3ZWVuIHRoZSBkYXRhIHBvaW50cyBpbiBYIGRpcmVjdGlvbi5cbiAqIEB0b2RvIFNob3VsZCBiZSBwb3NzaWJsZSB0byB1c2UgYWxvbmcgYWxsIGF4ZXMsIG5vdCBqdXN0IHlcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIEdlbmVyYXRlIHNvbWUgaGVpZ2h0IGRhdGEgKHktdmFsdWVzKS5cbiAqICAgICB2YXIgZGF0YSA9IFtdO1xuICogICAgIGZvcih2YXIgaSA9IDA7IGkgPCAxMDAwOyBpKyspe1xuICogICAgICAgICB2YXIgeSA9IDAuNSAqIE1hdGguY29zKDAuMiAqIGkpO1xuICogICAgICAgICBkYXRhLnB1c2goeSk7XG4gKiAgICAgfVxuICpcbiAqICAgICAvLyBDcmVhdGUgdGhlIGhlaWdodGZpZWxkIHNoYXBlXG4gKiAgICAgdmFyIGhlaWdodGZpZWxkU2hhcGUgPSBuZXcgSGVpZ2h0ZmllbGQoZGF0YSwge1xuICogICAgICAgICBlbGVtZW50V2lkdGg6IDEgLy8gRGlzdGFuY2UgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBkaXJlY3Rpb25cbiAqICAgICB9KTtcbiAqICAgICB2YXIgaGVpZ2h0ZmllbGRCb2R5ID0gbmV3IEJvZHkoKTtcbiAqICAgICBoZWlnaHRmaWVsZEJvZHkuYWRkU2hhcGUoaGVpZ2h0ZmllbGRTaGFwZSk7XG4gKiAgICAgd29ybGQuYWRkQm9keShoZWlnaHRmaWVsZEJvZHkpO1xuICovXG5mdW5jdGlvbiBIZWlnaHRmaWVsZChkYXRhLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBtYXhWYWx1ZSA6IG51bGwsXG4gICAgICAgIG1pblZhbHVlIDogbnVsbCxcbiAgICAgICAgZWxlbWVudFdpZHRoIDogMC4xXG4gICAgfSk7XG5cbiAgICBpZihvcHRpb25zLm1pblZhbHVlID09PSBudWxsIHx8IG9wdGlvbnMubWF4VmFsdWUgPT09IG51bGwpe1xuICAgICAgICBvcHRpb25zLm1heFZhbHVlID0gZGF0YVswXTtcbiAgICAgICAgb3B0aW9ucy5taW5WYWx1ZSA9IGRhdGFbMF07XG4gICAgICAgIGZvcih2YXIgaT0wOyBpICE9PSBkYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciB2ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIGlmKHYgPiBvcHRpb25zLm1heFZhbHVlKXtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1heFZhbHVlID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHYgPCBvcHRpb25zLm1pblZhbHVlKXtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1pblZhbHVlID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIG51bWJlcnMsIG9yIGhlaWdodCB2YWx1ZXMsIHRoYXQgYXJlIHNwcmVhZCBvdXQgYWxvbmcgdGhlIHggYXhpcy5cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBkYXRhXG4gICAgICovXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcblxuICAgIC8qKlxuICAgICAqIE1heCB2YWx1ZSBvZiB0aGUgZGF0YVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhWYWx1ZVxuICAgICAqL1xuICAgIHRoaXMubWF4VmFsdWUgPSBvcHRpb25zLm1heFZhbHVlO1xuXG4gICAgLyoqXG4gICAgICogTWF4IHZhbHVlIG9mIHRoZSBkYXRhXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1pblZhbHVlXG4gICAgICovXG4gICAgdGhpcy5taW5WYWx1ZSA9IG9wdGlvbnMubWluVmFsdWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgZWFjaCBlbGVtZW50XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGVsZW1lbnRXaWR0aFxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudFdpZHRoID0gb3B0aW9ucy5lbGVtZW50V2lkdGg7XG5cbiAgICBTaGFwZS5jYWxsKHRoaXMsU2hhcGUuSEVJR0hURklFTEQpO1xufVxuSGVpZ2h0ZmllbGQucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIZWlnaHRmaWVsZDtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbkhlaWdodGZpZWxkLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgYXJlYSA9IDA7XG4gICAgZm9yKHZhciBpPTA7IGk8ZGF0YS5sZW5ndGgtMTsgaSsrKXtcbiAgICAgICAgYXJlYSArPSAoZGF0YVtpXStkYXRhW2krMV0pIC8gMiAqIHRoaXMuZWxlbWVudFdpZHRoO1xuICAgIH1cbiAgICB0aGlzLmFyZWEgPSBhcmVhO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIC8vIFVzZSB0aGUgbWF4IGRhdGEgcmVjdGFuZ2xlXG4gICAgb3V0LnVwcGVyQm91bmRbMF0gPSB0aGlzLmVsZW1lbnRXaWR0aCAqIHRoaXMuZGF0YS5sZW5ndGggKyBwb3NpdGlvblswXTtcbiAgICBvdXQudXBwZXJCb3VuZFsxXSA9IHRoaXMubWF4VmFsdWUgKyBwb3NpdGlvblsxXTtcbiAgICBvdXQubG93ZXJCb3VuZFswXSA9IHBvc2l0aW9uWzBdO1xuICAgIG91dC5sb3dlckJvdW5kWzFdID0gLU51bWJlci5NQVhfVkFMVUU7IC8vIEluZmluaXR5XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vdXRpbHMvVXRpbHNcIjo1MCxcIi4vU2hhcGVcIjo0NX1dLDQxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKVxuLCAgIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xuXG4vKipcbiAqIExpbmUgc2hhcGUgY2xhc3MuIFRoZSBsaW5lIHNoYXBlIGlzIGFsb25nIHRoZSB4IGRpcmVjdGlvbiwgYW5kIHN0cmV0Y2hlcyBmcm9tIFstbGVuZ3RoLzIsIDBdIHRvIFtsZW5ndGgvMiwwXS5cbiAqIEBjbGFzcyBMaW5lXG4gKiBAcGFyYW0ge051bWJlcn0gW2xlbmd0aD0xXSBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBsaW5lXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIExpbmUobGVuZ3RoKXtcblxuICAgIC8qKlxuICAgICAqIExlbmd0aCBvZiB0aGlzIGxpbmVcbiAgICAgKiBAcHJvcGVydHkgbGVuZ3RoXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aCB8fCAxO1xuXG4gICAgU2hhcGUuY2FsbCh0aGlzLFNoYXBlLkxJTkUpO1xufVxuTGluZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbkxpbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZTtcblxuTGluZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHJldHVybiBtYXNzICogTWF0aC5wb3codGhpcy5sZW5ndGgsMikgLyAxMjtcbn07XG5cbkxpbmUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gdGhpcy5sZW5ndGgvMjtcbn07XG5cbnZhciBwb2ludHMgPSBbdmVjMi5jcmVhdGUoKSx2ZWMyLmNyZWF0ZSgpXTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuTGluZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgdmFyIGwyID0gdGhpcy5sZW5ndGggLyAyO1xuICAgIHZlYzIuc2V0KHBvaW50c1swXSwgLWwyLCAgMCk7XG4gICAgdmVjMi5zZXQocG9pbnRzWzFdLCAgbDIsICAwKTtcbiAgICBvdXQuc2V0RnJvbVBvaW50cyhwb2ludHMscG9zaXRpb24sYW5nbGUsMCk7XG59O1xuXG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL1NoYXBlXCI6NDV9XSw0MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJylcbiwgICB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFydGljbGU7XG5cbi8qKlxuICogUGFydGljbGUgc2hhcGUgY2xhc3MuXG4gKiBAY2xhc3MgUGFydGljbGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU2hhcGVcbiAqL1xuZnVuY3Rpb24gUGFydGljbGUoKXtcbiAgICBTaGFwZS5jYWxsKHRoaXMsU2hhcGUuUEFSVElDTEUpO1xufVxuUGFydGljbGUucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5QYXJ0aWNsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJ0aWNsZTtcblxuUGFydGljbGUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICByZXR1cm4gMDsgLy8gQ2FuJ3Qgcm90YXRlIGEgcGFydGljbGVcbn07XG5cblBhcnRpY2xlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKG91dCwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICB2ZWMyLmNvcHkob3V0Lmxvd2VyQm91bmQsIHBvc2l0aW9uKTtcbiAgICB2ZWMyLmNvcHkob3V0LnVwcGVyQm91bmQsIHBvc2l0aW9uKTtcbn07XG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL1NoYXBlXCI6NDV9XSw0MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgU2hhcGUgPSAgX2RlcmVxXygnLi9TaGFwZScpXG4sICAgIHZlYzIgPSAgX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICAgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsYW5lO1xuXG4vKipcbiAqIFBsYW5lIHNoYXBlIGNsYXNzLiBUaGUgcGxhbmUgaXMgZmFjaW5nIGluIHRoZSBZIGRpcmVjdGlvbi5cbiAqIEBjbGFzcyBQbGFuZVxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQbGFuZSgpe1xuICAgIFNoYXBlLmNhbGwodGhpcyxTaGFwZS5QTEFORSk7XG59XG5QbGFuZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcblBsYW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsYW5lO1xuXG4vKipcbiAqIENvbXB1dGUgbW9tZW50IG9mIGluZXJ0aWFcbiAqIEBtZXRob2QgY29tcHV0ZU1vbWVudE9mSW5lcnRpYVxuICovXG5QbGFuZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHJldHVybiAwOyAvLyBQbGFuZSBpcyBpbmZpbml0ZS4gVGhlIGluZXJ0aWEgc2hvdWxkIHRoZXJlZm9yZSBiZSBpbmZpbnR5IGJ1dCBieSBjb252ZW50aW9uIHdlIHNldCAwIGhlcmVcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBib3VuZGluZyByYWRpdXNcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqL1xuUGxhbmUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuUGxhbmUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciBhID0gMCxcbiAgICAgICAgc2V0ID0gdmVjMi5zZXQ7XG4gICAgaWYodHlwZW9mKGFuZ2xlKSA9PT0gXCJudW1iZXJcIil7XG4gICAgICAgIGEgPSBhbmdsZSAlICgyKk1hdGguUEkpO1xuICAgIH1cblxuICAgIGlmKGEgPT09IDApe1xuICAgICAgICAvLyB5IGdvZXMgZnJvbSAtaW5mIHRvIDBcbiAgICAgICAgc2V0KG91dC5sb3dlckJvdW5kLCAtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICBzZXQob3V0LnVwcGVyQm91bmQsICBOdW1iZXIuTUFYX1ZBTFVFLCAgMCk7XG4gICAgfSBlbHNlIGlmKGEgPT09IE1hdGguUEkgLyAyKXtcbiAgICAgICAgLy8geCBnb2VzIGZyb20gMCB0byBpbmZcbiAgICAgICAgc2V0KG91dC5sb3dlckJvdW5kLCAwLCAtTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgIHNldChvdXQudXBwZXJCb3VuZCwgICAgICBOdW1iZXIuTUFYX1ZBTFVFLCAgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgfSBlbHNlIGlmKGEgPT09IE1hdGguUEkpe1xuICAgICAgICAvLyB5IGdvZXMgZnJvbSAwIHRvIGluZlxuICAgICAgICBzZXQob3V0Lmxvd2VyQm91bmQsIC1OdW1iZXIuTUFYX1ZBTFVFLCAwKTtcbiAgICAgICAgc2V0KG91dC51cHBlckJvdW5kLCAgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgfSBlbHNlIGlmKGEgPT09IDMqTWF0aC5QSS8yKXtcbiAgICAgICAgLy8geCBnb2VzIGZyb20gLWluZiB0byAwXG4gICAgICAgIHNldChvdXQubG93ZXJCb3VuZCwgLU51bWJlci5NQVhfVkFMVUUsICAgICAtTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgIHNldChvdXQudXBwZXJCb3VuZCwgIDAsICBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZXQgbWF4IGJvdW5kc1xuICAgICAgICBzZXQob3V0Lmxvd2VyQm91bmQsIC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgIHNldChvdXQudXBwZXJCb3VuZCwgIE51bWJlci5NQVhfVkFMVUUsICBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICB9XG5cbiAgICB2ZWMyLmFkZChvdXQubG93ZXJCb3VuZCwgb3V0Lmxvd2VyQm91bmQsIHBvc2l0aW9uKTtcbiAgICB2ZWMyLmFkZChvdXQudXBwZXJCb3VuZCwgb3V0LnVwcGVyQm91bmQsIHBvc2l0aW9uKTtcbn07XG5cblBsYW5lLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmFyZWEgPSBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vdXRpbHMvVXRpbHNcIjo1MCxcIi4vU2hhcGVcIjo0NX1dLDQ0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKVxuLCAgIENvbnZleCA9IF9kZXJlcV8oJy4vQ29udmV4Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVjdGFuZ2xlO1xuXG4vKipcbiAqIFJlY3RhbmdsZSBzaGFwZSBjbGFzcy5cbiAqIEBjbGFzcyBSZWN0YW5nbGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aD0xXSBXaWR0aFxuICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9MV0gSGVpZ2h0XG4gKiBAZXh0ZW5kcyBDb252ZXhcbiAqL1xuZnVuY3Rpb24gUmVjdGFuZ2xlKHdpZHRoLCBoZWlnaHQpe1xuXG4gICAgLyoqXG4gICAgICogVG90YWwgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwcm9wZXJ0eSB3aWR0aFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDE7XG5cbiAgICAvKipcbiAgICAgKiBUb3RhbCBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG5cbiAgICB2YXIgdmVydHMgPSBbICAgdmVjMi5mcm9tVmFsdWVzKC13aWR0aC8yLCAtaGVpZ2h0LzIpLFxuICAgICAgICAgICAgICAgICAgICB2ZWMyLmZyb21WYWx1ZXMoIHdpZHRoLzIsIC1oZWlnaHQvMiksXG4gICAgICAgICAgICAgICAgICAgIHZlYzIuZnJvbVZhbHVlcyggd2lkdGgvMiwgIGhlaWdodC8yKSxcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5mcm9tVmFsdWVzKC13aWR0aC8yLCAgaGVpZ2h0LzIpXTtcbiAgICB2YXIgYXhlcyA9IFt2ZWMyLmZyb21WYWx1ZXMoMSwgMCksIHZlYzIuZnJvbVZhbHVlcygwLCAxKV07XG5cbiAgICBDb252ZXguY2FsbCh0aGlzLCB2ZXJ0cywgYXhlcyk7XG5cbiAgICB0aGlzLnR5cGUgPSBTaGFwZS5SRUNUQU5HTEU7XG59XG5SZWN0YW5nbGUucHJvdG90eXBlID0gbmV3IENvbnZleChbXSk7XG5SZWN0YW5nbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVjdGFuZ2xlO1xuXG4vKipcbiAqIENvbXB1dGUgbW9tZW50IG9mIGluZXJ0aWFcbiAqIEBtZXRob2QgY29tcHV0ZU1vbWVudE9mSW5lcnRpYVxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblJlY3RhbmdsZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHZhciB3ID0gdGhpcy53aWR0aCxcbiAgICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuICAgIHJldHVybiBtYXNzICogKGgqaCArIHcqdykgLyAxMjtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBib3VuZGluZyByYWRpdXNcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqL1xuUmVjdGFuZ2xlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHcgPSB0aGlzLndpZHRoLFxuICAgICAgICBoID0gdGhpcy5oZWlnaHQ7XG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IE1hdGguc3FydCh3KncgKyBoKmgpIC8gMjtcbn07XG5cbnZhciBjb3JuZXIxID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjb3JuZXIyID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjb3JuZXIzID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjb3JuZXI0ID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuUmVjdGFuZ2xlLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKG91dCwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICBvdXQuc2V0RnJvbVBvaW50cyh0aGlzLnZlcnRpY2VzLHBvc2l0aW9uLGFuZ2xlLDApO1xufTtcblxuUmVjdGFuZ2xlLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmFyZWEgPSB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG59O1xuXG5cbn0se1wiLi4vbWF0aC92ZWMyXCI6MzEsXCIuL0NvbnZleFwiOjM5LFwiLi9TaGFwZVwiOjQ1fV0sNDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBTaGFwZTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBzaGFwZXMuXG4gKiBAY2xhc3MgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGVcbiAqL1xuZnVuY3Rpb24gU2hhcGUodHlwZSl7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgc2hhcGUuIE9uZSBvZjpcbiAgICAgKlxuICAgICAqICoge3sjY3Jvc3NMaW5rIFwiU2hhcGUvQ0lSQ0xFOnByb3BlcnR5XCJ9fVNoYXBlLkNJUkNMRXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9QQVJUSUNMRTpwcm9wZXJ0eVwifX1TaGFwZS5QQVJUSUNMRXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9QTEFORTpwcm9wZXJ0eVwifX1TaGFwZS5QTEFORXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9DT05WRVg6cHJvcGVydHlcIn19U2hhcGUuQ09OVkVYe3svY3Jvc3NMaW5rfX1cbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL0xJTkU6cHJvcGVydHlcIn19U2hhcGUuTElORXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9SRUNUQU5HTEU6cHJvcGVydHlcIn19U2hhcGUuUkVDVEFOR0xFe3svY3Jvc3NMaW5rfX1cbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL0NBUFNVTEU6cHJvcGVydHlcIn19U2hhcGUuQ0FQU1VMRXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9IRUlHSFRGSUVMRDpwcm9wZXJ0eVwifX1TaGFwZS5IRUlHSFRGSUVMRHt7L2Nyb3NzTGlua319XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdHlwZVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBTaGFwZSBvYmplY3QgaWRlbnRpZmllci5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBTaGFwZS5pZENvdW50ZXIrKztcblxuICAgIC8qKlxuICAgICAqIEJvdW5kaW5nIGNpcmNsZSByYWRpdXMgb2YgdGhpcyBzaGFwZVxuICAgICAqIEBwcm9wZXJ0eSBib3VuZGluZ1JhZGl1c1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBDb2xsaXNpb24gZ3JvdXAgdGhhdCB0aGlzIHNoYXBlIGJlbG9uZ3MgdG8gKGJpdCBtYXNrKS4gU2VlIDxhIGhyZWY9XCJodHRwOi8vd3d3LmF1cmVsaWVucmlib24uY29tL2Jsb2cvMjAxMS8wNy9ib3gyZC10dXRvcmlhbC1jb2xsaXNpb24tZmlsdGVyaW5nL1wiPnRoaXMgdHV0b3JpYWw8L2E+LlxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaXNpb25Hcm91cFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gU2V0dXAgYml0cyBmb3IgZWFjaCBhdmFpbGFibGUgZ3JvdXBcbiAgICAgKiAgICAgdmFyIFBMQVlFUiA9IE1hdGgucG93KDIsMCksXG4gICAgICogICAgICAgICBFTkVNWSA9ICBNYXRoLnBvdygyLDEpLFxuICAgICAqICAgICAgICAgR1JPVU5EID0gTWF0aC5wb3coMiwyKVxuICAgICAqXG4gICAgICogICAgIC8vIFB1dCBzaGFwZXMgaW50byB0aGVpciBncm91cHNcbiAgICAgKiAgICAgcGxheWVyMVNoYXBlLmNvbGxpc2lvbkdyb3VwID0gUExBWUVSO1xuICAgICAqICAgICBwbGF5ZXIyU2hhcGUuY29sbGlzaW9uR3JvdXAgPSBQTEFZRVI7XG4gICAgICogICAgIGVuZW15U2hhcGUgIC5jb2xsaXNpb25Hcm91cCA9IEVORU1ZO1xuICAgICAqICAgICBncm91bmRTaGFwZSAuY29sbGlzaW9uR3JvdXAgPSBHUk9VTkQ7XG4gICAgICpcbiAgICAgKiAgICAgLy8gQXNzaWduIGdyb3VwcyB0aGF0IGVhY2ggc2hhcGUgY29sbGlkZSB3aXRoLlxuICAgICAqICAgICAvLyBOb3RlIHRoYXQgdGhlIHBsYXllcnMgY2FuIGNvbGxpZGUgd2l0aCBncm91bmQgYW5kIGVuZW1pZXMsIGJ1dCBub3Qgd2l0aCBvdGhlciBwbGF5ZXJzLlxuICAgICAqICAgICBwbGF5ZXIxU2hhcGUuY29sbGlzaW9uTWFzayA9IEVORU1ZIHwgR1JPVU5EO1xuICAgICAqICAgICBwbGF5ZXIyU2hhcGUuY29sbGlzaW9uTWFzayA9IEVORU1ZIHwgR1JPVU5EO1xuICAgICAqICAgICBlbmVteVNoYXBlICAuY29sbGlzaW9uTWFzayA9IFBMQVlFUiB8IEdST1VORDtcbiAgICAgKiAgICAgZ3JvdW5kU2hhcGUgLmNvbGxpc2lvbk1hc2sgPSBQTEFZRVIgfCBFTkVNWTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIEhvdyBjb2xsaXNpb24gY2hlY2sgaXMgZG9uZVxuICAgICAqICAgICBpZihzaGFwZUEuY29sbGlzaW9uR3JvdXAgJiBzaGFwZUIuY29sbGlzaW9uTWFzaykhPTAgJiYgKHNoYXBlQi5jb2xsaXNpb25Hcm91cCAmIHNoYXBlQS5jb2xsaXNpb25NYXNrKSE9MCl7XG4gICAgICogICAgICAgICAvLyBUaGUgc2hhcGVzIHdpbGwgY29sbGlkZVxuICAgICAqICAgICB9XG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25Hcm91cCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHByb2R1Y2UgY29udGFjdCBmb3JjZXMgd2hlbiBpbiBjb250YWN0IHdpdGggb3RoZXIgYm9kaWVzLiBOb3RlIHRoYXQgY29udGFjdHMgd2lsbCBiZSBnZW5lcmF0ZWQsIGJ1dCB0aGV5IHdpbGwgYmUgZGlzYWJsZWQuIFRoYXQgbWVhbnMgdGhhdCB0aGlzIHNoYXBlIHdpbGwgbW92ZSB0aHJvdWdoIG90aGVyIGJvZHkgc2hhcGVzLCBidXQgaXQgd2lsbCBzdGlsbCB0cmlnZ2VyIGNvbnRhY3QgZXZlbnRzLCBldGMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBjb2xsaXNpb25SZXNwb25zZVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQ29sbGlzaW9uIG1hc2sgb2YgdGhpcyBzaGFwZS4gU2VlIC5jb2xsaXNpb25Hcm91cC5cbiAgICAgKiBAcHJvcGVydHkgY29sbGlzaW9uTWFza1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25NYXNrID0gIDE7XG4gICAgaWYodHlwZSl7XG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXRlcmlhbCB0byB1c2UgaW4gY29sbGlzaW9ucyBmb3IgdGhpcyBTaGFwZS4gSWYgdGhpcyBpcyBzZXQgdG8gbnVsbCwgdGhlIHdvcmxkIHdpbGwgdXNlIGRlZmF1bHQgbWF0ZXJpYWwgcHJvcGVydGllcyBpbnN0ZWFkLlxuICAgICAqIEBwcm9wZXJ0eSBtYXRlcmlhbFxuICAgICAqIEB0eXBlIHtNYXRlcmlhbH1cbiAgICAgKi9cbiAgICB0aGlzLm1hdGVyaWFsID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEFyZWEgb2YgdGhpcyBzaGFwZS5cbiAgICAgKiBAcHJvcGVydHkgYXJlYVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hcmVhID0gMDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRoaXMgc2hhcGUgdG8gYmUgYSBzZW5zb3IuIEEgc2Vuc29yIGRvZXMgbm90IGdlbmVyYXRlIGNvbnRhY3RzLCBidXQgaXQgc3RpbGwgcmVwb3J0cyBjb250YWN0IGV2ZW50cy4gVGhpcyBpcyBnb29kIGlmIHlvdSB3YW50IHRvIGtub3cgaWYgYSBzaGFwZSBpcyBvdmVybGFwcGluZyBhbm90aGVyIHNoYXBlLCB3aXRob3V0IHRoZW0gZ2VuZXJhdGluZyBjb250YWN0cy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHNlbnNvclxuICAgICAqL1xuICAgIHRoaXMuc2Vuc29yID0gZmFsc2U7XG5cbiAgICB0aGlzLnVwZGF0ZUFyZWEoKTtcbn1cblxuU2hhcGUuaWRDb3VudGVyID0gMDtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gQ0lSQ0xFXG4gKi9cblNoYXBlLkNJUkNMRSA9ICAgICAgMTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gUEFSVElDTEVcbiAqL1xuU2hhcGUuUEFSVElDTEUgPSAgICAyO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBQTEFORVxuICovXG5TaGFwZS5QTEFORSA9ICAgICAgIDQ7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IENPTlZFWFxuICovXG5TaGFwZS5DT05WRVggPSAgICAgIDg7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IExJTkVcbiAqL1xuU2hhcGUuTElORSA9ICAgICAgICAxNjtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gUkVDVEFOR0xFXG4gKi9cblNoYXBlLlJFQ1RBTkdMRSA9ICAgMzI7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IENBUFNVTEVcbiAqL1xuU2hhcGUuQ0FQU1VMRSA9ICAgICA2NDtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gSEVJR0hURklFTERcbiAqL1xuU2hhcGUuSEVJR0hURklFTEQgPSAxMjg7XG5cbi8qKlxuICogU2hvdWxkIHJldHVybiB0aGUgbW9tZW50IG9mIGluZXJ0aWEgYXJvdW5kIHRoZSBaIGF4aXMgb2YgdGhlIGJvZHkgZ2l2ZW4gdGhlIHRvdGFsIG1hc3MuIFNlZSA8YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX21vbWVudHNfb2ZfaW5lcnRpYVwiPldpa2lwZWRpYSdzIGxpc3Qgb2YgbW9tZW50cyBvZiBpbmVydGlhPC9hPi5cbiAqIEBtZXRob2QgY29tcHV0ZU1vbWVudE9mSW5lcnRpYVxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IElmIHRoZSBpbmVydGlhIGlzIGluZmluaXR5IG9yIGlmIHRoZSBvYmplY3Qgc2ltcGx5IGlzbid0IHBvc3NpYmxlIHRvIHJvdGF0ZSwgcmV0dXJuIDAuXG4gKi9cblNoYXBlLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBTaGFwZS4uLlwiKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYm91bmRpbmcgY2lyY2xlIHJhZGl1cyBvZiB0aGlzIHNoYXBlLlxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5TaGFwZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNoYXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIFNoYXBlLi4uXCIpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIC5hcmVhIHByb3BlcnR5IG9mIHRoZSBzaGFwZS5cbiAqIEBtZXRob2QgdXBkYXRlQXJlYVxuICovXG5TaGFwZS5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gVG8gYmUgaW1wbGVtZW50ZWQgaW4gYWxsIHN1YmNsYXNzZXNcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgd29ybGQgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCAoQUFCQikgb2YgdGhpcyBzaGFwZS5cbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0ICAgICAgVGhlIHJlc3VsdGluZyBBQUJCLlxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5TaGFwZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgLy8gVG8gYmUgaW1wbGVtZW50ZWQgaW4gZWFjaCBzdWJjbGFzc1xufTtcblxufSx7fV0sNDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHZlYzIgPSBfZGVyZXFfKCcuLi9tYXRoL3ZlYzInKVxuLCAgIFNvbHZlciA9IF9kZXJlcV8oJy4vU29sdmVyJylcbiwgICBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJylcbiwgICBGcmljdGlvbkVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHU1NvbHZlcjtcblxuLyoqXG4gKiBJdGVyYXRpdmUgR2F1c3MtU2VpZGVsIGNvbnN0cmFpbnQgZXF1YXRpb24gc29sdmVyLlxuICpcbiAqIEBjbGFzcyBHU1NvbHZlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBTb2x2ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pdGVyYXRpb25zPTEwXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvbGVyYW5jZT0wXVxuICovXG5mdW5jdGlvbiBHU1NvbHZlcihvcHRpb25zKXtcbiAgICBTb2x2ZXIuY2FsbCh0aGlzLG9wdGlvbnMsU29sdmVyLkdTKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBkbyB3aGVuIHNvbHZpbmcuIE1vcmUgZ2l2ZXMgYmV0dGVyIHJlc3VsdHMsIGJ1dCBpcyBtb3JlIGV4cGVuc2l2ZS5cbiAgICAgKiBAcHJvcGVydHkgaXRlcmF0aW9uc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pdGVyYXRpb25zID0gb3B0aW9ucy5pdGVyYXRpb25zIHx8IDEwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVycm9yIHRvbGVyYW5jZSwgcGVyIGNvbnN0cmFpbnQuIElmIHRoZSB0b3RhbCBlcnJvciBpcyBiZWxvdyB0aGlzIGxpbWl0LCB0aGUgc29sdmVyIHdpbGwgc3RvcCBpdGVyYXRpbmcuIFNldCB0byB6ZXJvIGZvciBhcyBnb29kIHNvbHV0aW9uIGFzIHBvc3NpYmxlLCBidXQgdG8gc29tZXRoaW5nIGxhcmdlciB0aGFuIHplcm8gdG8gbWFrZSBjb21wdXRhdGlvbnMgZmFzdGVyLlxuICAgICAqIEBwcm9wZXJ0eSB0b2xlcmFuY2VcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudG9sZXJhbmNlID0gb3B0aW9ucy50b2xlcmFuY2UgfHwgMWUtMTA7XG5cbiAgICB0aGlzLmFycmF5U3RlcCA9IDMwO1xuICAgIHRoaXMubGFtYmRhID0gbmV3IFV0aWxzLkFSUkFZX1RZUEUodGhpcy5hcnJheVN0ZXApO1xuICAgIHRoaXMuQnMgPSAgICAgbmV3IFV0aWxzLkFSUkFZX1RZUEUodGhpcy5hcnJheVN0ZXApO1xuICAgIHRoaXMuaW52Q3MgPSAgbmV3IFV0aWxzLkFSUkFZX1RZUEUodGhpcy5hcnJheVN0ZXApO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gc2V0IGFsbCByaWdodCBoYW5kIHNpZGUgdGVybXMgdG8gemVybyB3aGVuIHNvbHZpbmcuIENhbiBiZSBoYW5keSBmb3IgYSBmZXcgYXBwbGljYXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSB1c2VaZXJvUkhTXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51c2VaZXJvUkhTID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2Ygc29sdmVyIGl0ZXJhdGlvbnMgdGhhdCBhcmUgZG9uZSB0byBhcHByb3hpbWF0ZSBub3JtYWwgZm9yY2VzLiBXaGVuIHRoZXNlIGl0ZXJhdGlvbnMgYXJlIGRvbmUsIGZyaWN0aW9uIGZvcmNlIHdpbGwgYmUgY29tcHV0ZWQgZnJvbSB0aGUgY29udGFjdCBub3JtYWwgZm9yY2VzLiBUaGVzZSBmcmljdGlvbiBmb3JjZXMgd2lsbCBvdmVycmlkZSBhbnkgb3RoZXIgZnJpY3Rpb24gZm9yY2VzIHNldCBmcm9tIHRoZSBXb3JsZCBmb3IgZXhhbXBsZS5cbiAgICAgKiBUaGUgc29sdmVyIHdpbGwgdXNlIGxlc3MgaXRlcmF0aW9ucyBpZiB0aGUgc29sdXRpb24gaXMgYmVsb3cgdGhlIC50b2xlcmFuY2UuXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uSXRlcmF0aW9uc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbkl0ZXJhdGlvbnMgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRoYXQgd2VyZSBtYWRlIGR1cmluZyB0aGUgbGFzdCBzb2x2ZS4gSWYgLnRvbGVyYW5jZSBpcyB6ZXJvLCB0aGlzIHZhbHVlIHdpbGwgYWx3YXlzIGJlIGVxdWFsIHRvIC5pdGVyYXRpb25zLCBidXQgaWYgLnRvbGVyYW5jZSBpcyBsYXJnZXIgdGhhbiB6ZXJvLCBhbmQgdGhlIHNvbHZlciBjYW4gcXVpdCBlYXJseSwgdGhlbiB0aGlzIG51bWJlciB3aWxsIGJlIHNvbWV3aGVyZSBiZXR3ZWVuIDEgYW5kIC5pdGVyYXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB1c2VkSXRlcmF0aW9uc1xuICAgICAqL1xuICAgIHRoaXMudXNlZEl0ZXJhdGlvbnMgPSAwO1xufVxuR1NTb2x2ZXIucHJvdG90eXBlID0gbmV3IFNvbHZlcigpO1xuR1NTb2x2ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR1NTb2x2ZXI7XG5cbmZ1bmN0aW9uIHNldEFycmF5WmVybyhhcnJheSl7XG4gICAgdmFyIGwgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgYXJyYXlbbF0gPSArMC4wO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTb2x2ZSB0aGUgc3lzdGVtIG9mIGVxdWF0aW9uc1xuICogQG1ldGhvZCBzb2x2ZVxuICogQHBhcmFtICB7TnVtYmVyfSAgaCAgICAgICBUaW1lIHN0ZXBcbiAqIEBwYXJhbSAge1dvcmxkfSAgIHdvcmxkICAgIFdvcmxkIHRvIHNvbHZlXG4gKi9cbkdTU29sdmVyLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uKGgsIHdvcmxkKXtcblxuICAgIHRoaXMuc29ydEVxdWF0aW9ucygpO1xuXG4gICAgdmFyIGl0ZXIgPSAwLFxuICAgICAgICBtYXhJdGVyID0gdGhpcy5pdGVyYXRpb25zLFxuICAgICAgICBtYXhGcmljdGlvbkl0ZXIgPSB0aGlzLmZyaWN0aW9uSXRlcmF0aW9ucyxcbiAgICAgICAgZXF1YXRpb25zID0gdGhpcy5lcXVhdGlvbnMsXG4gICAgICAgIE5lcSA9IGVxdWF0aW9ucy5sZW5ndGgsXG4gICAgICAgIHRvbFNxdWFyZWQgPSBNYXRoLnBvdyh0aGlzLnRvbGVyYW5jZSpOZXEsIDIpLFxuICAgICAgICBib2RpZXMgPSB3b3JsZC5ib2RpZXMsXG4gICAgICAgIE5ib2RpZXMgPSB3b3JsZC5ib2RpZXMubGVuZ3RoLFxuICAgICAgICBhZGQgPSB2ZWMyLmFkZCxcbiAgICAgICAgc2V0ID0gdmVjMi5zZXQsXG4gICAgICAgIHVzZVplcm9SSFMgPSB0aGlzLnVzZVplcm9SSFMsXG4gICAgICAgIGxhbWJkYSA9IHRoaXMubGFtYmRhO1xuXG4gICAgdGhpcy51c2VkSXRlcmF0aW9ucyA9IDA7XG5cbiAgICBpZihOZXEpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHNvbHZlIG1hc3NcbiAgICAgICAgICAgIGIudXBkYXRlU29sdmVNYXNzUHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpbmdzIHRoYXQgZG9lcyBub3QgY2hhbmdlIGR1cmluZyBpdGVyYXRpb24gY2FuIGJlIGNvbXB1dGVkIG9uY2VcbiAgICBpZihsYW1iZGEubGVuZ3RoIDwgTmVxKXtcbiAgICAgICAgbGFtYmRhID0gdGhpcy5sYW1iZGEgPSAgbmV3IFV0aWxzLkFSUkFZX1RZUEUoTmVxICsgdGhpcy5hcnJheVN0ZXApO1xuICAgICAgICB0aGlzLkJzID0gICAgICAgICAgICAgICBuZXcgVXRpbHMuQVJSQVlfVFlQRShOZXEgKyB0aGlzLmFycmF5U3RlcCk7XG4gICAgICAgIHRoaXMuaW52Q3MgPSAgICAgICAgICAgIG5ldyBVdGlscy5BUlJBWV9UWVBFKE5lcSArIHRoaXMuYXJyYXlTdGVwKTtcbiAgICB9XG4gICAgc2V0QXJyYXlaZXJvKGxhbWJkYSk7XG4gICAgdmFyIGludkNzID0gdGhpcy5pbnZDcyxcbiAgICAgICAgQnMgPSB0aGlzLkJzLFxuICAgICAgICBsYW1iZGEgPSB0aGlzLmxhbWJkYTtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09ZXF1YXRpb25zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGMgPSBlcXVhdGlvbnNbaV07XG4gICAgICAgIGlmKGMudGltZVN0ZXAgIT09IGggfHwgYy5uZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBjLnRpbWVTdGVwID0gaDtcbiAgICAgICAgICAgIGMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgQnNbaV0gPSAgICAgYy5jb21wdXRlQihjLmEsYy5iLGgpO1xuICAgICAgICBpbnZDc1tpXSA9ICBjLmNvbXB1dGVJbnZDKGMuZXBzaWxvbik7XG4gICAgfVxuXG4gICAgdmFyIHEsIEIsIGMsIGRlbHRhbGFtYmRhVG90LGksajtcblxuICAgIGlmKE5lcSAhPT0gMCl7XG5cbiAgICAgICAgZm9yKGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgLy8gUmVzZXQgdmxhbWJkYVxuICAgICAgICAgICAgYi5yZXNldENvbnN0cmFpbnRWZWxvY2l0eSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobWF4RnJpY3Rpb25JdGVyKXtcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBjb250YWN0IGVxdWF0aW9ucyB0byBnZXQgbm9ybWFsIGZvcmNlc1xuICAgICAgICAgICAgZm9yKGl0ZXI9MDsgaXRlciE9PW1heEZyaWN0aW9uSXRlcjsgaXRlcisrKXtcblxuICAgICAgICAgICAgICAgIC8vIEFjY3VtdWxhdGUgdGhlIHRvdGFsIGVycm9yIGZvciBlYWNoIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCA9IDAuMDtcblxuICAgICAgICAgICAgICAgIGZvcihqPTA7IGohPT1OZXE7IGorKyl7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBlcXVhdGlvbnNbal07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhbGFtYmRhID0gR1NTb2x2ZXIuaXRlcmF0ZUVxdWF0aW9uKGosYyxjLmVwc2lsb24sQnMsaW52Q3MsbGFtYmRhLHVzZVplcm9SSFMsaCxpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFsYW1iZGFUb3QgKz0gTWF0aC5hYnMoZGVsdGFsYW1iZGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMudXNlZEl0ZXJhdGlvbnMrKztcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0b3RhbCBlcnJvciBpcyBzbWFsbCBlbm91Z2ggLSBzdG9wIGl0ZXJhdGVcbiAgICAgICAgICAgICAgICBpZihkZWx0YWxhbWJkYVRvdCpkZWx0YWxhbWJkYVRvdCA8PSB0b2xTcXVhcmVkKXtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBHU1NvbHZlci51cGRhdGVNdWx0aXBsaWVycyhlcXVhdGlvbnMsIGxhbWJkYSwgMS9oKTtcblxuICAgICAgICAgICAgLy8gU2V0IGNvbXB1dGVkIGZyaWN0aW9uIGZvcmNlXG4gICAgICAgICAgICBmb3Ioaj0wOyBqIT09TmVxOyBqKyspe1xuICAgICAgICAgICAgICAgIHZhciBlcSA9IGVxdWF0aW9uc1tqXTtcbiAgICAgICAgICAgICAgICBpZihlcSBpbnN0YW5jZW9mIEZyaWN0aW9uRXF1YXRpb24pe1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBrPTA7IGshPT1lcS5jb250YWN0RXF1YXRpb25zLmxlbmd0aDsgaysrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgKz0gZXEuY29udGFjdEVxdWF0aW9uc1trXS5tdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGYgKj0gZXEuZnJpY3Rpb25Db2VmZmljaWVudCAvIGVxLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBlcS5tYXhGb3JjZSA9ICBmO1xuICAgICAgICAgICAgICAgICAgICBlcS5taW5Gb3JjZSA9IC1mO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgZXF1YXRpb25zXG4gICAgICAgIGZvcihpdGVyPTA7IGl0ZXIhPT1tYXhJdGVyOyBpdGVyKyspe1xuXG4gICAgICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSB0b3RhbCBlcnJvciBmb3IgZWFjaCBpdGVyYXRpb24uXG4gICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCA9IDAuMDtcblxuICAgICAgICAgICAgZm9yKGo9MDsgaiE9PU5lcTsgaisrKXtcbiAgICAgICAgICAgICAgICBjID0gZXF1YXRpb25zW2pdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhbGFtYmRhID0gR1NTb2x2ZXIuaXRlcmF0ZUVxdWF0aW9uKGosYyxjLmVwc2lsb24sQnMsaW52Q3MsbGFtYmRhLHVzZVplcm9SSFMsaCxpdGVyKTtcbiAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCArPSBNYXRoLmFicyhkZWx0YWxhbWJkYSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXNlZEl0ZXJhdGlvbnMrKztcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHRvdGFsIGVycm9yIGlzIHNtYWxsIGVub3VnaCAtIHN0b3AgaXRlcmF0ZVxuICAgICAgICAgICAgaWYoZGVsdGFsYW1iZGFUb3QqZGVsdGFsYW1iZGFUb3QgPD0gdG9sU3F1YXJlZCl7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgcmVzdWx0IHRvIHZlbG9jaXR5XG4gICAgICAgIGZvcihpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgYm9kaWVzW2ldLmFkZENvbnN0cmFpbnRWZWxvY2l0eSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgR1NTb2x2ZXIudXBkYXRlTXVsdGlwbGllcnMoZXF1YXRpb25zLCBsYW1iZGEsIDEvaCk7XG4gICAgfVxufTtcblxuLy8gU2V0cyB0aGUgLm11bHRpcGxpZXIgcHJvcGVydHkgb2YgZWFjaCBlcXVhdGlvblxuR1NTb2x2ZXIudXBkYXRlTXVsdGlwbGllcnMgPSBmdW5jdGlvbihlcXVhdGlvbnMsIGxhbWJkYSwgaW52RHQpe1xuICAgIC8vIFNldCB0aGUgLm11bHRpcGxpZXIgcHJvcGVydHkgb2YgZWFjaCBlcXVhdGlvblxuICAgIHZhciBsID0gZXF1YXRpb25zLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICBlcXVhdGlvbnNbbF0ubXVsdGlwbGllciA9IGxhbWJkYVtsXSAqIGludkR0O1xuICAgIH1cbn07XG5cbkdTU29sdmVyLml0ZXJhdGVFcXVhdGlvbiA9IGZ1bmN0aW9uKGosZXEsZXBzLEJzLGludkNzLGxhbWJkYSx1c2VaZXJvUkhTLGR0LGl0ZXIpe1xuICAgIC8vIENvbXB1dGUgaXRlcmF0aW9uXG4gICAgdmFyIEIgPSBCc1tqXSxcbiAgICAgICAgaW52QyA9IGludkNzW2pdLFxuICAgICAgICBsYW1iZGFqID0gbGFtYmRhW2pdLFxuICAgICAgICBHV2xhbWJkYSA9IGVxLmNvbXB1dGVHV2xhbWJkYSgpO1xuXG4gICAgdmFyIG1heEZvcmNlID0gZXEubWF4Rm9yY2UsXG4gICAgICAgIG1pbkZvcmNlID0gZXEubWluRm9yY2U7XG5cbiAgICBpZih1c2VaZXJvUkhTKXtcbiAgICAgICAgQiA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGRlbHRhbGFtYmRhID0gaW52QyAqICggQiAtIEdXbGFtYmRhIC0gZXBzICogbGFtYmRhaiApO1xuXG4gICAgLy8gQ2xhbXAgaWYgd2UgYXJlIG5vdCB3aXRoaW4gdGhlIG1pbi9tYXggaW50ZXJ2YWxcbiAgICB2YXIgbGFtYmRhal9wbHVzX2RlbHRhbGFtYmRhID0gbGFtYmRhaiArIGRlbHRhbGFtYmRhO1xuICAgIGlmKGxhbWJkYWpfcGx1c19kZWx0YWxhbWJkYSA8IG1pbkZvcmNlKmR0KXtcbiAgICAgICAgZGVsdGFsYW1iZGEgPSBtaW5Gb3JjZSpkdCAtIGxhbWJkYWo7XG4gICAgfSBlbHNlIGlmKGxhbWJkYWpfcGx1c19kZWx0YWxhbWJkYSA+IG1heEZvcmNlKmR0KXtcbiAgICAgICAgZGVsdGFsYW1iZGEgPSBtYXhGb3JjZSpkdCAtIGxhbWJkYWo7XG4gICAgfVxuICAgIGxhbWJkYVtqXSArPSBkZWx0YWxhbWJkYTtcbiAgICBlcS5hZGRUb1dsYW1iZGEoZGVsdGFsYW1iZGEpO1xuXG4gICAgcmV0dXJuIGRlbHRhbGFtYmRhO1xufTtcblxufSx7XCIuLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvblwiOjI0LFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi91dGlscy9VdGlsc1wiOjUwLFwiLi9Tb2x2ZXJcIjo0N31dLDQ3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJylcbiwgICBFdmVudEVtaXR0ZXIgPSBfZGVyZXFfKCcuLi9ldmVudHMvRXZlbnRFbWl0dGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU29sdmVyO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGNvbnN0cmFpbnQgc29sdmVycy5cbiAqIEBjbGFzcyBTb2x2ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmZ1bmN0aW9uIFNvbHZlcihvcHRpb25zLHR5cGUpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBlcXVhdGlvbnMgaW4gdGhlIHNvbHZlci5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBlcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBzb3J0IGFsbCBlcXVhdGlvbnMgYmVmb3JlIGVhY2ggc29sdmUuXG4gICAgICogQHByb3BlcnR5IGVxdWF0aW9uU29ydEZ1bmN0aW9uXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufGJvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5lcXVhdGlvblNvcnRGdW5jdGlvbiA9IG9wdGlvbnMuZXF1YXRpb25Tb3J0RnVuY3Rpb24gfHwgZmFsc2U7XG59XG5Tb2x2ZXIucHJvdG90eXBlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuU29sdmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbHZlcjtcblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgaW1wbGVtZW50ZWQgaW4gZWFjaCBzdWJjbGFzc1xuICogQG1ldGhvZCBzb2x2ZVxuICogQHBhcmFtICB7TnVtYmVyfSBkdFxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKi9cblNvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbihkdCx3b3JsZCl7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU29sdmVyLnNvbHZlIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzIVwiKTtcbn07XG5cbnZhciBtb2NrV29ybGQgPSB7Ym9kaWVzOltdfTtcblxuLyoqXG4gKiBTb2x2ZXMgYWxsIGNvbnN0cmFpbnRzIGluIGFuIGlzbGFuZC5cbiAqIEBtZXRob2Qgc29sdmVJc2xhbmRcbiAqIEBwYXJhbSAge051bWJlcn0gZHRcbiAqIEBwYXJhbSAge0lzbGFuZH0gaXNsYW5kXG4gKi9cblNvbHZlci5wcm90b3R5cGUuc29sdmVJc2xhbmQgPSBmdW5jdGlvbihkdCxpc2xhbmQpe1xuXG4gICAgdGhpcy5yZW1vdmVBbGxFcXVhdGlvbnMoKTtcblxuICAgIGlmKGlzbGFuZC5lcXVhdGlvbnMubGVuZ3RoKXtcbiAgICAgICAgLy8gQWRkIGVxdWF0aW9ucyB0byBzb2x2ZXJcbiAgICAgICAgdGhpcy5hZGRFcXVhdGlvbnMoaXNsYW5kLmVxdWF0aW9ucyk7XG4gICAgICAgIG1vY2tXb3JsZC5ib2RpZXMubGVuZ3RoID0gMDtcbiAgICAgICAgaXNsYW5kLmdldEJvZGllcyhtb2NrV29ybGQuYm9kaWVzKTtcblxuICAgICAgICAvLyBTb2x2ZVxuICAgICAgICBpZihtb2NrV29ybGQuYm9kaWVzLmxlbmd0aCl7XG4gICAgICAgICAgICB0aGlzLnNvbHZlKGR0LG1vY2tXb3JsZCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFNvcnQgYWxsIGVxdWF0aW9ucyB1c2luZyB0aGUgLmVxdWF0aW9uU29ydEZ1bmN0aW9uLiBTaG91bGQgYmUgY2FsbGVkIGJ5IHN1YmNsYXNzZXMgYmVmb3JlIHNvbHZpbmcuXG4gKiBAbWV0aG9kIHNvcnRFcXVhdGlvbnNcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5zb3J0RXF1YXRpb25zID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLmVxdWF0aW9uU29ydEZ1bmN0aW9uKXtcbiAgICAgICAgdGhpcy5lcXVhdGlvbnMuc29ydCh0aGlzLmVxdWF0aW9uU29ydEZ1bmN0aW9uKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBhbiBlcXVhdGlvbiB0byBiZSBzb2x2ZWQuXG4gKlxuICogQG1ldGhvZCBhZGRFcXVhdGlvblxuICogQHBhcmFtIHtFcXVhdGlvbn0gZXFcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5hZGRFcXVhdGlvbiA9IGZ1bmN0aW9uKGVxKXtcbiAgICBpZihlcS5lbmFibGVkKXtcbiAgICAgICAgdGhpcy5lcXVhdGlvbnMucHVzaChlcSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBZGQgZXF1YXRpb25zLiBTYW1lIGFzIC5hZGRFcXVhdGlvbiwgYnV0IHRoaXMgdGltZSB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXkgb2YgRXF1YXRpb25zXG4gKlxuICogQG1ldGhvZCBhZGRFcXVhdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVxc1xuICovXG5Tb2x2ZXIucHJvdG90eXBlLmFkZEVxdWF0aW9ucyA9IGZ1bmN0aW9uKGVxcyl7XG4gICAgLy9VdGlscy5hcHBlbmRBcnJheSh0aGlzLmVxdWF0aW9ucyxlcXMpO1xuICAgIGZvcih2YXIgaT0wLCBOPWVxcy5sZW5ndGg7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgZXEgPSBlcXNbaV07XG4gICAgICAgIGlmKGVxLmVuYWJsZWQpe1xuICAgICAgICAgICAgdGhpcy5lcXVhdGlvbnMucHVzaChlcSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBlcXVhdGlvbi5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUVxdWF0aW9uXG4gKiBAcGFyYW0ge0VxdWF0aW9ufSBlcVxuICovXG5Tb2x2ZXIucHJvdG90eXBlLnJlbW92ZUVxdWF0aW9uID0gZnVuY3Rpb24oZXEpe1xuICAgIHZhciBpID0gdGhpcy5lcXVhdGlvbnMuaW5kZXhPZihlcSk7XG4gICAgaWYoaSAhPT0gLTEpe1xuICAgICAgICB0aGlzLmVxdWF0aW9ucy5zcGxpY2UoaSwxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgY3VycmVudGx5IGFkZGVkIGVxdWF0aW9ucy5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUFsbEVxdWF0aW9uc1xuICovXG5Tb2x2ZXIucHJvdG90eXBlLnJlbW92ZUFsbEVxdWF0aW9ucyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5lcXVhdGlvbnMubGVuZ3RoPTA7XG59O1xuXG5Tb2x2ZXIuR1MgPSAxO1xuU29sdmVyLklTTEFORCA9IDI7XG5cbn0se1wiLi4vZXZlbnRzL0V2ZW50RW1pdHRlclwiOjI3LFwiLi4vdXRpbHMvVXRpbHNcIjo1MH1dLDQ4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBUdXBsZURpY3Rpb25hcnkgPSBfZGVyZXFfKCcuL1R1cGxlRGljdGlvbmFyeScpO1xudmFyIFV0aWxzID0gX2RlcmVxXygnLi9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE92ZXJsYXBLZWVwZXI7XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2Ygb3ZlcmxhcHMgaW4gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIHRoZSBsYXN0IHN0ZXAgc3RhdGUuXG4gKiBAY2xhc3MgT3ZlcmxhcEtlZXBlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE92ZXJsYXBLZWVwZXIoKSB7XG4gICAgdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZSA9IG5ldyBUdXBsZURpY3Rpb25hcnkoKTtcbiAgICB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlID0gbmV3IFR1cGxlRGljdGlvbmFyeSgpO1xuICAgIHRoaXMucmVjb3JkUG9vbCA9IFtdO1xuICAgIHRoaXMudG1wRGljdCA9IG5ldyBUdXBsZURpY3Rpb25hcnkoKTtcbiAgICB0aGlzLnRtcEFycmF5MSA9IFtdO1xufVxuXG4vKipcbiAqIFRpY2tzIG9uZSBzdGVwIGZvcndhcmQgaW4gdGltZS4gVGhpcyB3aWxsIG1vdmUgdGhlIGN1cnJlbnQgb3ZlcmxhcCBzdGF0ZSB0byB0aGUgXCJvbGRcIiBvdmVybGFwIHN0YXRlLCBhbmQgY3JlYXRlIGEgbmV3IG9uZSBhcyBjdXJyZW50LlxuICogQG1ldGhvZCB0aWNrXG4gKi9cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGFzdCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGU7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xuXG4gICAgLy8gU2F2ZSBvbGQgb2JqZWN0cyBpbnRvIHBvb2xcbiAgICB2YXIgbCA9IGxhc3Qua2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGtleSA9IGxhc3Qua2V5c1tsXTtcbiAgICAgICAgdmFyIGxhc3RPYmplY3QgPSBsYXN0LmdldEJ5S2V5KGtleSk7XG4gICAgICAgIHZhciBjdXJyZW50T2JqZWN0ID0gY3VycmVudC5nZXRCeUtleShrZXkpO1xuICAgICAgICBpZihsYXN0T2JqZWN0ICYmICFjdXJyZW50T2JqZWN0KXtcbiAgICAgICAgICAgIC8vIFRoZSByZWNvcmQgaXMgb25seSB1c2VkIGluIHRoZSBcImxhc3RcIiBkaWN0LCBhbmQgd2lsbCBiZSByZW1vdmVkLiBXZSBtaWdodCBhcyB3ZWxsIHBvb2wgaXQuXG4gICAgICAgICAgICB0aGlzLnJlY29yZFBvb2wucHVzaChsYXN0T2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENsZWFyIGxhc3Qgb2JqZWN0XG4gICAgbGFzdC5yZXNldCgpO1xuXG4gICAgLy8gVHJhbnNmZXIgZnJvbSBuZXcgb2JqZWN0IHRvIG9sZFxuICAgIGxhc3QuY29weShjdXJyZW50KTtcblxuICAgIC8vIENsZWFyIGN1cnJlbnQgb2JqZWN0XG4gICAgY3VycmVudC5yZXNldCgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldE92ZXJsYXBwaW5nXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IHNoYXBlQVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtCb2R5fSBzaGFwZUJcbiAqL1xuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuc2V0T3ZlcmxhcHBpbmcgPSBmdW5jdGlvbihib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKSB7XG4gICAgdmFyIGxhc3QgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlO1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZTtcblxuICAgIC8vIFN0b3JlIGN1cnJlbnQgY29udGFjdCBzdGF0ZVxuICAgIGlmKCFjdXJyZW50LmdldChzaGFwZUEuaWQsIHNoYXBlQi5pZCkpe1xuXG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZih0aGlzLnJlY29yZFBvb2wubGVuZ3RoKXtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLnJlY29yZFBvb2wucG9wKCk7XG4gICAgICAgICAgICBkYXRhLnNldChib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgT3ZlcmxhcEtlZXBlclJlY29yZChib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQuc2V0KHNoYXBlQS5pZCwgc2hhcGVCLmlkLCBkYXRhKTtcbiAgICB9XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXROZXdPdmVybGFwcyA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGlmZih0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlLCB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlLCByZXN1bHQpO1xufTtcblxuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0RW5kT3ZlcmxhcHMgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHJldHVybiB0aGlzLmdldERpZmYodGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZSwgdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZSwgcmVzdWx0KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBib2RpZXMgYXJlIGN1cnJlbnRseSBvdmVybGFwcGluZy5cbiAqIEBtZXRob2QgYm9kaWVzQXJlT3ZlcmxhcHBpbmdcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuYm9kaWVzQXJlT3ZlcmxhcHBpbmcgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpe1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZTtcbiAgICB2YXIgbCA9IGN1cnJlbnQua2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGtleSA9IGN1cnJlbnQua2V5c1tsXTtcbiAgICAgICAgdmFyIGRhdGEgPSBjdXJyZW50LmRhdGFba2V5XTtcbiAgICAgICAgaWYoKGRhdGEuYm9keUEgPT09IGJvZHlBICYmIGRhdGEuYm9keUIgPT09IGJvZHlCKSB8fCBkYXRhLmJvZHlBID09PSBib2R5QiAmJiBkYXRhLmJvZHlCID09PSBib2R5QSl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXREaWZmID0gZnVuY3Rpb24oZGljdEEsIGRpY3RCLCByZXN1bHQpe1xuICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgW107XG4gICAgdmFyIGxhc3QgPSBkaWN0QTtcbiAgICB2YXIgY3VycmVudCA9IGRpY3RCO1xuXG4gICAgcmVzdWx0Lmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgbCA9IGN1cnJlbnQua2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGtleSA9IGN1cnJlbnQua2V5c1tsXTtcbiAgICAgICAgdmFyIGRhdGEgPSBjdXJyZW50LmRhdGFba2V5XTtcblxuICAgICAgICBpZighZGF0YSl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSAnK2tleSsnIGhhZCBubyBkYXRhIScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3REYXRhID0gbGFzdC5kYXRhW2tleV07XG4gICAgICAgIGlmKCFsYXN0RGF0YSl7XG4gICAgICAgICAgICAvLyBOb3Qgb3ZlcmxhcHBpbmcgaW4gbGFzdCBzdGF0ZSwgYnV0IGluIGN1cnJlbnQuXG4gICAgICAgICAgICByZXN1bHQucHVzaChkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5pc05ld092ZXJsYXAgPSBmdW5jdGlvbihzaGFwZUEsIHNoYXBlQil7XG4gICAgdmFyIGlkQSA9IHNoYXBlQS5pZHwwLFxuICAgICAgICBpZEIgPSBzaGFwZUIuaWR8MDtcbiAgICB2YXIgbGFzdCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGU7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xuICAgIC8vIE5vdCBpbiBsYXN0IGJ1dCBpbiBuZXdcbiAgICByZXR1cm4gISEhbGFzdC5nZXQoaWRBLCBpZEIpICYmICEhY3VycmVudC5nZXQoaWRBLCBpZEIpO1xufTtcblxuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0TmV3Qm9keU92ZXJsYXBzID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB0aGlzLnRtcEFycmF5MS5sZW5ndGggPSAwO1xuICAgIHZhciBvdmVybGFwcyA9IHRoaXMuZ2V0TmV3T3ZlcmxhcHModGhpcy50bXBBcnJheTEpO1xuICAgIHJldHVybiB0aGlzLmdldEJvZHlEaWZmKG92ZXJsYXBzLCByZXN1bHQpO1xufTtcblxuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0RW5kQm9keU92ZXJsYXBzID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB0aGlzLnRtcEFycmF5MS5sZW5ndGggPSAwO1xuICAgIHZhciBvdmVybGFwcyA9IHRoaXMuZ2V0RW5kT3ZlcmxhcHModGhpcy50bXBBcnJheTEpO1xuICAgIHJldHVybiB0aGlzLmdldEJvZHlEaWZmKG92ZXJsYXBzLCByZXN1bHQpO1xufTtcblxuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0Qm9keURpZmYgPSBmdW5jdGlvbihvdmVybGFwcywgcmVzdWx0KXtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XG4gICAgdmFyIGFjY3VtdWxhdG9yID0gdGhpcy50bXBEaWN0O1xuXG4gICAgdmFyIGwgPSBvdmVybGFwcy5sZW5ndGg7XG5cbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIgZGF0YSA9IG92ZXJsYXBzW2xdO1xuXG4gICAgICAgIC8vIFNpbmNlIHdlIHVzZSBib2R5IGlkJ3MgZm9yIHRoZSBhY2N1bXVsYXRvciwgdGhlc2Ugd2lsbCBiZSBhIHN1YnNldCBvZiB0aGUgb3JpZ2luYWwgb25lXG4gICAgICAgIGFjY3VtdWxhdG9yLnNldChkYXRhLmJvZHlBLmlkfDAsIGRhdGEuYm9keUIuaWR8MCwgZGF0YSk7XG4gICAgfVxuXG4gICAgbCA9IGFjY3VtdWxhdG9yLmtleXMubGVuZ3RoO1xuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIHZhciBkYXRhID0gYWNjdW11bGF0b3IuZ2V0QnlLZXkoYWNjdW11bGF0b3Iua2V5c1tsXSk7XG4gICAgICAgIGlmKGRhdGEpe1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGF0YS5ib2R5QSwgZGF0YS5ib2R5Qik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY2N1bXVsYXRvci5yZXNldCgpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogT3ZlcmxhcCBkYXRhIGNvbnRhaW5lciBmb3IgdGhlIE92ZXJsYXBLZWVwZXJcbiAqIEBjbGFzcyBPdmVybGFwS2VlcGVyUmVjb3JkXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXG4gKi9cbmZ1bmN0aW9uIE92ZXJsYXBLZWVwZXJSZWNvcmQoYm9keUEsIHNoYXBlQSwgYm9keUIsIHNoYXBlQil7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtTaGFwZX0gc2hhcGVBXG4gICAgICovXG4gICAgdGhpcy5zaGFwZUEgPSBzaGFwZUE7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtTaGFwZX0gc2hhcGVCXG4gICAgICovXG4gICAgdGhpcy5zaGFwZUIgPSBzaGFwZUI7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtCb2R5fSBib2R5QVxuICAgICAqL1xuICAgIHRoaXMuYm9keUEgPSBib2R5QTtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlCXG4gICAgICovXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xufVxuXG4vKipcbiAqIFNldCB0aGUgZGF0YSBmb3IgdGhlIHJlY29yZFxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXG4gKi9cbk92ZXJsYXBLZWVwZXJSZWNvcmQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGJvZHlBLCBzaGFwZUEsIGJvZHlCLCBzaGFwZUIpe1xuICAgIE92ZXJsYXBLZWVwZXJSZWNvcmQuY2FsbCh0aGlzLCBib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKTtcbn07XG5cbn0se1wiLi9UdXBsZURpY3Rpb25hcnlcIjo0OSxcIi4vVXRpbHNcIjo1MH1dLDQ5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4vVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUdXBsZURpY3Rpb25hcnk7XG5cbi8qKlxuICogQGNsYXNzIFR1cGxlRGljdGlvbmFyeVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFR1cGxlRGljdGlvbmFyeSgpIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRhIHN0b3JhZ2VcbiAgICAgKiBAcHJvcGVydHkgZGF0YVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5kYXRhID0ge307XG5cbiAgICAvKipcbiAgICAgKiBLZXlzIHRoYXQgYXJlIGN1cnJlbnRseSB1c2VkLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGtleXNcbiAgICAgKi9cbiAgICB0aGlzLmtleXMgPSBbXTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBnaXZlbiB0d28gaW50ZWdlcnNcbiAqIEBtZXRob2QgZ2V0S2V5XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGlcbiAqIEBwYXJhbSAge251bWJlcn0galxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uKGlkMSwgaWQyKSB7XG4gICAgaWQxID0gaWQxfDA7XG4gICAgaWQyID0gaWQyfDA7XG5cbiAgICBpZiAoIChpZDF8MCkgPT09IChpZDJ8MCkgKXtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIHZhbGlkIGZvciB2YWx1ZXMgPCAyXjE2XG4gICAgcmV0dXJuICgoaWQxfDApID4gKGlkMnwwKSA/XG4gICAgICAgIChpZDEgPDwgMTYpIHwgKGlkMiAmIDB4RkZGRikgOlxuICAgICAgICAoaWQyIDw8IDE2KSB8IChpZDEgJiAweEZGRkYpKXwwXG4gICAgICAgIDtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBnZXRCeUtleVxuICogQHBhcmFtICB7TnVtYmVyfSBrZXlcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRCeUtleSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIGtleSA9IGtleXwwO1xuICAgIHJldHVybiB0aGlzLmRhdGFba2V5XTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBnZXRcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7TnVtYmVyfSBqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaSwgaikge1xuICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy5nZXRLZXkoaSwgaildO1xufTtcblxuLyoqXG4gKiBTZXQgYSB2YWx1ZS5cbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge051bWJlcn0galxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaSwgaiwgdmFsdWUpIHtcbiAgICBpZighdmFsdWUpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBkYXRhIVwiKTtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoaSwgaik7XG5cbiAgICAvLyBDaGVjayBpZiBrZXkgYWxyZWFkeSBleGlzdHNcbiAgICBpZighdGhpcy5kYXRhW2tleV0pe1xuICAgICAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YVtrZXldID0gdmFsdWU7XG5cbiAgICByZXR1cm4ga2V5O1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGRhdGEuXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAga2V5cyA9IHRoaXMua2V5cztcblxuICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKSB7XG4gICAgICAgIGRlbGV0ZSBkYXRhW2tleXNbbF1dO1xuICAgIH1cblxuICAgIGtleXMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogQ29weSBhbm90aGVyIFR1cGxlRGljdGlvbmFyeS4gTm90ZSB0aGF0IGFsbCBkYXRhIGluIHRoaXMgZGljdGlvbmFyeSB3aWxsIGJlIHJlbW92ZWQuXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSB7VHVwbGVEaWN0aW9uYXJ5fSBkaWN0IFRoZSBUdXBsZURpY3Rpb25hcnkgdG8gY29weSBpbnRvIHRoaXMgb25lLlxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihkaWN0KSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIFV0aWxzLmFwcGVuZEFycmF5KHRoaXMua2V5cywgZGljdC5rZXlzKTtcbiAgICB2YXIgbCA9IGRpY3Qua2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGtleSA9IGRpY3Qua2V5c1tsXTtcbiAgICAgICAgdGhpcy5kYXRhW2tleV0gPSBkaWN0LmRhdGFba2V5XTtcbiAgICB9XG59O1xuXG59LHtcIi4vVXRpbHNcIjo1MH1dLDUwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qIGdsb2JhbCBQMl9BUlJBWV9UWVBFICovXG5cbm1vZHVsZS5leHBvcnRzID0gVXRpbHM7XG5cbi8qKlxuICogTWlzYyB1dGlsaXR5IGZ1bmN0aW9uc1xuICogQGNsYXNzIFV0aWxzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVXRpbHMoKXt9XG5cbi8qKlxuICogQXBwZW5kIHRoZSB2YWx1ZXMgaW4gYXJyYXkgYiB0byB0aGUgYXJyYXkgYS4gU2VlIDxhIGhyZWY9XCJodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzNzQxMjYvaG93LXRvLWFwcGVuZC1hbi1hcnJheS10by1hbi1leGlzdGluZy1qYXZhc2NyaXB0LWFycmF5LzEzNzQxMzEjMTM3NDEzMVwiPnRoaXM8L2E+IGZvciBhbiBleHBsYW5hdGlvbi5cbiAqIEBtZXRob2QgYXBwZW5kQXJyYXlcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICovXG5VdGlscy5hcHBlbmRBcnJheSA9IGZ1bmN0aW9uKGEsYil7XG4gICAgaWYgKGIubGVuZ3RoIDwgMTUwMDAwKSB7XG4gICAgICAgIGEucHVzaC5hcHBseShhLCBiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYi5sZW5ndGg7IGkgIT09IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBhLnB1c2goYltpXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEdhcmJhZ2UgZnJlZSBBcnJheS5zcGxpY2UoKS4gRG9lcyBub3QgYWxsb2NhdGUgYSBuZXcgYXJyYXkuXG4gKiBAbWV0aG9kIHNwbGljZVxuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGhvd21hbnlcbiAqL1xuVXRpbHMuc3BsaWNlID0gZnVuY3Rpb24oYXJyYXksaW5kZXgsaG93bWFueSl7XG4gICAgaG93bWFueSA9IGhvd21hbnkgfHwgMTtcbiAgICBmb3IgKHZhciBpPWluZGV4LCBsZW49YXJyYXkubGVuZ3RoLWhvd21hbnk7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbaSArIGhvd21hbnldO1xuICAgIH1cbiAgICBhcnJheS5sZW5ndGggPSBsZW47XG59O1xuXG4vKipcbiAqIFRoZSBhcnJheSB0eXBlIHRvIHVzZSBmb3IgaW50ZXJuYWwgbnVtZXJpYyBjb21wdXRhdGlvbnMgdGhyb3VnaG91dCB0aGUgbGlicmFyeS4gRmxvYXQzMkFycmF5IGlzIHVzZWQgaWYgaXQgaXMgYXZhaWxhYmxlLCBidXQgZmFsbHMgYmFjayBvbiBBcnJheS4gSWYgeW91IHdhbnQgdG8gc2V0IGFycmF5IHR5cGUgbWFudWFsbHksIGluamVjdCBpdCB2aWEgdGhlIGdsb2JhbCB2YXJpYWJsZSBQMl9BUlJBWV9UWVBFLiBTZWUgZXhhbXBsZSBiZWxvdy5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IEFSUkFZX1RZUEVcbiAqIEBleGFtcGxlXG4gKiAgICAgPHNjcmlwdD5cbiAqICAgICAgICAgPCEtLSBJbmplY3QgeW91ciBwcmVmZXJyZWQgYXJyYXkgdHlwZSBiZWZvcmUgbG9hZGluZyBwMi5qcyAtLT5cbiAqICAgICAgICAgUDJfQVJSQVlfVFlQRSA9IEFycmF5O1xuICogICAgIDwvc2NyaXB0PlxuICogICAgIDxzY3JpcHQgc3JjPVwicDIuanNcIj48L3NjcmlwdD5cbiAqL1xuaWYodHlwZW9mIFAyX0FSUkFZX1RZUEUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgVXRpbHMuQVJSQVlfVFlQRSA9IFAyX0FSUkFZX1RZUEU7XG59IGVsc2UgaWYgKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKXtcbiAgICBVdGlscy5BUlJBWV9UWVBFID0gRmxvYXQzMkFycmF5O1xufSBlbHNlIHtcbiAgICBVdGlscy5BUlJBWV9UWVBFID0gQXJyYXk7XG59XG5cbi8qKlxuICogRXh0ZW5kIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIGFub3RoZXJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0gIHtvYmplY3R9IGFcbiAqIEBwYXJhbSAge29iamVjdH0gYlxuICovXG5VdGlscy5leHRlbmQgPSBmdW5jdGlvbihhLGIpe1xuICAgIGZvcih2YXIga2V5IGluIGIpe1xuICAgICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgfVxufTtcblxuLyoqXG4gKiBFeHRlbmQgYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZGVmYXVsdHNcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBvYmplY3QuIE1heSBiZSBmYWxzeTogaW4gdGhpcyBjYXNlLCBhIG5ldyBvYmplY3QgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKiBAcGFyYW0gIHtvYmplY3R9IGRlZmF1bHRzIEFuIG9iamVjdCBjb250YWluaW5nIGRlZmF1bHQgdmFsdWVzLlxuICogQHJldHVybiB7b2JqZWN0fSBUaGUgbW9kaWZpZWQgb3B0aW9ucyBvYmplY3QuXG4gKi9cblV0aWxzLmRlZmF1bHRzID0gZnVuY3Rpb24ob3B0aW9ucywgZGVmYXVsdHMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGZvcih2YXIga2V5IGluIGRlZmF1bHRzKXtcbiAgICAgICAgaWYoIShrZXkgaW4gb3B0aW9ucykpe1xuICAgICAgICAgICAgb3B0aW9uc1trZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5cbn0se31dLDUxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSXNsYW5kO1xuXG4vKipcbiAqIEFuIGlzbGFuZCBvZiBib2RpZXMgY29ubmVjdGVkIHdpdGggZXF1YXRpb25zLlxuICogQGNsYXNzIElzbGFuZFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIElzbGFuZCgpe1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBlcXVhdGlvbnMgaW4gdGhpcyBpc2xhbmQuXG4gICAgICogQHByb3BlcnR5IGVxdWF0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBib2RpZXMgaW4gdGhpcyBpc2xhbmQuXG4gICAgICogQHByb3BlcnR5IGJvZGllc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZGllcyA9IFtdO1xufVxuXG4vKipcbiAqIENsZWFuIHRoaXMgaXNsYW5kIGZyb20gYm9kaWVzIGFuZCBlcXVhdGlvbnMuXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cbklzbGFuZC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZXF1YXRpb25zLmxlbmd0aCA9IHRoaXMuYm9kaWVzLmxlbmd0aCA9IDA7XG59O1xuXG52YXIgYm9keUlkcyA9IFtdO1xuXG4vKipcbiAqIEdldCBhbGwgdW5pcXVlIGJvZGllcyBpbiB0aGlzIGlzbGFuZC5cbiAqIEBtZXRob2QgZ2V0Qm9kaWVzXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgQm9keVxuICovXG5Jc2xhbmQucHJvdG90eXBlLmdldEJvZGllcyA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgdmFyIGJvZGllcyA9IHJlc3VsdCB8fCBbXSxcbiAgICAgICAgZXFzID0gdGhpcy5lcXVhdGlvbnM7XG4gICAgYm9keUlkcy5sZW5ndGggPSAwO1xuICAgIGZvcih2YXIgaT0wOyBpIT09ZXFzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGVxID0gZXFzW2ldO1xuICAgICAgICBpZihib2R5SWRzLmluZGV4T2YoZXEuYm9keUEuaWQpPT09LTEpe1xuICAgICAgICAgICAgYm9kaWVzLnB1c2goZXEuYm9keUEpO1xuICAgICAgICAgICAgYm9keUlkcy5wdXNoKGVxLmJvZHlBLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZihib2R5SWRzLmluZGV4T2YoZXEuYm9keUIuaWQpPT09LTEpe1xuICAgICAgICAgICAgYm9kaWVzLnB1c2goZXEuYm9keUIpO1xuICAgICAgICAgICAgYm9keUlkcy5wdXNoKGVxLmJvZHlCLmlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm9kaWVzO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZW50aXJlIGlzbGFuZCB3YW50cyB0byBzbGVlcC5cbiAqIEBtZXRob2Qgd2FudHNUb1NsZWVwXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Jc2xhbmQucHJvdG90eXBlLndhbnRzVG9TbGVlcCA9IGZ1bmN0aW9uKCl7XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5ib2RpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYiA9IHRoaXMuYm9kaWVzW2ldO1xuICAgICAgICBpZihiLnR5cGUgPT09IEJvZHkuRFlOQU1JQyAmJiAhYi53YW50c1RvU2xlZXApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBNYWtlIGFsbCBib2RpZXMgaW4gdGhlIGlzbGFuZCBzbGVlcC5cbiAqIEBtZXRob2Qgc2xlZXBcbiAqL1xuSXNsYW5kLnByb3RvdHlwZS5zbGVlcCA9IGZ1bmN0aW9uKCl7XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5ib2RpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYiA9IHRoaXMuYm9kaWVzW2ldO1xuICAgICAgICBiLnNsZWVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxufSx7XCIuLi9vYmplY3RzL0JvZHlcIjozMn1dLDUyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciB2ZWMyID0gX2RlcmVxXygnLi4vbWF0aC92ZWMyJylcbiwgICBJc2xhbmQgPSBfZGVyZXFfKCcuL0lzbGFuZCcpXG4sICAgSXNsYW5kTm9kZSA9IF9kZXJlcV8oJy4vSXNsYW5kTm9kZScpXG4sICAgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElzbGFuZE1hbmFnZXI7XG5cbi8qKlxuICogU3BsaXRzIHRoZSBzeXN0ZW0gb2YgYm9kaWVzIGFuZCBlcXVhdGlvbnMgaW50byBpbmRlcGVuZGVudCBpc2xhbmRzXG4gKlxuICogQGNsYXNzIElzbGFuZE1hbmFnZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGV4dGVuZHMgU29sdmVyXG4gKi9cbmZ1bmN0aW9uIElzbGFuZE1hbmFnZXIob3B0aW9ucyl7XG5cbiAgICAvLyBQb29saW5nIG9mIG5vZGUgb2JqZWN0cyBzYXZlcyBzb21lIEdDIGxvYWRcbiAgICB0aGlzLl9ub2RlUG9vbCA9IFtdO1xuICAgIHRoaXMuX2lzbGFuZFBvb2wgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlcXVhdGlvbnMgdG8gc3BsaXQuIE1hbnVhbGx5IGZpbGwgdGhpcyBhcnJheSBiZWZvcmUgcnVubmluZyAuc3BsaXQoKS5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBlcXVhdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdGluZyB7eyNjcm9zc0xpbmsgXCJJc2xhbmRcIn19e3svY3Jvc3NMaW5rfX1zLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGlzbGFuZHNcbiAgICAgKi9cbiAgICB0aGlzLmlzbGFuZHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHRpbmcgZ3JhcGggbm9kZXMuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gbm9kZXNcbiAgICAgKi9cbiAgICB0aGlzLm5vZGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbm9kZSBxdWV1ZSwgdXNlZCB3aGVuIHRyYXZlcnNpbmcgdGhlIGdyYXBoIG9mIG5vZGVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gcXVldWVcbiAgICAgKi9cbiAgICB0aGlzLnF1ZXVlID0gW107XG59XG5cbi8qKlxuICogR2V0IGFuIHVudmlzaXRlZCBub2RlIGZyb20gYSBsaXN0IG9mIG5vZGVzLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZXRVbnZpc2l0ZWROb2RlXG4gKiBAcGFyYW0gIHtBcnJheX0gbm9kZXNcbiAqIEByZXR1cm4ge0lzbGFuZE5vZGV8Ym9vbGVhbn0gVGhlIG5vZGUgaWYgZm91bmQsIGVsc2UgZmFsc2UuXG4gKi9cbklzbGFuZE1hbmFnZXIuZ2V0VW52aXNpdGVkTm9kZSA9IGZ1bmN0aW9uKG5vZGVzKXtcbiAgICB2YXIgTm5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIGZvcih2YXIgaT0wOyBpIT09Tm5vZGVzOyBpKyspe1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZighbm9kZS52aXNpdGVkICYmIG5vZGUuYm9keS50eXBlID09PSBCb2R5LkRZTkFNSUMpe1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBWaXNpdCBhIG5vZGUuXG4gKiBAbWV0aG9kIHZpc2l0XG4gKiBAcGFyYW0gIHtJc2xhbmROb2RlfSBub2RlXG4gKiBAcGFyYW0gIHtBcnJheX0gYmRzXG4gKiBAcGFyYW0gIHtBcnJheX0gZXFzXG4gKi9cbklzbGFuZE1hbmFnZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKG5vZGUsYmRzLGVxcyl7XG4gICAgYmRzLnB1c2gobm9kZS5ib2R5KTtcbiAgICB2YXIgTmVxcyA9IG5vZGUuZXF1YXRpb25zLmxlbmd0aDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5lcXM7IGkrKyl7XG4gICAgICAgIHZhciBlcSA9IG5vZGUuZXF1YXRpb25zW2ldO1xuICAgICAgICBpZihlcXMuaW5kZXhPZihlcSkgPT09IC0xKXsgLy8gQWxyZWFkeSBhZGRlZD9cbiAgICAgICAgICAgIGVxcy5wdXNoKGVxKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogUnVucyB0aGUgc2VhcmNoIGFsZ29yaXRobSwgc3RhcnRpbmcgYXQgYSByb290IG5vZGUuIFRoZSByZXN1bHRpbmcgYm9kaWVzIGFuZCBlcXVhdGlvbnMgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIHByb3ZpZGVkIGFycmF5cy5cbiAqIEBtZXRob2QgYmZzXG4gKiBAcGFyYW0gIHtJc2xhbmROb2RlfSByb290IFRoZSBub2RlIHRvIHN0YXJ0IGZyb21cbiAqIEBwYXJhbSAge0FycmF5fSBiZHMgIEFuIGFycmF5IHRvIGFwcGVuZCByZXN1bHRpbmcgQm9kaWVzIHRvLlxuICogQHBhcmFtICB7QXJyYXl9IGVxcyAgQW4gYXJyYXkgdG8gYXBwZW5kIHJlc3VsdGluZyBFcXVhdGlvbnMgdG8uXG4gKi9cbklzbGFuZE1hbmFnZXIucHJvdG90eXBlLmJmcyA9IGZ1bmN0aW9uKHJvb3QsYmRzLGVxcyl7XG5cbiAgICAvLyBSZXNldCB0aGUgdmlzaXQgcXVldWVcbiAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlO1xuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBBZGQgcm9vdCBub2RlIHRvIHF1ZXVlXG4gICAgcXVldWUucHVzaChyb290KTtcbiAgICByb290LnZpc2l0ZWQgPSB0cnVlO1xuICAgIHRoaXMudmlzaXQocm9vdCxiZHMsZXFzKTtcblxuICAgIC8vIFByb2Nlc3MgYWxsIHF1ZXVlZCBub2Rlc1xuICAgIHdoaWxlKHF1ZXVlLmxlbmd0aCkge1xuXG4gICAgICAgIC8vIEdldCBuZXh0IG5vZGUgaW4gdGhlIHF1ZXVlXG4gICAgICAgIHZhciBub2RlID0gcXVldWUucG9wKCk7XG5cbiAgICAgICAgLy8gVmlzaXQgdW52aXNpdGVkIG5laWdoYm9yaW5nIG5vZGVzXG4gICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgd2hpbGUoKGNoaWxkID0gSXNsYW5kTWFuYWdlci5nZXRVbnZpc2l0ZWROb2RlKG5vZGUubmVpZ2hib3JzKSkpIHtcbiAgICAgICAgICAgIGNoaWxkLnZpc2l0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy52aXNpdChjaGlsZCxiZHMsZXFzKTtcblxuICAgICAgICAgICAgLy8gT25seSB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlIGlmIGl0J3MgZHluYW1pY1xuICAgICAgICAgICAgaWYoY2hpbGQuYm9keS50eXBlID09PSBCb2R5LkRZTkFNSUMpe1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBTcGxpdCB0aGUgd29ybGQgaW50byBpbmRlcGVuZGVudCBpc2xhbmRzLiBUaGUgcmVzdWx0IGlzIHN0b3JlZCBpbiAuaXNsYW5kcy5cbiAqIEBtZXRob2Qgc3BsaXRcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHJldHVybiB7QXJyYXl9IFRoZSBnZW5lcmF0ZWQgaXNsYW5kc1xuICovXG5Jc2xhbmRNYW5hZ2VyLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB2YXIgYm9kaWVzID0gd29ybGQuYm9kaWVzLFxuICAgICAgICBub2RlcyA9IHRoaXMubm9kZXMsXG4gICAgICAgIGVxdWF0aW9ucyA9IHRoaXMuZXF1YXRpb25zO1xuXG4gICAgLy8gTW92ZSBvbGQgbm9kZXMgdG8gdGhlIG5vZGUgcG9vbFxuICAgIHdoaWxlKG5vZGVzLmxlbmd0aCl7XG4gICAgICAgIHRoaXMuX25vZGVQb29sLnB1c2gobm9kZXMucG9wKCkpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBuZWVkZWQgbm9kZXMsIHJldXNlIGlmIHBvc3NpYmxlXG4gICAgZm9yKHZhciBpPTA7IGkhPT1ib2RpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZih0aGlzLl9ub2RlUG9vbC5sZW5ndGgpe1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9ub2RlUG9vbC5wb3AoKTtcbiAgICAgICAgICAgIG5vZGUucmVzZXQoKTtcbiAgICAgICAgICAgIG5vZGUuYm9keSA9IGJvZGllc1tpXTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBJc2xhbmROb2RlKGJvZGllc1tpXSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGNvbm5lY3Rpdml0eSBkYXRhLiBFYWNoIGVxdWF0aW9uIGNvbm5lY3RzIDIgYm9kaWVzLlxuICAgIGZvcih2YXIgaz0wOyBrIT09ZXF1YXRpb25zLmxlbmd0aDsgaysrKXtcbiAgICAgICAgdmFyIGVxPWVxdWF0aW9uc1trXSxcbiAgICAgICAgICAgIGk9Ym9kaWVzLmluZGV4T2YoZXEuYm9keUEpLFxuICAgICAgICAgICAgaj1ib2RpZXMuaW5kZXhPZihlcS5ib2R5QiksXG4gICAgICAgICAgICBuaT1ub2Rlc1tpXSxcbiAgICAgICAgICAgIG5qPW5vZGVzW2pdO1xuICAgICAgICBuaS5uZWlnaGJvcnMucHVzaChuaik7XG4gICAgICAgIG5qLm5laWdoYm9ycy5wdXNoKG5pKTtcbiAgICAgICAgbmkuZXF1YXRpb25zLnB1c2goZXEpO1xuICAgICAgICBuai5lcXVhdGlvbnMucHVzaChlcSk7XG4gICAgfVxuXG4gICAgLy8gTW92ZSBvbGQgaXNsYW5kcyB0byB0aGUgaXNsYW5kIHBvb2xcbiAgICB2YXIgaXNsYW5kcyA9IHRoaXMuaXNsYW5kcztcbiAgICB3aGlsZShpc2xhbmRzLmxlbmd0aCl7XG4gICAgICAgIHZhciBpc2xhbmQgPSBpc2xhbmRzLnBvcCgpO1xuICAgICAgICBpc2xhbmQucmVzZXQoKTtcbiAgICAgICAgdGhpcy5faXNsYW5kUG9vbC5wdXNoKGlzbGFuZCk7XG4gICAgfVxuXG4gICAgLy8gR2V0IGlzbGFuZHNcbiAgICB2YXIgY2hpbGQ7XG4gICAgd2hpbGUoKGNoaWxkID0gSXNsYW5kTWFuYWdlci5nZXRVbnZpc2l0ZWROb2RlKG5vZGVzKSkpe1xuXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaXNsYW5kXG4gICAgICAgIHZhciBpc2xhbmQgPSB0aGlzLl9pc2xhbmRQb29sLmxlbmd0aCA/IHRoaXMuX2lzbGFuZFBvb2wucG9wKCkgOiBuZXcgSXNsYW5kKCk7XG5cbiAgICAgICAgLy8gR2V0IGFsbCBlcXVhdGlvbnMgYW5kIGJvZGllcyBpbiB0aGlzIGlzbGFuZFxuICAgICAgICB0aGlzLmJmcyhjaGlsZCwgaXNsYW5kLmJvZGllcywgaXNsYW5kLmVxdWF0aW9ucyk7XG5cbiAgICAgICAgaXNsYW5kcy5wdXNoKGlzbGFuZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzbGFuZHM7XG59O1xuXG59LHtcIi4uL21hdGgvdmVjMlwiOjMxLFwiLi4vb2JqZWN0cy9Cb2R5XCI6MzIsXCIuL0lzbGFuZFwiOjUxLFwiLi9Jc2xhbmROb2RlXCI6NTN9XSw1MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IElzbGFuZE5vZGU7XG5cbi8qKlxuICogSG9sZHMgYSBib2R5IGFuZCBrZWVwcyB0cmFjayBvZiBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyBuZWVkZWQgZm9yIGdyYXBoIHRyYXZlcnNhbC5cbiAqIEBjbGFzcyBJc2xhbmROb2RlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICovXG5mdW5jdGlvbiBJc2xhbmROb2RlKGJvZHkpe1xuXG5cdC8qKlxuXHQgKiBUaGUgYm9keSB0aGF0IGlzIGNvbnRhaW5lZCBpbiB0aGlzIG5vZGUuXG5cdCAqIEBwcm9wZXJ0eSB7Qm9keX0gYm9keVxuXHQgKi9cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgLyoqXG4gICAgICogTmVpZ2hib3JpbmcgSXNsYW5kTm9kZXNcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBuZWlnaGJvcnNcbiAgICAgKi9cbiAgICB0aGlzLm5laWdoYm9ycyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRXF1YXRpb25zIGNvbm5lY3RlZCB0byB0aGlzIG5vZGUuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gZXF1YXRpb25zXG4gICAgICovXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoaXMgbm9kZSB3YXMgdmlzaXRpbmcgZHVyaW5nIHRoZSBncmFwaCB0cmF2ZXJzYWwuXG4gICAgICogQHByb3BlcnR5IHZpc2l0ZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnZpc2l0ZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBDbGVhbiB0aGlzIG5vZGUgZnJvbSBib2RpZXMgYW5kIGVxdWF0aW9ucy5cbiAqIEBtZXRob2QgcmVzZXRcbiAqL1xuSXNsYW5kTm9kZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZXF1YXRpb25zLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5uZWlnaGJvcnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnZpc2l0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJvZHkgPSBudWxsO1xufTtcblxufSx7fV0sNTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyogZ2xvYmFsIHBlcmZvcm1hbmNlICovXG4vKmpzaGludCAtVzAyMCAqL1xuXG52YXIgIEdTU29sdmVyID0gX2RlcmVxXygnLi4vc29sdmVyL0dTU29sdmVyJylcbiwgICAgU29sdmVyID0gX2RlcmVxXygnLi4vc29sdmVyL1NvbHZlcicpXG4sICAgIE5haXZlQnJvYWRwaGFzZSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2UnKVxuLCAgICBSYXkgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5JylcbiwgICAgdmVjMiA9IF9kZXJlcV8oJy4uL21hdGgvdmVjMicpXG4sICAgIENpcmNsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9DaXJjbGUnKVxuLCAgICBSZWN0YW5nbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvUmVjdGFuZ2xlJylcbiwgICAgQ29udmV4ID0gX2RlcmVxXygnLi4vc2hhcGVzL0NvbnZleCcpXG4sICAgIExpbmUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvTGluZScpXG4sICAgIFBsYW5lID0gX2RlcmVxXygnLi4vc2hhcGVzL1BsYW5lJylcbiwgICAgQ2Fwc3VsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9DYXBzdWxlJylcbiwgICAgUGFydGljbGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvUGFydGljbGUnKVxuLCAgICBFdmVudEVtaXR0ZXIgPSBfZGVyZXFfKCcuLi9ldmVudHMvRXZlbnRFbWl0dGVyJylcbiwgICAgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpXG4sICAgIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJylcbiwgICAgTGluZWFyU3ByaW5nID0gX2RlcmVxXygnLi4vb2JqZWN0cy9MaW5lYXJTcHJpbmcnKVxuLCAgICBNYXRlcmlhbCA9IF9kZXJlcV8oJy4uL21hdGVyaWFsL01hdGVyaWFsJylcbiwgICAgQ29udGFjdE1hdGVyaWFsID0gX2RlcmVxXygnLi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsJylcbiwgICAgRGlzdGFuY2VDb25zdHJhaW50ID0gX2RlcmVxXygnLi4vY29uc3RyYWludHMvRGlzdGFuY2VDb25zdHJhaW50JylcbiwgICAgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKVxuLCAgICBMb2NrQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50JylcbiwgICAgUmV2b2x1dGVDb25zdHJhaW50ID0gX2RlcmVxXygnLi4vY29uc3RyYWludHMvUmV2b2x1dGVDb25zdHJhaW50JylcbiwgICAgUHJpc21hdGljQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL1ByaXNtYXRpY0NvbnN0cmFpbnQnKVxuLCAgICBHZWFyQ29uc3RyYWludCA9IF9kZXJlcV8oJy4uL2NvbnN0cmFpbnRzL0dlYXJDb25zdHJhaW50JylcbiwgICAgcGtnID0gX2RlcmVxXygnLi4vLi4vcGFja2FnZS5qc29uJylcbiwgICAgQnJvYWRwaGFzZSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9Ccm9hZHBoYXNlJylcbiwgICAgU0FQQnJvYWRwaGFzZSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlJylcbiwgICAgTmFycm93cGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vTmFycm93cGhhc2UnKVxuLCAgICBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJylcbiwgICAgT3ZlcmxhcEtlZXBlciA9IF9kZXJlcV8oJy4uL3V0aWxzL092ZXJsYXBLZWVwZXInKVxuLCAgICBJc2xhbmRNYW5hZ2VyID0gX2RlcmVxXygnLi9Jc2xhbmRNYW5hZ2VyJylcbiwgICAgUm90YXRpb25hbFNwcmluZyA9IF9kZXJlcV8oJy4uL29iamVjdHMvUm90YXRpb25hbFNwcmluZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmxkO1xuXG5pZih0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnKXtcbiAgICBwZXJmb3JtYW5jZSA9IHt9O1xufVxuaWYoIXBlcmZvcm1hbmNlLm5vdyl7XG4gICAgdmFyIG5vd09mZnNldCA9IERhdGUubm93KCk7XG4gICAgaWYgKHBlcmZvcm1hbmNlLnRpbWluZyAmJiBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0KXtcbiAgICAgICAgbm93T2Zmc2V0ID0gcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydDtcbiAgICB9XG4gICAgcGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBub3dPZmZzZXQ7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGUgZHluYW1pY3Mgd29ybGQsIHdoZXJlIGFsbCBib2RpZXMgYW5kIGNvbnN0cmFpbnRzIGxpdmVzLlxuICpcbiAqIEBjbGFzcyBXb3JsZFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgW29wdGlvbnNdXG4gKiBAcGFyYW0ge1NvbHZlcn0gICAgICAgICAgW29wdGlvbnMuc29sdmVyXSAgICAgICAgICAgIERlZmF1bHRzIHRvIEdTU29sdmVyLlxuICogQHBhcmFtIHtBcnJheX0gICAgICAgICAgIFtvcHRpb25zLmdyYXZpdHldICAgICAgICAgICBEZWZhdWx0cyB0byBbMCwtOS43OF1cbiAqIEBwYXJhbSB7QnJvYWRwaGFzZX0gICAgICBbb3B0aW9ucy5icm9hZHBoYXNlXSAgICAgICAgRGVmYXVsdHMgdG8gTmFpdmVCcm9hZHBoYXNlXG4gKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMuaXNsYW5kU3BsaXQ9ZmFsc2VdXG4gKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMuZG9Qcm9maWxpbmc9ZmFsc2VdXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciB3b3JsZCA9IG5ldyBXb3JsZCh7XG4gKiAgICAgICAgIGdyYXZpdHk6IFswLCAtOS44MV0sXG4gKiAgICAgICAgIGJyb2FkcGhhc2U6IG5ldyBTQVBCcm9hZHBoYXNlKClcbiAqICAgICB9KTtcbiAqL1xuZnVuY3Rpb24gV29ybGQob3B0aW9ucyl7XG4gICAgRXZlbnRFbWl0dGVyLmFwcGx5KHRoaXMpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBBbGwgc3ByaW5ncyBpbiB0aGUgd29ybGQuIFRvIGFkZCBhIHNwcmluZyB0byB0aGUgd29ybGQsIHVzZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9hZGRTcHJpbmc6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHNwcmluZ3NcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5zcHJpbmdzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBBbGwgYm9kaWVzIGluIHRoZSB3b3JsZC4gVG8gYWRkIGEgYm9keSB0byB0aGUgd29ybGQsIHVzZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9hZGRCb2R5Om1ldGhvZFwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBib2RpZXNcbiAgICAgKi9cbiAgICB0aGlzLmJvZGllcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZWQgYm9keSBjb2xsaXNpb24gcGFpcnMuIFNlZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9kaXNhYmxlQm9keUNvbGxpc2lvbjptZXRob2RcIn19LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnNcbiAgICAgKi9cbiAgICB0aGlzLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc29sdmVyIHVzZWQgdG8gc2F0aXNmeSBjb25zdHJhaW50cyBhbmQgY29udGFjdHMuIERlZmF1bHQgaXMge3sjY3Jvc3NMaW5rIFwiR1NTb2x2ZXJcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IHtTb2x2ZXJ9IHNvbHZlclxuICAgICAqL1xuICAgIHRoaXMuc29sdmVyID0gb3B0aW9ucy5zb2x2ZXIgfHwgbmV3IEdTU29sdmVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFycm93cGhhc2UgdG8gdXNlIHRvIGdlbmVyYXRlIGNvbnRhY3RzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG5hcnJvd3BoYXNlXG4gICAgICogQHR5cGUge05hcnJvd3BoYXNlfVxuICAgICAqL1xuICAgIHRoaXMubmFycm93cGhhc2UgPSBuZXcgTmFycm93cGhhc2UodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaXNsYW5kIG1hbmFnZXIgb2YgdGhpcyB3b3JsZC5cbiAgICAgKiBAcHJvcGVydHkge0lzbGFuZE1hbmFnZXJ9IGlzbGFuZE1hbmFnZXJcbiAgICAgKi9cbiAgICB0aGlzLmlzbGFuZE1hbmFnZXIgPSBuZXcgSXNsYW5kTWFuYWdlcigpO1xuXG4gICAgLyoqXG4gICAgICogR3Jhdml0eSBpbiB0aGUgd29ybGQuIFRoaXMgaXMgYXBwbGllZCBvbiBhbGwgYm9kaWVzIGluIHRoZSBiZWdpbm5pbmcgb2YgZWFjaCBzdGVwKCkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZ3Jhdml0eVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmdyYXZpdHkgPSB2ZWMyLmZyb21WYWx1ZXMoMCwgLTkuNzgpO1xuICAgIGlmKG9wdGlvbnMuZ3Jhdml0eSl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmdyYXZpdHksIG9wdGlvbnMuZ3Jhdml0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR3Jhdml0eSB0byB1c2Ugd2hlbiBhcHByb3hpbWF0aW5nIHRoZSBmcmljdGlvbiBtYXggZm9yY2UgKG11Km1hc3MqZ3Jhdml0eSkuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyaWN0aW9uR3Jhdml0eVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25HcmF2aXR5ID0gdmVjMi5sZW5ndGgodGhpcy5ncmF2aXR5KSB8fCAxMDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IC5mcmljdGlvbkdyYXZpdHkgdG8gYmUgYXV0b21hdGljYWxseSBzZXQgdG8gdGhlIGxlbmd0aCBvZiAuZ3Jhdml0eS5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHVzZVdvcmxkR3Jhdml0eUFzRnJpY3Rpb25HcmF2aXR5XG4gICAgICovXG4gICAgdGhpcy51c2VXb3JsZEdyYXZpdHlBc0ZyaWN0aW9uR3Jhdml0eSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgbGVuZ3RoIG9mIC5ncmF2aXR5IGlzIHplcm8sIGFuZCAudXNlV29ybGRHcmF2aXR5QXNGcmljdGlvbkdyYXZpdHk9dHJ1ZSwgdGhlbiBzd2l0Y2ggdG8gdXNpbmcgLmZyaWN0aW9uR3Jhdml0eSBmb3IgZnJpY3Rpb24gaW5zdGVhZC4gVGhpcyBmYWxsYmFjayBpcyB1c2VmdWwgZm9yIGdyYXZpdHlsZXNzIGdhbWVzLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gdXNlRnJpY3Rpb25HcmF2aXR5T25aZXJvR3Jhdml0eVxuICAgICAqL1xuICAgIHRoaXMudXNlRnJpY3Rpb25HcmF2aXR5T25aZXJvR3Jhdml0eSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGRvIHRpbWluZyBtZWFzdXJlbWVudHMgZHVyaW5nIHRoZSBzdGVwKCkgb3Igbm90LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGRvUG9maWxpbmdcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmRvUHJvZmlsaW5nID0gb3B0aW9ucy5kb1Byb2ZpbGluZyB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEhvdyBtYW55IG1pbGxpc2VjY29uZHMgdGhlIGxhc3Qgc3RlcCgpIHRvb2suIFRoaXMgaXMgdXBkYXRlZCBlYWNoIHN0ZXAgaWYgLmRvUHJvZmlsaW5nIGlzIHNldCB0byB0cnVlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGxhc3RTdGVwVGltZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sYXN0U3RlcFRpbWUgPSAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYnJvYWRwaGFzZSBhbGdvcml0aG0gdG8gdXNlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJyb2FkcGhhc2VcbiAgICAgKiBAdHlwZSB7QnJvYWRwaGFzZX1cbiAgICAgKi9cbiAgICB0aGlzLmJyb2FkcGhhc2UgPSBvcHRpb25zLmJyb2FkcGhhc2UgfHwgbmV3IFNBUEJyb2FkcGhhc2UoKTtcbiAgICB0aGlzLmJyb2FkcGhhc2Uuc2V0V29ybGQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBVc2VyLWFkZGVkIGNvbnN0cmFpbnRzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbnN0cmFpbnRzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIER1bW15IGRlZmF1bHQgbWF0ZXJpYWwgaW4gdGhlIHdvcmxkLCB1c2VkIGluIC5kZWZhdWx0Q29udGFjdE1hdGVyaWFsXG4gICAgICogQHByb3BlcnR5IHtNYXRlcmlhbH0gZGVmYXVsdE1hdGVyaWFsXG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0TWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGNvbnRhY3QgbWF0ZXJpYWwgdG8gdXNlLCBpZiBubyBjb250YWN0IG1hdGVyaWFsIHdhcyBzZXQgZm9yIHRoZSBjb2xsaWRpbmcgbWF0ZXJpYWxzLlxuICAgICAqIEBwcm9wZXJ0eSB7Q29udGFjdE1hdGVyaWFsfSBkZWZhdWx0Q29udGFjdE1hdGVyaWFsXG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsID0gbmV3IENvbnRhY3RNYXRlcmlhbCh0aGlzLmRlZmF1bHRNYXRlcmlhbCx0aGlzLmRlZmF1bHRNYXRlcmlhbCk7XG5cbiAgICAvKipcbiAgICAgKiBGb3Iga2VlcGluZyB0cmFjayBvZiB3aGF0IHRpbWUgc3RlcCBzaXplIHdlIHVzZWQgbGFzdCBzdGVwXG4gICAgICogQHByb3BlcnR5IGxhc3RUaW1lU3RlcFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sYXN0VGltZVN0ZXAgPSAxLzYwO1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHkgc3ByaW5nIGZvcmNlcyBlYWNoIHN0ZXAuXG4gICAgICogQHByb3BlcnR5IGFwcGx5U3ByaW5nRm9yY2VzXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hcHBseVNwcmluZ0ZvcmNlcyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdG8gYXV0b21hdGljYWxseSBhcHBseSBib2R5IGRhbXBpbmcgZWFjaCBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSBhcHBseURhbXBpbmdcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmFwcGx5RGFtcGluZyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdG8gYXV0b21hdGljYWxseSBhcHBseSBncmF2aXR5IGVhY2ggc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgYXBwbHlHcmF2aXR5XG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hcHBseUdyYXZpdHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlL2Rpc2FibGUgY29uc3RyYWludCBzb2x2aW5nIGluIGVhY2ggc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgc29sdmVDb25zdHJhaW50c1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc29sdmVDb25zdHJhaW50cyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgQ29udGFjdE1hdGVyaWFscyBhZGRlZCB0byB0aGUgV29ybGQuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RNYXRlcmlhbHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0TWF0ZXJpYWxzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBXb3JsZCB0aW1lLlxuICAgICAqIEBwcm9wZXJ0eSB0aW1lXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWUgPSAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBJcyB0cnVlIGR1cmluZyB0aGUgc3RlcCgpLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc3RlcHBpbmdcbiAgICAgKi9cbiAgICB0aGlzLnN0ZXBwaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBCb2RpZXMgdGhhdCBhcmUgc2NoZWR1bGVkIHRvIGJlIHJlbW92ZWQgYXQgdGhlIGVuZCBvZiB0aGUgc3RlcC5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBib2RpZXNUb0JlUmVtb3ZlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5ib2RpZXNUb0JlUmVtb3ZlZCA9IFtdO1xuXG4gICAgdGhpcy5maXhlZFN0ZXBUaW1lID0gMC4wO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBlbmFibGUgaXNsYW5kIHNwbGl0dGluZy4gSXNsYW5kIHNwbGl0dGluZyBjYW4gYmUgYW4gYWR2YW50YWdlIGZvciBtYW55IHRoaW5ncywgaW5jbHVkaW5nIHNvbHZlciBwZXJmb3JtYW5jZS4gU2VlIHt7I2Nyb3NzTGluayBcIklzbGFuZE1hbmFnZXJcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc2xhbmRTcGxpdFxuICAgICAqL1xuICAgIHRoaXMuaXNsYW5kU3BsaXQgPSB0eXBlb2Yob3B0aW9ucy5pc2xhbmRTcGxpdCkhPT1cInVuZGVmaW5lZFwiID8gISFvcHRpb25zLmlzbGFuZFNwbGl0IDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byB0aGUgd29ybGQgdG8gZW1pdCB0aGUgXCJpbXBhY3RcIiBldmVudC4gVHVybmluZyB0aGlzIG9mZiBjb3VsZCBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgICAqIEBwcm9wZXJ0eSBlbWl0SW1wYWN0RXZlbnRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmVtaXRJbXBhY3RFdmVudCA9IHRydWU7XG5cbiAgICAvLyBJZCBjb3VudGVyc1xuICAgIHRoaXMuX2NvbnN0cmFpbnRJZENvdW50ZXIgPSAwO1xuICAgIHRoaXMuX2JvZHlJZENvdW50ZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgYWZ0ZXIgdGhlIHN0ZXAoKS5cbiAgICAgKiBAZXZlbnQgcG9zdFN0ZXBcbiAgICAgKi9cbiAgICB0aGlzLnBvc3RTdGVwRXZlbnQgPSB7XG4gICAgICAgIHR5cGUgOiBcInBvc3RTdGVwXCIsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBib2R5IGlzIGFkZGVkIHRvIHRoZSB3b3JsZC5cbiAgICAgKiBAZXZlbnQgYWRkQm9keVxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICAgICAqL1xuICAgIHRoaXMuYWRkQm9keUV2ZW50ID0ge1xuICAgICAgICB0eXBlIDogXCJhZGRCb2R5XCIsXG4gICAgICAgIGJvZHkgOiBudWxsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBib2R5IGlzIHJlbW92ZWQgZnJvbSB0aGUgd29ybGQuXG4gICAgICogQGV2ZW50IHJlbW92ZUJvZHlcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAgICAgKi9cbiAgICB0aGlzLnJlbW92ZUJvZHlFdmVudCA9IHtcbiAgICAgICAgdHlwZSA6IFwicmVtb3ZlQm9keVwiLFxuICAgICAgICBib2R5IDogbnVsbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgc3ByaW5nIGlzIGFkZGVkIHRvIHRoZSB3b3JsZC5cbiAgICAgKiBAZXZlbnQgYWRkU3ByaW5nXG4gICAgICogQHBhcmFtIHtTcHJpbmd9IHNwcmluZ1xuICAgICAqL1xuICAgIHRoaXMuYWRkU3ByaW5nRXZlbnQgPSB7XG4gICAgICAgIHR5cGUgOiBcImFkZFNwcmluZ1wiLFxuICAgICAgICBzcHJpbmcgOiBudWxsLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgZmlyc3QgY29udGFjdCBpcyBjcmVhdGVkIGJldHdlZW4gdHdvIGJvZGllcy4gVGhpcyBldmVudCBpcyBmaXJlZCBhZnRlciB0aGUgc3RlcCBoYXMgYmVlbiBkb25lLlxuICAgICAqIEBldmVudCBpbXBhY3RcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICAgICAqL1xuICAgIHRoaXMuaW1wYWN0RXZlbnQgPSB7XG4gICAgICAgIHR5cGU6IFwiaW1wYWN0XCIsXG4gICAgICAgIGJvZHlBIDogbnVsbCxcbiAgICAgICAgYm9keUIgOiBudWxsLFxuICAgICAgICBzaGFwZUEgOiBudWxsLFxuICAgICAgICBzaGFwZUIgOiBudWxsLFxuICAgICAgICBjb250YWN0RXF1YXRpb24gOiBudWxsLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBhZnRlciB0aGUgQnJvYWRwaGFzZSBoYXMgY29sbGVjdGVkIGNvbGxpc2lvbiBwYWlycyBpbiB0aGUgd29ybGQuXG4gICAgICogSW5zaWRlIHRoZSBldmVudCBoYW5kbGVyLCB5b3UgY2FuIG1vZGlmeSB0aGUgcGFpcnMgYXJyYXkgYXMgeW91IGxpa2UsIHRvXG4gICAgICogcHJldmVudCBjb2xsaXNpb25zIGJldHdlZW4gb2JqZWN0cyB0aGF0IHlvdSBkb24ndCB3YW50LlxuICAgICAqIEBldmVudCBwb3N0QnJvYWRwaGFzZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIEFuIGFycmF5IG9mIGNvbGxpc2lvbiBwYWlycy4gSWYgdGhpcyBhcnJheSBpcyBbYm9keTEsYm9keTIsYm9keTMsYm9keTRdLCB0aGVuIHRoZSBib2R5IHBhaXJzIDEsMiBhbmQgMyw0IHdvdWxkIGFkdmFuY2UgdG8gbmFycm93cGhhc2UuXG4gICAgICovXG4gICAgdGhpcy5wb3N0QnJvYWRwaGFzZUV2ZW50ID0ge1xuICAgICAgICB0eXBlOlwicG9zdEJyb2FkcGhhc2VcIixcbiAgICAgICAgcGFpcnM6bnVsbCxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSG93IHRvIGRlYWN0aXZhdGUgYm9kaWVzIGR1cmluZyBzaW11bGF0aW9uLiBQb3NzaWJsZSBtb2RlcyBhcmU6IHt7I2Nyb3NzTGluayBcIldvcmxkL05PX1NMRUVQSU5HOnByb3BlcnR5XCJ9fVdvcmxkLk5PX1NMRUVQSU5He3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIldvcmxkL0JPRFlfU0xFRVBJTkc6cHJvcGVydHlcIn19V29ybGQuQk9EWV9TTEVFUElOR3t7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJXb3JsZC9JU0xBTkRfU0xFRVBJTkc6cHJvcGVydHlcIn19V29ybGQuSVNMQU5EX1NMRUVQSU5He3svY3Jvc3NMaW5rfX0uXG4gICAgICogSWYgc2xlZXBpbmcgaXMgZW5hYmxlZCwgeW91IG1pZ2h0IG5lZWQgdG8ge3sjY3Jvc3NMaW5rIFwiQm9keS93YWtlVXA6bWV0aG9kXCJ9fXdha2UgdXB7ey9jcm9zc0xpbmt9fSB0aGUgYm9kaWVzIGlmIHRoZXkgZmFsbCBhc2xlZXAgd2hlbiB0aGV5IHNob3VsZG4ndC4gSWYgeW91IHdhbnQgdG8gZW5hYmxlIHNsZWVwaW5nIGluIHRoZSB3b3JsZCwgYnV0IHdhbnQgdG8gZGlzYWJsZSBpdCBmb3IgYSBwYXJ0aWN1bGFyIGJvZHksIHNlZSB7eyNjcm9zc0xpbmsgXCJCb2R5L2FsbG93U2xlZXA6cHJvcGVydHlcIn19Qm9keS5hbGxvd1NsZWVwe3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IHNsZWVwTW9kZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgV29ybGQuTk9fU0xFRVBJTkdcbiAgICAgKi9cbiAgICB0aGlzLnNsZWVwTW9kZSA9IFdvcmxkLk5PX1NMRUVQSU5HO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0d28gc2hhcGVzIHN0YXJ0cyBzdGFydCB0byBvdmVybGFwLiBGaXJlZCBpbiB0aGUgbmFycm93cGhhc2UsIGR1cmluZyBzdGVwLlxuICAgICAqIEBldmVudCBiZWdpbkNvbnRhY3RcbiAgICAgKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUFcbiAgICAgKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUJcbiAgICAgKiBAcGFyYW0ge0JvZHl9ICBib2R5QVxuICAgICAqIEBwYXJhbSB7Qm9keX0gIGJvZHlCXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29udGFjdEVxdWF0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuYmVnaW5Db250YWN0RXZlbnQgPSB7XG4gICAgICAgIHR5cGU6XCJiZWdpbkNvbnRhY3RcIixcbiAgICAgICAgc2hhcGVBIDogbnVsbCxcbiAgICAgICAgc2hhcGVCIDogbnVsbCxcbiAgICAgICAgYm9keUEgOiBudWxsLFxuICAgICAgICBib2R5QiA6IG51bGwsXG4gICAgICAgIGNvbnRhY3RFcXVhdGlvbnMgOiBbXSxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0d28gc2hhcGVzIHN0b3Agb3ZlcmxhcHBpbmcsIGFmdGVyIHRoZSBuYXJyb3dwaGFzZSAoZHVyaW5nIHN0ZXApLlxuICAgICAqIEBldmVudCBlbmRDb250YWN0XG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVBXG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXG4gICAgICogQHBhcmFtIHtCb2R5fSAgYm9keUFcbiAgICAgKiBAcGFyYW0ge0JvZHl9ICBib2R5QlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbnRhY3RFcXVhdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmVuZENvbnRhY3RFdmVudCA9IHtcbiAgICAgICAgdHlwZTpcImVuZENvbnRhY3RcIixcbiAgICAgICAgc2hhcGVBIDogbnVsbCxcbiAgICAgICAgc2hhcGVCIDogbnVsbCxcbiAgICAgICAgYm9keUEgOiBudWxsLFxuICAgICAgICBib2R5QiA6IG51bGwsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGp1c3QgYmVmb3JlIGVxdWF0aW9ucyBhcmUgYWRkZWQgdG8gdGhlIHNvbHZlciB0byBiZSBzb2x2ZWQuIENhbiBiZSB1c2VkIHRvIGNvbnRyb2wgd2hhdCBlcXVhdGlvbnMgZ29lcyBpbnRvIHRoZSBzb2x2ZXIuXG4gICAgICogQGV2ZW50IHByZVNvbHZlXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29udGFjdEVxdWF0aW9ucyAgQW4gYXJyYXkgb2YgY29udGFjdHMgdG8gYmUgc29sdmVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZyaWN0aW9uRXF1YXRpb25zIEFuIGFycmF5IG9mIGZyaWN0aW9uIGVxdWF0aW9ucyB0byBiZSBzb2x2ZWQuXG4gICAgICovXG4gICAgdGhpcy5wcmVTb2x2ZUV2ZW50ID0ge1xuICAgICAgICB0eXBlOlwicHJlU29sdmVcIixcbiAgICAgICAgY29udGFjdEVxdWF0aW9uczpudWxsLFxuICAgICAgICBmcmljdGlvbkVxdWF0aW9uczpudWxsLFxuICAgIH07XG5cbiAgICAvLyBGb3Iga2VlcGluZyB0cmFjayBvZiBvdmVybGFwcGluZyBzaGFwZXNcbiAgICB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlID0geyBrZXlzOltdIH07XG4gICAgdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZSA9IHsga2V5czpbXSB9O1xuXG4gICAgdGhpcy5vdmVybGFwS2VlcGVyID0gbmV3IE92ZXJsYXBLZWVwZXIoKTtcbn1cbldvcmxkLnByb3RvdHlwZSA9IG5ldyBPYmplY3QoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5Xb3JsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXb3JsZDtcblxuLyoqXG4gKiBOZXZlciBkZWFjdGl2YXRlIGJvZGllcy5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBOT19TTEVFUElOR1xuICovXG5Xb3JsZC5OT19TTEVFUElORyA9IDE7XG5cbi8qKlxuICogRGVhY3RpdmF0ZSBpbmRpdmlkdWFsIGJvZGllcyBpZiB0aGV5IGFyZSBzbGVlcHkuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gQk9EWV9TTEVFUElOR1xuICovXG5Xb3JsZC5CT0RZX1NMRUVQSU5HID0gMjtcblxuLyoqXG4gKiBEZWFjdGl2YXRlcyBib2RpZXMgdGhhdCBhcmUgaW4gY29udGFjdCwgaWYgYWxsIG9mIHRoZW0gYXJlIHNsZWVweS4gTm90ZSB0aGF0IHlvdSBtdXN0IGVuYWJsZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9pc2xhbmRTcGxpdDpwcm9wZXJ0eVwifX0uaXNsYW5kU3BsaXR7ey9jcm9zc0xpbmt9fSBmb3IgdGhpcyB0byB3b3JrLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IElTTEFORF9TTEVFUElOR1xuICovXG5Xb3JsZC5JU0xBTkRfU0xFRVBJTkcgPSA0O1xuXG4vKipcbiAqIEFkZCBhIGNvbnN0cmFpbnQgdG8gdGhlIHNpbXVsYXRpb24uXG4gKlxuICogQG1ldGhvZCBhZGRDb25zdHJhaW50XG4gKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNcbiAqL1xuV29ybGQucHJvdG90eXBlLmFkZENvbnN0cmFpbnQgPSBmdW5jdGlvbihjKXtcbiAgICB0aGlzLmNvbnN0cmFpbnRzLnB1c2goYyk7XG59O1xuXG4vKipcbiAqIEFkZCBhIENvbnRhY3RNYXRlcmlhbCB0byB0aGUgc2ltdWxhdGlvbi5cbiAqIEBtZXRob2QgYWRkQ29udGFjdE1hdGVyaWFsXG4gKiBAcGFyYW0ge0NvbnRhY3RNYXRlcmlhbH0gY29udGFjdE1hdGVyaWFsXG4gKi9cbldvcmxkLnByb3RvdHlwZS5hZGRDb250YWN0TWF0ZXJpYWwgPSBmdW5jdGlvbihjb250YWN0TWF0ZXJpYWwpe1xuICAgIHRoaXMuY29udGFjdE1hdGVyaWFscy5wdXNoKGNvbnRhY3RNYXRlcmlhbCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBjb250YWN0IG1hdGVyaWFsXG4gKlxuICogQG1ldGhvZCByZW1vdmVDb250YWN0TWF0ZXJpYWxcbiAqIEBwYXJhbSB7Q29udGFjdE1hdGVyaWFsfSBjbVxuICovXG5Xb3JsZC5wcm90b3R5cGUucmVtb3ZlQ29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24oY20pe1xuICAgIHZhciBpZHggPSB0aGlzLmNvbnRhY3RNYXRlcmlhbHMuaW5kZXhPZihjbSk7XG4gICAgaWYoaWR4IT09LTEpe1xuICAgICAgICBVdGlscy5zcGxpY2UodGhpcy5jb250YWN0TWF0ZXJpYWxzLGlkeCwxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCBhIGNvbnRhY3QgbWF0ZXJpYWwgZ2l2ZW4gdHdvIG1hdGVyaWFsc1xuICogQG1ldGhvZCBnZXRDb250YWN0TWF0ZXJpYWxcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1hdGVyaWFsQVxuICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWxCXG4gKiBAcmV0dXJuIHtDb250YWN0TWF0ZXJpYWx9IFRoZSBtYXRjaGluZyBDb250YWN0TWF0ZXJpYWwsIG9yIGZhbHNlIG9uIGZhaWwuXG4gKiBAdG9kbyBVc2UgZmFzdGVyIGhhc2ggbWFwIHRvIGxvb2t1cCBmcm9tIG1hdGVyaWFsIGlkJ3NcbiAqL1xuV29ybGQucHJvdG90eXBlLmdldENvbnRhY3RNYXRlcmlhbCA9IGZ1bmN0aW9uKG1hdGVyaWFsQSxtYXRlcmlhbEIpe1xuICAgIHZhciBjbWF0cyA9IHRoaXMuY29udGFjdE1hdGVyaWFscztcbiAgICBmb3IodmFyIGk9MCwgTj1jbWF0cy5sZW5ndGg7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgY20gPSBjbWF0c1tpXTtcbiAgICAgICAgaWYoIChjbS5tYXRlcmlhbEEuaWQgPT09IG1hdGVyaWFsQS5pZCkgJiYgKGNtLm1hdGVyaWFsQi5pZCA9PT0gbWF0ZXJpYWxCLmlkKSB8fFxuICAgICAgICAgICAgKGNtLm1hdGVyaWFsQS5pZCA9PT0gbWF0ZXJpYWxCLmlkKSAmJiAoY20ubWF0ZXJpYWxCLmlkID09PSBtYXRlcmlhbEEuaWQpICl7XG4gICAgICAgICAgICByZXR1cm4gY207XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgY29uc3RyYWludFxuICpcbiAqIEBtZXRob2QgcmVtb3ZlQ29uc3RyYWludFxuICogQHBhcmFtIHtDb25zdHJhaW50fSBjXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yZW1vdmVDb25zdHJhaW50ID0gZnVuY3Rpb24oYyl7XG4gICAgdmFyIGlkeCA9IHRoaXMuY29uc3RyYWludHMuaW5kZXhPZihjKTtcbiAgICBpZihpZHghPT0tMSl7XG4gICAgICAgIFV0aWxzLnNwbGljZSh0aGlzLmNvbnN0cmFpbnRzLGlkeCwxKTtcbiAgICB9XG59O1xuXG52YXIgc3RlcF9yID0gdmVjMi5jcmVhdGUoKSxcbiAgICBzdGVwX3J1bml0ID0gdmVjMi5jcmVhdGUoKSxcbiAgICBzdGVwX3UgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHN0ZXBfZiA9IHZlYzIuY3JlYXRlKCksXG4gICAgc3RlcF9maE1pbnYgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHN0ZXBfdmVsb2R0ID0gdmVjMi5jcmVhdGUoKSxcbiAgICBzdGVwX21nID0gdmVjMi5jcmVhdGUoKSxcbiAgICB4aXcgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICB4ancgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICB6ZXJvID0gdmVjMi5mcm9tVmFsdWVzKDAsMCksXG4gICAgaW50ZXJwdmVsbyA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4vKipcbiAqIFN0ZXAgdGhlIHBoeXNpY3Mgd29ybGQgZm9yd2FyZCBpbiB0aW1lLlxuICpcbiAqIFRoZXJlIGFyZSB0d28gbW9kZXMuIFRoZSBzaW1wbGUgbW9kZSBpcyBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uLiBJbiB0aGlzIGNhc2UgeW91IG9ubHkgdXNlIHRoZSBmaXJzdCBhcmd1bWVudC4gVGhlIHNlY29uZCBjYXNlIHVzZXMgaW50ZXJwb2xhdGlvbi4gSW4gdGhhdCB5b3UgYWxzbyBwcm92aWRlIHRoZSB0aW1lIHNpbmNlIHRoZSBmdW5jdGlvbiB3YXMgbGFzdCB1c2VkLCBhcyB3ZWxsIGFzIHRoZSBtYXhpbXVtIGZpeGVkIHRpbWVzdGVwcyB0byB0YWtlLlxuICpcbiAqIEBtZXRob2Qgc3RlcFxuICogQHBhcmFtIHtOdW1iZXJ9IGR0ICAgICAgICAgICAgICAgICAgICAgICBUaGUgZml4ZWQgdGltZSBzdGVwIHNpemUgdG8gdXNlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lU2luY2VMYXN0Q2FsbGVkPTBdICBUaGUgdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBmdW5jdGlvbiB3YXMgbGFzdCBjYWxsZWQuXG4gKiBAcGFyYW0ge051bWJlcn0gW21heFN1YlN0ZXBzPTEwXSAgICAgICAgIE1heGltdW0gbnVtYmVyIG9mIGZpeGVkIHN0ZXBzIHRvIHRha2UgcGVyIGZ1bmN0aW9uIGNhbGwuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAvLyBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uXG4gKiAgICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKCk7XG4gKiAgICAgd29ybGQuc3RlcCgwLjAxKTtcbiAqXG4gKiBAc2VlIGh0dHA6Ly9idWxsZXRwaHlzaWNzLm9yZy9tZWRpYXdpa2ktMS41LjgvaW5kZXgucGhwL1N0ZXBwaW5nX1RoZV9Xb3JsZFxuICovXG5Xb3JsZC5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uKGR0LHRpbWVTaW5jZUxhc3RDYWxsZWQsbWF4U3ViU3RlcHMpe1xuICAgIG1heFN1YlN0ZXBzID0gbWF4U3ViU3RlcHMgfHwgMTA7XG4gICAgdGltZVNpbmNlTGFzdENhbGxlZCA9IHRpbWVTaW5jZUxhc3RDYWxsZWQgfHwgMDtcblxuICAgIGlmKHRpbWVTaW5jZUxhc3RDYWxsZWQgPT09IDApeyAvLyBGaXhlZCwgc2ltcGxlIHN0ZXBwaW5nXG5cbiAgICAgICAgdGhpcy5pbnRlcm5hbFN0ZXAoZHQpO1xuXG4gICAgICAgIC8vIEluY3JlbWVudCB0aW1lXG4gICAgICAgIHRoaXMudGltZSArPSBkdDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIGZpeGVkIHN0ZXBzIHdlIHNob3VsZCBoYXZlIHRha2VuIHNpbmNlIHRoZSBsYXN0IHN0ZXBcbiAgICAgICAgdmFyIGludGVybmFsU3RlcHMgPSBNYXRoLmZsb29yKCAodGhpcy50aW1lK3RpbWVTaW5jZUxhc3RDYWxsZWQpIC8gZHQpIC0gTWF0aC5mbG9vcih0aGlzLnRpbWUgLyBkdCk7XG4gICAgICAgIGludGVybmFsU3RlcHMgPSBNYXRoLm1pbihpbnRlcm5hbFN0ZXBzLG1heFN1YlN0ZXBzKTtcblxuICAgICAgICAvLyBEbyBzb21lIGZpeGVkIHN0ZXBzIHRvIGNhdGNoIHVwXG4gICAgICAgIHZhciB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PWludGVybmFsU3RlcHM7IGkrKyl7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsU3RlcChkdCk7XG4gICAgICAgICAgICBpZihwZXJmb3JtYW5jZS5ub3coKSAtIHQwID4gZHQqMTAwMCl7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIHNsb3dlciB0aGFuIHJlYWwtdGltZS4gQmV0dGVyIGJhaWwgb3V0LlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5jcmVtZW50IGludGVybmFsIGNsb2NrXG4gICAgICAgIHRoaXMudGltZSArPSB0aW1lU2luY2VMYXN0Q2FsbGVkO1xuXG4gICAgICAgIC8vIENvbXB1dGUgXCJMZWZ0IG92ZXJcIiB0aW1lIHN0ZXBcbiAgICAgICAgdmFyIGggPSB0aGlzLnRpbWUgJSBkdDtcbiAgICAgICAgdmFyIGhfZGl2X2R0ID0gaC9kdDtcblxuICAgICAgICBmb3IodmFyIGo9MDsgaiE9PXRoaXMuYm9kaWVzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5ib2RpZXNbal07XG4gICAgICAgICAgICBpZihiLnR5cGUgIT09IEJvZHkuU1RBVElDICYmIGIuc2xlZXBTdGF0ZSAhPT0gQm9keS5TTEVFUElORyl7XG4gICAgICAgICAgICAgICAgLy8gSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgICB2ZWMyLnN1YihpbnRlcnB2ZWxvLCBiLnBvc2l0aW9uLCBiLnByZXZpb3VzUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHZlYzIuc2NhbGUoaW50ZXJwdmVsbywgaW50ZXJwdmVsbywgaF9kaXZfZHQpO1xuICAgICAgICAgICAgICAgIHZlYzIuYWRkKGIuaW50ZXJwb2xhdGVkUG9zaXRpb24sIGIucG9zaXRpb24sIGludGVycHZlbG8pO1xuXG4gICAgICAgICAgICAgICAgYi5pbnRlcnBvbGF0ZWRBbmdsZSA9IGIuYW5nbGUgKyAoYi5hbmdsZSAtIGIucHJldmlvdXNBbmdsZSkgKiBoX2Rpdl9kdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIHN0YXRpYyBib2RpZXMsIGp1c3QgY29weS4gV2hvIGVsc2Ugd2lsbCBkbyBpdD9cbiAgICAgICAgICAgICAgICB2ZWMyLmNvcHkoYi5pbnRlcnBvbGF0ZWRQb3NpdGlvbiwgYi5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgYi5pbnRlcnBvbGF0ZWRBbmdsZSA9IGIuYW5nbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZW5kT3ZlcmxhcHMgPSBbXTtcblxuLyoqXG4gKiBNYWtlIGEgZml4ZWQgc3RlcC5cbiAqIEBtZXRob2QgaW50ZXJuYWxTdGVwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGR0XG4gKiBAcHJpdmF0ZVxuICovXG5Xb3JsZC5wcm90b3R5cGUuaW50ZXJuYWxTdGVwID0gZnVuY3Rpb24oZHQpe1xuICAgIHRoaXMuc3RlcHBpbmcgPSB0cnVlO1xuXG4gICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICBkb1Byb2ZpbGluZyA9IHRoaXMuZG9Qcm9maWxpbmcsXG4gICAgICAgIE5zcHJpbmdzID0gdGhpcy5zcHJpbmdzLmxlbmd0aCxcbiAgICAgICAgc3ByaW5ncyA9IHRoaXMuc3ByaW5ncyxcbiAgICAgICAgYm9kaWVzID0gdGhpcy5ib2RpZXMsXG4gICAgICAgIGcgPSB0aGlzLmdyYXZpdHksXG4gICAgICAgIHNvbHZlciA9IHRoaXMuc29sdmVyLFxuICAgICAgICBOYm9kaWVzID0gdGhpcy5ib2RpZXMubGVuZ3RoLFxuICAgICAgICBicm9hZHBoYXNlID0gdGhpcy5icm9hZHBoYXNlLFxuICAgICAgICBucCA9IHRoaXMubmFycm93cGhhc2UsXG4gICAgICAgIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cyxcbiAgICAgICAgdDAsIHQxLFxuICAgICAgICBmaE1pbnYgPSBzdGVwX2ZoTWludixcbiAgICAgICAgdmVsb2R0ID0gc3RlcF92ZWxvZHQsXG4gICAgICAgIG1nID0gc3RlcF9tZyxcbiAgICAgICAgc2NhbGUgPSB2ZWMyLnNjYWxlLFxuICAgICAgICBhZGQgPSB2ZWMyLmFkZCxcbiAgICAgICAgcm90YXRlID0gdmVjMi5yb3RhdGUsXG4gICAgICAgIGlzbGFuZE1hbmFnZXIgPSB0aGlzLmlzbGFuZE1hbmFnZXI7XG5cbiAgICB0aGlzLm92ZXJsYXBLZWVwZXIudGljaygpO1xuXG4gICAgdGhpcy5sYXN0VGltZVN0ZXAgPSBkdDtcblxuICAgIGlmKGRvUHJvZmlsaW5nKXtcbiAgICAgICAgdDAgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgYXBwcm94aW1hdGUgZnJpY3Rpb24gZ3Jhdml0eS5cbiAgICBpZih0aGlzLnVzZVdvcmxkR3Jhdml0eUFzRnJpY3Rpb25HcmF2aXR5KXtcbiAgICAgICAgdmFyIGdyYXZpdHlMZW4gPSB2ZWMyLmxlbmd0aCh0aGlzLmdyYXZpdHkpO1xuICAgICAgICBpZighKGdyYXZpdHlMZW4gPT09IDAgJiYgdGhpcy51c2VGcmljdGlvbkdyYXZpdHlPblplcm9HcmF2aXR5KSl7XG4gICAgICAgICAgICAvLyBOb256ZXJvIGdyYXZpdHkuIFVzZSBpdC5cbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25HcmF2aXR5ID0gZ3Jhdml0eUxlbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBncmF2aXR5IHRvIGJvZGllc1xuICAgIGlmKHRoaXMuYXBwbHlHcmF2aXR5KXtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgdmFyIGIgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgZmkgPSBiLmZvcmNlO1xuICAgICAgICAgICAgaWYoYi50eXBlICE9PSBCb2R5LkRZTkFNSUMgfHwgYi5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HKXtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZlYzIuc2NhbGUobWcsZyxiLm1hc3MqYi5ncmF2aXR5U2NhbGUpOyAvLyBGPW0qZ1xuICAgICAgICAgICAgYWRkKGZpLGZpLG1nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBzcHJpbmcgZm9yY2VzXG4gICAgaWYodGhpcy5hcHBseVNwcmluZ0ZvcmNlcyl7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09TnNwcmluZ3M7IGkrKyl7XG4gICAgICAgICAgICB2YXIgcyA9IHNwcmluZ3NbaV07XG4gICAgICAgICAgICBzLmFwcGx5Rm9yY2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMuYXBwbHlEYW1waW5nKXtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgdmFyIGIgPSBib2RpZXNbaV07XG4gICAgICAgICAgICBpZihiLnR5cGUgPT09IEJvZHkuRFlOQU1JQyl7XG4gICAgICAgICAgICAgICAgYi5hcHBseURhbXBpbmcoZHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnJvYWRwaGFzZVxuICAgIHZhciByZXN1bHQgPSBicm9hZHBoYXNlLmdldENvbGxpc2lvblBhaXJzKHRoaXMpO1xuXG4gICAgLy8gUmVtb3ZlIGlnbm9yZWQgY29sbGlzaW9uIHBhaXJzXG4gICAgdmFyIGlnbm9yZWRQYWlycyA9IHRoaXMuZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnM7XG4gICAgZm9yKHZhciBpPWlnbm9yZWRQYWlycy5sZW5ndGgtMjsgaT49MDsgaS09Mil7XG4gICAgICAgIGZvcih2YXIgaj1yZXN1bHQubGVuZ3RoLTI7IGo+PTA7IGotPTIpe1xuICAgICAgICAgICAgaWYoIChpZ25vcmVkUGFpcnNbaV0gICA9PT0gcmVzdWx0W2pdICYmIGlnbm9yZWRQYWlyc1tpKzFdID09PSByZXN1bHRbaisxXSkgfHxcbiAgICAgICAgICAgICAgICAoaWdub3JlZFBhaXJzW2krMV0gPT09IHJlc3VsdFtqXSAmJiBpZ25vcmVkUGFpcnNbaV0gICA9PT0gcmVzdWx0W2orMV0pKXtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3BsaWNlKGosMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgY29uc3RyYWluZWQgcGFpcnMgd2l0aCBjb2xsaWRlQ29ubmVjdGVkID09IGZhbHNlXG4gICAgdmFyIE5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmxlbmd0aDtcbiAgICBmb3IoaT0wOyBpIT09TmNvbnN0cmFpbnRzOyBpKyspe1xuICAgICAgICB2YXIgYyA9IGNvbnN0cmFpbnRzW2ldO1xuICAgICAgICBpZighYy5jb2xsaWRlQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIGZvcih2YXIgaj1yZXN1bHQubGVuZ3RoLTI7IGo+PTA7IGotPTIpe1xuICAgICAgICAgICAgICAgIGlmKCAoYy5ib2R5QSA9PT0gcmVzdWx0W2pdICYmIGMuYm9keUIgPT09IHJlc3VsdFtqKzFdKSB8fFxuICAgICAgICAgICAgICAgICAgICAoYy5ib2R5QiA9PT0gcmVzdWx0W2pdICYmIGMuYm9keUEgPT09IHJlc3VsdFtqKzFdKSl7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoaiwyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwb3N0QnJvYWRwaGFzZSBldmVudFxuICAgIHRoaXMucG9zdEJyb2FkcGhhc2VFdmVudC5wYWlycyA9IHJlc3VsdDtcbiAgICB0aGlzLmVtaXQodGhpcy5wb3N0QnJvYWRwaGFzZUV2ZW50KTtcblxuICAgIC8vIE5hcnJvd3BoYXNlXG4gICAgbnAucmVzZXQodGhpcyk7XG4gICAgZm9yKHZhciBpPTAsIE5yZXN1bHRzPXJlc3VsdC5sZW5ndGg7IGkhPT1OcmVzdWx0czsgaSs9Mil7XG4gICAgICAgIHZhciBiaSA9IHJlc3VsdFtpXSxcbiAgICAgICAgICAgIGJqID0gcmVzdWx0W2krMV07XG5cbiAgICAgICAgLy8gTG9vcCBvdmVyIGFsbCBzaGFwZXMgb2YgYm9keSBpXG4gICAgICAgIGZvcih2YXIgaz0wLCBOc2hhcGVzaT1iaS5zaGFwZXMubGVuZ3RoOyBrIT09TnNoYXBlc2k7IGsrKyl7XG4gICAgICAgICAgICB2YXIgc2kgPSBiaS5zaGFwZXNba10sXG4gICAgICAgICAgICAgICAgeGkgPSBiaS5zaGFwZU9mZnNldHNba10sXG4gICAgICAgICAgICAgICAgYWkgPSBiaS5zaGFwZUFuZ2xlc1trXTtcblxuICAgICAgICAgICAgLy8gQWxsIHNoYXBlcyBvZiBib2R5IGpcbiAgICAgICAgICAgIGZvcih2YXIgbD0wLCBOc2hhcGVzaj1iai5zaGFwZXMubGVuZ3RoOyBsIT09TnNoYXBlc2o7IGwrKyl7XG4gICAgICAgICAgICAgICAgdmFyIHNqID0gYmouc2hhcGVzW2xdLFxuICAgICAgICAgICAgICAgICAgICB4aiA9IGJqLnNoYXBlT2Zmc2V0c1tsXSxcbiAgICAgICAgICAgICAgICAgICAgYWogPSBiai5zaGFwZUFuZ2xlc1tsXTtcblxuICAgICAgICAgICAgICAgIHZhciBjbSA9IHRoaXMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDtcbiAgICAgICAgICAgICAgICBpZihzaS5tYXRlcmlhbCAmJiBzai5tYXRlcmlhbCl7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSB0aGlzLmdldENvbnRhY3RNYXRlcmlhbChzaS5tYXRlcmlhbCxzai5tYXRlcmlhbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRtcCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbSA9IHRtcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucnVuTmFycm93cGhhc2UobnAsYmksc2kseGksYWksYmosc2oseGosYWosY20sdGhpcy5mcmljdGlvbkdyYXZpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2FrZSB1cCBib2RpZXNcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICBpZihib2R5Ll93YWtlVXBBZnRlck5hcnJvd3BoYXNlKXtcbiAgICAgICAgICAgIGJvZHkud2FrZVVwKCk7XG4gICAgICAgICAgICBib2R5Ll93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbWl0IGVuZCBvdmVybGFwIGV2ZW50c1xuICAgIGlmKHRoaXMuaGFzKCdlbmRDb250YWN0Jykpe1xuICAgICAgICB0aGlzLm92ZXJsYXBLZWVwZXIuZ2V0RW5kT3ZlcmxhcHMoZW5kT3ZlcmxhcHMpO1xuICAgICAgICB2YXIgZSA9IHRoaXMuZW5kQ29udGFjdEV2ZW50O1xuICAgICAgICB2YXIgbCA9IGVuZE92ZXJsYXBzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUobC0tKXtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZW5kT3ZlcmxhcHNbbF07XG4gICAgICAgICAgICBlLnNoYXBlQSA9IGRhdGEuc2hhcGVBO1xuICAgICAgICAgICAgZS5zaGFwZUIgPSBkYXRhLnNoYXBlQjtcbiAgICAgICAgICAgIGUuYm9keUEgPSBkYXRhLmJvZHlBO1xuICAgICAgICAgICAgZS5ib2R5QiA9IGRhdGEuYm9keUI7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJlU29sdmVFdmVudCA9IHRoaXMucHJlU29sdmVFdmVudDtcbiAgICBwcmVTb2x2ZUV2ZW50LmNvbnRhY3RFcXVhdGlvbnMgPSBucC5jb250YWN0RXF1YXRpb25zO1xuICAgIHByZVNvbHZlRXZlbnQuZnJpY3Rpb25FcXVhdGlvbnMgPSBucC5mcmljdGlvbkVxdWF0aW9ucztcbiAgICB0aGlzLmVtaXQocHJlU29sdmVFdmVudCk7XG5cbiAgICAvLyB1cGRhdGUgY29uc3RyYWludCBlcXVhdGlvbnNcbiAgICB2YXIgTmNvbnN0cmFpbnRzID0gY29uc3RyYWludHMubGVuZ3RoO1xuICAgIGZvcihpPTA7IGkhPT1OY29uc3RyYWludHM7IGkrKyl7XG4gICAgICAgIGNvbnN0cmFpbnRzW2ldLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGlmKG5wLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoIHx8IG5wLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCB8fCBjb25zdHJhaW50cy5sZW5ndGgpe1xuICAgICAgICBpZih0aGlzLmlzbGFuZFNwbGl0KXtcbiAgICAgICAgICAgIC8vIFNwbGl0IGludG8gaXNsYW5kc1xuICAgICAgICAgICAgaXNsYW5kTWFuYWdlci5lcXVhdGlvbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIFV0aWxzLmFwcGVuZEFycmF5KGlzbGFuZE1hbmFnZXIuZXF1YXRpb25zLCBucC5jb250YWN0RXF1YXRpb25zKTtcbiAgICAgICAgICAgIFV0aWxzLmFwcGVuZEFycmF5KGlzbGFuZE1hbmFnZXIuZXF1YXRpb25zLCBucC5mcmljdGlvbkVxdWF0aW9ucyk7XG4gICAgICAgICAgICBmb3IoaT0wOyBpIT09TmNvbnN0cmFpbnRzOyBpKyspe1xuICAgICAgICAgICAgICAgIFV0aWxzLmFwcGVuZEFycmF5KGlzbGFuZE1hbmFnZXIuZXF1YXRpb25zLCBjb25zdHJhaW50c1tpXS5lcXVhdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNsYW5kTWFuYWdlci5zcGxpdCh0aGlzKTtcblxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1pc2xhbmRNYW5hZ2VyLmlzbGFuZHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIHZhciBpc2xhbmQgPSBpc2xhbmRNYW5hZ2VyLmlzbGFuZHNbaV07XG4gICAgICAgICAgICAgICAgaWYoaXNsYW5kLmVxdWF0aW9ucy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICBzb2x2ZXIuc29sdmVJc2xhbmQoZHQsaXNsYW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gQWRkIGNvbnRhY3QgZXF1YXRpb25zIHRvIHNvbHZlclxuICAgICAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9ucyhucC5jb250YWN0RXF1YXRpb25zKTtcbiAgICAgICAgICAgIHNvbHZlci5hZGRFcXVhdGlvbnMobnAuZnJpY3Rpb25FcXVhdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBBZGQgdXNlci1kZWZpbmVkIGNvbnN0cmFpbnQgZXF1YXRpb25zXG4gICAgICAgICAgICBmb3IoaT0wOyBpIT09TmNvbnN0cmFpbnRzOyBpKyspe1xuICAgICAgICAgICAgICAgIHNvbHZlci5hZGRFcXVhdGlvbnMoY29uc3RyYWludHNbaV0uZXF1YXRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGhpcy5zb2x2ZUNvbnN0cmFpbnRzKXtcbiAgICAgICAgICAgICAgICBzb2x2ZXIuc29sdmUoZHQsdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0ZXAgZm9yd2FyZFxuICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgaWYoYm9keS5zbGVlcFN0YXRlICE9PSBCb2R5LlNMRUVQSU5HICYmIGJvZHkudHlwZSAhPT0gQm9keS5TVEFUSUMpe1xuICAgICAgICAgICAgYm9keS5pbnRlZ3JhdGUoZHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgZm9yY2VcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgIGJvZGllc1tpXS5zZXRaZXJvRm9yY2UoKTtcbiAgICB9XG5cbiAgICBpZihkb1Byb2ZpbGluZyl7XG4gICAgICAgIHQxID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoYXQubGFzdFN0ZXBUaW1lID0gdDEtdDA7XG4gICAgfVxuXG4gICAgLy8gRW1pdCBpbXBhY3QgZXZlbnRcbiAgICBpZih0aGlzLmVtaXRJbXBhY3RFdmVudCAmJiB0aGlzLmhhcygnaW1wYWN0Jykpe1xuICAgICAgICB2YXIgZXYgPSB0aGlzLmltcGFjdEV2ZW50O1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PW5wLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGVxID0gbnAuY29udGFjdEVxdWF0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmKGVxLmZpcnN0SW1wYWN0KXtcbiAgICAgICAgICAgICAgICBldi5ib2R5QSA9IGVxLmJvZHlBO1xuICAgICAgICAgICAgICAgIGV2LmJvZHlCID0gZXEuYm9keUI7XG4gICAgICAgICAgICAgICAgZXYuc2hhcGVBID0gZXEuc2hhcGVBO1xuICAgICAgICAgICAgICAgIGV2LnNoYXBlQiA9IGVxLnNoYXBlQjtcbiAgICAgICAgICAgICAgICBldi5jb250YWN0RXF1YXRpb24gPSBlcTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2xlZXBpbmcgdXBkYXRlXG4gICAgaWYodGhpcy5zbGVlcE1vZGUgPT09IFdvcmxkLkJPRFlfU0xFRVBJTkcpe1xuICAgICAgICBmb3IoaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIGJvZGllc1tpXS5zbGVlcFRpY2sodGhpcy50aW1lLCBmYWxzZSwgZHQpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmKHRoaXMuc2xlZXBNb2RlID09PSBXb3JsZC5JU0xBTkRfU0xFRVBJTkcgJiYgdGhpcy5pc2xhbmRTcGxpdCl7XG5cbiAgICAgICAgLy8gVGVsbCBhbGwgYm9kaWVzIHRvIHNsZWVwIHRpY2sgYnV0IGRvbnQgc2xlZXAgeWV0XG4gICAgICAgIGZvcihpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgYm9kaWVzW2ldLnNsZWVwVGljayh0aGlzLnRpbWUsIHRydWUsIGR0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNsZWVwIGlzbGFuZHNcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dGhpcy5pc2xhbmRNYW5hZ2VyLmlzbGFuZHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGlzbGFuZCA9IHRoaXMuaXNsYW5kTWFuYWdlci5pc2xhbmRzW2ldO1xuICAgICAgICAgICAgaWYoaXNsYW5kLndhbnRzVG9TbGVlcCgpKXtcbiAgICAgICAgICAgICAgICBpc2xhbmQuc2xlZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RlcHBpbmcgPSBmYWxzZTtcblxuICAgIC8vIFJlbW92ZSBib2RpZXMgdGhhdCBhcmUgc2NoZWR1bGVkIGZvciByZW1vdmFsXG4gICAgaWYodGhpcy5ib2RpZXNUb0JlUmVtb3ZlZC5sZW5ndGgpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PXRoaXMuYm9kaWVzVG9CZVJlbW92ZWQubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVCb2R5KHRoaXMuYm9kaWVzVG9CZVJlbW92ZWRbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm9kaWVzVG9CZVJlbW92ZWQubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQodGhpcy5wb3N0U3RlcEV2ZW50KTtcbn07XG5cbi8qKlxuICogUnVucyBuYXJyb3dwaGFzZSBmb3IgdGhlIHNoYXBlIHBhaXIgaSBhbmQgai5cbiAqIEBtZXRob2QgcnVuTmFycm93cGhhc2VcbiAqIEBwYXJhbSAge05hcnJvd3BoYXNlfSBucFxuICogQHBhcmFtICB7Qm9keX0gYmlcbiAqIEBwYXJhbSAge1NoYXBlfSBzaVxuICogQHBhcmFtICB7QXJyYXl9IHhpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFpXG4gKiBAcGFyYW0gIHtCb2R5fSBialxuICogQHBhcmFtICB7U2hhcGV9IHNqXG4gKiBAcGFyYW0gIHtBcnJheX0geGpcbiAqIEBwYXJhbSAge051bWJlcn0gYWpcbiAqIEBwYXJhbSAge051bWJlcn0gbXVcbiAqL1xuV29ybGQucHJvdG90eXBlLnJ1bk5hcnJvd3BoYXNlID0gZnVuY3Rpb24obnAsYmksc2kseGksYWksYmosc2oseGosYWosY20sZ2xlbil7XG5cbiAgICAvLyBDaGVjayBjb2xsaXNpb24gZ3JvdXBzIGFuZCBtYXNrc1xuICAgIGlmKCEoKHNpLmNvbGxpc2lvbkdyb3VwICYgc2ouY29sbGlzaW9uTWFzaykgIT09IDAgJiYgKHNqLmNvbGxpc2lvbkdyb3VwICYgc2kuY29sbGlzaW9uTWFzaykgIT09IDApKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEdldCB3b3JsZCBwb3NpdGlvbiBhbmQgYW5nbGUgb2YgZWFjaCBzaGFwZVxuICAgIHZlYzIucm90YXRlKHhpdywgeGksIGJpLmFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZSh4ancsIHhqLCBiai5hbmdsZSk7XG4gICAgdmVjMi5hZGQoeGl3LCB4aXcsIGJpLnBvc2l0aW9uKTtcbiAgICB2ZWMyLmFkZCh4ancsIHhqdywgYmoucG9zaXRpb24pO1xuICAgIHZhciBhaXcgPSBhaSArIGJpLmFuZ2xlO1xuICAgIHZhciBhancgPSBhaiArIGJqLmFuZ2xlO1xuXG4gICAgbnAuZW5hYmxlRnJpY3Rpb24gPSBjbS5mcmljdGlvbiA+IDA7XG4gICAgbnAuZnJpY3Rpb25Db2VmZmljaWVudCA9IGNtLmZyaWN0aW9uO1xuICAgIHZhciByZWR1Y2VkTWFzcztcbiAgICBpZihiaS50eXBlID09PSBCb2R5LlNUQVRJQyB8fCBiaS50eXBlID09PSBCb2R5LktJTkVNQVRJQyl7XG4gICAgICAgIHJlZHVjZWRNYXNzID0gYmoubWFzcztcbiAgICB9IGVsc2UgaWYoYmoudHlwZSA9PT0gQm9keS5TVEFUSUMgfHwgYmoudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpe1xuICAgICAgICByZWR1Y2VkTWFzcyA9IGJpLm1hc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVkdWNlZE1hc3MgPSAoYmkubWFzcypiai5tYXNzKS8oYmkubWFzcytiai5tYXNzKTtcbiAgICB9XG4gICAgbnAuc2xpcEZvcmNlID0gY20uZnJpY3Rpb24qZ2xlbipyZWR1Y2VkTWFzcztcbiAgICBucC5yZXN0aXR1dGlvbiA9IGNtLnJlc3RpdHV0aW9uO1xuICAgIG5wLnN1cmZhY2VWZWxvY2l0eSA9IGNtLnN1cmZhY2VWZWxvY2l0eTtcbiAgICBucC5mcmljdGlvblN0aWZmbmVzcyA9IGNtLmZyaWN0aW9uU3RpZmZuZXNzO1xuICAgIG5wLmZyaWN0aW9uUmVsYXhhdGlvbiA9IGNtLmZyaWN0aW9uUmVsYXhhdGlvbjtcbiAgICBucC5zdGlmZm5lc3MgPSBjbS5zdGlmZm5lc3M7XG4gICAgbnAucmVsYXhhdGlvbiA9IGNtLnJlbGF4YXRpb247XG4gICAgbnAuY29udGFjdFNraW5TaXplID0gY20uY29udGFjdFNraW5TaXplO1xuICAgIG5wLmVuYWJsZWRFcXVhdGlvbnMgPSBiaS5jb2xsaXNpb25SZXNwb25zZSAmJiBiai5jb2xsaXNpb25SZXNwb25zZSAmJiBzaS5jb2xsaXNpb25SZXNwb25zZSAmJiBzai5jb2xsaXNpb25SZXNwb25zZTtcblxuICAgIHZhciByZXNvbHZlciA9IG5wW3NpLnR5cGUgfCBzai50eXBlXSxcbiAgICAgICAgbnVtQ29udGFjdHMgPSAwO1xuICAgIGlmIChyZXNvbHZlcikge1xuICAgICAgICB2YXIgc2Vuc29yID0gc2kuc2Vuc29yIHx8IHNqLnNlbnNvcjtcbiAgICAgICAgdmFyIG51bUZyaWN0aW9uQmVmb3JlID0gbnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoO1xuICAgICAgICBpZiAoc2kudHlwZSA8IHNqLnR5cGUpIHtcbiAgICAgICAgICAgIG51bUNvbnRhY3RzID0gcmVzb2x2ZXIuY2FsbChucCwgYmksc2kseGl3LGFpdywgYmosc2oseGp3LGFqdywgc2Vuc29yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG51bUNvbnRhY3RzID0gcmVzb2x2ZXIuY2FsbChucCwgYmosc2oseGp3LGFqdywgYmksc2kseGl3LGFpdywgc2Vuc29yKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbnVtRnJpY3Rpb25FcXVhdGlvbnMgPSBucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGggLSBudW1GcmljdGlvbkJlZm9yZTtcblxuICAgICAgICBpZihudW1Db250YWN0cyl7XG5cbiAgICAgICAgICAgIGlmKCBiaS5hbGxvd1NsZWVwICYmXG4gICAgICAgICAgICAgICAgYmkudHlwZSA9PT0gQm9keS5EWU5BTUlDICYmXG4gICAgICAgICAgICAgICAgYmkuc2xlZXBTdGF0ZSAgPT09IEJvZHkuU0xFRVBJTkcgJiZcbiAgICAgICAgICAgICAgICBiai5zbGVlcFN0YXRlICA9PT0gQm9keS5BV0FLRSAmJlxuICAgICAgICAgICAgICAgIGJqLnR5cGUgIT09IEJvZHkuU1RBVElDXG4gICAgICAgICAgICApe1xuICAgICAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWRCID0gdmVjMi5zcXVhcmVkTGVuZ3RoKGJqLnZlbG9jaXR5KSArIE1hdGgucG93KGJqLmFuZ3VsYXJWZWxvY2l0eSwyKTtcbiAgICAgICAgICAgICAgICB2YXIgc3BlZWRMaW1pdFNxdWFyZWRCID0gTWF0aC5wb3coYmouc2xlZXBTcGVlZExpbWl0LDIpO1xuICAgICAgICAgICAgICAgIGlmKHNwZWVkU3F1YXJlZEIgPj0gc3BlZWRMaW1pdFNxdWFyZWRCKjIpe1xuICAgICAgICAgICAgICAgICAgICBiaS5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggYmouYWxsb3dTbGVlcCAmJlxuICAgICAgICAgICAgICAgIGJqLnR5cGUgPT09IEJvZHkuRFlOQU1JQyAmJlxuICAgICAgICAgICAgICAgIGJqLnNsZWVwU3RhdGUgID09PSBCb2R5LlNMRUVQSU5HICYmXG4gICAgICAgICAgICAgICAgYmkuc2xlZXBTdGF0ZSAgPT09IEJvZHkuQVdBS0UgJiZcbiAgICAgICAgICAgICAgICBiaS50eXBlICE9PSBCb2R5LlNUQVRJQ1xuICAgICAgICAgICAgKXtcbiAgICAgICAgICAgICAgICB2YXIgc3BlZWRTcXVhcmVkQSA9IHZlYzIuc3F1YXJlZExlbmd0aChiaS52ZWxvY2l0eSkgKyBNYXRoLnBvdyhiaS5hbmd1bGFyVmVsb2NpdHksMik7XG4gICAgICAgICAgICAgICAgdmFyIHNwZWVkTGltaXRTcXVhcmVkQSA9IE1hdGgucG93KGJpLnNsZWVwU3BlZWRMaW1pdCwyKTtcbiAgICAgICAgICAgICAgICBpZihzcGVlZFNxdWFyZWRBID49IHNwZWVkTGltaXRTcXVhcmVkQSoyKXtcbiAgICAgICAgICAgICAgICAgICAgYmouX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vdmVybGFwS2VlcGVyLnNldE92ZXJsYXBwaW5nKGJpLCBzaSwgYmosIHNqKTtcbiAgICAgICAgICAgIGlmKHRoaXMuaGFzKCdiZWdpbkNvbnRhY3QnKSAmJiB0aGlzLm92ZXJsYXBLZWVwZXIuaXNOZXdPdmVybGFwKHNpLCBzaikpe1xuXG4gICAgICAgICAgICAgICAgLy8gUmVwb3J0IG5ldyBzaGFwZSBvdmVybGFwXG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmJlZ2luQ29udGFjdEV2ZW50O1xuICAgICAgICAgICAgICAgIGUuc2hhcGVBID0gc2k7XG4gICAgICAgICAgICAgICAgZS5zaGFwZUIgPSBzajtcbiAgICAgICAgICAgICAgICBlLmJvZHlBID0gYmk7XG4gICAgICAgICAgICAgICAgZS5ib2R5QiA9IGJqO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgY29udGFjdCBlcXVhdGlvbnNcbiAgICAgICAgICAgICAgICBlLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgICAgIGlmKHR5cGVvZihudW1Db250YWN0cyk9PT1cIm51bWJlclwiKXtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpPW5wLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoLW51bUNvbnRhY3RzOyBpPG5wLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5jb250YWN0RXF1YXRpb25zLnB1c2gobnAuY29udGFjdEVxdWF0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRpdmlkZSB0aGUgbWF4IGZyaWN0aW9uIGZvcmNlIGJ5IHRoZSBudW1iZXIgb2YgY29udGFjdHNcbiAgICAgICAgICAgIGlmKHR5cGVvZihudW1Db250YWN0cyk9PT1cIm51bWJlclwiICYmIG51bUZyaWN0aW9uRXF1YXRpb25zID4gMSl7IC8vIFdoeSBkaXZpZGUgYnkgMT9cbiAgICAgICAgICAgICAgICBmb3IodmFyIGk9bnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoLW51bUZyaWN0aW9uRXF1YXRpb25zOyBpPG5wLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBucC5mcmljdGlvbkVxdWF0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZi5zZXRTbGlwRm9yY2UoZi5nZXRTbGlwRm9yY2UoKSAvIG51bUZyaWN0aW9uRXF1YXRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbi8qKlxuICogQWRkIGEgc3ByaW5nIHRvIHRoZSBzaW11bGF0aW9uXG4gKlxuICogQG1ldGhvZCBhZGRTcHJpbmdcbiAqIEBwYXJhbSB7U3ByaW5nfSBzXG4gKi9cbldvcmxkLnByb3RvdHlwZS5hZGRTcHJpbmcgPSBmdW5jdGlvbihzKXtcbiAgICB0aGlzLnNwcmluZ3MucHVzaChzKTtcbiAgICB0aGlzLmFkZFNwcmluZ0V2ZW50LnNwcmluZyA9IHM7XG4gICAgdGhpcy5lbWl0KHRoaXMuYWRkU3ByaW5nRXZlbnQpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBzcHJpbmdcbiAqXG4gKiBAbWV0aG9kIHJlbW92ZVNwcmluZ1xuICogQHBhcmFtIHtTcHJpbmd9IHNcbiAqL1xuV29ybGQucHJvdG90eXBlLnJlbW92ZVNwcmluZyA9IGZ1bmN0aW9uKHMpe1xuICAgIHZhciBpZHggPSB0aGlzLnNwcmluZ3MuaW5kZXhPZihzKTtcbiAgICBpZihpZHghPT0tMSl7XG4gICAgICAgIFV0aWxzLnNwbGljZSh0aGlzLnNwcmluZ3MsaWR4LDEpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQWRkIGEgYm9keSB0byB0aGUgc2ltdWxhdGlvblxuICpcbiAqIEBtZXRob2QgYWRkQm9keVxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgd29ybGQgPSBuZXcgV29ybGQoKSxcbiAqICAgICAgICAgYm9keSA9IG5ldyBCb2R5KCk7XG4gKiAgICAgd29ybGQuYWRkQm9keShib2R5KTtcbiAqIEB0b2RvIFdoYXQgaWYgdGhpcyBpcyBkb25lIGR1cmluZyBzdGVwP1xuICovXG5Xb3JsZC5wcm90b3R5cGUuYWRkQm9keSA9IGZ1bmN0aW9uKGJvZHkpe1xuICAgIGlmKHRoaXMuYm9kaWVzLmluZGV4T2YoYm9keSkgPT09IC0xKXtcbiAgICAgICAgdGhpcy5ib2RpZXMucHVzaChib2R5KTtcbiAgICAgICAgYm9keS53b3JsZCA9IHRoaXM7XG4gICAgICAgIHRoaXMuYWRkQm9keUV2ZW50LmJvZHkgPSBib2R5O1xuICAgICAgICB0aGlzLmVtaXQodGhpcy5hZGRCb2R5RXZlbnQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgYm9keSBmcm9tIHRoZSBzaW11bGF0aW9uLiBJZiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgZHVyaW5nIHN0ZXAoKSwgdGhlIGJvZHkgcmVtb3ZhbCBpcyBzY2hlZHVsZWQgdG8gYWZ0ZXIgdGhlIHN0ZXAuXG4gKlxuICogQG1ldGhvZCByZW1vdmVCb2R5XG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqL1xuV29ybGQucHJvdG90eXBlLnJlbW92ZUJvZHkgPSBmdW5jdGlvbihib2R5KXtcbiAgICBpZih0aGlzLnN0ZXBwaW5nKXtcbiAgICAgICAgdGhpcy5ib2RpZXNUb0JlUmVtb3ZlZC5wdXNoKGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJvZHkud29ybGQgPSBudWxsO1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5ib2RpZXMuaW5kZXhPZihib2R5KTtcbiAgICAgICAgaWYoaWR4IT09LTEpe1xuICAgICAgICAgICAgVXRpbHMuc3BsaWNlKHRoaXMuYm9kaWVzLGlkeCwxKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQm9keUV2ZW50LmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgYm9keS5yZXNldENvbnN0cmFpbnRWZWxvY2l0eSgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMucmVtb3ZlQm9keUV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IGEgYm9keSBieSBpdHMgaWQuXG4gKiBAbWV0aG9kIGdldEJvZHlCeUlkXG4gKiBAcmV0dXJuIHtCb2R5fEJvb2xlYW59IFRoZSBib2R5LCBvciBmYWxzZSBpZiBpdCB3YXMgbm90IGZvdW5kLlxuICovXG5Xb3JsZC5wcm90b3R5cGUuZ2V0Qm9keUJ5SWQgPSBmdW5jdGlvbihpZCl7XG4gICAgdmFyIGJvZGllcyA9IHRoaXMuYm9kaWVzO1xuICAgIGZvcih2YXIgaT0wOyBpPGJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuICAgICAgICBpZihiLmlkID09PSBpZCl7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIERpc2FibGUgY29sbGlzaW9uIGJldHdlZW4gdHdvIGJvZGllc1xuICogQG1ldGhvZCBkaXNhYmxlQ29sbGlzaW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKi9cbldvcmxkLnByb3RvdHlwZS5kaXNhYmxlQm9keUNvbGxpc2lvbiA9IGZ1bmN0aW9uKGJvZHlBLGJvZHlCKXtcbiAgICB0aGlzLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzLnB1c2goYm9keUEsYm9keUIpO1xufTtcblxuLyoqXG4gKiBFbmFibGUgY29sbGlzaW9ucyBiZXR3ZWVuIHRoZSBnaXZlbiB0d28gYm9kaWVzXG4gKiBAbWV0aG9kIGVuYWJsZUNvbGxpc2lvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICovXG5Xb3JsZC5wcm90b3R5cGUuZW5hYmxlQm9keUNvbGxpc2lvbiA9IGZ1bmN0aW9uKGJvZHlBLGJvZHlCKXtcbiAgICB2YXIgcGFpcnMgPSB0aGlzLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzO1xuICAgIGZvcih2YXIgaT0wOyBpPHBhaXJzLmxlbmd0aDsgaSs9Mil7XG4gICAgICAgIGlmKChwYWlyc1tpXSA9PT0gYm9keUEgJiYgcGFpcnNbaSsxXSA9PT0gYm9keUIpIHx8IChwYWlyc1tpKzFdID09PSBib2R5QSAmJiBwYWlyc1tpXSA9PT0gYm9keUIpKXtcbiAgICAgICAgICAgIHBhaXJzLnNwbGljZShpLDIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5mdW5jdGlvbiB2MmEodil7XG4gICAgaWYoIXYpe1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmV0dXJuIFt2WzBdLHZbMV1dO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoYSxiKXtcbiAgICBmb3IodmFyIGtleSBpbiBiKXtcbiAgICAgICAgYVtrZXldID0gYltrZXldO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29udGFjdE1hdGVyaWFsVG9KU09OKGNtKXtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZCA6IGNtLmlkLFxuICAgICAgICBtYXRlcmlhbEEgOiAgICAgICAgICAgICBjbS5tYXRlcmlhbEEuaWQsXG4gICAgICAgIG1hdGVyaWFsQiA6ICAgICAgICAgICAgIGNtLm1hdGVyaWFsQi5pZCxcbiAgICAgICAgZnJpY3Rpb24gOiAgICAgICAgICAgICAgY20uZnJpY3Rpb24sXG4gICAgICAgIHJlc3RpdHV0aW9uIDogICAgICAgICAgIGNtLnJlc3RpdHV0aW9uLFxuICAgICAgICBzdGlmZm5lc3MgOiAgICAgICAgICAgICBjbS5zdGlmZm5lc3MsXG4gICAgICAgIHJlbGF4YXRpb24gOiAgICAgICAgICAgIGNtLnJlbGF4YXRpb24sXG4gICAgICAgIGZyaWN0aW9uU3RpZmZuZXNzIDogICAgIGNtLmZyaWN0aW9uU3RpZmZuZXNzLFxuICAgICAgICBmcmljdGlvblJlbGF4YXRpb24gOiAgICBjbS5mcmljdGlvblJlbGF4YXRpb24sXG4gICAgfTtcbn1cblxuLyoqXG4gKiBSZXNldHMgdGhlIFdvcmxkLCByZW1vdmVzIGFsbCBib2RpZXMsIGNvbnN0cmFpbnRzIGFuZCBzcHJpbmdzLlxuICpcbiAqIEBtZXRob2QgY2xlYXJcbiAqL1xuV29ybGQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKXtcblxuICAgIHRoaXMudGltZSA9IDA7XG4gICAgdGhpcy5maXhlZFN0ZXBUaW1lID0gMDtcblxuICAgIC8vIFJlbW92ZSBhbGwgc29sdmVyIGVxdWF0aW9uc1xuICAgIGlmKHRoaXMuc29sdmVyICYmIHRoaXMuc29sdmVyLmVxdWF0aW9ucy5sZW5ndGgpe1xuICAgICAgICB0aGlzLnNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYWxsIGNvbnN0cmFpbnRzXG4gICAgdmFyIGNzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICBmb3IodmFyIGk9Y3MubGVuZ3RoLTE7IGk+PTA7IGktLSl7XG4gICAgICAgIHRoaXMucmVtb3ZlQ29uc3RyYWludChjc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFsbCBib2RpZXNcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5ib2RpZXM7XG4gICAgZm9yKHZhciBpPWJvZGllcy5sZW5ndGgtMTsgaT49MDsgaS0tKXtcbiAgICAgICAgdGhpcy5yZW1vdmVCb2R5KGJvZGllc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFsbCBzcHJpbmdzXG4gICAgdmFyIHNwcmluZ3MgPSB0aGlzLnNwcmluZ3M7XG4gICAgZm9yKHZhciBpPXNwcmluZ3MubGVuZ3RoLTE7IGk+PTA7IGktLSl7XG4gICAgICAgIHRoaXMucmVtb3ZlU3ByaW5nKHNwcmluZ3NbaV0pO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbGwgY29udGFjdCBtYXRlcmlhbHNcbiAgICB2YXIgY21zID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzO1xuICAgIGZvcih2YXIgaT1jbXMubGVuZ3RoLTE7IGk+PTA7IGktLSl7XG4gICAgICAgIHRoaXMucmVtb3ZlQ29udGFjdE1hdGVyaWFsKGNtc1tpXSk7XG4gICAgfVxuXG4gICAgV29ybGQuYXBwbHkodGhpcyk7XG59O1xuXG4vKipcbiAqIEdldCBhIGNvcHkgb2YgdGhpcyBXb3JsZCBpbnN0YW5jZVxuICogQG1ldGhvZCBjbG9uZVxuICogQHJldHVybiB7V29ybGR9XG4gKi9cbldvcmxkLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKCk7XG4gICAgd29ybGQuZnJvbUpTT04odGhpcy50b0pTT04oKSk7XG4gICAgcmV0dXJuIHdvcmxkO1xufTtcblxudmFyIGhpdFRlc3RfdG1wMSA9IHZlYzIuY3JlYXRlKCksXG4gICAgaGl0VGVzdF96ZXJvID0gdmVjMi5mcm9tVmFsdWVzKDAsMCksXG4gICAgaGl0VGVzdF90bXAyID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbi8qKlxuICogVGVzdCBpZiBhIHdvcmxkIHBvaW50IG92ZXJsYXBzIGJvZGllc1xuICogQG1ldGhvZCBoaXRUZXN0XG4gKiBAcGFyYW0gIHtBcnJheX0gIHdvcmxkUG9pbnQgIFBvaW50IHRvIHVzZSBmb3IgaW50ZXJzZWN0aW9uIHRlc3RzXG4gKiBAcGFyYW0gIHtBcnJheX0gIGJvZGllcyAgICAgIEEgbGlzdCBvZiBvYmplY3RzIHRvIGNoZWNrIGZvciBpbnRlcnNlY3Rpb25cbiAqIEBwYXJhbSAge051bWJlcn0gcHJlY2lzaW9uICAgVXNlZCBmb3IgbWF0Y2hpbmcgYWdhaW5zdCBwYXJ0aWNsZXMgYW5kIGxpbmVzLiBBZGRzIHNvbWUgbWFyZ2luIHRvIHRoZXNlIGluZmluaXRlc2ltYWwgb2JqZWN0cy5cbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgQXJyYXkgb2YgYm9kaWVzIHRoYXQgb3ZlcmxhcCB0aGUgcG9pbnRcbiAqL1xuV29ybGQucHJvdG90eXBlLmhpdFRlc3QgPSBmdW5jdGlvbih3b3JsZFBvaW50LGJvZGllcyxwcmVjaXNpb24pe1xuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuXG4gICAgLy8gQ3JlYXRlIGEgZHVtbXkgcGFydGljbGUgYm9keSB3aXRoIGEgcGFydGljbGUgc2hhcGUgdG8gdGVzdCBhZ2FpbnN0IHRoZSBib2RpZXNcbiAgICB2YXIgcGIgPSBuZXcgQm9keSh7IHBvc2l0aW9uOndvcmxkUG9pbnQgfSksXG4gICAgICAgIHBzID0gbmV3IFBhcnRpY2xlKCksXG4gICAgICAgIHB4ID0gd29ybGRQb2ludCxcbiAgICAgICAgcGEgPSAwLFxuICAgICAgICB4ID0gaGl0VGVzdF90bXAxLFxuICAgICAgICB6ZXJvID0gaGl0VGVzdF96ZXJvLFxuICAgICAgICB0bXAgPSBoaXRUZXN0X3RtcDI7XG4gICAgcGIuYWRkU2hhcGUocHMpO1xuXG4gICAgdmFyIG4gPSB0aGlzLm5hcnJvd3BoYXNlLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIC8vIENoZWNrIGJvZGllc1xuICAgIGZvcih2YXIgaT0wLCBOPWJvZGllcy5sZW5ndGg7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcbiAgICAgICAgZm9yKHZhciBqPTAsIE5TPWIuc2hhcGVzLmxlbmd0aDsgaiE9PU5TOyBqKyspe1xuICAgICAgICAgICAgdmFyIHMgPSBiLnNoYXBlc1tqXSxcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBiLnNoYXBlT2Zmc2V0c1tqXSB8fCB6ZXJvLFxuICAgICAgICAgICAgICAgIGFuZ2xlID0gYi5zaGFwZUFuZ2xlc1tqXSB8fCAwLjA7XG5cbiAgICAgICAgICAgIC8vIEdldCBzaGFwZSB3b3JsZCBwb3NpdGlvbiArIGFuZ2xlXG4gICAgICAgICAgICB2ZWMyLnJvdGF0ZSh4LCBvZmZzZXQsIGIuYW5nbGUpO1xuICAgICAgICAgICAgdmVjMi5hZGQoeCwgeCwgYi5wb3NpdGlvbik7XG4gICAgICAgICAgICB2YXIgYSA9IGFuZ2xlICsgYi5hbmdsZTtcblxuICAgICAgICAgICAgaWYoIChzIGluc3RhbmNlb2YgQ2lyY2xlICAgICYmIG4uY2lyY2xlUGFydGljbGUgIChiLHMseCxhLCAgICAgcGIscHMscHgscGEsIHRydWUpKSB8fFxuICAgICAgICAgICAgICAgIChzIGluc3RhbmNlb2YgQ29udmV4ICAgICYmIG4ucGFydGljbGVDb252ZXggIChwYixwcyxweCxwYSwgYixzLHgsYSwgICAgIHRydWUpKSB8fFxuICAgICAgICAgICAgICAgIChzIGluc3RhbmNlb2YgUGxhbmUgICAgICYmIG4ucGFydGljbGVQbGFuZSAgIChwYixwcyxweCxwYSwgYixzLHgsYSwgICAgIHRydWUpKSB8fFxuICAgICAgICAgICAgICAgIChzIGluc3RhbmNlb2YgQ2Fwc3VsZSAgICYmIG4ucGFydGljbGVDYXBzdWxlIChwYixwcyxweCxwYSwgYixzLHgsYSwgICAgIHRydWUpKSB8fFxuICAgICAgICAgICAgICAgIChzIGluc3RhbmNlb2YgUGFydGljbGUgICYmIHZlYzIuc3F1YXJlZExlbmd0aCh2ZWMyLnN1Yih0bXAseCx3b3JsZFBvaW50KSkgPCBwcmVjaXNpb24qcHJlY2lzaW9uKVxuICAgICAgICAgICAgICAgICl7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBFcXVhdGlvbiBwYXJhbWV0ZXJzIGZvciBhbGwgY29uc3RyYWludHMgYW5kIGNvbnRhY3QgbWF0ZXJpYWxzLlxuICogQG1ldGhvZCBzZXRHbG9iYWxFcXVhdGlvblBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1ldGVyc11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5yZWxheGF0aW9uXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnN0aWZmbmVzc11cbiAqL1xuV29ybGQucHJvdG90eXBlLnNldEdsb2JhbEVxdWF0aW9uUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMpe1xuICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG4gICAgLy8gU2V0IGZvciBhbGwgY29uc3RyYWludHNcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gdGhpcy5jb25zdHJhaW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBjID0gdGhpcy5jb25zdHJhaW50c1tpXTtcbiAgICAgICAgZm9yKHZhciBqPTA7IGogIT09IGMuZXF1YXRpb25zLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciBlcSA9IGMuZXF1YXRpb25zW2pdO1xuICAgICAgICAgICAgaWYodHlwZW9mKHBhcmFtZXRlcnMuc3RpZmZuZXNzKSAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgICAgICAgZXEuc3RpZmZuZXNzID0gcGFyYW1ldGVycy5zdGlmZm5lc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0eXBlb2YocGFyYW1ldGVycy5yZWxheGF0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgICAgICAgZXEucmVsYXhhdGlvbiA9IHBhcmFtZXRlcnMucmVsYXhhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCBmb3IgYWxsIGNvbnRhY3QgbWF0ZXJpYWxzXG4gICAgZm9yKHZhciBpPTA7IGkgIT09IHRoaXMuY29udGFjdE1hdGVyaWFscy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBjID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzW2ldO1xuICAgICAgICBpZih0eXBlb2YocGFyYW1ldGVycy5zdGlmZm5lc3MpICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgIGMuc3RpZmZuZXNzID0gcGFyYW1ldGVycy5zdGlmZm5lc3M7XG4gICAgICAgICAgICBjLmZyaWN0aW9uU3RpZmZuZXNzID0gcGFyYW1ldGVycy5zdGlmZm5lc3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYodHlwZW9mKHBhcmFtZXRlcnMucmVsYXhhdGlvbikgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICAgICAgYy5yZWxheGF0aW9uID0gcGFyYW1ldGVycy5yZWxheGF0aW9uO1xuICAgICAgICAgICAgYy5mcmljdGlvblJlbGF4YXRpb24gPSBwYXJhbWV0ZXJzLnJlbGF4YXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgZm9yIGRlZmF1bHQgY29udGFjdCBtYXRlcmlhbFxuICAgIHZhciBjID0gdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsO1xuICAgIGlmKHR5cGVvZihwYXJhbWV0ZXJzLnN0aWZmbmVzcykgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICBjLnN0aWZmbmVzcyA9IHBhcmFtZXRlcnMuc3RpZmZuZXNzO1xuICAgICAgICBjLmZyaWN0aW9uU3RpZmZuZXNzID0gcGFyYW1ldGVycy5zdGlmZm5lc3M7XG4gICAgfVxuICAgIGlmKHR5cGVvZihwYXJhbWV0ZXJzLnJlbGF4YXRpb24pICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgYy5yZWxheGF0aW9uID0gcGFyYW1ldGVycy5yZWxheGF0aW9uO1xuICAgICAgICBjLmZyaWN0aW9uUmVsYXhhdGlvbiA9IHBhcmFtZXRlcnMucmVsYXhhdGlvbjtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc3RpZmZuZXNzIGZvciBhbGwgZXF1YXRpb25zIGFuZCBjb250YWN0IG1hdGVyaWFscy5cbiAqIEBtZXRob2Qgc2V0R2xvYmFsU3RpZmZuZXNzXG4gKiBAcGFyYW0ge051bWJlcn0gc3RpZmZuZXNzXG4gKi9cbldvcmxkLnByb3RvdHlwZS5zZXRHbG9iYWxTdGlmZm5lc3MgPSBmdW5jdGlvbihzdGlmZm5lc3Mpe1xuICAgIHRoaXMuc2V0R2xvYmFsRXF1YXRpb25QYXJhbWV0ZXJzKHtcbiAgICAgICAgc3RpZmZuZXNzOiBzdGlmZm5lc3NcbiAgICB9KTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSByZWxheGF0aW9uIGZvciBhbGwgZXF1YXRpb25zIGFuZCBjb250YWN0IG1hdGVyaWFscy5cbiAqIEBtZXRob2Qgc2V0R2xvYmFsUmVsYXhhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJlbGF4YXRpb25cbiAqL1xuV29ybGQucHJvdG90eXBlLnNldEdsb2JhbFJlbGF4YXRpb24gPSBmdW5jdGlvbihyZWxheGF0aW9uKXtcbiAgICB0aGlzLnNldEdsb2JhbEVxdWF0aW9uUGFyYW1ldGVycyh7XG4gICAgICAgIHJlbGF4YXRpb246IHJlbGF4YXRpb25cbiAgICB9KTtcbn07XG5cbnZhciB0bXBSYXkgPSBuZXcgUmF5KCk7XG5cbi8qKlxuICogUmF5IGNhc3QgYWdhaW5zdCBhbGwgYm9kaWVzLiBUaGUgcHJvdmlkZWQgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaCBoaXQgd2l0aCBhIFJheWNhc3RSZXN1bHQgYXMgc2luZ2xlIGFyZ3VtZW50LlxuICogQG1ldGhvZCByYXljYXN0QWxsXG4gKiBAcGFyYW0gIHtWZWMzfSBmcm9tXG4gKiBAcGFyYW0gIHtWZWMzfSB0b1xuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbk1hc2s9LTFdXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkdyb3VwPS0xXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEJhY2tmYWNlcz1mYWxzZV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U9dHJ1ZV1cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbnkgYm9keSB3YXMgaGl0LlxuICovXG5Xb3JsZC5wcm90b3R5cGUucmF5Y2FzdEFsbCA9IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zLCBjYWxsYmFjayl7XG4gICAgb3B0aW9ucy5tb2RlID0gUmF5LkFMTDtcbiAgICBvcHRpb25zLmZyb20gPSBmcm9tO1xuICAgIG9wdGlvbnMudG8gPSB0bztcbiAgICBvcHRpb25zLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIHRtcFJheS5pbnRlcnNlY3RXb3JsZCh0aGlzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmF5IGNhc3QsIGFuZCBzdG9wIGF0IHRoZSBmaXJzdCByZXN1bHQuIE5vdGUgdGhhdCB0aGUgb3JkZXIgaXMgcmFuZG9tIC0gYnV0IHRoZSBtZXRob2QgaXMgZmFzdC5cbiAqIEBtZXRob2QgcmF5Y2FzdEFueVxuICogQHBhcmFtICB7VmVjM30gZnJvbVxuICogQHBhcmFtICB7VmVjM30gdG9cbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25NYXNrPS0xXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25Hcm91cD0tMV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLnNraXBCYWNrZmFjZXM9ZmFsc2VdXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlPXRydWVdXG4gKiBAcGFyYW0gIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW55IGJvZHkgd2FzIGhpdC5cbiAqL1xuV29ybGQucHJvdG90eXBlLnJheWNhc3RBbnkgPSBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucywgcmVzdWx0KXtcbiAgICBvcHRpb25zLm1vZGUgPSBSYXkuQU5ZO1xuICAgIG9wdGlvbnMuZnJvbSA9IGZyb207XG4gICAgb3B0aW9ucy50byA9IHRvO1xuICAgIG9wdGlvbnMucmVzdWx0ID0gcmVzdWx0O1xuICAgIHJldHVybiB0bXBSYXkuaW50ZXJzZWN0V29ybGQodGhpcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFJheSBjYXN0LCBhbmQgcmV0dXJuIGluZm9ybWF0aW9uIG9mIHRoZSBjbG9zZXN0IGhpdC5cbiAqIEBtZXRob2QgcmF5Y2FzdENsb3Nlc3RcbiAqIEBwYXJhbSAge1ZlYzN9IGZyb21cbiAqIEBwYXJhbSAge1ZlYzN9IHRvXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uTWFzaz0tMV1cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uR3JvdXA9LTFdXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5za2lwQmFja2ZhY2VzPWZhbHNlXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZT10cnVlXVxuICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFueSBib2R5IHdhcyBoaXQuXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yYXljYXN0Q2xvc2VzdCA9IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zLCByZXN1bHQpe1xuICAgIG9wdGlvbnMubW9kZSA9IFJheS5DTE9TRVNUO1xuICAgIG9wdGlvbnMuZnJvbSA9IGZyb207XG4gICAgb3B0aW9ucy50byA9IHRvO1xuICAgIG9wdGlvbnMucmVzdWx0ID0gcmVzdWx0O1xuICAgIHJldHVybiB0bXBSYXkuaW50ZXJzZWN0V29ybGQodGhpcywgb3B0aW9ucyk7XG59O1xufSx7XCIuLi8uLi9wYWNrYWdlLmpzb25cIjo2LFwiLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2VcIjo4LFwiLi4vY29sbGlzaW9uL05haXZlQnJvYWRwaGFzZVwiOjEwLFwiLi4vY29sbGlzaW9uL05hcnJvd3BoYXNlXCI6MTEsXCIuLi9jb2xsaXNpb24vUmF5XCI6MTIsXCIuLi9jb2xsaXNpb24vU0FQQnJvYWRwaGFzZVwiOjE0LFwiLi4vY29uc3RyYWludHMvQ29uc3RyYWludFwiOjE1LFwiLi4vY29uc3RyYWludHMvRGlzdGFuY2VDb25zdHJhaW50XCI6MTYsXCIuLi9jb25zdHJhaW50cy9HZWFyQ29uc3RyYWludFwiOjE3LFwiLi4vY29uc3RyYWludHMvTG9ja0NvbnN0cmFpbnRcIjoxOCxcIi4uL2NvbnN0cmFpbnRzL1ByaXNtYXRpY0NvbnN0cmFpbnRcIjoxOSxcIi4uL2NvbnN0cmFpbnRzL1Jldm9sdXRlQ29uc3RyYWludFwiOjIwLFwiLi4vZXZlbnRzL0V2ZW50RW1pdHRlclwiOjI3LFwiLi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsXCI6MjgsXCIuLi9tYXRlcmlhbC9NYXRlcmlhbFwiOjI5LFwiLi4vbWF0aC92ZWMyXCI6MzEsXCIuLi9vYmplY3RzL0JvZHlcIjozMixcIi4uL29iamVjdHMvTGluZWFyU3ByaW5nXCI6MzMsXCIuLi9vYmplY3RzL1JvdGF0aW9uYWxTcHJpbmdcIjozNCxcIi4uL3NoYXBlcy9DYXBzdWxlXCI6MzcsXCIuLi9zaGFwZXMvQ2lyY2xlXCI6MzgsXCIuLi9zaGFwZXMvQ29udmV4XCI6MzksXCIuLi9zaGFwZXMvTGluZVwiOjQxLFwiLi4vc2hhcGVzL1BhcnRpY2xlXCI6NDIsXCIuLi9zaGFwZXMvUGxhbmVcIjo0MyxcIi4uL3NoYXBlcy9SZWN0YW5nbGVcIjo0NCxcIi4uL3NoYXBlcy9TaGFwZVwiOjQ1LFwiLi4vc29sdmVyL0dTU29sdmVyXCI6NDYsXCIuLi9zb2x2ZXIvU29sdmVyXCI6NDcsXCIuLi91dGlscy9PdmVybGFwS2VlcGVyXCI6NDgsXCIuLi91dGlscy9VdGlsc1wiOjUwLFwiLi9Jc2xhbmRNYW5hZ2VyXCI6NTJ9XX0se30sWzM2XSlcbigzNilcbn0pOzsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0TU9WRV9UTzogMSxcblx0TElORV9UTzogMixcblx0QkVaSUVSX1RPOiAzLFxuXHRRVUFEUkFfVE86IDQsXG5cdENJUkNMRTogNSxcblx0RUxMSVBTRTogNlxufTtcbiIsInZhciBEZWNvcmF0aW9uRHJhd2luZyA9XG57XG5cdHNldFNjYWxlOiBmdW5jdGlvbiAoJHNjYWxlWCwgJHNjYWxlWSlcblx0e1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLmNvbW1hbmRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjb21tYW5kID0gdGhpcy5jb21tYW5kc1tpXTtcblx0XHRcdGNvbW1hbmQuc2V0U2NhbGUoJHNjYWxlWCwgJHNjYWxlWSk7XG5cdFx0fVxuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlY29yYXRpb25EcmF3aW5nO1xuIiwidmFyIENvbW1hbmRzID0gcmVxdWlyZSgnLi9Db21tYW5kcycpO1xuXG52YXIgRGVjb3JhdGlvbkRyYXdpbmdDb21tYW5kID0gZnVuY3Rpb24gKCRpbnN0cnVjdGlvbnMsICRwaHlzaWNzTWFuYWdlcilcbntcblx0dGhpcy5waHlzaWNzTWFuYWdlciA9ICRwaHlzaWNzTWFuYWdlcjtcblx0dGhpcy5uYW1lID0gJGluc3RydWN0aW9ucy5uYW1lO1xuXHR0aGlzLnBvaW50ID0gJGluc3RydWN0aW9ucy5wb2ludDtcblx0dGhpcy5vcHRpb25zID0gJGluc3RydWN0aW9ucy5vcHRpb25zO1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHRoaXMucGh5c2ljc01hbmFnZXIuYWRkZWRUb1dvcmxkLnRoZW4oZnVuY3Rpb24gKClcblx0e1xuXHRcdHNlbGYucmVsYXRpdmVQb2ludCA9XG5cdFx0W1xuXHRcdFx0c2VsZi5wb2ludFswXSAtICRwaHlzaWNzTWFuYWdlci5nZXRYKCksXG5cdFx0XHRzZWxmLnBvaW50WzFdIC0gJHBoeXNpY3NNYW5hZ2VyLmdldFkoKVxuXHRcdF07XG5cdFx0aWYgKHNlbGYubmFtZSA9PT0gQ29tbWFuZHMuQkVaSUVSX1RPIHx8IHNlbGYubmFtZSA9PT0gQ29tbWFuZHMuUVVBRFJBX1RPKVxuXHRcdHtcblx0XHRcdHNlbGYuY3AxID1cblx0XHRcdFtcblx0XHRcdFx0c2VsZi5yZWxhdGl2ZVBvaW50WzBdICsgc2VsZi5vcHRpb25zWzBdWzBdLFxuXHRcdFx0XHRzZWxmLnJlbGF0aXZlUG9pbnRbMV0gKyBzZWxmLm9wdGlvbnNbMF1bMV1cblx0XHRcdF07XG5cdFx0fVxuXHRcdGlmIChzZWxmLm5hbWUgPT09IENvbW1hbmRzLkJFWklFUl9UTylcblx0XHR7XG5cdFx0XHRzZWxmLmNwMiA9XG5cdFx0XHRbXG5cdFx0XHRcdHNlbGYucmVsYXRpdmVQb2ludFswXSArIHNlbGYub3B0aW9uc1sxXVswXSxcblx0XHRcdFx0c2VsZi5yZWxhdGl2ZVBvaW50WzFdICsgc2VsZi5vcHRpb25zWzFdWzFdXG5cdFx0XHRdO1xuXHRcdH1cblx0fSk7XG59O1xuXG5EZWNvcmF0aW9uRHJhd2luZ0NvbW1hbmQucHJvdG90eXBlLnNldFNjYWxlID0gZnVuY3Rpb24gKCRzY2FsZVgsICRzY2FsZVkpXG57XG5cdHRoaXMuc2NhbGVYID0gJHNjYWxlWDtcblx0dGhpcy5zY2FsZVkgPSAkc2NhbGVZO1xuXG5cdGlmICh0aGlzLm5hbWUgPT09IENvbW1hbmRzLkNJUkNMRSB8fCB0aGlzLm5hbWUgPT09IENvbW1hbmRzLkVMTElQU0UpXG5cdHtcblx0XHR0aGlzLnJhZGl1cyA9IHRoaXMub3B0aW9uc1swXSAqIHRoaXMuc2NhbGVYO1xuXHR9XG5cdGlmICh0aGlzLm5hbWUgPT09IENvbW1hbmRzLkVMTElQU0UpXG5cdHtcblx0XHR0aGlzLnJhZGl1c0IgPSB0aGlzLm9wdGlvbnNbMV0gKiB0aGlzLnNjYWxlWDtcblx0fVxufTtcblxuRGVjb3JhdGlvbkRyYXdpbmdDb21tYW5kLnByb3RvdHlwZS5nZXRSb3RhdGlvbiA9IGZ1bmN0aW9uICgpXG57XG5cdHZhciByb3RhID0gKHRoaXMucGh5c2ljc01hbmFnZXIuZ2V0QW5nbGUoKSk7XG5cdHJldHVybiB0aGlzLm9wdGlvbnNbMl0gLSByb3RhOy8vdGhpcy5waHlzaWNzTWFuYWdlci5nZXRBbmdsZSgpICogMTgwIC8gTWF0aC5QSTtcbn07XG5cbkRlY29yYXRpb25EcmF3aW5nQ29tbWFuZC5wcm90b3R5cGUuZ2V0Q29udHJvbFBvaW50ID0gZnVuY3Rpb24gKCRjcClcbntcblx0dmFyIGFuZ2xlID0gLXRoaXMucGh5c2ljc01hbmFnZXIuZ2V0QW5nbGUoKTtcblx0dmFyIHggPSAkY3BbMF07XG5cdHZhciB5ID0gJGNwWzFdO1xuXHRyZXR1cm4gW1xuXHRcdCh0aGlzLnBoeXNpY3NNYW5hZ2VyLmdldFgoKSArIHggKiBNYXRoLmNvcyhhbmdsZSkgLSB5ICogTWF0aC5zaW4oYW5nbGUpKSAqIHRoaXMuc2NhbGVYLFxuXHRcdCh0aGlzLnBoeXNpY3NNYW5hZ2VyLmdldFkoKSArIHkgKiBNYXRoLmNvcyhhbmdsZSkgKyB4ICogTWF0aC5zaW4oYW5nbGUpKSAqIHRoaXMuc2NhbGVZXG5cdF07XG59O1xuXG5EZWNvcmF0aW9uRHJhd2luZ0NvbW1hbmQucHJvdG90eXBlLmdldENQMSA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLmdldENvbnRyb2xQb2ludCh0aGlzLmNwMSk7XG59O1xuXG5EZWNvcmF0aW9uRHJhd2luZ0NvbW1hbmQucHJvdG90eXBlLmdldENQMiA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLmdldENvbnRyb2xQb2ludCh0aGlzLmNwMik7XG59O1xuXG5EZWNvcmF0aW9uRHJhd2luZ0NvbW1hbmQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKVxue1xuXHR2YXIgYW5nbGUgPSAtdGhpcy5waHlzaWNzTWFuYWdlci5nZXRBbmdsZSgpO1xuXHR2YXIgeCA9IHRoaXMucmVsYXRpdmVQb2ludFswXTtcblx0dmFyIHkgPSB0aGlzLnJlbGF0aXZlUG9pbnRbMV07XG5cdHJldHVybiAodGhpcy5waHlzaWNzTWFuYWdlci5nZXRYKCkgKyB4ICogTWF0aC5jb3MoYW5nbGUpIC0geSAqIE1hdGguc2luKGFuZ2xlKSkgKiB0aGlzLnNjYWxlWDtcbn07XG5cbkRlY29yYXRpb25EcmF3aW5nQ29tbWFuZC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpXG57XG5cdHZhciBhbmdsZSA9IC10aGlzLnBoeXNpY3NNYW5hZ2VyLmdldEFuZ2xlKCk7XG5cdHZhciB4ID0gdGhpcy5yZWxhdGl2ZVBvaW50WzBdO1xuXHR2YXIgeSA9IHRoaXMucmVsYXRpdmVQb2ludFsxXTtcblx0cmV0dXJuICh0aGlzLnBoeXNpY3NNYW5hZ2VyLmdldFkoKSArIHkgKiBNYXRoLmNvcyhhbmdsZSkgKyB4ICogTWF0aC5zaW4oYW5nbGUpKSAqIHRoaXMuc2NhbGVZO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWNvcmF0aW9uRHJhd2luZ0NvbW1hbmQ7XG4iLCJ2YXIgTm9kZUdyYXBoID0gZnVuY3Rpb24gKClcbntcblx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xuXHR0aGlzLmVkZ2VzID0gW107XG59O1xuXG5Ob2RlR3JhcGgucHJvdG90eXBlLmdldFZlcnRleCA9IGZ1bmN0aW9uICgkbm9kZSlcbntcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1tpXTtcblx0XHRpZiAodmVydGV4Lm5vZGUgPT09ICRub2RlKVxuXHRcdHtcblx0XHRcdHJldHVybiB2ZXJ0ZXg7XG5cdFx0fVxuXHR9XG59O1xuXG5Ob2RlR3JhcGgucHJvdG90eXBlLmNyZWF0ZVZlcnRleCA9IGZ1bmN0aW9uICgkbm9kZSlcbntcblx0dmFyIHZlcnRleCA9IHsgbm9kZTogJG5vZGUgfTtcblx0dGhpcy52ZXJ0aWNlcy5wdXNoKHZlcnRleCk7XG5cdHJldHVybiB2ZXJ0ZXg7XG59O1xuXG5Ob2RlR3JhcGgucHJvdG90eXBlLmdldEVkZ2VXZWlnaHQgPSBmdW5jdGlvbiAoJGVkZ2UpXG57XG5cdHZhciBkWCA9IE1hdGguYWJzKCRlZGdlLnZlcnRleEEubm9kZS5vWCAtICRlZGdlLnZlcnRleEIubm9kZS5vWCk7XG5cdHZhciBkWSA9IE1hdGguYWJzKCRlZGdlLnZlcnRleEEubm9kZS5vWSAtICRlZGdlLnZlcnRleEIubm9kZS5vWSk7XG5cdHZhciBkaXN0ID0gTWF0aC5zcXJ0KGRYICogZFggKyBkWSAqIGRZKTtcblx0cmV0dXJuIGRpc3Q7XG59O1xuXG5Ob2RlR3JhcGgucHJvdG90eXBlLmdldFZlcnRleEVkZ2VzID0gZnVuY3Rpb24gKCR2ZXJ0ZXgpXG57XG5cdHZhciB0b1JldHVybiA9IFtdO1xuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5lZGdlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBlZGdlID0gdGhpcy5lZGdlc1tpXTtcblx0XHRpZiAoZWRnZS52ZXJ0ZXhBID09PSAkdmVydGV4IHx8IGVkZ2UudmVydGV4QiA9PT0gJHZlcnRleClcblx0XHR7XG5cdFx0XHR0b1JldHVybi5wdXNoKGVkZ2UpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdG9SZXR1cm47XG59O1xuXG5Ob2RlR3JhcGgucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoJEFOb2RlLCAkQk5vZGUpXG57XG5cdHZhciB2ZXJ0ZXhBID0gdGhpcy5nZXRWZXJ0ZXgoJEFOb2RlKSB8fCB0aGlzLmNyZWF0ZVZlcnRleCgkQU5vZGUpO1xuXHR2YXIgdmVydGV4QiA9IHRoaXMuZ2V0VmVydGV4KCRCTm9kZSkgfHwgdGhpcy5jcmVhdGVWZXJ0ZXgoJEJOb2RlKTtcblxuXHR2YXIgZXhpc3RzID0gZmFsc2U7XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLmVkZ2VzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGVkZ2UgPSB0aGlzLmVkZ2VzW2ldO1xuXHRcdGlmICgoZWRnZS52ZXJ0ZXhBID09PSB2ZXJ0ZXhBICYmXG5cdFx0XHRlZGdlLnZlcnRleEIgPT09IHZlcnRleEIpIHx8XG5cdFx0XHQoZWRnZS52ZXJ0ZXhBID09PSB2ZXJ0ZXhCICYmXG5cdFx0XHRlZGdlLnZlcnRleEIgPT09IHZlcnRleEEpKVxuXHRcdHtcblx0XHRcdGV4aXN0cyA9IHRydWU7XG5cdFx0fVxuXHR9XG5cdGlmICghZXhpc3RzKVxuXHR7XG5cdFx0dGhpcy5lZGdlcy5wdXNoKHsgdmVydGV4QTogdmVydGV4QSwgdmVydGV4QjogdmVydGV4QiB9KTtcblx0fVxufTtcblxuTm9kZUdyYXBoLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uICgkc3RhcnRpbmdWZXJ0aWNlcylcbntcblx0dmFyIGk7XG5cdHZhciBvcGVuTGlzdCA9IFtdO1xuXHR2YXIgZWRnZXNMZW5ndGg7XG5cdHZhciB2ZXJ0ZXhFZGdlcztcblx0dmFyIHN0YXJ0aW5nVmVydGljZXNMZW5ndGggPSAkc3RhcnRpbmdWZXJ0aWNlcy5sZW5ndGg7XG5cdGZvciAoaSA9IDA7IGkgPCBzdGFydGluZ1ZlcnRpY2VzTGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHQkc3RhcnRpbmdWZXJ0aWNlc1tpXS5tYXBWYWx1ZSA9IDA7XG5cdFx0JHN0YXJ0aW5nVmVydGljZXNbaV0ub3BlbmVkID0gdHJ1ZTtcblx0XHRvcGVuTGlzdC5wdXNoKCRzdGFydGluZ1ZlcnRpY2VzW2ldKTtcblx0fVxuXG5cdHdoaWxlIChvcGVuTGlzdC5sZW5ndGgpXG5cdHtcblx0XHR2YXIgY2xvc2VkVmVydGV4ID0gb3Blbkxpc3Quc2hpZnQoKTtcblx0XHRjbG9zZWRWZXJ0ZXguY2xvc2VkID0gdHJ1ZTtcblxuXHRcdHZlcnRleEVkZ2VzID0gdGhpcy5nZXRWZXJ0ZXhFZGdlcyhjbG9zZWRWZXJ0ZXgpO1xuXHRcdGVkZ2VzTGVuZ3RoID0gdmVydGV4RWRnZXMubGVuZ3RoO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBlZGdlc0xlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjdXJyRWRnZSA9IHZlcnRleEVkZ2VzW2ldO1xuXHRcdFx0dmFyIG90aGVyVmVydGV4ID0gY3VyckVkZ2UudmVydGV4QSA9PT0gY2xvc2VkVmVydGV4ID8gY3VyckVkZ2UudmVydGV4QiA6IGN1cnJFZGdlLnZlcnRleEE7XG5cdFx0XHRpZiAob3RoZXJWZXJ0ZXguY2xvc2VkKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdGlmICghb3RoZXJWZXJ0ZXgub3BlbmVkKVxuXHRcdFx0e1xuXHRcdFx0XHRvdGhlclZlcnRleC5vcGVuZWQgPSB0cnVlO1xuXHRcdFx0XHRvcGVuTGlzdC5wdXNoKG90aGVyVmVydGV4KTtcblx0XHRcdH1cblx0XHRcdHZhciB2YWwgPSBjbG9zZWRWZXJ0ZXgubWFwVmFsdWUgKyB0aGlzLmdldEVkZ2VXZWlnaHQoY3VyckVkZ2UpO1xuXHRcdFx0b3RoZXJWZXJ0ZXgubWFwVmFsdWUgPSBvdGhlclZlcnRleC5tYXBWYWx1ZSA8IHZhbCA/IG90aGVyVmVydGV4Lm1hcFZhbHVlIDogdmFsOyAvL3dvcmtzIGV2ZW4gaWYgdW5kZWZpbmVkXG5cdFx0fVxuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVHcmFwaDtcbiIsInZhciBQb2x5Z29uID1cbntcblx0aW5pdDogZnVuY3Rpb24gKCRwb2ludHMpXG5cdHtcblx0XHR2YXIgcG9seWdvbiA9IE9iamVjdC5jcmVhdGUoUG9seWdvbik7XG5cdFx0cG9seWdvbi5wb2ludHMgPSAkcG9pbnRzO1xuXHRcdHBvbHlnb24uX2JvdW5kaW5nQm94ID0gdW5kZWZpbmVkO1xuXHRcdHJldHVybiBwb2x5Z29uO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXIgc3VtQSA9IDA7XG5cdFx0dmFyIHN1bUIgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgY3VyclBvaW50ID0gdGhpcy5wb2ludHNbaV07XG5cdFx0XHR2YXIgbmV4dCA9IGkgPT09IGxlbmd0aCAtIDEgPyB0aGlzLnBvaW50c1swXSA6IHRoaXMucG9pbnRzW2kgKyAxXTtcblxuXHRcdFx0c3VtQSArPSBjdXJyUG9pbnRbMF0gKiBuZXh0WzFdO1xuXHRcdFx0c3VtQiArPSBjdXJyUG9pbnRbMV0gKiBuZXh0WzBdO1xuXHRcdH1cblxuXHRcdHJldHVybiBNYXRoLmFicygoc3VtQSAtIHN1bUIpICogMC41KTtcblx0fSxcblxuXHRnZXRCb3VuZGluZ0JveDogZnVuY3Rpb24gKClcblx0e1xuXHRcdGlmICghdGhpcy5fYm91bmRpbmdCb3gpXG5cdFx0e1xuXHRcdFx0dmFyIG1pblggPSB0aGlzLnBvaW50c1swXVswXTtcblx0XHRcdHZhciBtYXhYID0gbWluWDtcblx0XHRcdHZhciBtaW5ZID0gdGhpcy5wb2ludHNbMF1bMV07XG5cdFx0XHR2YXIgbWF4WSA9IG1pblk7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIHBvaW50ID0gdGhpcy5wb2ludHNbaV07XG5cdFx0XHRcdG1pblggPSBNYXRoLm1pbihtaW5YLCBwb2ludFswXSk7XG5cdFx0XHRcdG1heFggPSBNYXRoLm1heChtYXhYLCBwb2ludFswXSk7XG5cdFx0XHRcdG1pblkgPSBNYXRoLm1pbihtaW5ZLCBwb2ludFsxXSk7XG5cdFx0XHRcdG1heFkgPSBNYXRoLm1heChtYXhZLCBwb2ludFsxXSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9ib3VuZGluZ0JveCA9IFtbbWluWCwgbWluWV0sIFttYXhYLCBtYXhZXV07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9ib3VuZGluZ0JveDtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXIgYm91bmRpbmcgPSB0aGlzLmdldEJvdW5kaW5nQm94KCk7XG5cdFx0dmFyIHggPSBib3VuZGluZ1swXVswXSArIChib3VuZGluZ1sxXVswXSAtIGJvdW5kaW5nWzBdWzBdKSAvIDI7XG5cdFx0dmFyIHkgPSBib3VuZGluZ1swXVsxXSArIChib3VuZGluZ1sxXVsxXSAtIGJvdW5kaW5nWzBdWzFdKSAvIDI7XG5cdFx0cmV0dXJuIFt4LCB5XTtcblx0fSxcblxuXHRnZXRTZWdtZW50czogZnVuY3Rpb24gKClcblx0e1xuXHRcdHZhciBzZWdtZW50cyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLnBvaW50cy5sZW5ndGggLSAxOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdFx0e1xuXHRcdFx0c2VnbWVudHMucHVzaChbdGhpcy5wb2ludHNbaV0sIHRoaXMucG9pbnRzW2kgKyAxXV0pO1xuXHRcdH1cblx0XHRzZWdtZW50cy5wdXNoKFt0aGlzLnBvaW50c1t0aGlzLnBvaW50cy5sZW5ndGggLSAxXSwgdGhpcy5wb2ludHNbMF1dKTtcblx0XHRyZXR1cm4gc2VnbWVudHM7XG5cdH0sXG5cblx0Z2V0SW50ZXJzZWN0aW9uc0F0WTogZnVuY3Rpb24gKCR0ZXN0WSlcblx0e1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuZ2V0U2VnbWVudHMoKTtcblx0XHR2YXIgaW50ZXJzZWN0aW9ucyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgY3VyclNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdHZhciB4MSA9IGN1cnJTZWdtZW50WzBdWzBdO1xuXHRcdFx0dmFyIHkxID0gY3VyclNlZ21lbnRbMF1bMV07XG5cdFx0XHR2YXIgeDIgPSBjdXJyU2VnbWVudFsxXVswXTtcblx0XHRcdHZhciB5MiA9IGN1cnJTZWdtZW50WzFdWzFdO1xuXHRcdFx0dmFyIHNtYWxsWSA9IE1hdGgubWluKHkxLCB5Mik7XG5cdFx0XHR2YXIgYmlnWSA9IE1hdGgubWF4KHkxLCB5Mik7XG5cblx0XHRcdGlmICgkdGVzdFkgPiBzbWFsbFkgJiYgJHRlc3RZIDwgYmlnWSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIHBZID0geTIgLSAkdGVzdFk7XG5cdFx0XHRcdHZhciBzZWdZID0geTIgLSB5MTtcblx0XHRcdFx0dmFyIHNlZ1ggPSB4MiAtIHgxO1xuXHRcdFx0XHR2YXIgcFggPSBwWSAqIHNlZ1ggLyBzZWdZO1xuXHRcdFx0XHRpbnRlcnNlY3Rpb25zLnB1c2goeDIgLSBwWCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBpbnRlcnNlY3Rpb25zO1xuXHR9LFxuXG5cdGlzSW5zaWRlOiBmdW5jdGlvbiAoJHBvaW50KVxuXHR7XG5cdFx0dmFyIGluZk51bWJlciA9IDA7XG5cdFx0dmFyIGludGVyc2VjdGlvbnMgPSB0aGlzLmdldEludGVyc2VjdGlvbnNBdFkoJHBvaW50WzFdKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gaW50ZXJzZWN0aW9ucy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHRpZiAoJHBvaW50WzBdIDwgaW50ZXJzZWN0aW9uc1tpXSkgeyBpbmZOdW1iZXIgKz0gMTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gaW5mTnVtYmVyICUgMiA+IDA7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9seWdvbjtcblxuIiwidmFyIEFuY2hvclAyR2hvc3RQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgkcDIsICRwMldvcmxkLCAkd29ybGRIZWlnaHQpXG57XG5cdHRoaXMucDIgPSAkcDI7XG5cdHRoaXMucDJXb3JsZCA9ICRwMldvcmxkO1xuXHR0aGlzLm9mZnNldCA9IFswLCAwXTtcblx0dGhpcy53b3JsZEhlaWdodCA9ICR3b3JsZEhlaWdodDtcbn07XG5cbkFuY2hvclAyR2hvc3RQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuc2V0RnJvbVBvaW50ID0gZnVuY3Rpb24gKCRwb2ludClcbntcblx0dGhpcy5wb2ludCA9ICRwb2ludDtcbn07XG5cbkFuY2hvclAyR2hvc3RQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuYWRkVG9Xb3JsZCA9IGZ1bmN0aW9uICgpXG57XG5cdHRoaXMuYm9keSA9IG5ldyB0aGlzLnAyLkJvZHkoe1xuXHRcdHBvc2l0aW9uOiBbdGhpcy5wb2ludFswXSwgdGhpcy53b3JsZEhlaWdodCAtIHRoaXMucG9pbnRbMV1dXG5cdH0pO1xuXHR0aGlzLnAyV29ybGQuYWRkQm9keSh0aGlzLmJvZHkpO1xufTtcblxuQW5jaG9yUDJHaG9zdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMuYm9keS5wb3NpdGlvblswXTtcbn07XG5cbkFuY2hvclAyR2hvc3RQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLndvcmxkSGVpZ2h0IC0gdGhpcy5ib2R5LnBvc2l0aW9uWzFdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbmNob3JQMkdob3N0UGh5c2ljc01hbmFnZXI7XG4iLCJ2YXIgQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXIgPSBmdW5jdGlvbiAoJGdyb3VwKSB7IHRoaXMuZ3JvdXAgPSAkZ3JvdXA7IH07XG5cbkFuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5zZXRGcm9tUG9pbnQgPSBmdW5jdGlvbiAoJHBvaW50KVxue1xuXHR0aGlzLnBvaW50ID0gJHBvaW50O1xufTtcblxuQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmFkZFRvV29ybGQgPSBmdW5jdGlvbiAoKVxue1xuXHR0aGlzLmJvZHkgPSB0aGlzLmdyb3VwLnBoeXNpY3NNYW5hZ2VyLmJvZHk7XG5cdHRoaXMud29ybGRIZWlnaHQgPSB0aGlzLmdyb3VwLnBoeXNpY3NNYW5hZ2VyLndvcmxkSGVpZ2h0O1xuXHR0aGlzLm9mZnNldCA9IFt0aGlzLnBvaW50WzBdIC0gdGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzBdLCAodGhpcy53b3JsZEhlaWdodCAtIHRoaXMucG9pbnRbMV0pIC0gdGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzFdXTtcblx0dmFyIGRYID0gdGhpcy5vZmZzZXRbMF07XG5cdHZhciBkWSA9IHRoaXMub2Zmc2V0WzFdO1xuXHR0aGlzLmFuZ2xlID0gTWF0aC5hdGFuMihkWSwgZFgpO1xuXHR0aGlzLmh5cCA9IE1hdGguc3FydChkWCAqIGRYICsgZFkgKiBkWSk7XG59O1xuXG5BbmNob3JQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuc2V0Rml4ZWQgPSBmdW5jdGlvbiAoJGZpeGVkKVxue1xuXHR0aGlzLmdyb3VwLmZpeGVkID0gJGZpeGVkO1xufTtcblxuQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzBdICsgdGhpcy5oeXAgKiBNYXRoLmNvcyh0aGlzLmJvZHkuYW5nbGUgKyB0aGlzLmFuZ2xlKTtcbn07XG5cbkFuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMud29ybGRIZWlnaHQgLSAodGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzFdICsgdGhpcy5oeXAgKiBNYXRoLnNpbih0aGlzLmJvZHkuYW5nbGUgKyB0aGlzLmFuZ2xlKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyO1xuIiwidmFyIEFuY2hvclAyU29mdFBoeXNpY3NNYW5hZ2VyID0gZnVuY3Rpb24gKCRncm91cCkgeyB0aGlzLmdyb3VwID0gJGdyb3VwOyB9O1xuXG5BbmNob3JQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuc2V0RnJvbVBvaW50ID0gZnVuY3Rpb24gKCRwb2ludClcbntcblx0dGhpcy5wb2ludCA9ICRwb2ludDtcblx0dGhpcy5ub2RlID0gdGhpcy5ncm91cC5nZXRDbG9zZXN0Tm9kZSgkcG9pbnQpO1xuXHR0aGlzLndvcmxkSGVpZ2h0ID0gdGhpcy5ncm91cC5waHlzaWNzTWFuYWdlci53b3JsZEhlaWdodDtcblx0dGhpcy5vZmZzZXQgPSBbMCwgMF07XG59O1xuXG5BbmNob3JQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuYWRkVG9Xb3JsZCA9IGZ1bmN0aW9uICgpXG57XG5cdHRoaXMuYm9keSA9IHRoaXMubm9kZS5waHlzaWNzTWFuYWdlci5ib2R5O1xufTtcblxuQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLnNldEZpeGVkID0gZnVuY3Rpb24gKCRmaXhlZClcbntcblx0dGhpcy5ub2RlLmZpeGVkID0gJGZpeGVkO1xufTtcblxuQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzBdO1xufTtcblxuQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy53b3JsZEhlaWdodCAtIHRoaXMuYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblsxXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXI7XG4iLCJ2YXIgSGFyZERlY29yYXRpb25EcmF3aW5nID0gcmVxdWlyZSgnLi9IYXJkRGVjb3JhdGlvbkRyYXdpbmcnKTtcblxudmFyIEdyb3VwR2hvc3RQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgkZ3JvdXApXG57XG5cdHRoaXMuZ3JvdXAgPSAkZ3JvdXA7XG5cdHRoaXMuX2JvdW5kaW5nQm94ID0gdW5kZWZpbmVkO1xuXHR0aGlzLl9wb3NpdGlvbiA9IFtdO1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHRoaXMubm9kZXNBZGRlZFByb21pc2UgPSBuZXcgd2luZG93LlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgc2VsZi5yZXNvbHZlTm9kZXNBZGRlZCA9IHJlc29sdmU7IH0pO1xufTtcblxuR3JvdXBHaG9zdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXROb2RlUGh5c2ljc01hbmFnZXIgPSBmdW5jdGlvbiAoJG5vZGUpXG57XG5cdHZhciBtYW5hZ2VyID0ge307XG5cdHZhciBnZXRYID0gZnVuY3Rpb24gKCRub2RlT1gpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuICRub2RlT1g7IH07IH07XG5cdHZhciBnZXRZID0gZnVuY3Rpb24gKCRub2RlT1kpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuICRub2RlT1k7IH07IH07XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLmdyb3VwLm5vZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0bWFuYWdlci5nZXRYID0gZ2V0WCgkbm9kZS5vWCk7XG5cdFx0bWFuYWdlci5nZXRZID0gZ2V0WSgkbm9kZS5vWSk7XG5cdH1cblx0cmV0dXJuIG1hbmFnZXI7XG59O1xuXG5Hcm91cEdob3N0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldERlY29yYXRpb25EcmF3aW5nID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIEhhcmREZWNvcmF0aW9uRHJhd2luZy5jcmVhdGUodGhpcy5ncm91cCk7XG59O1xuXG5Hcm91cEdob3N0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKClcbntcblx0aWYgKCF0aGlzLl9ib3VuZGluZ0JveClcblx0e1xuXHRcdHZhciBtaW5YID0gSW5maW5pdHk7XG5cdFx0dmFyIG1pblkgPSBJbmZpbml0eTtcblx0XHR2YXIgbWF4WCA9IC1JbmZpbml0eTtcblx0XHR2YXIgbWF4WSA9IC1JbmZpbml0eTtcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5ncm91cC5ub2Rlc0xlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjdXJyTm9kZSA9IHRoaXMuZ3JvdXAubm9kZXNbaV07XG5cdFx0XHRtaW5YID0gTWF0aC5taW4oY3Vyck5vZGUucGh5c2ljc01hbmFnZXIuZ2V0WCgpLCBtaW5YKTtcblx0XHRcdG1pblkgPSBNYXRoLm1pbihjdXJyTm9kZS5waHlzaWNzTWFuYWdlci5nZXRZKCksIG1pblkpO1xuXHRcdFx0bWF4WCA9IE1hdGgubWluKGN1cnJOb2RlLnBoeXNpY3NNYW5hZ2VyLmdldFgoKSwgbWF4WCk7XG5cdFx0XHRtYXhZID0gTWF0aC5taW4oY3Vyck5vZGUucGh5c2ljc01hbmFnZXIuZ2V0WSgpLCBtYXhZKTtcblx0XHR9XG5cdFx0dGhpcy5fYm91bmRpbmdCb3ggPSBbW21pblgsIG1pblldLCBbbWF4WCwgbWF4WV1dO1xuXHR9XG5cdHJldHVybiB0aGlzLl9ib3VuZGluZ0JveDtcbn07XG5cbkdyb3VwR2hvc3RQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuYWRkSm9pbnRzVG9Xb3JsZCA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiBudWxsO1xufTtcblxuR3JvdXBHaG9zdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbmdsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDA7IH07XG5Hcm91cEdob3N0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwOyB9O1xuR3JvdXBHaG9zdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfTtcblxuR3JvdXBHaG9zdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uICgpXG57XG5cdGlmICghdGhpcy5fYm91bmRpbmdCb3gpXG5cdHtcblx0XHR2YXIgbWluWCA9IEluZmluaXR5O1xuXHRcdHZhciBtaW5ZID0gSW5maW5pdHk7XG5cdFx0dmFyIG1heFggPSAtSW5maW5pdHk7XG5cdFx0dmFyIG1heFkgPSAtSW5maW5pdHk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuZ3JvdXAubm9kZXNMZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHR2YXIgY3Vyck5vZGUgPSB0aGlzLmdyb3VwLm5vZGVzW2ldO1xuXHRcdFx0bWluWCA9IE1hdGgubWluKGN1cnJOb2RlLnBoeXNpY3NNYW5hZ2VyLmdldFgoKSwgbWluWCk7XG5cdFx0XHRtaW5ZID0gTWF0aC5taW4oY3Vyck5vZGUucGh5c2ljc01hbmFnZXIuZ2V0WSgpLCBtaW5ZKTtcblx0XHRcdG1heFggPSBNYXRoLm1heChjdXJyTm9kZS5waHlzaWNzTWFuYWdlci5nZXRYKCksIG1heFgpO1xuXHRcdFx0bWF4WSA9IE1hdGgubWF4KGN1cnJOb2RlLnBoeXNpY3NNYW5hZ2VyLmdldFkoKSwgbWF4WSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fYm91bmRpbmdCb3ggPSBbW21pblgsIG1pblldLCBbbWF4WCwgbWF4WV1dO1xuXHR9XG5cdHJldHVybiB0aGlzLl9ib3VuZGluZ0JveDtcbn07XG5cbkdyb3VwR2hvc3RQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuYWRkTm9kZXNUb1dvcmxkID0gZnVuY3Rpb24gKClcbntcblx0dGhpcy5yZXNvbHZlTm9kZXNBZGRlZCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cEdob3N0UGh5c2ljc01hbmFnZXI7XG5cbiIsIi8vIGpzY3M6ZGlzYWJsZSByZXF1aXJlQ2FtZWxDYXNlT3JVcHBlckNhc2VJZGVudGlmaWVyc1xuLypqc2hpbnQgY2FtZWxjYXNlOmZhbHNlKi9cblxudmFyIHAyID0gcmVxdWlyZSgnLi4vLi4vLi4vbGlicy9wMicpO1xudmFyIE5vZGVQMkhhcmRQaHlzaWNzTWFuYWdlciA9IHJlcXVpcmUoJy4vTm9kZVAySGFyZFBoeXNpY3NNYW5hZ2VyJyk7XG52YXIgQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXIgPSByZXF1aXJlKCcuL0FuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyJyk7XG52YXIgSGFyZERlY29yYXRpb25EcmF3aW5nID0gcmVxdWlyZSgnLi9IYXJkRGVjb3JhdGlvbkRyYXdpbmcnKTtcblxudmFyIEdyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXIgPSBmdW5jdGlvbiAoJGdyb3VwLCAkUDJXb3JsZCwgJHdvcmxkSGVpZ2h0LCAkbWF0ZXJpYWxzTGlzdClcbntcblx0dGhpcy5ncm91cCA9ICRncm91cDtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR0aGlzLl9wb3NpdGlvbiA9IFtdO1xuXHR0aGlzLmFkZGVkVG9Xb3JsZCA9IG5ldyB3aW5kb3cuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyBzZWxmLnJlc29sdmVBZGRlZFRvV29ybGQgPSByZXNvbHZlOyB9KTtcblx0dGhpcy5tYXRlcmlhbHNMaXN0ID0gJG1hdGVyaWFsc0xpc3Q7XG5cdHRoaXMud29ybGRIZWlnaHQgPSAkd29ybGRIZWlnaHQ7XG5cdHRoaXMuUDJXb3JsZCA9ICRQMldvcmxkO1xuXHR0aGlzLmNvbmYgPSAkZ3JvdXAuY29uZi5waHlzaWNzO1xuXHR0aGlzLl9ib3VuZGluZ0JveCA9IFtbMCwgMF0sIFswLCAwXV07XG59O1xuXG5Hcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXREZWNvcmF0aW9uRHJhd2luZyA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiBIYXJkRGVjb3JhdGlvbkRyYXdpbmcuY3JlYXRlKHRoaXMuZ3JvdXApO1xufTtcblxuR3JvdXBQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0Tm9kZVBoeXNpY3NNYW5hZ2VyID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIG5ldyBOb2RlUDJIYXJkUGh5c2ljc01hbmFnZXIoKTtcbn07XG5cbkdyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKClcbntcblx0dmFyIEFBQkIgPSB0aGlzLmJvZHkuZ2V0QUFCQigpO1xuXHR0aGlzLl9ib3VuZGluZ0JveFswXVswXSA9IEFBQkIubG93ZXJCb3VuZFswXTtcblx0dGhpcy5fYm91bmRpbmdCb3hbMF1bMV0gPSB0aGlzLndvcmxkSGVpZ2h0IC0gQUFCQi51cHBlckJvdW5kWzFdO1xuXHR0aGlzLl9ib3VuZGluZ0JveFsxXVswXSA9IEFBQkIudXBwZXJCb3VuZFswXTtcblx0dGhpcy5fYm91bmRpbmdCb3hbMV1bMV0gPSB0aGlzLndvcmxkSGVpZ2h0IC0gQUFCQi5sb3dlckJvdW5kWzFdO1xuXHRyZXR1cm4gdGhpcy5fYm91bmRpbmdCb3g7XG59O1xuXG5Hcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzBdOyB9O1xuR3JvdXBQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMud29ybGRIZWlnaHQgLSB0aGlzLmJvZHkuaW50ZXJwb2xhdGVkUG9zaXRpb25bMV07IH07XG5cbkdyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldEFuZ2xlID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMuYm9keS5pbnRlcnBvbGF0ZWRBbmdsZTtcbn07XG5cbkdyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUFuY2hvckZyb21Qb2ludCA9IGZ1bmN0aW9uICgkcG9pbnQpXG57XG5cdHZhciBhbmNob3IgPSBuZXcgQW5jaG9yUDJIYXJkUGh5c2ljc01hbmFnZXIodGhpcy5ncm91cCk7XG5cdGFuY2hvci5zZXRGcm9tUG9pbnQoJHBvaW50KTtcblx0cmV0dXJuIGFuY2hvcjtcbn07XG5cbkdyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUFuY2hvckZyb21MaW5lID0gZnVuY3Rpb24gKCRsaW5lUG9pbnRzKVxue1xuXHR2YXIgY2xvc2VzdFBvaW50ID0gdGhpcy5ncm91cC5nZXRDbG9zZXN0UG9pbnQoJGxpbmVQb2ludHMpO1xuXHR2YXIgYW5jaG9yID0gbmV3IEFuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyKHRoaXMuZ3JvdXApO1xuXHRhbmNob3Iuc2V0RnJvbVBvaW50KGNsb3Nlc3RQb2ludCk7XG5cdHJldHVybiBhbmNob3I7XG59O1xuXG5Hcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVBbmNob3JzID0gZnVuY3Rpb24gKCRwb2ludHMpXG57XG5cdHZhciB0b1JldHVybiA9IFtdO1xuXHR2YXIgbm9kZXMgPSB0aGlzLmdyb3VwLmdldE5vZGVzSW5zaWRlKCRwb2ludHMpO1xuXHRpZiAoIW5vZGVzLmxlbmd0aClcblx0e1xuXHRcdHZhciBkZWZhdWx0QW5jaG9yID0gbmV3IEFuY2hvclAySGFyZFBoeXNpY3NNYW5hZ2VyKHRoaXMuZ3JvdXApO1xuXHRcdHZhciBQb2x5Z29uID0gcmVxdWlyZSgnLi4vLi4vY29yZS9Qb2x5Z29uJyk7XG5cdFx0dmFyIHBvbHlnb24gPSBQb2x5Z29uLmluaXQoJHBvaW50cyk7XG5cdFx0dmFyIGNlbnRlciA9IHBvbHlnb24uZ2V0Q2VudGVyKCk7XG5cdFx0Ly92YXIgY2xvc2VzdCA9IHRoaXMuZ3JvdXAuZ2V0Q2xvc2VzdFBvaW50KCRwb2ludHMpO1xuXHRcdGRlZmF1bHRBbmNob3Iuc2V0RnJvbVBvaW50KGNlbnRlcik7XG5cdFx0cmV0dXJuIFtkZWZhdWx0QW5jaG9yXTtcblx0fVxuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbm9kZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgbm9kZSA9IG5vZGVzW2ldO1xuXHRcdHZhciBjdXJyQW5jaG9yQSA9IG5ldyBBbmNob3JQMkhhcmRQaHlzaWNzTWFuYWdlcih0aGlzLmdyb3VwKTtcblx0XHRjdXJyQW5jaG9yQS5zZXRGcm9tUG9pbnQoW25vZGUub1gsIG5vZGUub1ldKTtcblx0XHR0b1JldHVybi5wdXNoKGN1cnJBbmNob3JBKTtcblx0fVxuXHRyZXR1cm4gdG9SZXR1cm47XG59O1xuXG5Hcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24gKCR2ZWN0b3IpXG57XG5cdHRoaXMuYm9keS5hcHBseUZvcmNlKCR2ZWN0b3IsIHRoaXMuYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvbik7XG59O1xuXG5Hcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5hZGRKb2ludHNUb1dvcmxkID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XG5cbkdyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmFkZE5vZGVzVG9Xb3JsZCA9IGZ1bmN0aW9uICgpXG57XG5cdHZhciBwYXRoID0gW107XG5cblx0dmFyIHN0YXJ0WCA9IHRoaXMuZ3JvdXAubm9kZXNbMF0ub1g7XG5cdHZhciBzdGFydFkgPSB0aGlzLmdyb3VwLm5vZGVzWzBdLm9ZO1xuXHR2YXIgaW5pdFggPSBzdGFydFg7XG5cdHZhciBpbml0WSA9IHRoaXMud29ybGRIZWlnaHQgLSBzdGFydFk7XG5cblx0dGhpcy5ib2R5ID0gbmV3IHAyLkJvZHkoe1xuXHRcdG1hc3M6IHRoaXMuZ3JvdXAuZml4ZWQgPyAwIDogMSxcblx0XHRwb3NpdGlvbjogW3N0YXJ0WCwgdGhpcy53b3JsZEhlaWdodCAtIHN0YXJ0WV1cblx0fSk7XG5cdHZhciBub2RlO1xuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5ncm91cC5ub2Rlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdG5vZGUgPSB0aGlzLmdyb3VwLm5vZGVzW2ldO1xuXHRcdHZhciBwb3MgPSBbbm9kZS5vWCAtIHN0YXJ0WCwgLShub2RlLm9ZIC0gc3RhcnRZKV07XG5cdFx0bm9kZS5waHlzaWNzTWFuYWdlci5hZGRUb1dvcmxkKHRoaXMuYm9keSwgcG9zLCB0aGlzLndvcmxkSGVpZ2h0KTtcblx0XHRwYXRoLnB1c2gocG9zKTtcblx0fVxuXG5cdGlmIChsZW5ndGggPiAxKVxuXHR7XG5cdFx0dGhpcy5ib2R5LmZyb21Qb2x5Z29uKHBhdGgpO1xuXHRcdHZhciBvZmZzZXQgPSBbaW5pdFggLSB0aGlzLmJvZHkucG9zaXRpb25bMF0sIHRoaXMuYm9keS5wb3NpdGlvblsxXSAtIGluaXRZXTtcblx0XHRpID0gMDtcblx0XHRmb3IgKGk7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0XHR7XG5cdFx0XHRub2RlID0gdGhpcy5ncm91cC5ub2Rlc1tpXTtcblx0XHRcdG5vZGUucGh5c2ljc01hbmFnZXIuc2V0T2Zmc2V0KG9mZnNldCk7XG5cdFx0fVxuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdHZhciByYWRpdXMgPSB0aGlzLmdyb3VwLnN0cnVjdHVyZS5yYWRpdXNYO1xuXHRcdHZhciBjaXJjbGVTaGFwZSA9IG5ldyBwMi5DaXJjbGUocmFkaXVzKTtcblx0XHR0aGlzLmJvZHkuYWRkU2hhcGUoY2lyY2xlU2hhcGUpO1xuXHR9XG5cblx0dGhpcy5ib2R5LmdyYXZpdHlTY2FsZSA9IHRoaXMuY29uZi5ncmF2aXR5U2NhbGUgIT09IHVuZGVmaW5lZCA/IHRoaXMuY29uZi5ncmF2aXR5U2NhbGUgOiAxO1xuXHQvLyBjb25zb2xlLmxvZyhzdGFydFgsIHRoaXMud29ybGRIZWlnaHQgLSBzdGFydFksIHRoaXMuYm9keS5wb3NpdGlvblswXSwgdGhpcy5ib2R5LnBvc2l0aW9uWzFdKTtcblx0Ly90aGlzLmJvZHkubWFzcyA9IHRoaXMuY29uZi5tYXNzO1xuXHQvL2lmICh0aGlzLmdyb3VwLmNvbmYuZml4ZWQpIHsgbm9kZS5waHlzaWNzTWFuYWdlci5zZXRGaXhlZCh0aGlzLmdyb3VwLmNvbmYuZml4ZWQpOyB9XG5cdC8vdGhpcy5ib2R5LnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG5cdHZhciBzaGFwZXNMZW5ndGggPSB0aGlzLmJvZHkuc2hhcGVzLmxlbmd0aDtcblx0Zm9yIChpID0gMDsgaSA8IHNoYXBlc0xlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJTaGFwZSA9IHRoaXMuYm9keS5zaGFwZXNbaV07XG5cdFx0Y3VyclNoYXBlLm1hdGVyaWFsID0gdGhpcy5jb25mLm1hdGVyaWFsID8gdGhpcy5tYXRlcmlhbHNMaXN0W3RoaXMuY29uZi5tYXRlcmlhbF0ubWF0ZXJpYWwgOiB0aGlzLm1hdGVyaWFsc0xpc3QuZGVmYXVsdC5tYXRlcmlhbDtcblx0fVxuXHR0aGlzLlAyV29ybGQuYWRkQm9keSh0aGlzLmJvZHkpO1xuXHRpZiAodGhpcy5jb25mLm1hc3MgPiAwKVxuXHR7XG5cdFx0dGhpcy5ib2R5LnNldERlbnNpdHkodGhpcy5jb25mLm1hc3MpO1xuXHR9XG5cblx0dGhpcy5ib2R5LmNvbGxpc2lvblJlc3BvbnNlID0gIXRoaXMuY29uZi5ub0NvbGxpZGU7XG5cdGNvbnNvbGUubG9nKCd0cnl0ZnV5ZnB5Z3Z5b2Z2dXQnKTtcblxuXHQvLyBpZiAodGhpcy5ncm91cC5JRCA9PT0gJ3JlYXJXaGVlbCcpXG5cdC8vIHtcblx0Ly8gXHRjb25zb2xlLmxvZyh0aGlzLmJvZHkubWFzcyk7XG5cdC8vIH1cblxuXHR0aGlzLmJvZHkuaW50ZXJwb2xhdGVkUG9zaXRpb25bMF0gPSB0aGlzLmJvZHkucG9zaXRpb25bMF07XG5cdHRoaXMuYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblsxXSA9IHRoaXMuYm9keS5wb3NpdGlvblsxXTtcblx0Ly9ub2RlLnBoeXNpY3NNYW5hZ2VyLnNldEZpeGVkKHRoaXMuZ3JvdXAuY29uZi5maXhlZCk7XG5cdC8vIGNvbnNvbGUubG9nKHRoaXMuYm9keS5zaGFwZXMpO1xuXHQvLyBkZWJ1Z2dlcjtcblxuXHR0aGlzLnJlc29sdmVBZGRlZFRvV29ybGQoKTtcbn07XG5cbkdyb3VwUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmhpdFRlc3QgPSBmdW5jdGlvbiAoJHBvaW50KVxue1xuXHR2YXIgcmVzdWx0ID0gdGhpcy5QMldvcmxkLmhpdFRlc3QoWyRwb2ludFswXSwgdGhpcy53b3JsZEhlaWdodCAtICRwb2ludFsxXV0sIFt0aGlzLmJvZHldKTtcblx0cmV0dXJuIHJlc3VsdCA/IHJlc3VsdFswXSA6IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JvdXBQMkhhcmRQaHlzaWNzTWFuYWdlcjtcblxuIiwiLy8ganNjczpkaXNhYmxlIHJlcXVpcmVDYW1lbENhc2VPclVwcGVyQ2FzZUlkZW50aWZpZXJzXG4vKmpzaGludCBjYW1lbGNhc2U6ZmFsc2UqL1xuXG52YXIgcDIgPSByZXF1aXJlKCcuLi8uLi8uLi9saWJzL3AyJyk7XG4vLyB2YXIgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50L0Rpc3BhdGNoZXInKTtcbnZhciBOb2RlUDJTb2Z0UGh5c2ljc01hbmFnZXIgPSByZXF1aXJlKCcuL05vZGVQMlNvZnRQaHlzaWNzTWFuYWdlcicpO1xudmFyIEFuY2hvclAyU29mdFBoeXNpY3NNYW5hZ2VyID0gcmVxdWlyZSgnLi9BbmNob3JQMlNvZnRQaHlzaWNzTWFuYWdlcicpO1xudmFyIEpvaW50UDJQaHlzaWNzTWFuYWdlciA9IHJlcXVpcmUoJy4vSm9pbnRQMlBoeXNpY3NNYW5hZ2VyJyk7XG52YXIgU29mdERlY29yYXRpb25EcmF3aW5nID0gcmVxdWlyZSgnLi9Tb2Z0RGVjb3JhdGlvbkRyYXdpbmcnKTtcblxudmFyIEdyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXIgPSBmdW5jdGlvbiAoJGdyb3VwLCAkd29ybGQsICR3b3JsZEhlaWdodCwgJG1hdGVyaWFsc0xpc3QpXG57XG5cdHRoaXMuZ3JvdXAgPSAkZ3JvdXA7XG5cdHRoaXMuX2JvdW5kaW5nQm94ID0gW1swLCAwXSwgWzAsIDBdXTtcblx0dGhpcy5tYXRlcmlhbHNMaXN0ID0gJG1hdGVyaWFsc0xpc3Q7XG5cdHRoaXMuX3Bvc2l0aW9uID0gW107XG5cdHZhciBzZWxmID0gdGhpcztcblx0dGhpcy5hZGRlZFRvV29ybGQgPSBuZXcgd2luZG93LlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgc2VsZi5yZXNvbHZlQWRkZWRUb1dvcmxkID0gcmVzb2x2ZTsgfSk7XG5cdHRoaXMud29ybGQgPSAkd29ybGQ7XG5cdHRoaXMud29ybGRIZWlnaHQgPSAkd29ybGRIZWlnaHQ7XG5cdHRoaXMuY29uZiA9ICRncm91cC5jb25mLnBoeXNpY3M7XG5cdC8vIHRoaXMuY29uc3RyYWludHMgPSBbXTtcblx0Ly90aGlzLm5vZGVzRGlhbWV0ZXIgPSB0aGlzLmNvbmYubm9kZXNEaWFtZXRlcjtcbn07XG5cbkdyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmFkZE5vZGVzVG9Xb3JsZCA9IGZ1bmN0aW9uICgpXG57XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLmdyb3VwLm5vZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0Ly8gdGhpcy5iYXNlQm9keSA9IG5ldyBwMi5Cb2R5KHtcblx0XHQvLyBcdG1hc3M6IDFcblx0XHQvLyB9KTtcblx0XHR2YXIgbm9kZSA9IHRoaXMuZ3JvdXAubm9kZXNbaV07XG5cdFx0Ly92YXIgZnJhY3Rpb25NYXNzID0gdGhpcy5jb25mLm1hc3MgLyB0aGlzLmdyb3VwLm5vZGVzLmxlbmd0aDtcblx0XHR2YXIgYXJlYSA9IHRoaXMuZ3JvdXAuc3RydWN0dXJlLmFyZWE7XG5cdFx0dmFyIG5vZGVNYXNzID0gYXJlYSAqIHRoaXMuY29uZi5tYXNzIC8gdGhpcy5ncm91cC5ub2Rlcy5sZW5ndGg7XG5cdFx0Ly92YXIgbWFzcyA9IDUwMDtcblx0XHQvL3ZhciBtYXNzID0gdGhpcy5jb25mLm1hc3M7Ly9NYXRoLnJhbmRvbSgpICogMTAgKyAxO1xuXHRcdHZhciBib2R5ID0gbmV3IHAyLkJvZHkoe1xuXHRcdFx0bWFzczogbm9kZS5maXhlZCA/IDAgOiBub2RlTWFzcyxcblx0XHRcdHBvc2l0aW9uOiBbbm9kZS5vWCwgdGhpcy53b3JsZEhlaWdodCAtIG5vZGUub1ldXG5cdFx0fSk7XG5cdFx0Ym9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblswXSA9IGJvZHkucG9zaXRpb25bMF07XG5cdFx0Ym9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblsxXSA9IGJvZHkucG9zaXRpb25bMV07XG5cblx0XHQvL2lmIChub2RlLmZpeGVkKSB7IGJvZHkudHlwZSA9IHAyLkJvZHkuU1RBVElDOyB9XG5cdFx0Ly9jb25zb2xlLmxvZyhub2RlLm9YLCBub2RlLm9ZKTtcblx0XHQvL3RoaXMuYm9keS5maXhlZFJvdGF0aW9uID0gdHJ1ZTtcblxuXHRcdC8vIHZhciByYWRpdXMgPSB0aGlzLmNvbmYubm9kZVJhZGl1cztcblx0XHQvLyB2YXIgY2lyY2xlU2hhcGUgPSBuZXcgcDIuQ2lyY2xlKHJhZGl1cyk7XG5cdFx0Ly8gYm9keS5hZGRTaGFwZShjaXJjbGVTaGFwZSk7XG5cblx0XHR2YXIgcmFkaXVzID0gdGhpcy5ncm91cC5zdHJ1Y3R1cmUuaW5uZXJSYWRpdXMgfHwgdGhpcy5ncm91cC5jb25mLm5vZGVSYWRpdXMgfHwgMC4xO1xuXHRcdHZhciBzaGFwZSA9IG5ldyBwMi5DaXJjbGUocmFkaXVzKTtcblx0XHRib2R5LmFkZFNoYXBlKHNoYXBlKTtcblx0XHRzaGFwZS5tYXRlcmlhbCA9IHRoaXMuY29uZi5tYXRlcmlhbCA/IHRoaXMubWF0ZXJpYWxzTGlzdFt0aGlzLmNvbmYubWF0ZXJpYWxdLm1hdGVyaWFsIDogdGhpcy5tYXRlcmlhbHNMaXN0LmRlZmF1bHQubWF0ZXJpYWw7XG5cblx0XHQvL2NvbnNvbGUubG9nKHRoaXMuYm9keS5nZXRBcmVhKCkpO1xuXG5cdFx0Ly90aGlzLmJvZHkuc2V0RGVuc2l0eShub2RlLnR5cGUgPT09ICdsaW5lJyA/IDEgOiA1MDAwKTtcblxuXHRcdC8vYm9keS5kYW1waW5nID0gMTtcblx0XHQvL2JvZHkubWFzcyA9IG1hc3M7XG5cdFx0bm9kZS5waHlzaWNzTWFuYWdlci5hZGRUb1dvcmxkKHAyLCBib2R5LCB0aGlzLndvcmxkSGVpZ2h0KTtcblx0XHRub2RlLnBoeXNpY3NNYW5hZ2VyLnJhZGl1cyA9IHJhZGl1cztcblx0XHQvL25vZGUucGh5c2ljc01hbmFnZXIuc2V0Rml4ZWQobm9kZS5maXhlZCk7XG5cdFx0Ly9ib2R5LnNldERlbnNpdHkoMC4xKTtcblx0XHR0aGlzLndvcmxkLmFkZEJvZHkoYm9keSk7XG5cblx0XHQvL2JvZHkubWFzcyA9IGJvZHkuZ2V0QXJlYSgpICogdGhpcy5jb25mLm1hc3M7XG5cdFx0Ly9ib2R5LmdyYXZpdHlTY2FsZSA9IDAuMTtcblx0XHQvL2JvZHkudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcblx0XHQvLyBib2R5Lm1hc3MgPSAwO1xuXHRcdC8vIGJvZHkuc2V0RGVuc2l0eSgwKTtcblx0XHQvL25vZGUucGh5c2ljc01hbmFnZXIuYXBwbHlGb3JjZShbMCwgMF0pO1xuXHRcdC8vIGJvZHkubWFzcyA9IDEwO1xuXHRcdHZhciBtYXNzVmFyaWFuY2UgPSB0aGlzLmNvbmYubWFzc1ZhcmlhbmNlIHx8IDA7XG5cdFx0dmFyIHJhbmRvbSA9IC1tYXNzVmFyaWFuY2UgKyBNYXRoLnJhbmRvbSgpICogbWFzc1ZhcmlhbmNlICogMjtcblx0XHRib2R5Lm1hc3MgPSBib2R5Lm1hc3MgKyBib2R5Lm1hc3MgKiByYW5kb207XG5cdFx0Ly9ib2R5Lm1hc3MgPSBib2R5Lm1hc3M7XG5cdFx0Ym9keS5pbnZNYXNzID0gMSAvIGJvZHkubWFzcztcblx0XHRib2R5LmluZXJ0aWEgPSBib2R5Lm1hc3MgKiAwLjU7XG5cdFx0Ym9keS5pbnZJbmVydGlhID0gMSAvIGJvZHkuaW5lcnRpYTtcblx0XHRib2R5LmNvbGxpc2lvblJlc3BvbnNlID0gIXRoaXMuY29uZi5ub0NvbGxpZGU7XG5cblx0XHRib2R5LmFuZ3VsYXJEYW1waW5nID0gdGhpcy5jb25mLmFuZ3VsYXJEYW1waW5nIHx8IGJvZHkuYW5ndWxhckRhbXBpbmc7XG5cdFx0Ym9keS5kYW1waW5nID0gdGhpcy5jb25mLmRhbXBpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmNvbmYuZGFtcGluZyAhPT0gbnVsbCA/IE51bWJlcih0aGlzLmNvbmYuZGFtcGluZykgOiBib2R5LmRhbXBpbmc7XG5cblx0XHRib2R5LmdyYXZpdHlTY2FsZSA9IHRoaXMuY29uZi5ncmF2aXR5U2NhbGUgIT09IHVuZGVmaW5lZCA/IHRoaXMuY29uZi5ncmF2aXR5U2NhbGUgOiAxO1xuXHR9XG5cblx0dmFyIFBvbHlnb24gPSByZXF1aXJlKCcuLi8uLi9jb3JlL1BvbHlnb24nKTtcblx0dmFyIHBvaW50cyA9IFtdO1xuXHR2YXIgZW52ZWxvcGUgPSB0aGlzLmdyb3VwLnN0cnVjdHVyZS5lbnZlbG9wZTtcblx0dmFyIGVudmVsb3BlTGVuZ3RoID0gdGhpcy5ncm91cC5zdHJ1Y3R1cmUuZW52ZWxvcGUubGVuZ3RoO1xuXHRmb3IgKGkgPSAwOyBpIDwgZW52ZWxvcGVMZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHBvaW50cy5wdXNoKGVudmVsb3BlW2ldLnBoeXNpY3NNYW5hZ2VyLmJvZHkuaW50ZXJwb2xhdGVkUG9zaXRpb24pO1xuXHR9XG5cdHRoaXMucG9seWdvbiA9IFBvbHlnb24uaW5pdChwb2ludHMpO1xuXHQvL2RlYnVnZ2VyO1xuXG5cdGlmICh0aGlzLmNvbmYuc3RydWN0dXJhbE1hc3NEZWNheSkgeyB0aGlzLnNldE5vZGVzTWFzc0Zyb21Kb2ludHMoKTsgfVxuXG5cdHRoaXMucmVzb2x2ZUFkZGVkVG9Xb3JsZCgpO1xuXG5cdGlmICh0aGlzLmdyb3VwLklEID09PSAnc21pbGV5Jylcblx0e1xuXHRcdGNvbnNvbGUubG9nKHRoaXMuZ3JvdXAuc3RydWN0dXJlLmFyZWEgKiB0aGlzLmNvbmYubWFzcywgdGhpcy5nZXRNYXNzKCkpO1xuXHR9XG59O1xuXG5Hcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXREZWNvcmF0aW9uRHJhd2luZyA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiBTb2Z0RGVjb3JhdGlvbkRyYXdpbmcuY3JlYXRlKHRoaXMuZ3JvdXApO1xufTtcblxuR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0Tm9kZVBoeXNpY3NNYW5hZ2VyID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIG5ldyBOb2RlUDJTb2Z0UGh5c2ljc01hbmFnZXIoKTtcbn07XG5cbkdyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKClcbntcblx0dmFyIG1pblggPSBJbmZpbml0eTtcblx0dmFyIG1pblkgPSBJbmZpbml0eTtcblx0dmFyIG1heFggPSAtSW5maW5pdHk7XG5cdHZhciBtYXhZID0gLUluZmluaXR5O1xuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5ncm91cC5ub2Rlc0xlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJOb2RlID0gdGhpcy5ncm91cC5ub2Rlc1tpXTtcblx0XHRtaW5YID0gTWF0aC5taW4oY3Vyck5vZGUucGh5c2ljc01hbmFnZXIuZ2V0WCgpLCBtaW5YKTtcblx0XHRtaW5ZID0gTWF0aC5taW4oY3Vyck5vZGUucGh5c2ljc01hbmFnZXIuZ2V0WSgpLCBtaW5ZKTtcblx0XHRtYXhYID0gTWF0aC5tYXgoY3Vyck5vZGUucGh5c2ljc01hbmFnZXIuZ2V0WCgpLCBtYXhYKTtcblx0XHRtYXhZID0gTWF0aC5tYXgoY3Vyck5vZGUucGh5c2ljc01hbmFnZXIuZ2V0WSgpLCBtYXhZKTtcblx0fVxuXG5cdHRoaXMuX2JvdW5kaW5nQm94WzBdWzBdID0gbWluWDtcblx0dGhpcy5fYm91bmRpbmdCb3hbMF1bMV0gPSBtaW5ZO1xuXHR0aGlzLl9ib3VuZGluZ0JveFsxXVswXSA9IG1heFg7XG5cdHRoaXMuX2JvdW5kaW5nQm94WzFdWzFdID0gbWF4WTtcblxuXHRyZXR1cm4gdGhpcy5fYm91bmRpbmdCb3g7XG59O1xuXG5Hcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVBbmNob3JGcm9tUG9pbnQgPSBmdW5jdGlvbiAoJHBvaW50KVxue1xuXHR2YXIgYW5jaG9yID0gbmV3IEFuY2hvclAyU29mdFBoeXNpY3NNYW5hZ2VyKHRoaXMuZ3JvdXApO1xuXHRhbmNob3Iuc2V0RnJvbVBvaW50KCRwb2ludCk7XG5cdHJldHVybiBhbmNob3I7XG59O1xuXG5Hcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVBbmNob3JGcm9tTGluZSA9IGZ1bmN0aW9uICgkbGluZVBvaW50cylcbntcblx0dmFyIGNsb3Nlc3RQb2ludCA9IHRoaXMuZ3JvdXAuZ2V0Q2xvc2VzdFBvaW50KCRsaW5lUG9pbnRzKTtcblx0dmFyIGFuY2hvciA9IG5ldyBBbmNob3JQMlNvZnRQaHlzaWNzTWFuYWdlcih0aGlzLmdyb3VwKTtcblx0YW5jaG9yLnNldEZyb21Qb2ludChjbG9zZXN0UG9pbnQpO1xuXHRyZXR1cm4gYW5jaG9yO1xufTtcblxuR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlQW5jaG9ycyA9IGZ1bmN0aW9uICgkcG9pbnRzKVxue1xuXHR2YXIgdG9SZXR1cm4gPSBbXTtcblx0dmFyIG5vZGVzID0gdGhpcy5ncm91cC5nZXROb2Rlc0luc2lkZSgkcG9pbnRzKTtcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIG5vZGUgPSBub2Rlc1tpXTtcblx0XHR2YXIgY3VyckFuY2hvckEgPSBuZXcgQW5jaG9yUDJTb2Z0UGh5c2ljc01hbmFnZXIodGhpcy5ncm91cCk7XG5cdFx0Y3VyckFuY2hvckEuc2V0RnJvbVBvaW50KFtub2RlLm9YLCBub2RlLm9ZXSk7XG5cdFx0dG9SZXR1cm4ucHVzaChjdXJyQW5jaG9yQSk7XG5cdH1cblx0cmV0dXJuIHRvUmV0dXJuO1xufTtcblxuR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuYWRkSm9pbnRzVG9Xb3JsZCA9IGZ1bmN0aW9uICgpXG57XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLmdyb3VwLmpvaW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBqb2ludCA9IHRoaXMuZ3JvdXAuam9pbnRzW2ldO1xuXHRcdGpvaW50LnBoeXNpY3NNYW5hZ2VyID0gbmV3IEpvaW50UDJQaHlzaWNzTWFuYWdlcihqb2ludCwgdGhpcy53b3JsZCwgdGhpcy5jb25mKTtcblx0fVxufTtcblxuR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuc2V0Tm9kZXNNYXNzRnJvbUpvaW50cyA9IGZ1bmN0aW9uICgpXG57XG5cdHZhciBOb2RlR3JhcGggPSByZXF1aXJlKCcuLi8uLi9jb3JlL05vZGVHcmFwaCcpO1xuXHR2YXIgbm9kZUdyYXBoID0gbmV3IE5vZGVHcmFwaCgpO1xuXHR2YXIgaTtcblx0dmFyIHN0YXJ0aW5nVmVydGljZXMgPSBbXTtcblx0dmFyIG5vZGVzTGVuZ3RoID0gdGhpcy5ncm91cC5ub2Rlcy5sZW5ndGg7XG5cdHZhciBqb2ludHNMZW5ndGggPSB0aGlzLmdyb3VwLmpvaW50cy5sZW5ndGg7XG5cdGZvciAoaSA9IDA7IGkgPCBqb2ludHNMZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJySm9pbnQgPSB0aGlzLmdyb3VwLmpvaW50c1tpXTtcblx0XHRub2RlR3JhcGguY29ubmVjdChjdXJySm9pbnQubm9kZUEsIGN1cnJKb2ludC5ub2RlQik7XG5cdH1cblx0Zm9yIChpID0gMDsgaSA8IG5vZGVzTGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgbm9kZSA9IHRoaXMuZ3JvdXAubm9kZXNbaV07XG5cdFx0aWYgKG5vZGUuZml4ZWQpXG5cdFx0e1xuXHRcdFx0c3RhcnRpbmdWZXJ0aWNlcy5wdXNoKG5vZGVHcmFwaC5nZXRWZXJ0ZXgobm9kZSkpO1xuXHRcdH1cblx0fVxuXHRpZiAoc3RhcnRpbmdWZXJ0aWNlcy5sZW5ndGggPT09IDApXG5cdHtcblx0XHRyZXR1cm47XG5cdH1cblx0bm9kZUdyYXBoLnRyYXZlcnNlKHN0YXJ0aW5nVmVydGljZXMpO1xuXHR2YXIgdmVydGljZXNMZW5ndGggPSBub2RlR3JhcGgudmVydGljZXMubGVuZ3RoO1xuXHRmb3IgKGkgPSAwOyBpIDwgdmVydGljZXNMZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciB2ZXJ0ZXggPSBub2RlR3JhcGgudmVydGljZXNbaV07XG5cdFx0dmFyIGRlY2F5ID0gTnVtYmVyKHRoaXMuZ3JvdXAuY29uZi5waHlzaWNzLnN0cnVjdHVyYWxNYXNzRGVjYXkpO1xuXHRcdHZhciB2YWx1ZSA9IE1hdGgucG93KGRlY2F5LCB2ZXJ0ZXgubWFwVmFsdWUgLyAyKTsvL01hdGgucG93KDIsIHZlcnRleC5tYXBWYWx1ZSAvIDcuMzMpO1xuXHRcdHZhciBib2R5ID0gdmVydGV4Lm5vZGUucGh5c2ljc01hbmFnZXIuYm9keTtcblx0XHRpZiAoIXZlcnRleC5ub2RlLmZpeGVkKVxuXHRcdHtcblx0XHRcdC8vYm9keS5tYXNzID0gdGhpcy5jb25mLm1hc3MgLyB0aGlzLmdyb3VwLm5vZGVzLmxlbmd0aCAvIHZhbHVlICogYm9keS5nZXRBcmVhKCk7XG5cdFx0XHQvL2JvZHkudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcblx0XHRcdHZhciBtYXNzVmFyaWFuY2UgPSB0aGlzLmNvbmYubWFzc1ZhcmlhbmNlIHx8IDA7XG5cdFx0XHR2YXIgcmFuZG9tID0gLW1hc3NWYXJpYW5jZSArIE1hdGgucmFuZG9tKCkgKiBtYXNzVmFyaWFuY2UgKiAyO1xuXHRcdFx0dmFyIGJhc2VNYXNzID0gdGhpcy5ncm91cC5zdHJ1Y3R1cmUuYXJlYSAqIHRoaXMuY29uZi5tYXNzO1xuXHRcdFx0dmFyIG1hc3MgPSBiYXNlTWFzcyArIGJhc2VNYXNzICogcmFuZG9tO1xuXHRcdFx0Ym9keS5tYXNzID0gbWFzcyAvIHZhbHVlO1xuXHRcdFx0Ym9keS5pbnZNYXNzID0gMSAvIGJvZHkubWFzcztcblx0XHRcdGJvZHkuaW5lcnRpYSA9IGJvZHkubWFzcyAvIDI7XG5cdFx0XHRib2R5LmludkluZXJ0aWEgPSAxIC8gYm9keS5pbmVydGlhO1xuXHRcdFx0dmVydGV4Lm5vZGUuZGVidWdUZXh0ID0gTWF0aC5yb3VuZChib2R5Lm1hc3MgKiAxMDApIC8gMTAwO1xuXHRcdFx0Ly92ZXJ0ZXgubm9kZS5kZWJ1Z1RleHQgPSBNYXRoLnJvdW5kKHZlcnRleC5tYXBWYWx1ZSAqIDEwMCkgLyAxMDA7XG5cdFx0fVxuXHR9XG59O1xuXG5Hcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5hcHBseUFuZ3VsYXJGb3JjZSA9IGZ1bmN0aW9uICgkdmFsdWUpXG57XG5cdC8vdGhpcy5ncm91cC5ub2Rlc1swXS5waHlzaWNzTWFuYWdlci5ib2R5LmFuZ3VsYXJGb3JjZSArPSAkdmFsdWU7XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLmdyb3VwLm5vZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKVxuXHR7XG5cdFx0dmFyIGN1cnJQaHlzID0gdGhpcy5ncm91cC5ub2Rlc1tpXS5waHlzaWNzTWFuYWdlcjtcblx0XHRjdXJyUGh5cy5ib2R5LmFuZ3VsYXJGb3JjZSArPSAkdmFsdWU7XG5cdH1cbn07XG5cbkdyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbiAoJHZlY3Rvcilcbntcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuZ3JvdXAubm9kZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3VyclBoeXMgPSB0aGlzLmdyb3VwLm5vZGVzW2ldLnBoeXNpY3NNYW5hZ2VyO1xuXHRcdGN1cnJQaHlzLmJvZHkuZm9yY2UgPSBbXG5cdFx0XHRjdXJyUGh5cy5ib2R5LmZvcmNlWzBdICsgJHZlY3RvclswXSxcblx0XHRcdGN1cnJQaHlzLmJvZHkuZm9yY2VbMV0gKyAkdmVjdG9yWzFdXG5cdFx0XTtcblx0fVxufTtcblxuR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0TWFzcyA9IGZ1bmN0aW9uICgpXG57XG5cdHZhciBtYXNzID0gMDtcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMuZ3JvdXAubm9kZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgbm9kZSA9IHRoaXMuZ3JvdXAubm9kZXNbaV07XG5cdFx0bWFzcyArPSBub2RlLnBoeXNpY3NNYW5hZ2VyLmJvZHkubWFzcztcblx0fVxuXG5cdHJldHVybiBtYXNzO1xufTtcblxuR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ3JvdXAubm9kZXNbMF0ucGh5c2ljc01hbmFnZXIuYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblswXTsgfTtcbkdyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLndvcmxkSGVpZ2h0IC0gdGhpcy5ncm91cC5ub2Rlc1swXS5waHlzaWNzTWFuYWdlci5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzFdOyB9O1xuXG5Hcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbmdsZSA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLmdyb3VwLm5vZGVzWzBdLnBoeXNpY3NNYW5hZ2VyLmJvZHkuaW50ZXJwb2xhdGVkQW5nbGU7XG59O1xuXG5Hcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5oaXRUZXN0ID0gZnVuY3Rpb24gKCRwb2ludCwgJHByZWNpc2lvbilcbntcblx0JHBvaW50WzFdID0gdGhpcy53b3JsZEhlaWdodCAtICRwb2ludFsxXTtcblx0dmFyIGR4O1xuXHR2YXIgZHk7XG5cdHZhciBub2Rlc0xlbmd0aCA9IHRoaXMuZ3JvdXAubm9kZXMubGVuZ3RoO1xuXG5cdGZvciAodmFyIG0gPSAwOyBtIDwgbm9kZXNMZW5ndGg7IG0gKz0gMSlcblx0e1xuXHRcdHZhciBib2R5ID0gdGhpcy5ncm91cC5ub2Rlc1ttXS5waHlzaWNzTWFuYWdlci5ib2R5O1xuXHRcdGR4ID0gTWF0aC5hYnMoYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblswXSAtICRwb2ludFswXSk7XG5cdFx0ZHkgPSBNYXRoLmFicyhib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzFdIC0gJHBvaW50WzFdKTtcblx0XHRpZiAoZHggPCAkcHJlY2lzaW9uICYmIGR5IDwgJHByZWNpc2lvbilcblx0XHR7XG5cdFx0XHRyZXR1cm4gYm9keTtcblx0XHR9XG5cdH1cblx0aWYgKHRoaXMucG9seWdvbi5pc0luc2lkZSgkcG9pbnQpKVxuXHR7XG5cdFx0dmFyIGNsb3Nlc3Q7XG5cdFx0dmFyIGNsb3Nlc3RIeXA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMucG9seWdvbi5wb2ludHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnJQb2ludCA9IHRoaXMucG9seWdvbi5wb2ludHNbaV07XG5cdFx0XHRkeCA9IE1hdGguYWJzKCRwb2ludFswXSAtIGN1cnJQb2ludFswXSk7XG5cdFx0XHRkeSA9IE1hdGguYWJzKCRwb2ludFsxXSAtIGN1cnJQb2ludFsxXSk7XG5cdFx0XHR2YXIgaHlwID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHRcdGlmIChjbG9zZXN0SHlwID09PSB1bmRlZmluZWQgfHwgaHlwIDwgY2xvc2VzdEh5cClcblx0XHRcdHtcblx0XHRcdFx0Y2xvc2VzdCA9IGN1cnJQb2ludDtcblx0XHRcdFx0Y2xvc2VzdEh5cCA9IGh5cDtcblx0XHRcdH1cblx0XHR9XG5cdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBub2Rlc0xlbmd0aDsgayArPSAxKVxuXHRcdHtcblx0XHRcdHZhciBjdXJyTm9kZSA9IHRoaXMuZ3JvdXAubm9kZXNba107XG5cdFx0XHRpZiAoY3Vyck5vZGUucGh5c2ljc01hbmFnZXIuYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblswXSA9PT0gY2xvc2VzdFswXSAmJlxuXHRcdFx0XHRjdXJyTm9kZS5waHlzaWNzTWFuYWdlci5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzFdID09PSBjbG9zZXN0WzFdKVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gY3Vyck5vZGUucGh5c2ljc01hbmFnZXIuYm9keTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNsb3Nlc3Q7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JvdXBQMlNvZnRQaHlzaWNzTWFuYWdlcjtcblxuIiwidmFyIERlY29yYXRpb25EcmF3aW5nQ29tbWFuZCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvRGVjb3JhdGlvbkRyYXdpbmdDb21tYW5kJyk7XG52YXIgRGVjb3JhdGlvbkRyYXdpbmcgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0RlY29yYXRpb25EcmF3aW5nJyk7XG5cbnZhciBIYXJkRGVjb3JhdGlvbkRyYXdpbmcgPSBPYmplY3QuY3JlYXRlKERlY29yYXRpb25EcmF3aW5nKTtcbkhhcmREZWNvcmF0aW9uRHJhd2luZy5jcmVhdGUgPSBmdW5jdGlvbiAoJGdyb3VwKVxue1xuXHR2YXIgaW5zdCA9IE9iamVjdC5jcmVhdGUoSGFyZERlY29yYXRpb25EcmF3aW5nKTtcblx0aW5zdC5ncm91cCA9ICRncm91cDtcblx0aW5zdC5jb21tYW5kcyA9IFtdO1xuXG5cdGluc3QucHJvcGVydGllcyA9IHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gaW5zdDtcbn07XG5cbkhhcmREZWNvcmF0aW9uRHJhd2luZy5zZXREcmF3aW5nQ29tbWFuZHMgPSBmdW5jdGlvbiAoJGRyYXdpbmdDb21tYW5kcylcbntcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9ICRkcmF3aW5nQ29tbWFuZHMucG9pbnRDb21tYW5kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSlcblx0e1xuXHRcdHZhciBjdXJyID0gJGRyYXdpbmdDb21tYW5kcy5wb2ludENvbW1hbmRzW2ldO1xuXHRcdHRoaXMuY29tbWFuZHMucHVzaChuZXcgRGVjb3JhdGlvbkRyYXdpbmdDb21tYW5kKGN1cnIsIHRoaXMuZ3JvdXAucGh5c2ljc01hbmFnZXIpKTtcblx0fVxuXHR0aGlzLmNvbW1hbmRzTGVuZ3RoID0gdGhpcy5jb21tYW5kcy5sZW5ndGg7XG59O1xuXG5IYXJkRGVjb3JhdGlvbkRyYXdpbmcuc2V0UHJvcGVydGllcyA9IGZ1bmN0aW9uICgkcHJvcGVydGllcylcbntcblx0dGhpcy5wcm9wZXJ0aWVzID0gJHByb3BlcnRpZXM7XG5cdHRoaXMudXNlRHluYW1pY0dyYWRpZW50ID0gZmFsc2U7XG59O1xuXG5IYXJkRGVjb3JhdGlvbkRyYXdpbmcuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5ncm91cC5waHlzaWNzTWFuYWdlci5nZXRCb3VuZGluZ0JveCgpO1xufTtcblxuSGFyZERlY29yYXRpb25EcmF3aW5nLmlzU3RhdGljID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMuZ3JvdXAuY29uZi5maXhlZCA9PT0gdHJ1ZTtcbn07XG5cbkhhcmREZWNvcmF0aW9uRHJhd2luZy53aWxsTm90SW50ZXJzZWN0ID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIGZhbHNlO1xufTtcblxuSGFyZERlY29yYXRpb25EcmF3aW5nLmlzU2ltcGxlRHJhd2luZyA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSGFyZERlY29yYXRpb25EcmF3aW5nO1xuIiwiLy92YXIgcDIgPSByZXF1aXJlKCcuLi8uLi8uLi9saWJzL3AyJyk7XG52YXIgUDJVdGlscyA9IHJlcXVpcmUoJy4vUDJVdGlscycpO1xuXG52YXIgSm9pbnRQMlBoeXNpY3NNYW5hZ2VyID0gZnVuY3Rpb24gKCRqb2ludCwgJHdvcmxkLCAkY29uZilcbntcblx0dmFyIGpvaW50Q29uZiA9ICRjb25mLmpvaW50c1skam9pbnQudHlwZV07XG5cdHZhciBib2R5QSA9ICRqb2ludC5ub2RlQS5waHlzaWNzTWFuYWdlci5ib2R5O1xuXHR2YXIgYm9keUIgPSAkam9pbnQubm9kZUIucGh5c2ljc01hbmFnZXIuYm9keTtcblx0dGhpcy5jb25zdHJhaW50cyA9IFAyVXRpbHMuY3JlYXRlQ29uc3RyYWludHMoJHdvcmxkLCBib2R5QSwgYm9keUIsIGpvaW50Q29uZik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpvaW50UDJQaHlzaWNzTWFuYWdlcjtcbiIsIi8vIGpzY3M6ZGlzYWJsZSByZXF1aXJlQ2FtZWxDYXNlT3JVcHBlckNhc2VJZGVudGlmaWVyc1xuLypqc2hpbnQgY2FtZWxjYXNlOmZhbHNlKi9cbnZhciBwMiA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYnMvcDInKTtcblxudmFyIE5vZGVQMkhhcmRQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgpXG57XG5cdHRoaXMuZ2V0WCA9IHRoaXMuZ2V0WFNpbXBsZTtcblx0dGhpcy5nZXRZID0gdGhpcy5nZXRZU2ltcGxlO1xufTtcblxuTm9kZVAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5hZGRUb1dvcmxkID0gZnVuY3Rpb24gKCRib2R5LCAkcG9zaXRpb24sICR3b3JsZEhlaWdodClcbntcblx0dGhpcy5ib2R5ID0gJGJvZHk7XG5cdHRoaXMucG9zaXRpb24gPSAkcG9zaXRpb247XG5cdHRoaXMud29ybGRIZWlnaHQgPSAkd29ybGRIZWlnaHQ7XG5cdHRoaXMub2Zmc2V0ID0gWzAsIDBdO1xufTtcblxuTm9kZVAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5zZXRGaXhlZCA9IGZ1bmN0aW9uICgkZml4ZWQpXG57XG5cdGlmICgkZml4ZWQpXG5cdHtcblx0XHR0aGlzLmJvZHkudHlwZSA9IHAyLkJvZHkuU1RBVElDO1xuXHRcdHRoaXMuYm9keS51cGRhdGVNYXNzUHJvcGVydGllcygpO1xuXHR9XG59O1xuXG5Ob2RlUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLnNldE9mZnNldCA9IGZ1bmN0aW9uICgkb2Zmc2V0KVxue1xuXHR2YXIgZFggPSB0aGlzLnBvc2l0aW9uWzBdICsgJG9mZnNldFswXTtcblx0dmFyIGRZID0gdGhpcy5wb3NpdGlvblsxXSAtICRvZmZzZXRbMV07XG5cdHRoaXMuYW5nbGUgPSBNYXRoLmF0YW4yKGRZLCBkWCk7XG5cdHRoaXMuaHlwID0gTWF0aC5zcXJ0KGRYICogZFggKyBkWSAqIGRZKTtcblx0dGhpcy5nZXRYID0gdGhpcy5nZXRYT2Zmc2V0O1xuXHR0aGlzLmdldFkgPSB0aGlzLmdldFlPZmZzZXQ7XG59O1xuXG5Ob2RlUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFhTaW1wbGUgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzBdO1xufTtcblxuTm9kZVAySGFyZFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRZU2ltcGxlID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMud29ybGRIZWlnaHQgLSB0aGlzLmJvZHkuaW50ZXJwb2xhdGVkUG9zaXRpb25bMV07XG59O1xuXG5Ob2RlUDJIYXJkUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFhPZmZzZXQgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzBdICsgdGhpcy5oeXAgKiBNYXRoLmNvcyh0aGlzLmJvZHkuaW50ZXJwb2xhdGVkQW5nbGUgKyB0aGlzLmFuZ2xlKTtcbn07XG5cbk5vZGVQMkhhcmRQaHlzaWNzTWFuYWdlci5wcm90b3R5cGUuZ2V0WU9mZnNldCA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLndvcmxkSGVpZ2h0IC0gKHRoaXMuYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvblsxXSArIHRoaXMuaHlwICogTWF0aC5zaW4odGhpcy5ib2R5LmludGVycG9sYXRlZEFuZ2xlICsgdGhpcy5hbmdsZSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlUDJIYXJkUGh5c2ljc01hbmFnZXI7XG5cbiIsIi8vIGpzY3M6ZGlzYWJsZSByZXF1aXJlQ2FtZWxDYXNlT3JVcHBlckNhc2VJZGVudGlmaWVyc1xuLypqc2hpbnQgY2FtZWxjYXNlOmZhbHNlKi9cblxudmFyIE5vZGVQMlNvZnRQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgpXG57XG5cdHZhciBzZWxmID0gdGhpcztcblx0dGhpcy5hZGRlZFRvV29ybGQgPSBuZXcgd2luZG93LlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgc2VsZi5yZXNvbHZlQWRkZWRUb1dvcmxkID0gcmVzb2x2ZTsgfSk7XG59O1xuXG5Ob2RlUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmFkZFRvV29ybGQgPSBmdW5jdGlvbiAoJHAyLCAkYm9keSwgJHdvcmxkSGVpZ2h0KVxue1xuXHR0aGlzLnAyID0gJHAyO1xuXHR0aGlzLmJvZHkgPSAkYm9keTtcblx0dGhpcy53b3JsZEhlaWdodCA9ICR3b3JsZEhlaWdodDtcblx0dGhpcy5yZXNvbHZlQWRkZWRUb1dvcmxkKCk7XG59O1xuXG5Ob2RlUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbiAoJHZlYylcbntcblx0Ly9jb25zb2xlLmxvZygnbm9wJywgdGhpcy5ib2R5LmFwcGx5Rm9yY2VMb2NhbCwgJHZlYyk7XG5cdHZhciBsb2MgPSBbXTtcblx0dGhpcy5ib2R5LnRvV29ybGRGcmFtZShsb2MsIFswLCAwXSk7XG5cdHRoaXMuYm9keS5hcHBseUZvcmNlKCR2ZWMsIGxvYyk7XG59O1xuXG5Ob2RlUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLnNldEZpeGVkID0gZnVuY3Rpb24gKCRmaXhlZClcbntcblx0aWYgKCRmaXhlZClcblx0e1xuXHRcdHRoaXMuYm9keS50eXBlID0gdGhpcy5wMi5Cb2R5LlNUQVRJQztcblx0fVxufTtcblxuTm9kZVAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbmdsZSA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLmJvZHkuaW50ZXJwb2xhdGVkQW5nbGU7XG59O1xuXG5Ob2RlUDJTb2Z0UGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKVxue1xuXHQvL2NvbnNvbGUubG9nKHRoaXMuYm9keS5HZXRXb3JsZENlbnRlcigpLmdldF94KCkpO1xuXHRyZXR1cm4gdGhpcy5ib2R5LmludGVycG9sYXRlZFBvc2l0aW9uWzBdO1xufTtcblxuTm9kZVAyU29mdFBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIHRoaXMud29ybGRIZWlnaHQgLSB0aGlzLmJvZHkuaW50ZXJwb2xhdGVkUG9zaXRpb25bMV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVQMlNvZnRQaHlzaWNzTWFuYWdlcjtcblxuIiwiLy8ganNjczpkaXNhYmxlIHJlcXVpcmVDYW1lbENhc2VPclVwcGVyQ2FzZUlkZW50aWZpZXJzXG4vKmpzaGludCBjYW1lbGNhc2U6ZmFsc2UqL1xuXG52YXIgcDIgPSByZXF1aXJlKCcuLi8uLi8uLi9saWJzL3AyJyk7XG52YXIgUDJVdGlscyA9IHJlcXVpcmUoJy4vUDJVdGlscycpO1xudmFyIEdyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXIgPSByZXF1aXJlKCcuL0dyb3VwUDJTb2Z0UGh5c2ljc01hbmFnZXInKTtcbnZhciBHcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyID0gcmVxdWlyZSgnLi9Hcm91cFAySGFyZFBoeXNpY3NNYW5hZ2VyJyk7XG52YXIgR3JvdXBHaG9zdFBoeXNpY3NNYW5hZ2VyID0gcmVxdWlyZSgnLi9Hcm91cEdob3N0UGh5c2ljc01hbmFnZXInKTtcbnZhciBBbmNob3JQMkdob3N0UGh5c2ljc01hbmFnZXIgPSByZXF1aXJlKCcuL0FuY2hvclAyR2hvc3RQaHlzaWNzTWFuYWdlcicpO1xuXG52YXIgUDJQaHlzaWNzTWFuYWdlciA9IGZ1bmN0aW9uICgkY29uZiwgJHAyV29ybGQpXG57XG5cdHRoaXMucDJXb3JsZCA9ICRwMldvcmxkIHx8IG5ldyBwMi5Xb3JsZCgkY29uZik7XG5cdHRoaXMucDIgPSBwMjtcblx0dGhpcy5jb25mID0gJGNvbmY7XG5cdHRoaXMud29ybGRXaWR0aCA9IHVuZGVmaW5lZDtcblx0dGhpcy53b3JsZEhlaWdodCA9IHVuZGVmaW5lZDtcblx0dGhpcy5uZXdUaW1lID0gdW5kZWZpbmVkO1xuXHR0aGlzLmxhc3RUaW1lID0gdW5kZWZpbmVkO1xuXHR0aGlzLm1hdGVyaWFsc0xpc3QgPSBbXTtcblxuXHQvL3RoaXMucDJXb3JsZC5ncmF2aXR5ID0gdGhpcy5jb25mLmdyYXZpdHk7XG5cblx0dGhpcy5zZXRNYXRlcmlhbHMoKTtcbn07XG5cblAyUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiAoJHRpbWUpXG57XG5cdHRoaXMubmV3VGltZSA9ICR0aW1lIC0gdGhpcy5sYXN0VGltZSB8fCAwO1xuXHR0aGlzLmxhc3RUaW1lID0gJHRpbWU7XG5cdHRoaXMucDJXb3JsZC5zdGVwKDEgLyA2MCwgdGhpcy5uZXdUaW1lIC8gMTAwMCwgNSk7XG59O1xuXG5QMlBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJhaW5Hcm91cHMgPSBmdW5jdGlvbiAoJGFuY2hvckEsICRhbmNob3JCLCAkdHlwZSlcbntcblx0JGFuY2hvckEuYWRkVG9Xb3JsZCgpO1xuXHQkYW5jaG9yQi5hZGRUb1dvcmxkKCk7XG5cblx0dmFyIGNvbnN0cmFpbnRDb25maWcgPSB0aGlzLmNvbmYuY29uc3RyYWludHNbJHR5cGVdO1xuXG5cdFAyVXRpbHMuY3JlYXRlQ29uc3RyYWludHModGhpcy5wMldvcmxkLCAkYW5jaG9yQS5ib2R5LCAkYW5jaG9yQi5ib2R5LCBjb25zdHJhaW50Q29uZmlnLCBbJGFuY2hvckEub2Zmc2V0LCAkYW5jaG9yQi5vZmZzZXRdKTtcbn07XG5cblAyUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUdob3N0QW5jaG9yRnJvbVBvaW50cyA9IGZ1bmN0aW9uICgkcG9pbnRzKVxue1xuXHR2YXIgUG9seWdvbiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvUG9seWdvbicpO1xuXHR2YXIgcG9seWdvbiA9IFBvbHlnb24uaW5pdCgkcG9pbnRzKTtcblx0dmFyIGNlbnRlciA9IHBvbHlnb24uZ2V0Q2VudGVyKCk7XG5cdHJldHVybiB0aGlzLmNyZWF0ZUdob3N0QW5jaG9yRnJvbVBvaW50KGNlbnRlcik7XG59O1xuXG5QMlBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVHaG9zdEFuY2hvckZyb21Qb2ludCA9IGZ1bmN0aW9uICgkcG9pbnQpXG57XG5cdHZhciBhbmNob3IgPSBuZXcgQW5jaG9yUDJHaG9zdFBoeXNpY3NNYW5hZ2VyKHRoaXMucDIsIHRoaXMucDJXb3JsZCwgdGhpcy53b3JsZEhlaWdodCk7XG5cdGFuY2hvci5zZXRGcm9tUG9pbnQoJHBvaW50KTtcblx0cmV0dXJuIGFuY2hvcjtcbn07XG5cblAyUGh5c2ljc01hbmFnZXIucHJvdG90eXBlLmdldEdyb3VwUGh5c2ljc01hbmFnZXIgPSBmdW5jdGlvbiAoJGdyb3VwKVxue1xuXHRzd2l0Y2ggKCRncm91cC5jb25mLnBoeXNpY3MuYm9keVR5cGUpXG5cdHtcblx0XHRjYXNlICdnaG9zdCc6IHJldHVybiBuZXcgR3JvdXBHaG9zdFBoeXNpY3NNYW5hZ2VyKCRncm91cCk7XG5cdFx0Y2FzZSAnaGFyZCc6IHJldHVybiBuZXcgR3JvdXBQMkhhcmRQaHlzaWNzTWFuYWdlcigkZ3JvdXAsIHRoaXMucDJXb3JsZCwgdGhpcy53b3JsZEhlaWdodCwgdGhpcy5tYXRlcmlhbHNMaXN0KTtcblx0XHRjYXNlICdzb2Z0JzogcmV0dXJuIG5ldyBHcm91cFAyU29mdFBoeXNpY3NNYW5hZ2VyKCRncm91cCwgdGhpcy5wMldvcmxkLCB0aGlzLndvcmxkSGVpZ2h0LCB0aGlzLm1hdGVyaWFsc0xpc3QpO1xuXHR9XG59O1xuXG5QMlBoeXNpY3NNYW5hZ2VyLnByb3RvdHlwZS5zZXRNYXRlcmlhbHMgPSBmdW5jdGlvbiAoKVxue1xuXHR2YXIgbWF0ZXJpYWxOYW1lO1xuXHRmb3IgKG1hdGVyaWFsTmFtZSBpbiB0aGlzLmNvbmYubWF0ZXJpYWxzKVxuXHR7XG5cdFx0dmFyIG1hdGVyaWFsQ29uZiA9IHRoaXMuY29uZi5tYXRlcmlhbHNbbWF0ZXJpYWxOYW1lXTtcblx0XHR2YXIgY3Vyck1hdGVyaWFsID0gbmV3IHAyLk1hdGVyaWFsKCk7XG5cdFx0dmFyIGN1cnIgPSB0aGlzLm1hdGVyaWFsc0xpc3RbbWF0ZXJpYWxOYW1lXSA9IHsgbWF0ZXJpYWw6IGN1cnJNYXRlcmlhbCwgbWF0ZXJpYWxDb25maWc6IG1hdGVyaWFsQ29uZiB9O1xuXHRcdGZvciAodmFyIG90aGVyTmFtZSBpbiB0aGlzLm1hdGVyaWFsc0xpc3QpXG5cdFx0e1xuXHRcdFx0dmFyIG90aGVyID0gdGhpcy5tYXRlcmlhbHNMaXN0W290aGVyTmFtZV07XG5cdFx0XHR2YXIgY29udGFjdE1hdGVyaWFsID0gbmV3IHAyLkNvbnRhY3RNYXRlcmlhbChjdXJyLm1hdGVyaWFsLCBvdGhlci5tYXRlcmlhbCwge1xuXHRcdFx0XHRmcmljdGlvbjogY3Vyci5tYXRlcmlhbENvbmZpZy5mcmljdGlvbiArIChvdGhlci5tYXRlcmlhbENvbmZpZy5mcmljdGlvbiAtIGN1cnIubWF0ZXJpYWxDb25maWcuZnJpY3Rpb24pIC8gMixcblx0XHRcdFx0cmVsYXhhdGlvbjogY3Vyci5tYXRlcmlhbENvbmZpZy5ib3VuY2luZXNzICsgKG90aGVyLm1hdGVyaWFsQ29uZmlnLmJvdW5jaW5lc3MgLSBjdXJyLm1hdGVyaWFsQ29uZmlnLmJvdW5jaW5lc3MpIC8gMlxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLnAyV29ybGQuYWRkQ29udGFjdE1hdGVyaWFsKGNvbnRhY3RNYXRlcmlhbCk7XG5cdFx0fVxuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFAyUGh5c2ljc01hbmFnZXI7XG5cbiIsInZhciBwMiA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYnMvcDInKTtcbnZhciBQMlV0aWxzID0ge307XG5cblAyVXRpbHMuY3JlYXRlQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoJHdvcmxkLCAkYm9keUEsICRib2R5QiwgJGNvbmZpZywgJG9wdGlvbnMpXG57XG5cdGlmICghJGNvbmZpZykgeyByZXR1cm47IH1cblxuXHR2YXIgY29uc3RyYWludHMgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9ICRjb25maWcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY29uZmlnID0gJGNvbmZpZ1tpXTtcblxuXHRcdHZhciBjb25zdHJhaW50O1xuXG5cdFx0dmFyIG5vdE51bGxPclVuZGVmaW5lZCA9IGZ1bmN0aW9uICgkcHJvcGVydHkpXG5cdFx0e1xuXHRcdFx0cmV0dXJuICRwcm9wZXJ0eSAhPT0gdW5kZWZpbmVkICYmICRwcm9wZXJ0eSAhPT0gbnVsbDtcblx0XHR9O1xuXG5cdFx0c3dpdGNoIChjb25maWcudHlwZSlcblx0XHR7XG5cdFx0XHRjYXNlICdyZXZvbHV0ZUNvbnN0cmFpbnQnOlxuXHRcdFx0XHR2YXIgdmVjV29ybGRBID0gcDIudmVjMi5jcmVhdGUoKTtcblx0XHRcdFx0dmFyIHZlY1dvcmxkQiA9IHAyLnZlYzIuY3JlYXRlKCk7XG5cdFx0XHRcdHZhciB2ZWNMb2NBID0gcDIudmVjMi5jcmVhdGUoKTtcblx0XHRcdFx0dmFyIHZlY0xvY0IgPSBwMi52ZWMyLmNyZWF0ZSgpO1xuXHRcdFx0XHQkYm9keUEudG9Xb3JsZEZyYW1lKHZlY1dvcmxkQSwgWzAsIDBdKTtcblx0XHRcdFx0JGJvZHlCLnRvV29ybGRGcmFtZSh2ZWNXb3JsZEIsIFswLCAwXSk7XG5cdFx0XHRcdCRib2R5QS50b0xvY2FsRnJhbWUodmVjTG9jQSwgJGJvZHlCLmludGVycG9sYXRlZFBvc2l0aW9uKTtcblx0XHRcdFx0JGJvZHlCLnRvTG9jYWxGcmFtZSh2ZWNMb2NCLCAkYm9keUEuaW50ZXJwb2xhdGVkUG9zaXRpb24pO1xuXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKHJldm9sdXRlLmF1dG9QaXZvdCk7XG5cdFx0XHRcdGlmICghJG9wdGlvbnMgfHwgISRvcHRpb25zWzBdIHx8ICEkb3B0aW9uc1sxXSkgeyBjb25maWcuYXV0b1Bpdm90ID0gdHJ1ZTsgfVxuXHRcdFx0XHR2YXIgbG9jYWxQaXZvdEEgPSBjb25maWcuYXV0b1Bpdm90ID8gdW5kZWZpbmVkIDogJG9wdGlvbnNbMF07XG5cdFx0XHRcdHZhciBsb2NhbFBpdm90QiA9IGNvbmZpZy5hdXRvUGl2b3QgPyB1bmRlZmluZWQgOiAkb3B0aW9uc1sxXTtcblx0XHRcdFx0dmFyIHdvcmxkUGl2b3QgPSBjb25maWcuYXV0b1Bpdm90ID8gJGJvZHlBLmludGVycG9sYXRlZFBvc2l0aW9uIDogdW5kZWZpbmVkO1xuXHRcdFx0XHRjb25zdHJhaW50ID0gbmV3IHAyLlJldm9sdXRlQ29uc3RyYWludCgkYm9keUEsICRib2R5Qixcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHdvcmxkUGl2b3Q6IHdvcmxkUGl2b3QsXG5cdFx0XHRcdFx0bG9jYWxQaXZvdEE6IGxvY2FsUGl2b3RBLFxuXHRcdFx0XHRcdGxvY2FsUGl2b3RCOiBsb2NhbFBpdm90QlxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKCFjb25maWcubW90b3IpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvL2NvbnN0cmFpbnQuc2V0TGltaXRzKDAsIDApO1xuXHRcdFx0XHRcdGlmIChjb25maWcuY29sbGlkZUNvbm5lY3RlZCAhPT0gdW5kZWZpbmVkKSB7IGNvbnN0cmFpbnQuY29sbGlkZUNvbm5lY3RlZCA9IGNvbmZpZy5jb2xsaWRlQ29ubmVjdGVkOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3RyYWludC5lbmFibGVNb3RvcigpO1xuXHRcdFx0XHRcdGNvbnN0cmFpbnQuc2V0TW90b3JTcGVlZCgtMSk7XG5cdFx0XHRcdFx0Y29uc3RyYWludC5jb2xsaWRlQ29ubmVjdGVkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNvbmZpZy5ub1JvdGF0aW9uKSB7IGNvbnN0cmFpbnQuc2V0TGltaXRzKDAsIDApOyB9XG5cdFx0XHRcdGlmIChub3ROdWxsT3JVbmRlZmluZWQoY29uZmlnLnN0aWZmbmVzcykpIHsgY29uc3RyYWludC5zZXRTdGlmZm5lc3MoTnVtYmVyKGNvbmZpZy5zdGlmZm5lc3MpKTsgfSAvL2RlZmF1bHQgMjBcblx0XHRcdFx0aWYgKG5vdE51bGxPclVuZGVmaW5lZChjb25maWcucmVsYXhhdGlvbikpIHsgY29uc3RyYWludC5zZXRSZWxheGF0aW9uKE51bWJlcihjb25maWcucmVsYXhhdGlvbikpOyB9XG5cdFx0XHRcdCR3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnQpO1xuXHRcdFx0XHRjb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xuXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncHJpc21hdGljQ29uc3RyYWludCc6XG5cdFx0XHRcdHZhciBheGlzVmVjID0gcDIudmVjMi5jcmVhdGUoKTtcblx0XHRcdFx0dmFyIHdvcmxkT2Zmc2V0QiA9IHAyLnZlYzIuY3JlYXRlKCk7XG5cdFx0XHRcdCRib2R5Qi50b1dvcmxkRnJhbWUod29ybGRPZmZzZXRCLCAkb3B0aW9uc1sxXSk7XG5cdFx0XHRcdCRib2R5QS50b0xvY2FsRnJhbWUoYXhpc1ZlYywgd29ybGRPZmZzZXRCKTsvL1skYm9keUIuaW50ZXJwb2xhdGVkUG9zaXRpb25bMF0gKyAkb3B0aW9uc1sxXVswXSAtICgkYm9keUEuaW50ZXJwb2xhdGVkUG9zaXRpb25bMF0gKyAkb3B0aW9uc1swXVswXSksICRib2R5Qi5pbnRlcnBvbGF0ZWRQb3NpdGlvblsxXSAtICRib2R5QS5pbnRlcnBvbGF0ZWRQb3NpdGlvblsxXV07XG5cdFx0XHRcdHZhciBzeCA9IGF4aXNWZWNbMF0gLSAkb3B0aW9uc1swXVswXTtcblx0XHRcdFx0dmFyIHN5ID0gYXhpc1ZlY1sxXSAtICRvcHRpb25zWzBdWzFdO1xuXHRcdFx0XHQvLyB2YXIgY3ggPSBNYXRoLmFicyhzeCk7XG5cdFx0XHRcdC8vIHZhciBjeSA9IE1hdGguYWJzKHN5KTtcblx0XHRcdFx0Ly8gdmFyIGRpc3QgPSBNYXRoLnNxcnQoY3ggKiBjeCArIGN5ICogY3kpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKGF4aXNWZWMsICRvcHRpb25zWzBdKTtcblx0XHRcdFx0Ly9kZWJ1Z2dlcjtcblx0XHRcdFx0Y29uc3RyYWludCA9IG5ldyBwMi5QcmlzbWF0aWNDb25zdHJhaW50KCRib2R5QSwgJGJvZHlCLCB7XG5cdFx0XHRcdFx0bG9jYWxBbmNob3JBOiAkb3B0aW9uc1swXSxcblx0XHRcdFx0XHRsb2NhbEFuY2hvckI6ICRvcHRpb25zWzFdLFxuXHRcdFx0XHRcdGxvY2FsQXhpc0E6IFtzeCwgc3ldLFxuXHRcdFx0XHRcdHVwcGVyTGltaXQ6IG5vdE51bGxPclVuZGVmaW5lZChjb25maWcudXBwZXJMaW1pdCkgPyBOdW1iZXIoY29uZmlnLnVwcGVyTGltaXQpIDogMSxcblx0XHRcdFx0XHRsb3dlckxpbWl0OiBub3ROdWxsT3JVbmRlZmluZWQoY29uZmlnLmxvd2VyTGltaXQpID8gTnVtYmVyKGNvbmZpZy5sb3dlckxpbWl0KSA6IDAsXG5cdFx0XHRcdFx0ZGlzYWJsZVJvdGF0aW9uYWxMb2NrOiBjb25maWcuY2FuUm90YXRlID09PSB0cnVlID8gdHJ1ZSA6IGZhbHNlXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAoY29uZmlnLmNvbGxpZGVDb25uZWN0ZWQgIT09IHVuZGVmaW5lZCkgeyBjb25zdHJhaW50LmNvbGxpZGVDb25uZWN0ZWQgPSBjb25maWcuY29sbGlkZUNvbm5lY3RlZDsgfVxuXHRcdFx0XHRpZiAobm90TnVsbE9yVW5kZWZpbmVkKGNvbmZpZy5zdGlmZm5lc3MpKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdub3QgbnVsbGxsbGwnKTtcblx0XHRcdFx0Y29uc3RyYWludC5zZXRTdGlmZm5lc3MoTnVtYmVyKGNvbmZpZy5zdGlmZm5lc3MpKTsgfSAvL2RlZmF1bHQgMjBcblx0XHRcdFx0aWYgKG5vdE51bGxPclVuZGVmaW5lZChjb25maWcucmVsYXhhdGlvbikpIHsgY29uc3RyYWludC5zZXRSZWxheGF0aW9uKE51bWJlcihjb25maWcucmVsYXhhdGlvbikpOyB9XG5cdFx0XHRcdCR3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnQpO1xuXHRcdFx0XHRjb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2xvY2tDb25zdHJhaW50Jzpcblx0XHRcdFx0Y29uc3RyYWludCA9IG5ldyBwMi5Mb2NrQ29uc3RyYWludCgkYm9keUEsICRib2R5Qik7XG5cdFx0XHRcdC8vaWYgKCRvcHRpb25zICYmICRvcHRpb25zWzBdKSB7IGNvbnN0cmFpbnQubG9jYWxPZmZzZXRCID0gJG9wdGlvbnNbMF07IH1cblx0XHRcdFx0aWYgKGNvbmZpZy5jb2xsaWRlQ29ubmVjdGVkICE9PSB1bmRlZmluZWQpIHsgY29uc3RyYWludC5jb2xsaWRlQ29ubmVjdGVkID0gY29uZmlnLmNvbGxpZGVDb25uZWN0ZWQ7IH1cblx0XHRcdFx0aWYgKG5vdE51bGxPclVuZGVmaW5lZChjb25maWcuc3RpZmZuZXNzKSkgeyBjb25zdHJhaW50LnNldFN0aWZmbmVzcyhOdW1iZXIoY29uZmlnLnN0aWZmbmVzcykpOyB9IC8vZGVmYXVsdCAyMFxuXHRcdFx0XHRpZiAobm90TnVsbE9yVW5kZWZpbmVkKGNvbmZpZy5yZWxheGF0aW9uKSkgeyBjb25zdHJhaW50LnNldFJlbGF4YXRpb24oTnVtYmVyKGNvbmZpZy5yZWxheGF0aW9uKSk7IH1cblx0XHRcdFx0JHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XG5cdFx0XHRcdGNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnbGluZWFyU3ByaW5nJzpcblx0XHRcdFx0Y29uc3RyYWludCA9IG5ldyBwMi5MaW5lYXJTcHJpbmcoJGJvZHlBLCAkYm9keUIsIHtcblx0XHRcdFx0XHRsb2NhbEFuY2hvckE6ICRvcHRpb25zICYmICRvcHRpb25zWzBdID8gJG9wdGlvbnNbMF0gOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0bG9jYWxBbmNob3JCOiAkb3B0aW9ucyAmJiAkb3B0aW9uc1sxXSA/ICRvcHRpb25zWzFdIDogdW5kZWZpbmVkXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAobm90TnVsbE9yVW5kZWZpbmVkKGNvbmZpZy5zdGlmZm5lc3MpKSB7IGNvbnN0cmFpbnQuc3RpZmZuZXNzID0gTnVtYmVyKGNvbmZpZy5zdGlmZm5lc3MpOyB9XG5cdFx0XHRcdGlmIChub3ROdWxsT3JVbmRlZmluZWQoY29uZmlnLmRhbXBpbmcpKSB7IGNvbnN0cmFpbnQuZGFtcGluZyA9IE51bWJlcihjb25maWcuZGFtcGluZyk7IH1cblx0XHRcdFx0JHdvcmxkLmFkZFNwcmluZyhjb25zdHJhaW50KTtcblx0XHRcdFx0Y29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdyb3RhdGlvbmFsU3ByaW5nJzpcblx0XHRcdFx0Y29uc3RyYWludCA9IG5ldyBwMi5Sb3RhdGlvbmFsU3ByaW5nKCRib2R5QSwgJGJvZHlCKTtcblx0XHRcdFx0aWYgKG5vdE51bGxPclVuZGVmaW5lZChjb25maWcuc3RpZmZuZXNzKSkgeyBjb25zdHJhaW50LnN0aWZmbmVzcyA9IE51bWJlcihjb25maWcuc3RpZmZuZXNzKTsgfVxuXHRcdFx0XHRpZiAobm90TnVsbE9yVW5kZWZpbmVkKGNvbmZpZy5kYW1waW5nKSkgeyBjb25zdHJhaW50LmRhbXBpbmcgPSBOdW1iZXIoY29uZmlnLmRhbXBpbmcpOyB9XG5cdFx0XHRcdGNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XG5cdFx0XHRcdCR3b3JsZC5hZGRTcHJpbmcoY29uc3RyYWludCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Y29uc3RyYWludCA9IG5ldyBwMi5EaXN0YW5jZUNvbnN0cmFpbnQoJGJvZHlBLCAkYm9keUIpO1xuXHRcdFx0XHRpZiAoJG9wdGlvbnMgJiYgJG9wdGlvbnNbMF0pIHsgY29uc3RyYWludC5sb2NhbEFuY2hvckEgPSAkb3B0aW9uc1swXTsgfVxuXHRcdFx0XHRpZiAoJG9wdGlvbnMgJiYgJG9wdGlvbnNbMV0pIHsgY29uc3RyYWludC5sb2NhbEFuY2hvckIgPSAkb3B0aW9uc1sxXTsgfVxuXHRcdFx0XHRpZiAobm90TnVsbE9yVW5kZWZpbmVkKGNvbmZpZy5zdGlmZm5lc3MpKSB7IGNvbnN0cmFpbnQuc2V0U3RpZmZuZXNzKE51bWJlcihjb25maWcuc3RpZmZuZXNzKSk7IH0gLy8gZGVmYXVsdCA1MDBcblx0XHRcdFx0aWYgKG5vdE51bGxPclVuZGVmaW5lZChjb25maWcucmVsYXhhdGlvbikpIHsgY29uc3RyYWludC5zZXRSZWxheGF0aW9uKE51bWJlcihjb25maWcucmVsYXhhdGlvbikpOyB9Ly8gZGVmYXVsdCAwLjFcblx0XHRcdFx0JHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XG5cdFx0XHRcdGNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXHRjb25zb2xlLmxvZyhjb25zdHJhaW50cyk7XG5cdHJldHVybiBjb25zdHJhaW50cztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUDJVdGlscztcbiIsInZhciBEZWNvcmF0aW9uRHJhd2luZ0NvbW1hbmQgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0RlY29yYXRpb25EcmF3aW5nQ29tbWFuZCcpO1xudmFyIERlY29yYXRpb25EcmF3aW5nID0gcmVxdWlyZSgnLi4vLi4vY29yZS9EZWNvcmF0aW9uRHJhd2luZycpO1xuXG52YXIgU29mdERlY29yYXRpb25EcmF3aW5nID0gT2JqZWN0LmNyZWF0ZShEZWNvcmF0aW9uRHJhd2luZyk7XG5Tb2Z0RGVjb3JhdGlvbkRyYXdpbmcuY3JlYXRlID0gZnVuY3Rpb24gKCRncm91cClcbntcblx0dmFyIGluc3QgPSBPYmplY3QuY3JlYXRlKFNvZnREZWNvcmF0aW9uRHJhd2luZyk7XG5cdGluc3QuZ3JvdXAgPSAkZ3JvdXA7XG5cdGluc3QuY29tbWFuZHMgPSBbXTtcblxuXHRpbnN0LnByb3BlcnRpZXMgPSB1bmRlZmluZWQ7XG5cblx0cmV0dXJuIGluc3Q7XG59O1xuXG5Tb2Z0RGVjb3JhdGlvbkRyYXdpbmcuc2V0RHJhd2luZ0NvbW1hbmRzID0gZnVuY3Rpb24gKCRkcmF3aW5nQ29tbWFuZHMpXG57XG5cdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSAkZHJhd2luZ0NvbW1hbmRzLnBvaW50Q29tbWFuZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpXG5cdHtcblx0XHR2YXIgY3VyciA9ICRkcmF3aW5nQ29tbWFuZHMucG9pbnRDb21tYW5kc1tpXTtcblx0XHR2YXIgY2xvc2VzdE5vZGUgPSB0aGlzLmdyb3VwLmdldENsb3Nlc3ROb2RlKGN1cnIucG9pbnQpO1xuXHRcdGNvbnNvbGUubG9nKGNsb3Nlc3ROb2RlLklEKTtcblx0XHR0aGlzLmNvbW1hbmRzLnB1c2gobmV3IERlY29yYXRpb25EcmF3aW5nQ29tbWFuZChjdXJyLCBjbG9zZXN0Tm9kZS5waHlzaWNzTWFuYWdlcikpO1xuXHR9XG5cdHRoaXMuY29tbWFuZHNMZW5ndGggPSB0aGlzLmNvbW1hbmRzLmxlbmd0aDtcbn07XG5cblNvZnREZWNvcmF0aW9uRHJhd2luZy5zZXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCRwcm9wZXJ0aWVzKVxue1xuXHR0aGlzLnByb3BlcnRpZXMgPSAkcHJvcGVydGllcztcblx0dGhpcy51c2VEeW5hbWljR3JhZGllbnQgPSBmYWxzZTtcbn07XG5cblNvZnREZWNvcmF0aW9uRHJhd2luZy5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiB0aGlzLmdyb3VwLnBoeXNpY3NNYW5hZ2VyLmdldEJvdW5kaW5nQm94KCk7XG59O1xuXG5Tb2Z0RGVjb3JhdGlvbkRyYXdpbmcuaXNTdGF0aWMgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gdGhpcy5ncm91cC5jb25mLmZpeGVkID09PSB0cnVlO1xufTtcblxuU29mdERlY29yYXRpb25EcmF3aW5nLndpbGxOb3RJbnRlcnNlY3QgPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5Tb2Z0RGVjb3JhdGlvbkRyYXdpbmcuaXNTaW1wbGVEcmF3aW5nID0gZnVuY3Rpb24gKClcbntcblx0cmV0dXJuIGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2Z0RGVjb3JhdGlvbkRyYXdpbmc7XG4iXX0=
